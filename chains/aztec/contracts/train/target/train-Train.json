{
  "transpiled": true,
  "noir_version": "1.0.0-beta.4+0000000000000000000000000000000000000000",
  "name": "Train",
  "functions": [
    {
      "name": "refund_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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SWlTSWlTSWlTSWlTSWlTSWlTSWlTSWlTSWlSiTOm7TTbdpprO823nUZtp4W202LbaanttNx2WptK2nqvrq336tp6r66t9+raeq+urffq2nqvrq336tp6r66t9+raeq+urffq2nqvrq336tp6r66t9+raeq+urffq2nqvrq336tp6r66t9+raeq+urffq2nqvrq336tp6r66t9+raeq+urffq2nqvrq336tp6r66t9+raeq+urffq2nqvrq336tp6r66t9+raeq+urffq2nqvrq336tp6r66t9+raeq+urffq2nqvrq336tp6r66t9+raeq+urffq2nqvrq336tp6r66t9+raeq+urffq2nqvrq336tp6r66t9+raeq+urffq2nqvrq336tp6r66t9+raeq+urffq2nqvrq336tp6r+5J77XsL+9d2nX24LQnKklpP624H6cdrTjLtJ/FJZw0Vzh5rnDKVOE8622PCsfOFY6bKxw/Vzg0VzhhrnDmuiuXue7KZa67cpnqruzNVHdlb6a6K3sz1V3Zm6nuyt70viu/3IrpEk+YLJ44WTxpsnjyZPGUueKxH9+br6fZttNc22mH96TLU8xtCY/Ls8JQgWZj8vvuvjHF28I6RysdXKzytojMZb7wlb8djdkXwDL+9jF5Md/x0+TxB7MlIAbvH+MPwuOPwuNPwuPPwuMvsuM/fgFDUPxWePxOePyzz7+1+IXPv074/OuEz79O+PzrhM+/Tvj864XPv174/OuFz79e+Pzrhc+/Xvj864XPv174/OuFz79e+PxLwudfEj7/kvD5l4TPvyR8/iXh8y8Jn39J+PxLwudfEj7/BuHzbxA+/wbh828QPv8G4fNvED7/BuHzbxA+/wbh828QPv9G4fNvFD7/RuHzbxQ+/0bh828UPv9G4fNvFD7/RuHzbxQ+/ybh828SPv8m4fNvEj7/JuHzbxI+/ybh828SPv8m4fNvEj7/ZuHzbxY+/2bh828WPv9m4fNvFj7/ZuHzbxY+/2bh828WPv8W4fNvET7/FuHzbxE+/xbh828RPv8W4fNvET7/FuHzb5E9/5KRPf+SkT3/kpE9/5KRPf+SkT3/kpE9/5KRPf+SkT3/kpE9/5IRPv9a4fOvFT7/WuHz7/TrX9XiFz7/Cl//ioSvf0XC178i4etfkfD1r0j4+lckfP0rEr7+FQlf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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "get_note_internal",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "call_private_function_internal",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "AAAAAAAEAAAAAAAAAAAAEgAAAAAAAAAQAAAAAAAAVgkBAAAAAAAAAAEAAAACAAAAAwAAAAQAAAAF\nAAAABgAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAAAAAAAAAAAAACKKDE9Ef\nD3SHVFHCOMNjujUD8dcUqEimqtMN39Lc/MEBTYpTwJ6nJnj22+VgrxgqKsupjl4lKhDZBQmtxe1Z\nmxiUgZqCUIkCGO4NwZ5QKCL2Tca+nwIj27qe+sBA0zE6FGtg1OiIAK40nIoM+e/qY/GIepUYSnCu\ntv076M1jUiApDdguSFzDl0J3zG6gO9NuOibtE1IQhtN9rMgKJRJaDiyOa1NO3PPTbFZNRb3TcZar\nnETtMAst7FxA22MWT4KwFgoyT7Xwdm6qNxegNjs6kCHUOfLH8vdkxm7L2H0k63YBwY+ePIettjGA\niWCR+c7M7AvBmh+ijkJtOVIZnplMWxBoksZHmKjpC6ri0RlPzn797XsWZgfUcdz3abMBFeghJ0dS\nkC+1AXMoaMAX2mBhp+tfX+p74/bkhV0XwZHGMBcL3cOx0tbqqF/rmdYR7Z4DqT7U6iajhSmJlZ/w\nbzCtYARoNxfnQ8xC327JR9JqGG1ReTtzpwXG0I2KAGC+qzIiIuSmLVifXcWOAD4X0sKeZqqcjXq3\nWBuYEO2nPlPhfd8OP4PTyf+mJHwLpRXOLm9SrLCVbfb6d5ltuCSwof5icCmMMxH8kXD5LelAsEKq\nuZDVPGo7JjOc2mtz35IIMUFZB7BfQIphKEclkBa5IErkvzdTfrGWsFwdmPpRAWqbrLspCdO2J8Wi\nf7YmI5x20JHSEzgSKq4mjUlw5kOs48Ff4AavW2nqjZuNbzZhWwZtOHxRy9+0/TiMXH3ex4kGTCJC\nCXDD8qHJg2gEMNTWJVpQHcxt6yA3zBF0ifQEVo9UNMkimmnklkHaBXX/OFronRHykPiNOdsLfvrF\nsiXG8IDeHyHrSJuRmKhkLL92LlSOA5ve52T8+85x9jwkt2+sZv9oEf1BtfmTbZMquuTG6TPg05wk\n6o4uDu5wKlMm81nJR8AUoX18ClXS1F7o7fbsFlwRPSgrmEfVYv1BQCIOR+GCrxpw0tC/U/KBmNxu\na015bsn0E4YWuRKVxKct3D6sKlhhBJF9Mf6yOU8UhybsXvYCmZKEbxWFINSQCIu9uzzm+oUnMwgT\nUznlOgSOYhdaeN6h6hmW+9nLnaWovYGo59NWQC43Ql5n7vwY9x0GJXYpyectJAt8qlXy2rRPDC4F\noob+Ft0ILfucx4PhdRKz4+xzJFqOFBkRps2IjQEVDdB726YeTQdJRyJ+h+GUA427dYeb/136LXf6\n+d2GlLk+FinaMQBjDqgI8ucWz9H4H+13oEhQA0RyQcHkjt6n4R0Ve/UcAHnOgqC7mKhuCDmDXGWC\nFOk8er1YDfsVwfhPRz2e3tQDWxCIvHre0EjOY1Gs5rijNsWt2mMeNHEy2uMeR/Ilix9xC0qLTx7y\ngmI+0f4pjYhLv09iMFfRhVTZBdtZlpzdFrl7a+Kx9OfMoQtUcEx5EgSoT0aSxDoaVt26MpcBqJMQ\nZxpNhep38AFzKEtnx9BeqXDrLmc9LcgYLDUMoQQVQwW5nuqcwncMft8ZiQog2Vf6Jjn2dBkgdfTB\n52OBldq6GjcW+qevc8trW8hVgTMKKvnDivTAio9DR57ZH6QlQ3Qd5H1bsj8TQiSsdWIc5S5+DPEe\n8ip/Ex0676jdBtuAUQH7xyqeTyFQua+MOS8ZOlaJTVr7IVB1POJywkEfYbsqDl83cZSYkPWL8yPJ\nqjdkh+Qr9aI2uetxrWoVEGgjs2Qbjgkck+nI7fyejrY7dyXAaY/GeWMbvbIjBNq7tef+kxYcs8MJ\nRSa023PYgV1RoJV1UgwRAnSoDB7oBQwI6J+vIwNQ5ldpX2bLECtvVJgifGurJFdpfTDy6HDcpAFq\na58JK3uWn8trFGSYzSL3e9iAMIIKxLXDkshWjOv8AtdbIQrcicSNdbVxY29bvrSoBvb0WWICMBtq\n5OsOu+rdIDNABm8oE1dI8RljHD/gf6nXAANOPidFTvmStL+EuXuqdHEuJXg1Ud9QwATsfNH03Ys7\nZKZvKsSXm2XlZWjFoxsU7Rj3bPDO7MtHmN50GuibZOglj4RHfBtiVlpVm6e7OIMuLSmftoZ40BUL\nzFsW3IJSNT1D+nDpkjnBwcZ+JxoO6sUV06xaGZq7dJM6TvyYxZsoFO3nzSfa7QDDPBKGC8SwRi04\n1tS6Hkdjp07NsRyh80aWgMJw5VFRU0RZL1kYj6dlEts56JKCazJhDuCCUeAF/OkXwNXcoBlHfFL2\nB1MythIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAACLYst3CnW8ERIf/Y/VB3Zq7MitG3r3/o8ESDsRrJIG2MHx1nAYWs7qCWfvF0e\nVzPMV41jeWUE6I7PWsk4gv7w3QDENyb3W2/aDeIs4ODfq2vMegX/lalrKJQkxfczZw2WL5tuC04s\nAZaN5cMkgqp9HQoJ1xeOyTuteFj5bmTwtI0dWKphxkrVIgQ9ecSAIhnlW6GXUa3+bDYyTT+2wtoJ\niS18GKk8Pa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "lock_private_solver",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "ownership_hash",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 48
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6418028854678020178": {
            "error_kind": "string",
            "string": "FundsNotSent"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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tlx72XrtZefCTvs831/2cOr67WX7tZelSy87fwpN+WUZ3dL9/PkpreHHyzIk0347hz6EafpBct+uvWy/9LI0XZrb+d268ssyCyel+WGQy4+XzddeJtdetlx72bncH5em+8viowD/4YJcm8WH7BYfkv7+Q57f19vPDwzU/Yjw/o+Iv/2Iz5fN114m1162XPn22af12su2ay/br70sXXpZmK69LFx7Wbz2svnay+TayzK//1+OL9Zte/yTz7PWLG7T8Wudj3sYPz4ivf0jMrd/VD8ivP8j4vs/Yn7/R8j7P2J5/0es7/+I7f0f8f7VHd+/uuf3r+75/at7fv/qnt+/uuf3r+75/at7fv/qnt+/uudfr+7Pl6VLL5Pp2svCtZfFay+br71Mrr1sufay9drLtmsvu1Ylcq1KlmtVslyrkuValSzXqmS5ViXLtSpZrlXJcq1KlmtVslyrkvValazXqmS9ViXrtSpZr1XJeq1K1mtVsl6rkvValazXqmS7ViXbtSrZrlXJdq1KtmtVsl2rku1alWzXqmS7ViXbtSrZr1XJfq1K9mtVsl+rkv1alezXqmS/ViX7tSrZr1XJfq1K0rUqSdeqJF2rknStStK1KknXqiRdq5J0rUrStSpJl6okTdO1l4VrL4vXXjZfe5lce9ly7WXrtZdt1162X3vZtSoJ16okXKuScK1KwrUqCdeqJFyrknCtSsK1KgnXqiRcq5J4rUritSqJ16okXquSeK1K4rUqideqJF6rknitSuK1KpmvVcl8rUrma1UyX6uS+VqVzNeqZL5WJfO1KrmWvaZr2Wu6lr2ma9lrupa9pmvZa7qWvaZr2Wu6lr2ma9lrupa9pmvZa7qWvaZr2Wu6lr2ma9lrupa9pmvZa7qWvaZr2Wu6lr2ma9lrupa9pmvZa7qWvaZr2Wu6lr2ma9lrupa9pmvZa7qWvaZr2Wu6lr2ma9lrupa9pmvZa7qWvaZr2Wu6lr2ma9lrupa9pmvZa7qWvaZr2Wu6lr2ma9lrupa9pmvZa7qWvaZr2Wu6lr2ma9lrupa9pmvZa7qWvaZr2Wu6lr2ma9lrupa9pmvZa7qWvaZL2esyXcpeP14Wrr0sXnvZfO1lcu1ly7WXrddetl172X7tZdeqJFyrknCtSsK1KgnXqiRcq5JwrUrCtSoJ16okXKuScK1K4rUqideqJJO9puPH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REtWT7Rk9URLTk+05PRES05PtOT0REtOT7Tk9ERLTk+05PRESzTSvOo3V0N4d3WgEfjz9zKRBhqBa64ONALXXB1oBK65OtAIXHN1oHy15upA+WrFVT/QvFpzdaB8tebqQPlqzVUax1Vnl31ecwjs310dKISouTpQCFFzdaAQYjv8dfb6PbPxA4UQNVcHCiEqroaBQoiaqwOFEDVXBwohaq4OVHCpuUp6XB0pWqq4OlK0VHFVT7QUH/gcp/LtS2z/MWVa71iY/8wFk9p/TFk5FDJGJ88kkmeSl2dSkGdSlGdS+48pax/AxSzOpDTJM8nIM8nKM8nJM4nkmeTlmVQ+WjWs12T7OG3lN+NMKSbLeT3AZZrSj6d/NVI+AuDqRkKLRmKLRlKLRhoInw4OY764EdOiEduiEdeiEWrRiG/RSGjRSGzRSGrRSIs33rR4402LN960eONNizfetHjjTYs33rR4402LN960eONNizfetnjjbYs33rZ4422LN962eONtizfetnjjbYs33rZ4422LN961eONdizfetXjjXYs33rV4412LN961eONdizfetXjjXYs3nlq88dTijacWbzy1eOOpxRtPLd54avHGU4s3nlq88dTijfct3njf4o33Ld543+KN9y3eeN/ijfct3njf4o33Ld543+KNDy3e+NDijQ8t3vjQ4o0PLd740OKNDy3e+NDijQ8t3vjQ4o2PLd742OKNjy3e+NjijY8t3vjY4o2PLd742OKNjy3e+NjijU8t3vjU4o1PLd741OKNTy3e+NTijU8t3vjU4o1PLd74FluvUm7xxucWb3xu8cbnFm98bvHGt9hzl1rsuUst9tylFnvuUos9d7nFnrvcYs9dbrHnLrfYc5cnatGIb9FIaNFIbNFIatFIize+xZ673GLPXW6x5y632HOXW+y5yy323OUWe+5yiz13ucWeu9xiz11usecut9hzl1vsucst9tzlFnvucos9d7nFnrvcYs9dbrHnLrfYc5db7LnLLfbc5RZ77nKLPXe5xZ673GLPXW6x5y632HOXW+y5yy323OUWe+5yiz13ucWeu9xiz11usecut9hzl1vsucst9tzlFnvucos9d7nFnrvcYs9dvmLPnZvy8lm8s6b2dFwMitsH9OS+rXGirCFR1nhR1gRR1kRR1iRR1mRJ1lyxd/FCa4woa0SNxUHU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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "notify_created_nullifier_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "random",
        "decompose_hint",
        "lte_hint",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "redeem_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "772057049813214347": {
            "error_kind": "string",
            "string": "HTLCNotExists"
          },
          "2570651705007895968": {
            "error_kind": "string",
            "string": "HashlockNotMatch"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17814817983036354427": {
            "error_kind": "string",
            "string": "Function redeem_public can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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DhIIACgIAggtDhIIACgIAggtDhIIACgIAggtDhIIACgIAggtDhIIACgIAggtDhIIACgIAggtDhIIACgIAggtDhIIACgIAggtDhIIACgIAggtDhIIACgIAggtDhIIACgIAggtDhIIJwIGBBMtCAATLQwEFAAQAAYAJQAAL+gtBAAALQwUAy4EAAeAAygAgAQEAAYlAAAqYS4IgAUABAAoBAIGASgABoBbAAgtDgMILQ4EBS0NAgMAKAMCAy0OAwItCAEDJwIEBCAAEAEEAScDAwQBACgDAgQnAgYEHwA4BgQGLQwEBww4BwYIFgwICCQCAAgAABmgLQ4SBwAoBwIHIwAAGYEtCAEEAAABAgEtDgMELgiAVQABIwAAGbgNKAABgGEAAyQCAAMAABzjIwAAGc0tDQUDLQ0EBicCBwQTLQgAEy0MBhQAEAAHACUAAC/oLQQAAC0MFAQuBAADgAMoAIAEBAAGJQAAKmEuCIAFAAYAKAYCBwEoAAeAUwAILQ4ECAEoAAKAYgAELQ0EAy0IAQInAgQEIAAQAQQBJwMCBAEAKAICBC0MBActDgMHACgHAgctDhIHACgHAgctDhIHACgHAgctDhIHACgHAgctDhIHACgHAgctDhIHACgHAgctDhIHACgHAgctDhIHACgHAgctDhIHACgHAgctDhIHACgHAgctDhIHACgHAgctDhIHACgHAgctDhIHACgHAgctDhIHACgHAgctDhIHACgHAgctDhIHACgHAgctDhIHACgHAgctDhIHACgHAgctDhIHACgHAgctDhIHACgHAgctDhIHACgHAgctDhIHACgHAgctDhIHACgHAgctDhIHACgHAgctDhIHACgHAgctDhIHACgHAgctDhIHACgHAgctDhIHACgHAgctDhIHACgHAgctDhIHACgHAgctDhIHJwIEBActCAAHLQwCCAAQAAQAJQAAL+gtBAAALQwIAy4EAAaAAygAgAQEAAYlAAAqYS4IgAUAAgAoAgIEASgABIBMAActDgMHLQ4CBS0IAQMnAgQEBgAQAQQBJwMDBAEAKAMCBC0MBAUuCoBXAAUAKAUCBS4KgFcABQAoBQIFLgqAVwAFACgFAgUuCoBXAAUAKAUCBS4KgFcABS0IAQQAAAECAS0OAwQuCIBVAAEjAAAcCQ0oAAGAXAADJAIAAwAAHJYjAAAcHi0N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",
      "debug_symbols": "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",
      "brillig_names": [
        "redeem_public"
      ]
    },
    {
      "name": "get_htlc_public_solver",
      "is_unconstrained": true,
      "custom_attributes": [
        "view",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "key",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "Train::HTLC_Public",
            "fields": [
              {
                "name": "src_receiver",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "amount",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "token",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "hashlock_high",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "hashlock_low",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "secret_high",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "secret_low",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "ownership_hash_high",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "ownership_hash_low",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "timelock",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "claimed",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 8
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16480166116992993320": {
            "error_kind": "string",
            "string": "Function get_htlc_public_solver can only be called statically"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_htlc_public_solver"
      ]
    },
    {
      "name": "is_contract_initialized",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "is_contract_initialized"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "772057049813214347": {
            "error_kind": "string",
            "string": "HTLCNotExists"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2570651705007895968": {
            "error_kind": "string",
            "string": "HashlockNotMatch"
          },
          "2722406262643068352": {
            "error_kind": "string",
            "string": "HashlockAlreadySet"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3559210201980528457": {
            "error_kind": "string",
            "string": "Function commit_public_user can only be called internally"
          },
          "3564161243949231814": {
            "error_kind": "string",
            "string": "Function refund_public can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "9323748002447105156": {
            "error_kind": "string",
            "string": "NotPassedTimelock"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "15001264570739363109": {
            "error_kind": "string",
            "string": "Function lock_public_solver can only be called internally"
          },
          "16480166116992993320": {
            "error_kind": "string",
            "string": "Function get_htlc_public_solver can only be called statically"
          },
          "16870384257694633552": {
            "error_kind": "string",
            "string": "Function add_lock_public_user can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17814817983036354427": {
            "error_kind": "string",
            "string": "Function redeem_public can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [
        "aztec::macros::functions::utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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39bJ3n87RPz8IdbPHyJ9/hD584conz9E/fghXjz+6XoI9/lD+M8f4vNnd/382V0/f3bXz5/d9fNnd/382V0/fna7Zfn8IdznD+E/f4jfPrvvu8Vzu63ndkvndsvndivndqundnPLud3cud38ud3OVYk7VyXuXJW4c1XizlWJO1cl7lyV+HNV4s9ViT9XJf5clfhzVeLPVYk/VyX+XJX4c1Xiz1VJOFcl4VyVhHNVEs5VSThXJeFclYRzVRLOVUk4VyXhXJXEc1USz1VJPFcl8VyVxHNVEs9VSTxXJfFclcRzVRLPVcl6rkrWc1WynquS9VyVrOeqZD1XJeu5KlnPVcl6rkrWc1WSzlVJOlcl6VyVpHNVks5VSTpXJelclaRzVZLOVUk6VyX5XJXkc1WSz1VJPlcl+VyV5HNVks9VST5XJflcleRzVVLOVUk5VyXlXJWUc1VSzlVJOVcl5VyVlHNVUs5VSTlXJfVcldRzVVLPVUk9VyX1XJXUc1VSz1VJPVcl9VyV1FNV4pfl3G7u3G7+3G7h3G7x3G7rud3Sud3yud3Kud3OVcm57NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1b/IXuv+8t4tHHQHu72okpz33ar/abejFWc7fc/iNpyqajivsmKp4Thdw/G6hhN0DSfqGs6qazhJ13CyruHouipXVVflsKi6KodF1VU5LKquymFRdVUOi6qrclhUXZXDcvVV+e2nmG7jycrGU5SNp+oaj1uUjccpG89vX5vvu4Vzu8Vzux1ek27PTLclPG5PJtcGNJdy2L/um3J6LKxztNLBzZhvi8jc7qah8bfTsuwLYC3h8WPyunyNPykf/7psAqQ1hO/jz4OPvww+/jr2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",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "lock_public_solver",
      "is_unconstrained": true,
      "custom_attributes": [
        "internal",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "ownership_hash",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 48
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "15001264570739363109": {
            "error_kind": "string",
            "string": "Function lock_public_solver can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIDdJwAABAMnAgoEhCcCCwQAHxgACwAKgFkdAIBagFoCHQCAW4BbAh0AgFyAXAIdAIBdgF0CHQCAXoBeAh0AgF+AXwIdAIBggGACHQCAYYBhAh0AgGKAYgIdAIBjgGMCHQCAZIBkAh0AgGWAZQIdAIBmgGYCHQCAZ4BnAh0AgGiAaAIdAIBpgGkCHQCAaoBqAh0AgGuAawIdAIBsgGwCHQCAbYBtAh0AgG6AbgIdAIBvgG8CHQCAcIBwAh0AgHGAcQIdAIBygHICHQCAc4BzAh0AgHSAdAIdAIB1gHUCHQCAdoB2Ah0AgHeAdwIdAIB4gHgCHQCAeYB5Ah0AgHqAegIdAIB7gHsCHQCAfIB8Ah0AgH2AfQIdAIB+gH4CHQCAf4B/Ah0AgICAgAIdAICBgIECHQCAgoCCAh0AgIOAgwIdAICEgIQCHQCAhYCFAh0AgIaAhgIdAICHgIcCHQCAiICIAh0AgImAiQIdAICKgIoCHQCAi4CLAh0AgIyAjAIdAICNgI0CHQCAjoCOAh0AgI+AjwIdAICQgJACHQCAkYCRAh0AgJKAkgIdAICTgJMCHQCAlICUAh0AgJWAlQIdAICWgJYCHQCAl4CXAh0AgJiAmAIdAICZgJkCHQCAmoCaBh0AgJyAnAUdAICdgJ0CHQCAnoCeAh0AgJ+AnwIdAICggKACHQCAoYChAh0AgKKAogIdAICjgKMCHQCApICkAh0AgKWApQIdAICmgKYCHQCAp4CnAh0AgKiAqAIdAICpgKkCHQCAqoCqAh0AgKuAqwIdAICsgKwCHQCArYCtAh0AgK6ArgIdAICvgK8CHQCAsICwAh0AgLGAsQIdAICygLICHQCAs4CzAh0AgLSAtAIdAIC1gLUCHQCAtoC2Ah0AgLeAtwIdAIC4gLgCHQCAuYC5Ah0AgLqAugIdAIC7gLsCHQCAvIC8Ah0AgL2AvQIdAIC+gL4CHQCAv4C/Ah0AgMCAwAIdAIDBgMECHQCAwoDCAh0AgMOAwwIdAIDEgMQCHQCAxYDFAh0AgMaAxgIdAIDHgMcCHQCAyIDIAh0AgMmAyQIdAIDKgMoCHQCAy4DLAh0AgMyAzAIdAIDNgM0CHQCAzoDOAh0AgM+AzwIdAIDQgNACHQCA0YDRAh0AgNKA0gIdAIDTgNMCHQCA1IDUAh0AgNWA1QIdAIDWgNYCHQCA14DXAh0AgNiA2AIdAIDZgNkCHQCA2oDaAh0AgNuA2wIdAIDcgNwCLgiAWQABKAIAAgSAWicCCwQgLQgBCicCDAQhABABDAEnAwoEAQAoCgIMLgQAAoADLgQADIAELgQAC4AFJQAABSAtDAoCKAIAAwSAeicCCwQgLQgBCicCDAQhABABDAEnAwoEAQAoCgIMLgQAA4ADLgQADIAELgQAC4AFJQAABSAtDAoDLgiAmgAELgiAmwAFLgiAnAAGKAIABwSAnScCCwQILQgBCicCDAQJABABDAEnAwoEAQAoCgIMLgQAB4ADLgQADIAELgQAC4AFJQAABSAtDAoHKAIACASApScCCwQILQgBCicCDAQJABABDAEnAwoEAQAoCgIMLgQACIADLgQADIAELgQAC4AFJQAABSAtDAoIKAIACQSArScCCwQwLQgBCicCDAQxABABDAEnAwoEAQAoCgIMLgQACYADLgQADIAELgQAC4AFJQAABSAtDAoJJQAABWYlAAAGBygCAAEEgN0nAgIEADsNAAEAAgEAgAOABYAHLgCAA4AILgCABIAJCwCACIAHgAokAIAKAAAFZS4BgAiABi4CgAaACQEAgAgAAoAIAQCACQACgAkjAAAFNCYqAIBDAAAAAAEAAAAAKACARAABACgAgEUEAAMoAIBGAQAAKACARwQAACgAgEgGAAAoAIBJAAAAKACASgEAASgAgEsEAAEoAIBMAAABKACATQQAAigAgE4EAAQoAIBPBAAFKACAUAQABigAgFEEAAcoAIBSBAAIKACAUwQACSgAgFQEAAooAIBVBAALKACAVgQAFygAgFcEAB8oAIBYBAAgJiUAACINLQgBCwAAAQIBLgqARgALLQgBCwAAAQIBLgqASQALLQgBCwAAAQIBJwIMAAItDgwLHgIACwAeAgANADM4AAsADQAOJAIADgAABlslAAAiNh4CAAsBHgIADQAKOAsNDiQCAA4AAAZ3JQAAIkgeAgALBigCAA0FCowAOAsNDg44Cw4PJAIADwAABpolAAAiWgw4DgYLJAIACwAABqwlAAAibCcCDgQPLQgADy0MAhAAEAAOACUAACJ+LQQAAC0MEAstDBENJwIQBBEtCAARLQwDEgAQABAAJQAAIn4tBAAALQwSDi0MEw8rAgAQAAAAAAAAAAACAAAAAAAAAAAn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",
      "debug_symbols": "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",
      "brillig_names": [
        "lock_public_solver"
      ]
    },
    {
      "name": "refund_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3564161243949231814": {
            "error_kind": "string",
            "string": "Function refund_public can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "9323748002447105156": {
            "error_kind": "string",
            "string": "NotPassedTimelock"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBQJwAABAMnAgIEAScCAwQAHxgAAwACgE8uCIBPAAElAAAARSUAAACgKAIAAQSAUCcCAgQAOw0AAQACKgCAQwAAAAABAAAAACgAgEQAAQAoAIBFBAADKACARgEAACgAgEcEAAAoAIBIAAAAKACASQEAASgAgEoEAAEoAIBLBAAEKACATAQACygAgE0EABcoAIBOAABTJiUAAA3VLQgBAwAAAQIBLgqARgADLQgBBAAAAQIBLgqASAAELQgBBQAAAQIBJwIGAAItDgYFHgIABwAeAgAIADM4AAcACAAJJAIACQAAAPQlAAAN/h4CAAcBHgIACAAKOAcICSQCAAkAAAEQJQAADhAnAgsEDC0IAAwtDAMNLQwEDi0MBQ8tDAYQLgiATgARLQwBEgAQAAsAJQAADiItBAAALQwNBy0MDggtDA8JLQwQCh4CAAsFHAwLDQQcDA0MABwMDAsEJwIjBCQtCAAkLQwHJS0MCCYtDAknLQwKKAAQACMAJQAAD9MtBAAALQwlDC0MJg0tDCcOLQwoDy0MKRAtDCoRLQwrEi0MLBMtDC0ULQwuFS0MLxYtDDAXLQwxGC0MMhktDDMaLQw0Gy0MNRwtDDYdLQw3Hi0MOB8tDDkgLQw6IS0MOyIMOAsiBxYMBwgcDAcJABwMCAoABDgJDAsEOAoXDAA4CwwXHAwHCwYcDAgMBgQ4Cw0iBDgMGA0AOCINGAQ4CQ4NBDgKGQkAOA0JCgQ4Cw8JBDgMGg0AOAkNDgQ4CxAJBDgMGw0AOAkNDwQ4CxEJBDgMHA0AOAkNEAQ4CxIJBDgMHQ0AOAkNEQQ4CxMJBDgMHg0AOAkNEgQ4CxQJBDgMHwsAOAkLDBwMBwkFHAwICwUEOAkVDQQ4CyAJADgNCQscDAcJAhwMCAcCBDgJFggEOAchCQA4CAkHJwIIAgEKOAcICSQCAAkAAALVJQAAE2QeAgAHBgw4CwcIJAIACAAAAuwlAAATdicCEwQZLQgAGS0MAxotDAQbLQwFHC0MBh0uCIBOAB4tDAEfABAAEwAlAAAOIi0EAAAtDBoHLQwbCC0MHAktDB0NJwIpBCotCAAqLQwHKy0MCCwtDAktLQwNLgAQACkAJQAAD9MtBAAALQwrAy0MLAQtDC0FLQwuEy0MLxQtDDAVLQwxFi0MMhktDDMaLQw0Gy0MNRwtDDYdLQw3Hi0MOB8tDDkgLQw6IS0MOyItDDwjLQw9JC0MPiUtDD8mLQxAJy0MQSgtCAEHAAABAgEtDgMHLQgBCAAAAQIBLQ4ECC0IAQkAAAECAS0OBQktCAEpAAABAgEtDhMpLQgBKgAAAQIBLQ4UKi0IASsAAAECAS0OFSstCAEsAAABAgEtDhYsLQgBLQAAAQIBLQ4ZLS0IAS4AAAECAS0OGi4tCAEvAAABAgEtDhsvLQgBMAAAAQIBLQ4cMC0IATEAAAECAS0OHTEtCAEyAAABAgEtDh4yLQgBMwAAAQIBLQ4fMy0IATQAAAECAS0OIDQtCAE1AAABAgEtDiE1LQgBNgAAAQIBLQ4iNi0IATcAAAECAS0OIzctCAE4AAABAgEtDiQ4LQgBOQAAAQIBLQ4lOS0IAToAAAECAS0OJjotCAE7AAABAgEtDic7LQgBPAAAAQIBLQ4oPC8MAA0APRwMPT8EHAw/PgACOD0+PwkoAD+AQwA9HAw9PwQcDD8+ABwMPj8EAjg9PkAJKABAgEMAPRwMPUEBHAxBQAAcDEBBAQI4PUBCCSgAQoBEAD0cDD1DBBwMQ0IAHAxCQwQCOD1CRAkoAESAQwA9HAw9RAEcDERCABwMQkQBAjg9QkUJKABFgEQAPRwMPUYEHAxGRQAcDEU9BBYMREUcDEJEBBwMRUYEBDhEPUUWDEE9HAxAQQQcDD1EBAQ4QUM9HgIAQQUcDEFHBBwMR0MAHAxDQQQMOEE/QyQCAEMAAAXjIwAABcMcDEA/BAQ4Pz1DBSgARIBFAD8AOEM/RC0MRAIjAAAGAxwMQj8EBDg/RUMFKABGgEUAPwA4Qz9ELQxEAiMAAAYDADhBAkMOOEFDRCQCAEQAAAYaJQAAE4gMOEEoAhYMAigcDAJBABwMKEQABDhBA0YEOEQdAwA4RgMdHAwCAwYcDChGBgQ4AwRHBDhGHgQAOEcEHgQ4QQUEBDhEHwUAOAQFHwQ4AxMEBDhGIAUAOAQFEwQ4AxQEBDhGIQUAOAQFFAQ4AxUEBDhGIgUAOAQFFQQ4AxYEBDhGIwUAOAQFFgQ4AxkEBDhGJAUAOAQFGQQ4AxoEBDhGJQMAOAQDBRwMAgMFHAwoBAUEOAMbGgQ4BCYDADgaAwQcDAIDAhwMKAICBDgDHBoEOAInAwA4GgMCLQ4dBy0OHggtDh8JLQ4TKS0OFCotDhUrLQ4WLC0OGS0tDgUuLQ4ELy0OAjAtDhcxLQ4YMi0OCjMtDg40LQ4PNS0OEDYtDhE3LQ4SOC0ODDktDgs6JwIDAgItDgM7LQ5DPC0IAQcAAAECARwMQwgAJwIJACAnAhsERi0IAEYtDAZHLQwJSAAQABsAJQAAE5otBAAALQxHGgQ4PhoJADgICRocDEAIACcCCQBAJwIcBEYtCABGLQwGRy0MCUgAEAAcACUAABOaLQQAAC0MRxsEOAgbCQA4GgkIHAw9CQAnAhoASCcCHARGLQgARi0MBkctDBpIABAAHAAlAAATmi0EAAAtDEcbBDgJGxoAOAgaCRwMQggAJwIaAGgnAhwERi0IAEYtDAZHLQwaSAAQABwAJQAAE5otBAAALQxHGwQ4CBsaADgJGggcDEUJACcCGgBwJwIcBEAtCABALQwGQS0MGkIAEAAcACUAABOaLQQAAC0MQRsEOAkbBgA4CAYJLQgBBicCCAQYABABCAEnAwYEAQAoBgIILQwIGi0OCRoAKBoCGi4KgEgAGgAoGgIaLgqASAAaACgaAhouCoBIABoAKBoCGi4KgEgAGgAoGgIaLgqASAAaACgaAhouCoBIABoAKBoCGi4KgEgAGgAoGgIaLgqASAAaACgaAhouCoBIABoAKBoCGi4KgEgAGgAoGgIaLgqASAAaACgaAhouCoBIABoAKBoCGi4KgEgAGgAoGgIaLgqASAAaACgaAhouCoBIABoAKBoCGi4KgEgAGgAoGgIaLgqASAAaACgaAhouCoBIABoAKBoCGi4KgEgAGgAoGgIaLgqASAAaACgaAhouCoBIABoAKBoCGi4KgEgAGi0OBgcnAggEQC0IAEAtDB1BLQweQi0MH0MtDBNELQwURS0MFUYtDBZHLQwZSC0MBUktDARKLQwCSwAQAAgAJQAAFJotBAAALQxBBicCBARALQgAQC0MF0EtDBhCLQwKQy0MDkQtDA9FLQwQRi0MEUctDBJILQwMSS0MC0otDANLABAABAAlAAAUmi0EAAAtDEECLgiARwA/IwAAChwNKAA/gEwAAyQCAAMAAA0QIwAACjEtDQcDLQ0DBAAoBAIELQ4EAysCAAQAAAAAAAAAABcAAAAAAAAAACcCCQQOLQgADi0MBA8AEAAJACUAABZVLQQAAC0MDwUtDBAGLQwRBy0MEggtDQUEACgEAgQtDgQFLQ0GBAAoBAIELQ4EBi0IAQQAAAECAS0OBQQtCAEFAAABAgEtDgYFLQgBBgAAAQIBLQ4HBi0IAQcAAAECAS0OCAcuCIBHAAIjAAAK2w0oAAKATQAIJAIACAAADMYjAAAK8CcCCQQOLQgADi0MBA8tDAUQLQwGES0MBxIAEAAJACUAABb1LQQAAC0MDwgtDQMEACgEAgQtDgQDLQgBBCcCBQQZABABBQEnAwQEAQAoBAIFJwIGBBgAOAYFBi0MBQcMOAcGCRYMCQkkAgAJAAALby4KgEgABwAoBwIHIwAAC04tCAEFAAABAgEtDgQFLgiARwACIwAAC4cNKAACgE0ABCQCAAQAAAx5IwAAC5wtDQUDLgQAA4ADKACABAQAGSUAABdpLgiABQAEACgEAgYBKAAGgE0ABy0OCActDgQFJwIDBBguCIBHAAIjAAAL3Qw4AgMFJAIABQAADEojAAAL7ycCAwQBJwIFBAMAOAMFBC0IAQIAEAEEAScDAgQBACgCAgQtDgMEACgEAgQtDgMEJwIEBAMAOAIEAy0MAwQtDgEEACgCAgQtDQQDJwIFBAIAOAQFATcNAAEAAyYcDAIFAAA4DQUGACgEAgcAOAcCCC0NCAUwDAAFAAYBKAACgEoABS0MBQIjAAAL3S0NBQQAKAMCBwA4BwIJLQ0JBi4EAASAAygAgAQEABklAAAXaS4IgAUABwAoBwIJADgJAgotDgYKLQ4HBQEoAAKASgAELQwEAiMAAAuHACgDAgkAOAkCCi0NCggnAgkEDi0IAA4tDAQPLQwFEC0MBhEtDAcSLQwIEwAQAAkAJQAAF/ctBAAAASgAAoBKAAgtDAgCIwAACtstDQcDASgAP4BKAAQAKAYCCAA4CD8JLQ0JBQ0oAASATQAIJAIACAAADT8lAAAZIC4EAAOAAygAgAQEABglAAAXaS4IgAUACAAoCAIJADgJBAotDgUKASgABIBMAAMOOAQDBSQCAAUAAA1/JQAAE4gAKAICCQA4CT8KLQ0KBQ0oAAOATQAJJAIACQAADaIlAAAZIC4EAAiAAygAgAQEABglAAAXaS4IgAUACQAoCQIKADgKAwstDgULLQ4JBy0MBD8jAAAKHCgAgAQEeAANAAAAgASAAyQAgAMAAA39KgEAAQX3ofOvpa3UyjwBAQImKgEAAQW+Hj//PqT2+jwBAQImKgEAAQUxdnHEg87uxjwBAQImJQAADdUrAgALAAAAAAAAAAACAAAAAAAAAAAnAhAEES0IABEtDAsSABAAEAAlAAAWVS0EAAAtDBIMLQwTDS0MFA4tDBUPLQ0MCwAoCwILLQ4LDC0NDQsAKAsCCy0OCw0tCAELAAABAgEtDgwLLQgBDAAAAQIBLQ4NDC0IAQ0AAAECAS0ODg0tCAEOAAABAgEtDg8OJwIPBBAtCAAQLQwLES0MDBItDA0TLQwOFC0MBBUAEAAPACUAABf3LQQAACcCBAQPLQgADy0MCxAtDAwRLQwNEi0MDhMtDAYUABAABAAlAAAX9y0EAAAnAgYEDy0IAA8tDAsQLQwMES0MDRItDA4TABAABgAlAAAW9S0EAAAtDBAEJwIGAFEKOAUGCwsoAASASAAGJAIACwAAD5gjAAAPVQsoAAWATgALJAIACwAAD24nAgwEADwJAQwLKAAGgEYABSQCAAUAAA+DJQAAGTItDAEHLQwCCC0MAwktDAQKIwAAD8ILKAAGgEYABSQCAAUAAA+tJQAAGTItDAEHLQwCCC0MAwktDAQKIwAAD8ItDAoELQwHAS0MCAItDAkDJiUAAA3VLQgBBicCBwQYABABBwEnAwYEAQAoBgIHJwIIBBcAOAgHCC0MBwkMOAkIChYMCgokAgAKAAAQHy4KgEgACQAoCQIJIwAAD/4tCAEHAAABAgEtDgYHLgiARwAFIwAAEDcNKAAFgE0AASQCAAEAABMVIwAAEEwtDQcCLQ0CAwAoAwIDLQ4DAi0IAQMAAAECAS0OAgMtCAECAAABAgEuCoBHAAItCAEEJwIFBBgAEAEFAScDBAQBACgEAgUnAgYEFwA4BgUGLQwFBww4BwYIFgwICCQCAAgAABDALgqASAAHACgHAgcjAAAQny0IAQUAAAECAS0OBAUtDQQGACgGAgYtDgYELgiARwABIwAAEOUNKAABgE0ABiQCAAYAABKJIwAAEPotDQUBLQ0EAgIoAgICLQ4CBC0NAQIAKAICAi0OAgEnAgMEBC0IAAQtDAEFLgiASgAGABAAAwAlAAAZRC0EAAAtDAUCLQ0CAwAoAwIDLQ4DAicCAwQMJwIFBAYtCAAGLQwBBy0MAwgAEAAFACUAABlELQQAAC0MBwQtDQQDACgDAgMtDgMEJwIPBBAtCAAQLQwCEQAQAA8AJQAAGnItBAAALQwRAy0MEgUtDBMGLQwUBy0MFQgtDBYJLQwXCi0MGAstDBkMLQwaDS0MGw4nAhkEGi0IABotDAQbABAAGQAlAAAaci0EAAAtDBsCLQwcDy0MHRAtDB4RLQwfEi0MIBMtDCEULQwiFS0MIxYtDCQXLQwlGAEoAAGASgAZLQ0ZBBwMBBkEHAwZAQAcDAEEBC0MBBktDAcELQwKBy0MDQotDA8NLQwRDy0MExEtDBUTLQwXFS0MGRctDAMBLQwGAy0MCQYtDAwJLQwCDC0MBQItDAgFLQwLCC0MDgstDBAOLQwSEC0MFBItDBYULQwYFiYtDQUGLQ0DBy0NAggNKAAIgE0ACSQCAAkAABKqJQAAGSAAKAcCCgA4CggLLQ0LCQEoAAiASgAKDjgICgskAgALAAAS0iUAABOILQ4HAy0OCgIuBAAGgAMoAIAEBAAYJQAAF2kuCIAFAAcAKAcCCAA4CAEKLQ4JCi0OBwUBKAABgEoABi0MBgEjAAAQ5S0NBwEcDAUCAAA4BAIDLwwAAwACLgQAAYADKACABAQAGCUAABdpLgiABQADACgDAgYAOAYFCC0OAggtDgMHASgABYBKAAEtDAEFIwAAEDcqAQABBVVFTwUJdio6PAEBAiYqAQABBYFkm2itHhyEPAEBAiYqAQABBUWnynEZQeQVPAEBAiYlAAAN1S0IAQQAAAECAScCBQABLQ4FBCcCBwQCJwIIAQEtCAEGJwIJBCEAEAEJAScDBgQBACgGAgknAgoEIEMD8AACAAcACgAIAAknAgsEIC4EAAmAAy4EAAuABCUAAB0JJwICBCEnAgcEIC4IgEoAAyMAABQQDDgDAggkAgAIAAAUJyMAABQiLQ0EASYtDQQIBDgICAkCOAcDCA44AwcKJAIACgAAFEclAAAdiQw4CAcKJAIACgAAFFklAAAZIAAoBgILADgLCAwtDQwKHAwKCAAEOAkBCgQ4CAoLAjgFCAoEOAoJCAA4CwgJLQ4JBAEoAAOASgAILQwIAyMAABQQJQAADdUnAg0EDi0IAA4tDAIPABAADQAlAAAdmy0EAAAtDA8MJwINBA4tCAAOLQwEDwAQAA0AJQAAHZstBAAALQwPAicCDQQOLQgADi0MBQ8AEAANACUAAB2bLQQAAC0MDwQnAg0EDi0IAA4tDAYPABAADQAlAAAdmy0EAAAtDA8FJwINBA4tCAAOLQwHDwAQAA0AJQAAHZstBAAALQwPBicCDQQOLQgADi0MCA8AEAANACUAAB2bLQQAAC0MDwcnAg0EDi0IAA4tDAkPABAADQAlAAAdmy0EAAAtDA8IHAwKCQAcDAsKAAEoAAyASgANLQ0NCwEoAAKASgANLQ0NDAEoAASASgANLQ0NAgEoAAWASgANLQ0NBAEoAAaASgANLQ0NBQEoAAeASgANLQ0NBgEoAAiASgANLQ0NBy0IAQgnAg0EDAAQAQ0BJwMIBAEAKAgCDS0MDQ4tDgEOACgOAg4tDgsOACgOAg4tDgMOACgOAg4tDgwOACgOAg4tDgIOACgOAg4tDgQOACgOAg4tDgUOACgOAg4tDgYOACgOAg4tDgcOACgOAg4tDgkOACgOAg4tDgoOLQwIASYlAAAN1S0IAQInAgMEBAAQAQMBJwMCBAEAKAICAy0MAwQuCoBIAAQAKAQCBC4KgEgABAAoBAIELgqASAAELQ0CAwAoAwIDLQ4DAi0IAQMnAgQEBQAQAQQBJwMDBAEAKAMCBC0MBAUuCoBIAAUAKAUCBS4KgEgABQAoBQIFLgqASAAFACgFAgUtDgEFLQwCAS0MAwIuCIBHAAMuCIBGAAQmJQAADdUtDQQFCygABYBGAAYkAgAGAAAXFycCBwQAPAkBBycCBQQGLQgABi0MAQctDAIILQwDCS0MBAoAEAAFACUAAB3GLQQAAC0NAQUtDQIGLQ0DBy0OBQEtDgYCLQ4HAy4KgEkABAEoAAaASgACLQ0CASYuAYADgAYLAIAGAAKAByQAgAcAABeEIwAAF48uAIADgAUjAAAX9i4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAABfiLgGACoAILgKACIALAQCACgACgAoBAIALAAKACyMAABexKAGABQQAAQMAgAYAAoAGIwAAF/YmJQAADdUtDQMGLQ0EBwsoAAeARgAIJAIACAAAGB0nAgkEADwJAQkLKAAGgEUAByQCAAcAABisIwAAGDItDQEGLQ0CBy0NAwgtDQQJDSgACIBFAAokAgAKAAAYVyUAABkgLgQABoADKACABAQABCUAABdpLgiABQAKACgKAgsAOAsIDC0OBQwBKAAIgEoABQ44CAUGJAIABgAAGJclAAATiC0OCgEtDgcCLQ4FAy0OCQQjAAAZHycCBgQHLQgABy0MAQgtDAIJLQwDCi0MBAsAEAAGACUAAB3GLQQAAC0NAQYtDQIHLQ0ECC4EAAaAAygAgAQEAAQlAAAXaS4IgAUACQAoCQIKASgACoBHAAstDgULLQ4JAS0OBwIuCoBKAAMtDggEIwAAGR8mKgEAAQXFa8RaDhAAAjwBAQImKgEAAQUC3G4ngHYSnTwBAQImJQAADdUBKAACgEwABA44AgQFJAIABQAAGWMlAAATiA0wgE0ABAAFCygABYBGAAQkAgAEAAAZgCUAAB7ULQgBBCcCBQQMABABBQEnAwQEAQAoBAIFJwIGBAsAOAYFBi0MBQcMOAcGCBYMCAgkAgAIAAAZxy4KgEgABwAoBwIHIwAAGaYtCAEFAAABAgEtDgQFLgiARwADIwAAGd8NKAADgEwABCQCAAQAABn5IwAAGfQtDQUBJi0NBQQAOAMCBg44AwYHJAIABwAAGhQlAAATiA0oAAaATQAHJAIABwAAGiklAAAZIAAoAQIIADgIBgktDQkHLgQABIADKACABAQADCUAABdpLgiABQAGACgGAggAOAgDCS0OBwkBKAADgEoABC0OBgUtDAQDIwAAGd8lAAAN1QEoAAGASgADLQ0DAicCAwQCADgBAwUtDQUELQgBAycCBQQCABABBQEnAwMEAQAoAwIFLQwFBi0OBAYnAgUEBi0IAAYtDAMHABAABQAlAAAe5i0EAAAtDAcEASgAAYBFAAUtDQUDASgAAYBLAAYtDQYFLQgBBicCBwQCABABBwEnAwYEAQAoBgIHLQwHCC0OBQgnAgcECC0IAAgtDAYJABAABwAlAAAe5i0EAAAtDAkFJwIGBAUAOAEGCC0NCActCAEGJwIIBAIAEAEIAScDBgQBACgGAggtDAgJLQ4HCScCCAQJLQgACS0MBgoAEAAIACUAAB7mLQQAAC0MCgcnAgYEBgA4AQYJLQ0JCC0IAQYnAgkEAgAQAQkBJwMGBAEAKAYCCS0MCQotDggKJwIJBAotCAAKLQwGCwAQAAkAJQAAHuYtBAAALQwLCCcCBgQHADgBBgotDQoJLQgBBicCCgQCABABCgEnAwYEAQAoBgIKLQwKCy0OCQsnAgoECy0IAAstDAYMABAACgAlAAAe5i0EAAAtDAwJJwIGBAgAOAEGCy0NCwotCAEGJwILBAIAEAELAScDBgQBACgGAgstDAsMLQ4KDCcCCwQMLQgADC0MBg0AEAALACUAAB7mLQQAAC0MDQonAgYECQA4AQYMLQ0MCy0IAQYnAgwEAgAQAQwBJwMGBAEAKAYCDC0MDA0tDgsNJwIMBA0tCAANLQwGDgAQAAwAJQAAHuYtBAAALQwOCycCBgQKADgBBg0tDQ0MHAwMDQUcDA0GABwMBgwFASgAAYBMAA0tDQ0GHAwGDQIcDA0BABwMAQYCLQwCAS0MBAItDAUELQwHBS0MCQctDAsJLQwGCy0MCAYtDAoILQwMCiYoAIAGBAACBwCABIAGgAUuAIAEgAgoAIAJBAAADQCACYAFgAoXAIAKgAokAIAKAAAdiAMAgAgAAoAIAQCAA4AJgAsuAYALgAYBAIADgAiACy4BgAuABwEAgAOACYALLgKAB4ALAQCAA4AIgAsuAoAGgAsBAIAJAAKACSMAAB0lJioBAAEFKIaSsEfc/UM8AQECJiUAAA3VHAwBAgAtCAEBJwIDBAIAEAEDAScDAQQBACgBAgMtDAMELQ4CBCYlAAAN1S4IgEcABSMAAB3WDSgABYBFAAYkAgAGAAAeQSMAAB3rLQ0BBS0NAgYtDQMHLQ0ECC0IAQknAgoEBQAQAQoBJwMJBAEAKAYCCicCCwQEACgJAgw/DwAKAAwtDQkGACgGAgYtDgYJLQ4FAS0OCQItDgcDLQ4IBCYtDQMGDDgFBgcBKAAFgEoABiQCAAcAAB5fIwAAHsstDQEHLQ0CCC0NAwktDQQKACgIAgwAOAwFDS0NDQsAKAcCDQA4DQUOLQ0ODAA4CwwNLgQACIADKACABAQABSUAABdpLgiABQALACgLAgwAOAwFDi0ODQ4tDgcBLQ4LAi0OCQMtDgoEIwAAHsstDAYFIwAAHdYqAQABBfQu5YS79CHRPAEBAiYlAAAN1QEoAAGASgADLQ0DAhwMAgMGHAwDAQAcDAECBi0MAgEm",
      "debug_symbols": "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",
      "brillig_names": [
        "refund_public"
      ]
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "constructor"
      ]
    },
    {
      "name": "commit_private_user",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "src_receiver",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 48
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6652550611004701521": {
            "error_kind": "string",
            "string": "Funds Not Sent"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "notify_created_nullifier_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "random",
        "decompose_hint",
        "lte_hint",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "commit_public_user",
      "is_unconstrained": true,
      "custom_attributes": [
        "internal",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 48
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "src_receiver",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3559210201980528457": {
            "error_kind": "string",
            "string": "Function commit_public_user can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "commit_public_user"
      ]
    },
    {
      "name": "add_lock_private_user",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17476367995570638746": {
            "error_kind": "string",
            "string": "NoAllowance"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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k7N7MtK/DAttw2LbsNQ2rBzu26H5Mcw+B+Cvn4er/CyM+ySmx0nsz0/y9rne7RTu+lPQ9afwn57iPiy0DYttw1LT3Se03SJj2y0ytt0iT54XVoe5tmHUNsy3DQttw2LTsJPHP9EfN9YYnz/5LJVmNm7H2zrR2pdT2OtP4a4/BV1/Cn/9KcL1p4jXnyJdf4p8+SlOHv+wnuL6qztff3Xn66/ufP3Vna+/uvP1V3e+/urO11/d+fKr22zb9af4+Oq+D7Ntw1zbMGob5tuGhbZhsW1YahuWm4aZrW1YW5aYtiwxbVli2rLEtGWJacsS05Ylpi1LTFuW2LYssW1ZYtuyxLZliW3LEtuWJbYtS2xblti2LLFtWeLassS1ZYlryxLXliWuLUtcW5a4tixxbVni2rLEtWUJtWUJtWUJtWUJtWUJtWUJtWUJtWUJtWUJtWUJtWWJb8sS35Ylvi1LfFuW+LYs8W1Z4tuyxLdliW/LEt+WJaEtS0JbloS2LAltWRLasiS0ZUloy5LQliWhLUtCW5bEtiyJbVkS27IktmVJbMuS2JYlsS1LYluWxLYsiW1ZktqyJLVlSWrLktSWJaktS1JblqS2LEltWZLasiS1ZUluy5LcliW5LUtyW5bktizJbVmS27Ikt2VJbsuS3JQldtvahpm2YbZtmGsbRm3DfNuw0DYstg1LbcPasqSt92rbeq+2rfdq23qvtq33att6r7at92rbeq+2rfdq23qvtq33att6r7at92rbeq+2rfdq23qvtq33att6r7at92rbeq+2rfdq23qvtq33att6r7at92rbeq+2rfdq23qvtq33att6r7at92rbeq+2rfdq23qvtq33att6r7at92rbeq+2rfdq23qvtq33att6r7at92rbeq+2rfdq23qvtq33att6r7at92rbeq+2rfdq23qvtq33att6r7at92rbeq+2rfdq23qvtq33att6r7at92rbeq+2rfdq23qvtq33att6r7at92rbeq+2rfdq23qvtq33att6r7at92rbeq+2rfdqT3qv+Xh579auM4VhJ1kS4zEs22/DSivOMu1ncTMnzmVOmsucPJU5Z73tUeaYucyxc5nj5jKH5jLHz2XOXHflPNddOc91V85T3ZXdNtVd2W1T3ZXdNtVd2W1T3ZXd1vuu/HYrpps9fjJ7wmT2xMnsSZPZk+eyx3x8b74PM23DbNuw4j3p9hRzX8Lj9qzQV6CZEN2xu2+I4bGwTmmlg5tU3heRuc0XrvLbYduOBbA29/iYPG9f9tPk9vttD0Dwzr3a74XbH4TbH4Xbn4Tbn2XbX34BQ5D9Rrj9Vrj9s8+/NfuFz79W+Pxrhc+/Vvj8a4XPv1b4/OuEz79O+PzrhM+/Tvj864TPv074/OuEz79O+PzrhM+/Tvj8S8LnXxI+/5Lw+ZeEz78kfP4l4fMvCZ9/Sfj8S8LnXxI+/3rh868XPv964fOvFz7/euHzrxc+/3rh868XPv964fOvFz7/BuHzbxA+/wbh828QPv8G4fNvED7/BuHzbxA+/wbh828QPv9G4fNvFD7/RuHzbxQ+/0bh828UPv9G4fNvFD7/RuHzbxQ+/ybh828SPv8m4fNvEj7/JuHzbxI+/ybh828SPv8m4fNvEj7/ZuHzbxY+/2bh828WPv9m4fNvFj7/ZuHzbxY+/2bh82+WPf/SJnv+pU32/Eub7PmXNtnzL22y51/aZM+/tMmef2mTPf/SJnv+pU34/GuEz79G+PxrhM+/069/VbNf+PwrfP0rEr7+FQlf/4qEr39Fwte/IuHrX5Hw9a9I+PpXJHz9KxK+/hUJX/+KhK9/RcLXvyLh61+R8PWvSPj6VyR8/SsSvv4VCV//ioSvf0XC178i4etfkfD1r0j4+lckfP0rEr7+FQlf/4qEr39Fwte/IuHrX5Hw9a9I+PpXJHz9KxK+/hUJX/+KhK9/RcLXvyLh61+R8PWvSPj6VyR8/SsSvv4VCV//ioSvf0XC178i4etfkfD1r0j4+lckfP0rEr7+FQlf/4qEr39Fwte/IuHrX5Hw9a9I+PpXJHz9KxK+/hUJX/+KhK9/RcLXvyLh61+R8PWvSPj6VyR8/SsSvv4VCV//ioSvf0XC178i4etfkfD1r0j4+lckfP0rEr7+FQlf/4qEr39Fwte/IuHrX5Hw9a9I+PpXJHz9KxK+/hUJX/+KhK9/RcLXv/LC17/ywte/8sLXv/LC17/ym+z51wtf/8oLX//KC1//ygtf/8oLX//KC1//ygtf/8oLX//KC1//ygtf/8pPv/7V46dDzObZ/tLBu9UhhccPJ/fl6+xzNaevs8/rnL7OXgNw+jp7vcDo6/Rre3H6Onkd4rNPD1/te18p5t2O2wPmdBxscyiabeJhtaPjaOfiF5vJa5yhbCavn4ayocnvH9t23BM2F15qs7nWRrubNFUJdTdpqkrnbtJUBcndpKnqht8mzbV02N2kqWbhu0lTTX53k6aac+4mTXWrv5s03917rsWy7ibNd/eea0mru0nz3b3nWnjqbtJ8d++5loe6mzTf3XuuRZzuJs13955rqaW7SfPdvedaEOlu0nx377mWLbqbNN/de67Fhe4mzXf3nmsJoLtJ892951qo527SfHfvuZbTuZs03917rkVv7ibNd/eea2mau0nz3b3nWkDmbtJ8d++5lnm5mzTf3XuuxVjuJs13955ryZS7SfPdveda2ORu0nx377mWH7mbNN/de65FQu4mzXf3nmspj7tJ892951pw427SfHfvuZbFuJs03917rsUr7ibNd/eea4mJu0nz3b3nWgjibtJ8d++5lmu4mzTf3XuuRRXuJs13955r6YO7SfPdvedaoOBu0nx377mWEbibNN3dO8z1sf/dpOnu3mGuT/LvJk139w7bdHfvMNe38HeTprt7h7m+WL+bNN3dO8z1Xflvk+b6VPxu0nx377k+6L6bNN/de67Pru8mzXf3nuuD57tJ89295/p8+G7SfHfvuT7GvZs03917rk9V7ybNd/ee68PMu0nz3b3n+9YyzPetZZjvW8sw37eWYb5vLcN831qG+b61DPN9axnm+9YyzPetZZjvW8sw37eWYb5vLcN831qG+b61DPN9axnm+9YyzPetZZjvW8sw37eWYa5vLV+PflpWJyaTj6OLy+rc3NkXyvEpPv906ehkYv46+vbL8TjaJvvFZvKl5YaymXwpuqFsJl+6biSbub7HnYyNnKXx+rORszRefzZylsbrz4bnXrw9FuCLJj6x+X2Szz/AvA9zbcOobZhvGxbahsW2YaltWG4a9vkHavdhpm1YW5bEtiyJbVkS27IktmVJbMuS2JYlsS1LUluWpLYsSW1ZktqyJLVlSWrLktSWJaktS1JblqS2LMltWZLbsiS3ZUluy5LcliW5LUtyW5bktizJbVmSm7IkblvbMNM2zLYNc23DqG2YbxsW2obFtmGpbVhblpi2LDFtWWLassS0ZYlpyxLTliWmLUtMW5aYtiwxbVli27LEtmWJbcsS25Ylti1LbFuW2LYssW1ZYtuyxLZliWvLkvJLCxSOYXS7bxSG2fIw8xhmt/98L7fT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",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert"
      ],
      "verification_key": "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"
    },
    {
      "name": "add_lock_public_user",
      "is_unconstrained": true,
      "custom_attributes": [
        "internal",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "2722406262643068352": {
            "error_kind": "string",
            "string": "HashlockAlreadySet"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16870384257694633552": {
            "error_kind": "string",
            "string": "Function add_lock_public_user can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "add_lock_public_user"
      ]
    },
    {
      "name": "redeem_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "ownership_key",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6012086182631426650": {
            "error_kind": "string",
            "string": "NotAnOwner"
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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+4ty+6tu+/ffe1Bkv1Nuv1duf1Buv/T627Jfef0l5fWXlNdfUl5/SXn9jcrrb1Ref6Py+huV19+ovP5G5fU3Kq+/UXn9jcrrb1Ref5Py+puU19+kvP4m5fU3Ka+/SXn9Tcrrb1Jef5Py+puU19+svP5m5fU3K6+/WXn9zcrrb1Zef7Py+puV19+svP5m5fW3KK+/RXn9Lcrrb1Fef4vy+luU19+ivP4W5fW3KK+/RXn9rcrrb1Vef6vy+luV19+qvP5W5fW3Kq+/VXn9rcrrb9Vdf/2iu/76RXf99Yvu+usX3fXXL7rrr19011+/6K6/ftFdf/2iu/76RXn9dcrrr1Nef53y+uuU11+nvP465fXXKa+/Tnn9dcrrr1Nef73y+uuV11+vvP565fXXK6+/Xnn99crrr1def73y+uuV19+gvP4G5fU3KK+/QXn9Fb/+Vct+5fVX+fpXXvn6V175+lde+fpXXvn6V175+lde+fpXXvn6V175+lde+fpXXvn6V175+lde+fpXXvn6V175+lde+fpXXvn6V175+lde+fpXXvn6V175+lde+fpXXvn6V175+lde+fpXXvn6V175+lde+fpXXvn6V175+lde+fpXXvn6V175+lde+fpXXvn6V175+lde+fpXXvn6V175+lde+fpXXvn6V175+lde+fpXXvn6V175+lde+fpXXvn6V175+lde+fpXXvn6V175+lde+fpXXvn6V175+lde+fpXXvn6V175+lde+fpXXvn6V175+lde+fpXXvn6V175+lde+fpXQfn6V0H5+ldB+fpXQfn6V2HRXX+D8vWvgvL1r4Ly9a+C8vWvgvL1r4Ly9a+C8vWvgvL1r4Ly9a+C8vWvgvL1r4Ly9a+C8vWvgvL1r4Ly9a+C8vWvgvL1r4Ly9a+C8vWvgvL1r4Ly9a+C8vWvgvL1r4Ly9a+C8vWvgvL1r4Ly9a+C8vWvgvL1r4Ly9a+C8vWvgvj1r15/OuXq3u3fO3i1OpX0+sMlfPkqvVZz+iq9rnP6Kr0HYPRV/HpdnL5K7y04fRXeh8Qay8tX/9lXv9TqV7sf/y7b4b6mL3+F9y3s/pIxf4X3Rez+Cu+j2P0V3kux+yu8n2L3V3pPtSxbPV1C+qFrZK2r9jRJVDvzNElU1/E0SVRj8DRJVO1+miSqvD5NElUBnyaJKlJPk0TVkadJ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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "build_msg_block",
        "attach_len_to_msg_block",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000001"
            },
            {
              "kind": "string",
              "value": "HTLC_Private"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Train"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "contracts_private",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "contracts_public",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "ownership_hash",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 48
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::lock_public_solver_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::lock_public_solver_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "ownership_hash",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 48
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::lock_private_solver_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::lock_private_solver_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "secret",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::redeem_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::redeem_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "Train::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "src_receiver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 48
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::commit_private_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::commit_private_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::refund_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::refund_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 48
                    }
                  },
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "src_receiver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::commit_public_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::commit_public_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::add_lock_private_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::add_lock_private_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::refund_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::refund_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::add_lock_public_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::add_lock_public_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "secret",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "ownership_key",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::redeem_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::redeem_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "key",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::get_htlc_public_solver_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "src_receiver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "hashlock_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "hashlock_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "secret_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "secret_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "ownership_hash_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "ownership_hash_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "claimed",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::HTLC_Public"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::get_htlc_public_solver_abi"
        }
      ]
    }
  },
  "file_map": {
    "100": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, &[], true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "101": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\nuse super::utils::is_note;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract. Only a single struct in the entire contract\n/// should have this macro (or `storage_no_init`) applied to it.\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot }, false);\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n/// Only a single struct in the entire contract should have this macro (or `storage`) applied to it.\npub comptime fn storage_no_init(_s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(\n    typ: Type,\n    slot: Quoted,\n    parent_is_map: bool,\n) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot }, true);\n        (quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }, 1)\n    } else {\n        let storage_size = if parent_is_map {\n            // Variables inside a map do not require contiguous slots since the map slot derivation is assumed to result\n            // in slots very far away from one another.\n            1\n        } else {\n            let (_, container_struct_generics) = typ.as_data_type().unwrap();\n            let stored_struct = container_struct_generics[0];\n\n            if is_note(stored_struct) {\n                // Private notes always occupy a single slot, since the slot is only used as a state variable\n                // identifier.\n                1\n            } else {\n                get_storage_size(typ)\n            }\n        };\n\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        (quote { $struct_name::new(context, $slot)}, storage_size)\n    }\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "103": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "104": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash =\n            compute_unique_note_hash(nonce, compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash));\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.nonce, note_and_data.nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == first_note_and_data.nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == second_note_and_data.nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "105": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    pending_partial_notes.for_each(|i, pending_partial_note: DeliveredPendingPartialNote| {\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log sans the extra\n            // fields) to get the complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                // temporary node connectivity issue - is simply throwing good enough here?\n                assert(\n                    deliver_note(\n                        contract_address,\n                        pending_partial_note.storage_slot,\n                        discovered_note.nonce,\n                        complete_packed_note,\n                        discovered_note.note_hash,\n                        discovered_note.inner_nullifier,\n                        log.tx_hash,\n                        pending_partial_note.recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "107": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/messages/discovery/private_logs.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{\n            ComputeNoteHashAndNullifier,\n            partial_notes::process_partial_note_private_msg,\n            pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n            private_notes::process_private_note_msg,\n        },\n        encoding::decode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        msg_type::{\n            PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n        },\n    },\n    oracle::{logs::store_private_event_log, message_discovery::sync_notes},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `syncNotes` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    sync_notes(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get the logs from the capsule array and process them one by one\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    logs.for_each(|i, log: PendingTaggedLog| {\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n        logs.remove(i);\n    });\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(log_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            pending_tagged_log.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        // In the case of events, the msg metadata is the event selector.\n        let event_selector = EventSelector::from_field(msg_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            msg_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n            pending_tagged_log.tx_index_in_block,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "108": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n        // issue, and we should perhaps not have marked the tag index as taken.\n        assert(\n            oracle::message_discovery::deliver_note(\n                contract_address,\n                storage_slot,\n                discovered_note.nonce,\n                packed_note,\n                discovered_note.note_hash,\n                discovered_note.inner_nullifier,\n                tx_hash,\n                recipient,\n            ),\n            \"Failed to deliver note\",\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "109": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\nglobal MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "110": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "117": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/messages/logs/note.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    messages::{\n        encoding::encode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        logs::utils::prefix_with_tag,\n        msg_type::{PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID},\n    },\n    note::{note_emission::NoteEmission, note_interface::NoteType},\n};\nuse protocol_types::{\n    abis::note_hash::NoteHash, address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS,\n    traits::Packable,\n};\n\n// TODO: it feels like this existence check is in the wrong place. In fact, why is it needed at all? Under what circumstances have we found a non-existent note being emitted accidentally?\nfn assert_note_exists<let N: u32>(context: PrivateContext, note_hash_counter: u32) {\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists =\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n}\n\npub fn compute_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PRIVATE_NOTE_MSG_TYPE_ID,\n    )\n}\n\npub fn compute_partial_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID,\n    )\n}\n\nfn compute_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    msg_type: u64,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let packed_note = note.pack();\n\n    // A note message's content is the storage slot followed by the packed note representation\n    let mut msg_content: [Field; N + 1] = std::mem::zeroed();\n    msg_content[0] = storage_slot;\n    for i in 0..packed_note.len() {\n        msg_content[1 + i] = packed_note[i];\n    }\n\n    // Notes use the note type id for metadata\n    let plaintext = encode_message(msg_type, Note::get_id() as u64, msg_content);\n\n    let ciphertext = AES128::encrypt_log(plaintext, recipient);\n\n    let log = prefix_with_tag(ciphertext, sender, recipient);\n\n    log\n}\n\npub unconstrained fn compute_note_log_unconstrained<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_note_log(note, storage_slot, recipient, sender)\n}\n\n/// Sends an encrypted message to `recipient` with the content of the note, which they will discover when processing\n/// private logs.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n        assert_note_exists(*context, note_hash_counter);\n\n        let encrypted_log = compute_note_log(note, storage_slot, recipient, sender);\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n\n/// Same as `encode_and_encrypt_note`, except encryption is unconstrained. This means that the sender is free to make\n/// the log contents be whatever they wish, potentially resulting in scenarios in which the recipient is unable to\n/// decrypt and process the payload, **leading to the note being lost**.\n///\n/// Only use this function in scenarios where the recipient not receiving the note is an acceptable outcome.\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n\n        assert_note_exists(*context, note_hash_counter);\n\n        // Safety: this function does not constrain the encryption of the log, as explained on its description.\n        let encrypted_log =\n            unsafe { compute_note_log_unconstrained(note, storage_slot, recipient, sender) };\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n"
    },
    "118": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/messages/logs/utils.nr",
      "source": "use crate::{\n    oracle::notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n    prelude::AztecAddress,\n};\n\npub(crate) fn prefix_with_tag<let L: u32>(\n    log_without_tag: [Field; L],\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> [Field; L + 1] {\n    // Safety: we assume that the sender wants for the recipient to find the tagged note, and therefore that they will\n    // cooperate and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the\n    // note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    let mut log_with_tag = [0; L + 1];\n\n    log_with_tag[0] = tag;\n    for i in 0..log_without_tag.len() {\n        log_with_tag[i + 1] = log_without_tag[i];\n    }\n\n    log_with_tag\n}\n\nmod test {\n    use super::prefix_with_tag;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn prefixing_with_tag() {\n        let sender = AztecAddress::from_field(1);\n        let recipient = AztecAddress::from_field(2);\n\n        let app_tagging_secret = 42;\n        let index = 5;\n\n        // I am using the deserialize trait instead of directly instantiating the IndexedTaggingSecret struct because\n        // direct instantiation functionality is not exposed.\n        let indexed_tagging_secret = IndexedTaggingSecret::deserialize([app_tagging_secret, index]);\n\n        // Mock the tagging oracles\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(indexed_tagging_secret);\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        let log_without_tag = [1, 2, 3];\n        let log_with_tag = prefix_with_tag(log_without_tag, sender, recipient);\n\n        let expected_result = [indexed_tagging_secret.compute_tag(recipient), 1, 2, 3];\n\n        // Check tag was prefixed correctly\n        assert_eq(log_with_tag, expected_result, \"Tag was not prefixed correctly\");\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "123": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_interface::{NoteHash, NoteType},\n    retrieved_note::RetrievedNote,\n    utils::{compute_note_hash_for_nullify_from_read_request, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::notify_created_note;\nuse protocol_types::traits::Packable;\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    let note_hash_counter = context.side_effect_counter;\n\n    let note_hash = note.compute_note_hash(storage_slot);\n\n    let packed_note = Note::pack(note);\n    notify_created_note(\n        storage_slot,\n        Note::get_id(),\n        packed_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(note, storage_slot, note_hash_counter)\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n\n    destroy_note_unsafe(context, retrieved_note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_from_read_request(retrieved_note, note_hash_for_read_request);\n    let nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash = if retrieved_note.metadata.is_settled() {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifying so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, note_hash)\n}\n"
    },
    "125": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub note: Note,\n    pub storage_slot: Field,\n    pub note_hash_counter: u32, // a note_hash_counter of 0 means settled\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note, storage_slot: Field, note_hash_counter: u32) -> Self {\n        Self { note, storage_slot, note_hash_counter }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "128": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/note/note_getter.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n    retrieved_note::RetrievedNote,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::oracle;\nuse crate::utils::{array, comparison::compare};\nuse dep::protocol_types::{\n    constants::{GET_NOTES_ORACLE_RETURN_LENGTH, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL},\n    traits::{Packable, ToField},\n};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    packed_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the packed note.\n    // This allows easier packing and custom (un)packing schemas. A note property is located\n    // inside the packed note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = packed_note[selector.index as u32].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[(31 + offset - i) as u32] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_packed_note<let N: u32>(packed_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(packed_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (RetrievedNote<Note>, Field)\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    // Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do\n    // is check that the metadata is correct, and that the note exists.\n    let retrieved_note = unsafe { get_note_internal::<Note, N>(storage_slot) };\n\n    // For settled notes, the contract address is implicitly checked since the hash returned from\n    // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n    // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the contract\n    // address returned from the oracle matches. Since branching in circuits is expensive, we perform this check on all\n    // note types.\n    assert(\n        retrieved_note.contract_address.eq(context.this_address()),\n        \"Note contract address mismatch.\",\n    );\n\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (retrieved_note, note_hash_for_read_request)\n}\n\n/// Returns a BoundedVec of notes that have been proven to have been created by this contract, either in the current or\n/// past transactions (i.e. pending or settled notes). A second BoundedVec contains the note hashes used for the read\n/// requests, which can save constraints when computing the note's nullifiers.\n///\n/// WARNING: recall that notes are never destroyed! Note existence therefore does not imply that the note is _current_\n/// or _valid_ - this typically requires also emitting the note's nullifier to prove that it had not been emitted\n/// before. Because of this, calling this function directly from end-user applications should be discouraged, and safe\n/// abstractions such as aztec-nr's state variables should be used instead.\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // Safety: The notes are constrained below.\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the notes (as opposed to simply removing some), the private\n    // kernel will later validate that these note actually exist, so transformations would cause for that check\n    // to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = array::collapse(filtered_notes);\n    let mut note_hashes = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_packed_note = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let retrieved_note = notes.get_unchecked(i);\n\n            // For settled notes, the contract address is implicitly checked since the hash returned from\n            // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n            // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the\n            // contract address returned from the oracle matches. Since branching in circuits is expensive, we perform\n            // this check on all note types.\n            assert(\n                retrieved_note.contract_address.eq(context.this_address()),\n                \"Note contract address mismatch.\",\n            );\n\n            let packed_note = retrieved_note.note.pack();\n            check_packed_note(packed_note, options.selects);\n            if i != 0 {\n                check_notes_order(prev_packed_note, packed_note, options.sorts);\n            }\n            prev_packed_note = packed_note;\n\n            let note_hash_for_read_request =\n                compute_note_hash_for_read_request(retrieved_note, storage_slot);\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> RetrievedNote<Note>\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let opt_notes: [_; 1] = oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_fields,\n    );\n\n    opt_notes[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_fields,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\n/// Unconstrained variant of `get_notes`, meant to be used in unconstrained execution contexts. Notably only the note\n/// content is returned, and not any of the information used when proving its existence (e.g. nonce, note hash, etc.).\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteType + Packable<N> + Eq,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n\n    // We fetch the notes from the same oracle we use in the constrained case, except we don't bother inspecting the\n    // metadata in order to prove existence.\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_fields,\n    );\n\n    // Even though we don't expect for the opt_notes array to be sparse, collapse is still useful in this case to\n    // convert it into a BoundedVec.\n    array::collapse(opt_notes).map(\n        // view_notes just returns the actual note, so we drop the metadata\n        |retrieved_note| retrieved_note.note,\n    )\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects as u32] = select.unwrap_unchecked().value;\n            select_comparators[num_selects as u32] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
    },
    "131": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "134": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "137": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "138": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "139": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "140": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "141": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "142": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "146": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "147": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "148": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "149": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use crate::messages::encoding::MAX_MESSAGE_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        msg_content,\n        tx_hash,\n        log_index_in_tx,\n        tx_index_in_block,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {}\n"
    },
    "150": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr",
      "source": "use crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn sync_notes(pending_tagged_log_array_base_slot: Field) {\n    sync_notes_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "152": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::{\n    note::{note_interface::NoteType, note_metadata::NoteMetadata, retrieved_note::RetrievedNote},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::IndexedTaggingSecret,\n    traits::{FromField, Packable},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {\n    // This wrapper exists to extract the ORACLE_RETURN_FIELD_LENGTH generic numeric param into a value and pass it to\n    // the oracle, so that it knows how big the return array must be.\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        ORACLE_RETURN_FIELD_LENGTH,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let MAX_NOTES: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    _placeholder_fields: [Field; ORACLE_RETURN_FIELD_LENGTH], // TODO: Compute this value automatically from MAX_NOTES\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let fields: [_; ORACLE_RETURN_FIELD_LENGTH] = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n\n    let mut opt_notes = [Option::none(); MAX_NOTES];\n    for i in 0..opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let maybe_nonce = fields[read_offset];\n            let maybe_note_hash_counter = fields[read_offset + 1] as u32;\n            let packed_note = array::subarray(fields, read_offset + 2);\n\n            let note = Note::unpack(packed_note);\n            let retrieved_note = RetrievedNote {\n                note,\n                contract_address,\n                metadata: NoteMetadata::from_raw_data(maybe_note_hash_counter != 0, maybe_nonce),\n            };\n\n            opt_notes[i] = Option::some(retrieved_note);\n        };\n    }\n    opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "153": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "154": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "155": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "157": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "159": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/state_vars/private_immutable.nr",
      "source": "use dep::protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\nuse crate::context::{PrivateContext, UtilityContext};\nuse crate::note::{\n    lifecycle::create_note,\n    note_emission::NoteEmission,\n    note_getter::{get_note, view_notes},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateImmutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context, let N: u32> Storage<N> for PrivateImmutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateImmutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateImmutable>` type (for example), because the storage slot often also identifies an actor.\n    // e.g. the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<Note> PrivateImmutable<Note, &mut PrivateContext> {\n    // docs:start:initialize\n    pub fn initialize<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: NoteType + NoteHash + Packable<N>,\n    {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:get_note\n    pub fn get_note<let N: u32>(self) -> Note\n    where\n        Note: NoteType + NoteHash + Packable<N>,\n    {\n        let storage_slot = self.storage_slot;\n        let retrieved_note = get_note(self.context, storage_slot).0;\n\n        // Because the notes obtained from PrivateImmutable are not meant to be nullified and get_note(...) function\n        // has already constrained the note (by pushing a read request to the context), we can return just the note\n        // and skip the additional data in RetrievedNote.\n        retrieved_note.note\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateImmutable<Note, UtilityContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    // docs:start:is_initialized\n    pub unconstrained fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // view_note does not actually use the context, but it calls oracles that are only available in private\n    // docs:start:view_note\n    pub unconstrained fn view_note<let N: u32>(self) -> Note\n    where\n        Note: Packable<N>,\n    {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: x_coordinates_match,\n        };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "168": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable.nr",
      "source": "use dep::protocol_types::{\n    shared_mutable::{\n        ScheduledDelayChange,\n        ScheduledValueChange,\n        shared_mutable_values::{unpack_delay_change, unpack_value_change},\n        SharedMutableValues,\n    },\n    traits::Packable,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\n\nmod test;\n\npub struct SharedMutable<T, let INITIAL_DELAY: u32, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// This will make the Aztec macros require that T implements the Packable and Eq traits, and allocate `M` storage\n// slots to this state variable.\nimpl<T, let INITIAL_DELAY: u32, Context, let M: u32> Storage<M> for SharedMutable<T, INITIAL_DELAY, Context>\nwhere\n    WithHash<SharedMutableValues<T, INITIAL_DELAY>, _>: Packable<M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in blocks. Reads in private are only valid as long as they are included in a block not too far into the\n// future, so that they can guarantee the value will not have possibly changed by then (because of the delay).\n// The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, let INITIAL_DELAY: u32, Context> SharedMutable<T, INITIAL_DELAY, Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PublicContext>\nwhere\n    T: Eq,\n{\n\n    pub fn schedule_value_change<let N: u32>(self, new_value: T)\n    where\n        T: Packable<N>,\n    {\n        let _value_change = self.schedule_and_return_value_change(new_value);\n    }\n\n    pub fn schedule_and_return_value_change<let N: u32>(\n        self,\n        new_value: T,\n    ) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n        let current_delay = delay_change.get_current(block_number);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let block_of_change = block_number + current_delay;\n        value_change.schedule_change(new_value, block_number, current_delay, block_of_change);\n\n        self.write(value_change, delay_change);\n\n        value_change\n    }\n\n    pub fn schedule_delay_change<let N: u32>(self, new_delay: u32)\n    where\n        T: Packable<N>,\n    {\n        let mut delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n\n        delay_change.schedule_change(new_delay, block_number);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    pub fn get_current_delay<let N: u32>(self) -> u32\n    where\n        T: Packable<N>,\n    {\n        let block_number = self.context.block_number() as u32;\n        self.read_delay_change().get_current(block_number)\n    }\n\n    pub fn get_scheduled_value<let N: u32>(self) -> (T, u32)\n    where\n        T: Packable<N>,\n    {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay<let N: u32>(self) -> (u32, u32)\n    where\n        T: Packable<N>,\n    {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change<let N: u32>(self) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        // We don't read ScheduledValueChange directly by having it implement Packable because ScheduledValueChange\n        // and ScheduledDelayChange are packed together (sdc and svc.block_of_change are stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_value_change::<T, N>(packed)\n    }\n\n    fn read_delay_change<let N: u32>(self) -> ScheduledDelayChange<INITIAL_DELAY>\n    where\n        T: Packable<N>,\n    {\n        // Since all ScheduledDelayChange member are packed into a single field, we can read a single storage slot\n        // here and skip the ones that correspond to ScheduledValueChange members. We are abusing the fact that\n        // the field containing the ScheduledDelayChange data is the first one in the storage layout - otherwise we'd\n        // need to offset the storage slot to get the position where it'd land.\n        // We don't read ScheduledDelayChange directly by having it implement Packable because\n        // ScheduledValueChange and ScheduledDelayChange are packed together (sdc and svc.block_of_change are\n        // stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_delay_change::<INITIAL_DELAY>(packed)\n    }\n\n    fn write<let N: u32>(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>,\n    )\n    where\n        T: Packable<N>,\n    {\n        // Whenever we write to public storage, we write both the value change and delay change to storage at once.\n        // We do so by wrapping them in a single struct (`SharedMutableValues`). Then we wrap the resulting struct in\n        // `WithHash`.\n        // Wrapping in `WithHash` makes for more costly writes but it also makes private proofs much simpler because\n        // they only need to produce a historical proof for the hash, which results in a single inclusion proof (as\n        // opposed to 4 in the best case scenario in which T is a single field). Private shared mutable reads are\n        // assumed to be much more frequent than public writes, so this tradeoff makes sense.\n        let values = WithHash::new(SharedMutableValues::new(value_change, delay_change));\n\n        self.context.storage_write(self.storage_slot, values);\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext>\nwhere\n    T: Eq,\n{\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction block number as this proof\n        // will only be valid for however many blocks we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n        let (value_change, delay_change, historical_block_number) =\n            self.historical_read_from_public_storage();\n\n        // We use the effective minimum delay as opposed to the current delay at the historical block as this one also\n        // takes into consideration any scheduled delay changes.\n        // For example, consider a scenario in which at block 200 the current delay was 50. We may naively think that\n        // the earliest we could change the value would be at block 251 by scheduling immediately after the historical\n        // block, i.e. at block 201. But if there was a delay change scheduled for block 210 to reduce the delay to 20\n        // blocks, then if a value change was scheduled at block 210 it would go into effect at block 230, which is\n        // earlier than what we'd expect if we only considered the current delay.\n        let effective_minimum_delay =\n            delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon =\n            value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any block after the block horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_tx_max_block_number(block_horizon);\n        value_change.get_current_at(historical_block_number)\n    }\n\n    fn historical_read_from_public_storage<let N: u32>(\n        self,\n    ) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u32)\n    where\n        T: Packable<N>,\n    {\n        let header = self.context.get_block_header();\n        let address = self.context.this_address();\n\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        let values: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::historical_public_storage_read(header, address, self.storage_slot);\n\n        (values.svc, values.sdc, historical_block_number)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, UtilityContext>\nwhere\n    T: Eq,\n{\n    pub unconstrained fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let smv: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::utility_public_storage_read(self.context, self.storage_slot);\n\n        let block_number = self.context.block_number() as u32;\n        smv.svc.get_current_at(block_number)\n    }\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "180": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "183": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "184": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "186": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "187": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "189": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "191": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "192": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/utils/random.nr",
      "source": "use crate::oracle::random::random;\n\n/// Returns as many random bytes as specified through N.\npub unconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n"
    },
    "195": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "20": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "219": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "221": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "264": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "279": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "281": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "282": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "283": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr",
      "source": "use crate::traits::{Deserialize, Serialize, ToField};\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\nuse std::meta::derive;\n\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\n\n#[derive(Serialize, Deserialize)]\npub struct IndexedTaggingSecret {\n    app_tagging_secret: Field,\n    index: u32,\n}\n\nimpl IndexedTaggingSecret {\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\n        poseidon2_hash(\n            [self.app_tagging_secret, recipient.to_field(), self.index as Field],\n        )\n    }\n}\n"
    },
    "292": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "296": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `omit`: A list of field names (as `Quoted`) to be excluded from the serialized output.\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, &[], false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, &[], false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], &[], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, &[], false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with Omitted Field and packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// Serializing while omitting `value2`:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, MyStruct, &[quote { self.value2 }], true)\n/// // Returns:\n/// // ([`value_packed[0]`], [`let value_packed = self.value.pack()`])\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    omit: [Quoted],\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // Proceed if none of the omit rules omits this name\n    if !omit.any(|to_omit| to_omit == name) {\n        // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n        let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n        let packable_constraint =\n            quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n        if (should_pack & typ.implements(packable_constraint)) {\n            // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n            // method, add the resulting field array to `aux_vars` and each field to `fields`.\n            let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n            // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n            let name_at_one_token = collapse_to_one_token(name);\n            let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n            // We add the individual fields to the fields array\n            let pack_method = get_trait_impl_method(\n                typ,\n                quote { crate::traits::Packable<$packed_len> },\n                quote { pack },\n            );\n            let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n            for i in 0..packed_len {\n                fields = fields.push_back(quote { $packed_struct_name[$i] });\n            }\n\n            // We add the new auxiliary variable to the aux_vars array\n            aux_vars = aux_vars.push_back(packed_struct);\n        } else if typ.is_field() {\n            // For field we just add the value to fields\n            fields = fields.push_back(name);\n        } else if typ.as_integer().is_some() | typ.is_bool() {\n            // For integer and bool we just cast to Field and add the value to fields\n            fields = fields.push_back(quote { $name as Field });\n        } else if typ.as_data_type().is_some() {\n            // For struct we pref\n            let nested_struct = typ.as_data_type().unwrap();\n            let params = nested_struct.0.fields(nested_struct.1);\n            let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n                let maybe_prefixed_name = if name == quote {} {\n                    // Triggered when the param name is of a value available in the current scope (e.g. a function\n                    // argument) --> then we don't prefix the name with anything.\n                    param_name\n                } else {\n                    // Triggered when we want to prefix the param name with the `name` from function input. This\n                    // can typically be `self` when implementing a method on a struct.\n                    quote { $name.$param_name }\n                };\n                generate_serialize_to_fields(\n                    quote {$maybe_prefixed_name},\n                    param_type,\n                    omit,\n                    should_pack,\n                )\n            });\n            let struct_flattened_fields = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n            );\n            let struct_flattened_aux_vars = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n            );\n            fields = fields.append(struct_flattened_fields);\n            aux_vars = aux_vars.append(struct_flattened_aux_vars);\n        } else if typ.as_array().is_some() {\n            // For array we recursively call `generate_serialize_to_fields(...)` for each element\n            let (element_type, array_len) = typ.as_array().unwrap();\n            let array_len = array_len.as_constant().unwrap();\n            for i in 0..array_len {\n                let (element_fields, element_aux_vars) = generate_serialize_to_fields(\n                    quote { $name[$i] },\n                    element_type,\n                    omit,\n                    should_pack,\n                );\n                fields = fields.append(element_fields);\n                aux_vars = aux_vars.append(element_aux_vars);\n            }\n        } else if typ.as_str().is_some() {\n            // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n            // then we add each byte to fields as a Field\n            let length_type = typ.as_str().unwrap();\n            let str_len = length_type.as_constant().unwrap();\n            let as_member = name.as_expr().unwrap().as_member_access();\n            let var_name = if as_member.is_some() {\n                as_member.unwrap().1\n            } else {\n                name\n            };\n            let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n            let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n            for i in 0..str_len {\n                fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n            }\n            aux_vars = aux_vars.push_back(as_bytes);\n        } else {\n            panic(\n                f\"Unsupported type for serialization of argument {name} and type {typ}\",\n            )\n        }\n    }\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) =\n        generate_serialize_to_fields(quote { self }, typ, &[], packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "298": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "299": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "308": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize, ToField},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "312": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_delay_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initially equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation\n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the\n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a\n// reduced delay, invalidating prior private reads.\npub struct ScheduledDelayChange<let INITIAL_DELAY: u32> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option,\n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pub(crate) pre: Option<u32>,\n    pub(crate) post: Option<u32>,\n    // Block at which `post` value is used instead of `pre`\n    pub(crate) block_of_change: u32,\n}\n\nimpl<let INITIAL_DELAY: u32> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u32>, post: Option<u32>, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current block number - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_block_number: u32) -> u32 {\n        // The post value becomes the current one at the block of change, so any transaction that is included in the\n        // block of change will use the post value.\n        if current_block_number < self.block_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the block at which it will become the current\n    /// delay. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u32, u32) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.block_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current block number. This function is only meaningful\n    /// when called in public with the current block number.\n    /// The block at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u32, current_block_number: u32) {\n        let current = self.get_current(current_block_number);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let blocks_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior constraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value block of change\n            //       block                 block of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   blocks until change               new delay            |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.block_of_change = current_block_number + blocks_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical block number. It only returns a meaningful value when called in private with historical blocks. This\n    /// function can be used alongside `ScheduledValueChange.get_block_horizon` to properly constrain the\n    /// `max_block_number` transaction property when reading mutable shared state.\n    /// This value typically equals the current delay at the block following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is\n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_block_number: u32) -> u32 {\n        if self.block_of_change <= historical_block_number {\n            // If no delay changes were scheduled, then the delay value at the historical block (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // block of change the current delay will be the scheduled one, with an overall delay from the historical\n            // block number equal to the number of blocks until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //         block                  delay                  actual earliest value\n            //           v                block of change              block of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest block in            |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |         blocks                  new delay                      |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest block in\n            //                             which to scheduled value change\n            let blocks_until_change = self.block_of_change - (historical_block_number + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                blocks_until_change + self.post.unwrap_or(INITIAL_DELAY),\n            )\n        }\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Empty for ScheduledDelayChange<INITIAL_DELAY> {\n    fn empty() -> Self {\n        Self { pre: Option::none(), post: Option::none(), block_of_change: 0 }\n    }\n}\n"
    },
    "314": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_value_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some block\n// called the `block_of_change`. The value can only be made to change by scheduling a change event at some future block\n// of change after some minimum delay measured in blocks has elapsed. This means that at any given block number we know\n// both the current value and the smallest block number at which the value might change - this is called the\n// 'block horizon'.\npub struct ScheduledValueChange<T> {\n    pub(crate) pre: T,\n    pub(crate) post: T,\n    // Block at which `post` value is used instead of `pre`\n    pub(crate) block_of_change: u32,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given block. This function can be called both in public\n    /// (where `block_number` is simply the current block number, i.e. the number of the block in which the current\n    /// transaction will be included) and in private (where `block_number` is the historical block number that is used\n    /// to construct the proof).\n    /// Reading in private is only safe if the transaction's `max_block_number` property is set to a value lower or\n    /// equal to the block horizon (see `get_block_horizon()`).\n    pub fn get_current_at(self, block_number: u32) -> T {\n        // The post value becomes the current one at the block of change. This means different things in each realm:\n        // - in public, any transaction that is included in the block of change will use the post value\n        // - in private, any transaction that includes the block of change as part of the historical state will use the\n        //   post value (barring any follow-up changes)\n        if block_number < self.block_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the block at which it will become the current\n    /// value. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u32) {\n        (self.post, self.block_of_change)\n    }\n\n    // Returns the previous value. This is the value that is current up until the block of change. Note that this value\n    // might not be the current anymore since block of change might have already passed.\n    pub fn get_previous(self) -> (T, u32) {\n        (self.pre, self.block_of_change)\n    }\n\n    /// Returns the largest block number at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_block_number`,\n    /// since due to its asynchronous nature private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum number of blocks that need to\n    /// elapse from the next block until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical block number is only safe to use\n    /// if the transaction's `max_block_number` property is set to a value lower or equal to the block horizon computed\n    /// using the same historical block number.\n    pub fn get_block_horizon(self, historical_block_number: u32, minimum_delay: u32) -> u32 {\n        // The block horizon is the very last block in which the current value is known. Any block past the horizon\n        // (i.e. with a block number larger than the block horizon) may have a different current value. Reading the\n        // current value in private typically requires constraining the maximum valid block number to be equal to the\n        // block horizon.\n        if historical_block_number >= self.block_of_change {\n            // Once the block of change has been mined, the current value (post) will not change unless a new value\n            // change is scheduled. This did not happen at the historical block number (or else it would not be\n            // greater or equal to the block of change), and therefore could only happen after the historical block\n            // number. The earliest would be the immediate next block, and so the smallest possible next block of change\n            // equals `historical_block_number + 1 + minimum_delay`. Our block horizon is simply the previous block to\n            // that one.\n            //\n            //      block of      historical\n            //       change         block            block horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n            historical_block_number + minimum_delay\n        } else {\n            // If the block of change has not yet been mined however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the block horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the block of change is in the past: the time horizon is the\n            //      block prior to the earliest one in which a new block of change might land.\n            //\n            //         historical\n            //           block                        block horizon      block of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` blocks away from the historical block number, in which case\n            //      the block of change would become the limiting factor for the time horizon, which would equal the\n            //      block right before the block of change (since by definition the value changes at the block of\n            //      change).\n            //\n            //           historical                         block horizon\n            //             block     block of change       if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the block of change to an arbitrary\n            // value, and therefore scenario a) is not currently possible. However implementing #5501 would allow for\n            // this to happen.\n            // Because historical_block_number < self.block_of_change, then block_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.block_of_change - 1,\n                historical_block_number + minimum_delay,\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current block number. This function is only meaningful when\n    /// called in public with the current block number.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_block_number: u32,\n        minimum_delay: u32,\n        block_of_change: u32,\n    ) {\n        assert(block_of_change >= current_block_number + minimum_delay);\n\n        self.pre = self.get_current_at(current_block_number);\n        self.post = new_value;\n        self.block_of_change = block_of_change;\n    }\n}\n\nimpl<T> Eq for ScheduledValueChange<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n\nimpl<T> Empty for ScheduledValueChange<T>\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        Self { pre: T::empty(), post: T::empty(), block_of_change: 0 }\n    }\n}\n"
    },
    "316": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/shared_mutable_values.nr",
      "source": "use crate::{\n    hash::poseidon2_hash,\n    shared_mutable::{\n        scheduled_delay_change::ScheduledDelayChange, scheduled_value_change::ScheduledValueChange,\n    },\n    traits::{Hash, Packable},\n    utils::arrays,\n};\nuse std::meta::derive;\n\nmod test;\n\n/// SharedMutableValues is just a wrapper around ScheduledValueChange and ScheduledDelayChange that then allows us\n/// to wrap both of these values in WithHash. WithHash allows for efficient read of values in private.\n///\n/// Note that the WithHash optimization does not work in public (due to there being no unconstrained). But we also want\n/// to be able to read the values efficiently in public and we want to be able to read each value separately. Reading\n/// the values separately is tricky because ScheduledValueChange and ScheduledDelayChange are packed together (sdc and\n/// svc.block_of_change are stored in the same slot). For that reason we expose `unpack_value_change` and\n/// `unpack_delay_change` functions that can be used to extract the values from the packed representation. This\n/// is \"hacky\" but there is no way around it.\n#[derive(Eq)]\npub struct SharedMutableValues<T, let INITIAL_DELAY: u32> {\n    pub svc: ScheduledValueChange<T>,\n    pub sdc: ScheduledDelayChange<INITIAL_DELAY>,\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutableValues<T, INITIAL_DELAY> {\n    pub fn new(svc: ScheduledValueChange<T>, sdc: ScheduledDelayChange<INITIAL_DELAY>) -> Self {\n        SharedMutableValues { svc, sdc }\n    }\n}\n\npub fn unpack_value_change<T, let N: u32>(packed: [Field; 2 * N + 1]) -> ScheduledValueChange<T>\nwhere\n    T: Packable<N>,\n{\n    let svc_pre_packed = arrays::subarray(packed, 1);\n    let svc_post_packed = arrays::subarray(packed, N + 1);\n    ScheduledValueChange::new(\n        T::unpack(svc_pre_packed),\n        T::unpack(svc_post_packed),\n        packed[0] as u32,\n    )\n}\n\npub fn unpack_delay_change<let INITIAL_DELAY: u32>(\n    packed: Field,\n) -> ScheduledDelayChange<INITIAL_DELAY> {\n    // This function expects to be called with just the first field of the packed representation, which contains sdc\n    // and svc block_of_change. We'll discard the svc component.\n    let svc_block_of_change = packed as u32;\n\n    let mut tmp = (packed - svc_block_of_change as Field) / TWO_POW_32;\n    let sdc_block_of_change = tmp as u32;\n\n    tmp = (tmp - sdc_block_of_change as Field) / TWO_POW_32;\n    let sdc_post_is_some = tmp as bool;\n\n    tmp = (tmp - sdc_post_is_some as Field) / TWO_POW_8;\n    let sdc_post_inner = tmp as u32;\n\n    tmp = (tmp - sdc_post_inner as Field) / TWO_POW_32;\n    let sdc_pre_is_some = tmp as bool;\n\n    tmp = (tmp - sdc_pre_is_some as Field) / TWO_POW_8;\n    let sdc_pre_inner = tmp as u32;\n\n    ScheduledDelayChange {\n        pre: if sdc_pre_is_some {\n            Option::some(sdc_pre_inner)\n        } else {\n            Option::none()\n        },\n        post: if sdc_post_is_some {\n            Option::some(sdc_post_inner)\n        } else {\n            Option::none()\n        },\n        block_of_change: sdc_block_of_change,\n    }\n}\n\nglobal TWO_POW_32: Field = 2.pow_32(32);\nglobal TWO_POW_8: Field = 2.pow_32(8);\n\n// We pack to `2 * N + 1` fields because ScheduledValueChange contains T twice (hence `2 * N`) and we need one extra\n// field to store ScheduledDelayChange and the block_of_change of ScheduledValueChange.\nimpl<T, let INITIAL_DELAY: u32, let N: u32> Packable<2 * N + 1> for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; 2 * N + 1] {\n        let mut result = [0; 2 * N + 1];\n\n        // We pack sdc.pre, sdc.post, sdc.block_of_change and svc.block_of_change into a single field as follows:\n        // [ sdc.pre_inner: u32 | sdc.pre_is_some: u8 | sdc.post_inner: u32 | sdc.post_is_some: u8 | sdc.block_of_change: u32 | svc.block_of_change: u32 ]\n        result[0] = self.svc.block_of_change as Field\n            + ((self.sdc.block_of_change as Field) * 2.pow_32(32))\n            + ((self.sdc.post.is_some() as Field) * 2.pow_32(64))\n            + ((self.sdc.post.unwrap_unchecked() as Field) * 2.pow_32(72))\n            + ((self.sdc.pre.is_some() as Field) * 2.pow_32(104))\n            + ((self.sdc.pre.unwrap_unchecked() as Field) * 2.pow_32(112));\n\n        // Pack the pre and post values from ScheduledValueChange\n        let svc_pre_packed = self.svc.pre.pack();\n        let svc_post_packed = self.svc.post.pack();\n        for i in 0..N {\n            result[i + 1] = svc_pre_packed[i];\n            result[i + 1 + N] = svc_post_packed[i];\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; 2 * N + 1]) -> Self {\n        let svc = unpack_value_change::<T, N>(fields);\n        let sdc = unpack_delay_change::<INITIAL_DELAY>(fields[0]);\n        Self::new(svc, sdc)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32, let N: u32> Hash for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn hash(self) -> Field {\n        poseidon2_hash(self.pack())\n    }\n}\n"
    },
    "319": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "333": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n"
    },
    "337": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "338": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "354": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "355": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "357": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "363": {
      "path": "/home/nerses/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "392": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER},\n        hash::poseidon2_hash_with_separator,\n        traits::{Deserialize, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// The returned `PartialUintNote` value must be sent to public execution via a secure channel, since it is not\n    /// possible to verify the integrity of its contents due to it hiding information. The recommended ways to do this\n    /// are to retrieve it from public storage, or to receive it in an internal public function call.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient, sender);\n        context.emit_private_log(encrypted_log);\n\n        PartialUintNote { commitment }\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nimpl PartialUintNote {\n    pub fn commitment(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, value: u128, context: &mut PublicContext) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; 2] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "50": {
      "path": "/home/nerses/contracts/chains/aztec/contracts/train/src/lib.nr",
      "source": "pub fn bytes_to_u128_limbs(bytes: [u8; 32]) -> (u128, u128) {\n    let mut high: u128 = 0;\n    let mut low: u128 = 0;\n    for i in 0..16 {\n        high = (high << 8) + (bytes[i] as u128);\n    }\n    for i in 16..32 {\n        low = (low << 8) + (bytes[i] as u128);\n    }\n    (high, low)\n}\n\npub fn u128_limbs_to_bytes(high: u128, low: u128) -> [u8; 32] {\n    let mut bytes: [u8; 32] = [0; 32];\n\n    let mut temp = high;\n    for i in 0..16 {\n        bytes[15 - i] = (temp & 0xff) as u8;\n        temp >>= 8;\n    }\n\n    temp = low;\n    for i in 0..16 {\n        bytes[31 - i] = (temp & 0xff) as u8;\n        temp >>= 8;\n    }\n\n    bytes\n}\n"
    },
    "51": {
      "path": "/home/nerses/contracts/chains/aztec/contracts/train/src/main.nr",
      "source": "//     @@                                    @@@\n//    @@@\n//    @@@        @@   @@@@      @@@@@         @     @    @@@@@\n//  @@@@@@@@@   @@@@@@      @@@@    @@@@@    @@@   @@@@@@    @@@@\n//    @@@       @@@       @@@           @@@  @@@   @@@          @@@\n//    @@@       @@@       @@@           @@@  @@@   @@@          @@@\n//    @@@       @@@       @@@           @@@  @@@   @@@          @@@\n//     @@@      @@@        @@@@       @@@@@  @@@   @@@          @@@\n//       @@@@@  @@@           @@@@@@@@@ @@@  @@@   @@@          @@@\n\nmod lib;\nmod types;\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract Train {\n    use crate::lib::{bytes_to_u128_limbs, u128_limbs_to_bytes};\n    use crate::types::events::{\n        TokenCommitted, TokenLockAdded, TokenLocked, TokenRedeemed, TokenRefunded,\n    };\n    use dep::aztec::messages::logs::note::encode_and_encrypt_note;\n    use dep::aztec::protocol_types::traits::{Packable, Serialize};\n    use dep::aztec::state_vars::{private_immutable::PrivateImmutable, SharedMutable};\n    use dep::sha256;\n    use dep::token::Token;\n    use aztec::macros::{\n        functions::{initializer, internal, private, public, utility, view},\n        notes::note,\n        storage::storage,\n    };\n    use aztec::prelude::{AztecAddress, Map};\n    use std::meta::derive;\n\n    #[note]\n    #[derive(Eq)]\n    struct HTLC_Private {\n        owner: AztecAddress,\n        randomness: Field,\n    }\n    #[derive(Eq, Packable, Serialize)]\n    pub struct HTLC_Public {\n        src_receiver: AztecAddress,\n        amount: u128,\n        token: AztecAddress,\n        hashlock_high: u128,\n        hashlock_low: u128,\n        secret_high: u128,\n        secret_low: u128,\n        ownership_hash_high: u128,\n        ownership_hash_low: u128,\n        timelock: u64,\n        claimed: u8,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor() {}\n\n    #[storage]\n    struct Storage<Context> {\n        contracts_private: Map<Field, PrivateImmutable<HTLC_Private, Context>, Context>,\n        contracts_public: Map<Field, SharedMutable<HTLC_Public, 3, Context>, Context>,\n    }\n\n    #[private]\n    fn commit_private_user(\n        Id: Field,\n        src_receiver: AztecAddress,\n        timelock: u64,\n        token: AztecAddress,\n        amount: u128,\n        dst_chain: str<8>,\n        dst_asset: str<8>,\n        dst_address: str<48>,\n        randomness: Field,\n    ) {\n        assert(amount > 0, \"Funds Not Sent\");\n\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address())\n            .commit_public_user(\n                dst_chain,\n                dst_asset,\n                dst_address,\n                Id,\n                src_receiver,\n                timelock,\n                token,\n                amount,\n            )\n            .enqueue(&mut context);\n\n        let htlc_note = HTLC_Private { owner: context.msg_sender(), randomness: randomness };\n        storage.contracts_private.at(Id).initialize(htlc_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n\n        Token::at(token)\n            .transfer_to_public(context.msg_sender(), context.this_address(), amount, randomness)\n            .call(&mut context);\n    }\n\n    #[internal]\n    #[public]\n    fn commit_public_user(\n        dst_chain: str<8>,\n        dst_asset: str<8>,\n        dst_address: str<48>,\n        Id: Field,\n        src_receiver: AztecAddress,\n        timelock: u64,\n        token: AztecAddress,\n        amount: u128,\n    ) {\n        assert(context.timestamp() + 900 < timelock, \"InvalidTimelock\");\n        let htlc_public = HTLC_Public {\n            src_receiver: src_receiver,\n            amount: amount,\n            token: token,\n            hashlock_high: 0 as u128,\n            hashlock_low: 0 as u128,\n            secret_high: 0 as u128,\n            secret_low: 0 as u128,\n            ownership_hash_high: 0 as u128,\n            ownership_hash_low: 0 as u128,\n            timelock: timelock,\n            claimed: 1 as u8,\n        };\n        storage.contracts_public.at(Id).schedule_value_change(htlc_public);\n        let log_msg = TokenCommitted {\n            Id: Id,\n            amount: amount,\n            token: token,\n            timelock: timelock,\n            dst_chain: dst_chain,\n            dst_asset: dst_asset,\n            dst_address: dst_address,\n            src_receiver: src_receiver,\n        };\n        context.emit_public_log(log_msg.pack());\n    }\n\n    #[private]\n    fn add_lock_private_user(Id: Field, hashlock: [u8; 32], timelock: u64) {\n        let htlc_private = storage.contracts_private.at(Id).get_note();\n        assert(htlc_private.owner == context.msg_sender(), \"NoAllowance\");\n\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address()).add_lock_public_user(Id, hashlock, timelock).enqueue(\n            &mut context,\n        );\n    }\n\n    #[internal]\n    #[public]\n    fn add_lock_public_user(Id: Field, hashlock: [u8; 32], timelock: u64) {\n        assert(context.timestamp() + 900 < timelock, \"InvalidTimelock\");\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n        assert(htlc_public.hashlock_high == (0 as u128), \"HashlockAlreadySet\");\n        assert(htlc_public.hashlock_low == (0 as u128), \"HashlockAlreadySet\");\n\n        let hashlock_tuple = bytes_to_u128_limbs(hashlock);\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: hashlock_tuple.0,\n            hashlock_low: hashlock_tuple.1,\n            secret_high: htlc_public.secret_high,\n            secret_low: htlc_public.secret_low,\n            ownership_hash_high: htlc_public.ownership_hash_high,\n            ownership_hash_low: htlc_public.ownership_hash_low,\n            timelock: timelock,\n            claimed: htlc_public.claimed,\n        };\n        storage.contracts_public.at(Id).schedule_value_change(modified_htlc_public);\n        let log_msg = TokenLockAdded { Id, hashlock, timelock };\n        context.emit_public_log(log_msg.pack());\n    }\n\n    #[private]\n    fn refund_private(Id: Field, randomness: Field) {\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address()).refund_public(Id).enqueue(&mut context);\n\n        let htlc_private = storage.contracts_private.at(Id).get_note();\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n\n        Token::at(htlc_public.token)\n            .transfer_to_private(htlc_private.owner, htlc_public.amount)\n            .call(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn refund_public(Id: Field) {\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n        assert(htlc_public.timelock < context.timestamp(), \"NotPassedTimelock\");\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: htlc_public.hashlock_high,\n            hashlock_low: htlc_public.hashlock_low,\n            secret_high: htlc_public.secret_high,\n            secret_low: htlc_public.secret_low,\n            ownership_hash_high: htlc_public.ownership_hash_high,\n            ownership_hash_low: htlc_public.ownership_hash_low,\n            timelock: htlc_public.timelock,\n            claimed: 2 as u8,\n        };\n\n        storage.contracts_public.at(Id).schedule_value_change(modified_htlc_public);\n        let log_msg = TokenRefunded { Id };\n        context.emit_public_log(log_msg);\n    }\n\n    #[private]\n    fn lock_private_solver(\n        Id: Field,\n        hashlock: [u8; 32],\n        amount: u128,\n        ownership_hash: [u8; 32],\n        timelock: u64,\n        token: AztecAddress,\n        randomness: Field,\n        dst_chain: str<8>,\n        dst_asset: str<8>,\n        dst_address: str<48>,\n    ) {\n        assert(amount > 0, \"FundsNotSent\");\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address())\n            .lock_public_solver(\n                Id,\n                hashlock,\n                ownership_hash,\n                amount,\n                token,\n                timelock,\n                dst_chain,\n                dst_asset,\n                dst_address,\n            )\n            .enqueue(&mut context);\n\n        let htlc_note = HTLC_Private { owner: context.msg_sender(), randomness: randomness };\n        storage.contracts_private.at(Id).initialize(htlc_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n\n        Token::at(token)\n            .transfer_to_public(context.msg_sender(), context.this_address(), amount, randomness)\n            .call(&mut context);\n    }\n\n    #[internal]\n    #[public]\n    fn lock_public_solver(\n        Id: Field,\n        hashlock: [u8; 32],\n        ownership_hash: [u8; 32],\n        amount: u128,\n        token: AztecAddress,\n        timelock: u64,\n        dst_chain: str<8>,\n        dst_asset: str<8>,\n        dst_address: str<48>,\n    ) {\n        assert(context.timestamp() + 2700 < timelock, \"InvalidTimelock\");\n        let hashlock_tuple = bytes_to_u128_limbs(hashlock);\n        let ownership_hash_tuple = bytes_to_u128_limbs(ownership_hash);\n        let htlc_public = HTLC_Public {\n            src_receiver: AztecAddress::zero(),\n            amount: amount,\n            token: token,\n            hashlock_high: hashlock_tuple.0,\n            hashlock_low: hashlock_tuple.1,\n            secret_high: 0 as u128,\n            secret_low: 0 as u128,\n            ownership_hash_high: ownership_hash_tuple.0,\n            ownership_hash_low: ownership_hash_tuple.1,\n            timelock: timelock,\n            claimed: 1 as u8,\n        };\n        storage.contracts_public.at(Id).schedule_value_change(htlc_public);\n\n        let log_msg = TokenLocked {\n            Id: Id,\n            hashlock: hashlock,\n            ownership_hash: ownership_hash,\n            amount: amount,\n            src_receiver: AztecAddress::zero(),\n            token: token,\n            timelock: timelock,\n            dst_chain: dst_chain,\n            dst_asset: dst_asset,\n            dst_address: dst_address,\n        };\n\n        context.emit_public_log(log_msg.pack());\n    }\n\n    #[private]\n    fn redeem_private(Id: Field, secret: [u8; 32], ownership_key: [u8; 32], randomness: Field) {\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address()).redeem_public(Id, secret).enqueue(&mut context);\n\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n\n        if (htlc_public.ownership_hash_high == 0 as u128) {\n            if htlc_public.ownership_hash_low == 0 as u128 {\n                let ownership_key_hashed =\n                    sha256::sha256_var(ownership_key, ownership_key.len() as u64);\n                let ownership_key_tuple = bytes_to_u128_limbs(ownership_key_hashed);\n                assert(htlc_public.ownership_hash_high == ownership_key_tuple.0, \"NotAnOwner\");\n                assert(htlc_public.ownership_hash_low == ownership_key_tuple.1, \"NotAnOwner\");\n            }\n        }\n\n        Token::at(htlc_public.token)\n            .transfer_to_private(context.msg_sender(), htlc_public.amount)\n            .call(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn redeem_public(Id: Field, secret: [u8; 32]) {\n        let mut htlc_public = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public.amount > 0, \"HTLCNotExists\"); // If it doesn't exist, all parameters will default to zero values.\n        let hashed_secret = sha256::sha256_var(secret, secret.len() as u64);\n        let hashed_secret_tuple = bytes_to_u128_limbs(hashed_secret);\n        assert(htlc_public.hashlock_high == hashed_secret_tuple.0, \"HashlockNotMatch\");\n        assert(htlc_public.hashlock_low == hashed_secret_tuple.1, \"HashlockNotMatch\");\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n        let secret_limbs = bytes_to_u128_limbs(secret);\n\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: htlc_public.hashlock_high,\n            hashlock_low: htlc_public.hashlock_low,\n            secret_high: secret_limbs.0,\n            secret_low: secret_limbs.1,\n            ownership_hash_high: htlc_public.ownership_hash_high,\n            ownership_hash_low: htlc_public.ownership_hash_low,\n            timelock: htlc_public.timelock,\n            claimed: 3 as u8,\n        };\n\n        storage.contracts_public.at(Id).schedule_value_change(modified_htlc_public);\n\n        let log_msg = TokenRedeemed {\n            Id: Id,\n            hashlock: u128_limbs_to_bytes(htlc_public.hashlock_high, htlc_public.hashlock_low),\n            secret: secret,\n        };\n\n        context.emit_public_log(log_msg.pack());\n    }\n\n    // This utility function should be invoked by the frontend before each function call\n    // where the existence or non-existence of an HTLC is a critical security check.\n    #[utility]\n    unconstrained fn is_contract_initialized(Id: Field) -> bool {\n        storage.contracts_private.at(Id).is_initialized()\n    }\n\n    #[view]\n    #[public]\n    fn get_htlc_public_solver(key: Field) -> pub HTLC_Public {\n        storage.contracts_public.at(key).get_current_value()\n    }\n}\n"
    },
    "52": {
      "path": "/home/nerses/contracts/chains/aztec/contracts/train/src/types/events.nr",
      "source": "use dep::aztec::prelude::AztecAddress;\nuse dep::aztec::protocol_types::traits::{Packable, Serialize};\n\n#[derive(Serialize)]\npub struct TokenCommitted {\n    pub Id: Field,\n    pub amount: u128,\n    pub token: AztecAddress,\n    pub timelock: u64,\n    pub dst_chain: str<8>,\n    pub dst_asset: str<8>,\n    pub dst_address: str<48>,\n    pub src_receiver: AztecAddress,\n}\n\nimpl Packable<9> for TokenCommitted {\n    fn pack(self) -> [Field; 9] {\n        let zero: Field = 0;\n        let mut out = [zero; 9];\n        out[0] = self.Id;\n        out[1] = self.amount as Field;\n        out[2] = self.token.inner;\n        out[3] = self.timelock as Field;\n\n        let dst_chain_byte_array = self.dst_chain.as_bytes();\n        let mut dst_chain_byte_array_filled = [0 as u8; 31];\n        for i in 0..dst_chain_byte_array.len() {\n            dst_chain_byte_array_filled[i] = dst_chain_byte_array[i];\n        }\n\n        out[4] = Field::from_be_bytes::<31>(dst_chain_byte_array_filled);\n\n        let dst_asset_byte_array = self.dst_asset.as_bytes();\n        let mut dst_asset_byte_array_filled = [0 as u8; 31];\n        for i in 0..dst_asset_byte_array.len() {\n            dst_asset_byte_array_filled[i] = dst_asset_byte_array[i];\n        }\n\n        out[5] = Field::from_be_bytes::<31>(dst_asset_byte_array_filled);\n\n        let dst_address_byte_array = self.dst_address.as_bytes();\n        let mut dst_address_byte_array_filled_1 = [0 as u8; 31];\n        let mut dst_address_byte_array_filled_2 = [0 as u8; 31];\n\n        for i in 0..31 {\n            dst_address_byte_array_filled_1[i] = dst_address_byte_array[i];\n        }\n\n        for i in 31..48 {\n            dst_address_byte_array_filled_2[i - 31] = dst_address_byte_array[i];\n        }\n\n        out[6] = Field::from_be_bytes::<31>(dst_address_byte_array_filled_1);\n        out[7] = Field::from_be_bytes::<31>(dst_address_byte_array_filled_2);\n\n        out[8] = self.src_receiver.inner;\n        out\n    }\n\n    fn unpack(fields: [Field; 9]) -> Self {\n        assert(false, \"unpack not implemented\");\n        TokenCommitted {\n            Id: fields[0] as Field,\n            amount: 0 as u128,\n            token: AztecAddress::zero(),\n            timelock: 0 as u64,\n            dst_chain: \"00000000\",\n            dst_asset: \"00000000\",\n            dst_address: \"000000000000000000000000000000000000000000000000\",\n            src_receiver: AztecAddress::zero(),\n        }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenLockAdded {\n    pub Id: Field,\n    pub hashlock: [u8; 32],\n    pub timelock: u64,\n}\n\nimpl Packable<4> for TokenLockAdded {\n    fn pack(self) -> [Field; 4] {\n        let mut out = [0 as Field; 4];\n        out[0] = self.Id;\n\n        let hb = self.hashlock;\n        let mut h1 = [0 as u8; 31];\n        for i in 0..31 {\n            h1[i] = hb[i];\n        }\n        out[1] = Field::from_be_bytes::<31>(h1);\n\n        let mut h2 = [0 as u8; 31];\n        h2[0] = hb[31];\n        out[2] = Field::from_be_bytes::<31>(h2);\n\n        out[3] = self.timelock as Field;\n        out\n    }\n\n    fn unpack(fields: [Field; 4]) -> Self {\n        let Id = fields[0];\n\n        let b1 = fields[1].to_be_bytes();\n        let b2 = fields[2].to_be_bytes();\n        let mut hash = [0 as u8; 32];\n        for i in 0..31 {\n            hash[i] = b1[i];\n        }\n        hash[31] = b2[0];\n\n        let timelock = fields[3] as u64;\n\n        TokenLockAdded { Id, hashlock: hash, timelock }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenRefunded {\n    pub Id: Field,\n}\n\n#[derive(Serialize)]\npub struct TokenRedeemed {\n    pub Id: Field,\n    pub hashlock: [u8; 32],\n    pub secret: [u8; 32],\n}\n\nimpl Packable<5> for TokenRedeemed {\n    fn pack(self) -> [Field; 5] {\n        let mut out = [0 as Field; 5];\n        out[0] = self.Id;\n\n        let hb = self.hashlock;\n        let mut h1 = [0 as u8; 31];\n        for i in 0..31 {\n            h1[i] = hb[i];\n        }\n        out[1] = Field::from_be_bytes::<31>(h1);\n        let mut h2 = [0 as u8; 31];\n        h2[0] = hb[31];\n        out[2] = Field::from_be_bytes::<31>(h2);\n\n        let sb = self.secret;\n        let mut s1 = [0 as u8; 31];\n        for i in 0..31 {\n            s1[i] = sb[i];\n        }\n        out[3] = Field::from_be_bytes::<31>(s1);\n        let mut s2 = [0 as u8; 31];\n        s2[0] = sb[31];\n        out[4] = Field::from_be_bytes::<31>(s2);\n\n        out\n    }\n\n    fn unpack(fields: [Field; 5]) -> Self {\n        let Id = fields[0];\n\n        let b1 = fields[1].to_be_bytes();\n        let b2 = fields[2].to_be_bytes();\n        let mut hashlock = [0 as u8; 32];\n        for i in 0..31 {\n            hashlock[i] = b1[i];\n        }\n        hashlock[31] = b2[0];\n\n        let b3 = fields[3].to_be_bytes();\n        let b4 = fields[4].to_be_bytes();\n        let mut secret = [0 as u8; 32];\n        for i in 0..31 {\n            secret[i] = b3[i];\n        }\n        secret[31] = b4[0];\n\n        TokenRedeemed { Id, hashlock, secret }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenLocked {\n    pub Id: Field,\n    pub hashlock: [u8; 32],\n    pub ownership_hash: [u8; 32],\n    pub amount: u128,\n    pub src_receiver: AztecAddress,\n    pub token: AztecAddress,\n    pub timelock: u64,\n    pub dst_chain: str<8>,\n    pub dst_asset: str<8>,\n    pub dst_address: str<48>,\n}\n\nimpl Packable<13> for TokenLocked {\n    fn pack(self) -> [Field; 13] {\n        let mut out = [0 as Field; 13];\n        out[0] = self.Id;\n\n        let hb = self.hashlock;\n        let mut h1 = [0 as u8; 31];\n        for i in 0..31 {\n            h1[i] = hb[i];\n        }\n        out[1] = Field::from_be_bytes::<31>(h1);\n\n        let mut h2 = [0 as u8; 31];\n        h2[0] = hb[31];\n        out[2] = Field::from_be_bytes::<31>(h2);\n\n        let ownership = self.ownership_hash;\n        let mut o1 = [0 as u8; 31];\n        for i in 0..31 {\n            o1[i] = ownership[i];\n        }\n        out[3] = Field::from_be_bytes::<31>(o1);\n\n        let mut o2 = [0 as u8; 31];\n        o2[0] = ownership[31];\n        out[4] = Field::from_be_bytes::<31>(o2);\n\n        out[5] = self.amount as Field;\n        out[6] = self.src_receiver.inner as Field;\n        out[7] = self.token.inner;\n        out[8] = self.timelock as Field;\n\n        let dst_chain_byte_array = self.dst_chain.as_bytes();\n        let mut dst_chain_byte_array_filled = [0 as u8; 31];\n        for i in 0..dst_chain_byte_array.len() {\n            dst_chain_byte_array_filled[i] = dst_chain_byte_array[i];\n        }\n        out[9] = Field::from_be_bytes::<31>(dst_chain_byte_array_filled);\n\n        let dst_asset_byte_array = self.dst_asset.as_bytes();\n        let mut dst_asset_byte_array_filled = [0 as u8; 31];\n        for i in 0..dst_asset_byte_array.len() {\n            dst_asset_byte_array_filled[i] = dst_asset_byte_array[i];\n        }\n        out[10] = Field::from_be_bytes::<31>(dst_asset_byte_array_filled);\n\n        let addr = self.dst_address.as_bytes();\n        let mut dst_address_byte_array_filled_1 = [0 as u8; 31];\n        let mut dst_address_byte_array_filled_2 = [0 as u8; 31];\n        for i in 0..31 {\n            dst_address_byte_array_filled_1[i] = addr[i];\n        }\n        for i in 31..48 {\n            dst_address_byte_array_filled_2[i - 31] = addr[i];\n        }\n        out[11] = Field::from_be_bytes::<31>(dst_address_byte_array_filled_1);\n        out[12] = Field::from_be_bytes::<31>(dst_address_byte_array_filled_2);\n\n        out\n    }\n\n    fn unpack(fields: [Field; 13]) -> Self {\n        assert(false, \"unpack not implemented\");\n        TokenLocked {\n            Id: fields[0] as Field,\n            hashlock: [0 as u8; 32],\n            ownership_hash: [0 as u8; 32],\n            amount: 0 as u128,\n            src_receiver: AztecAddress::zero(),\n            token: AztecAddress::zero(),\n            timelock: 0 as u64,\n            dst_chain: \"00000000\",\n            dst_asset: \"00000000\",\n            dst_address: \"000000000000000000000000000000000000000000000000\",\n        }\n    }\n}\n"
    },
    "54": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
    },
    "55": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "62": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "63": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(gas_for_call(gas_opts), contract_address, calldata);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(gas_for_call(gas_opts), contract_address, calldata);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_opcode(gas, address, args)\n}\n\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "64": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "65": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "69": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "81": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "84": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/keys/ecdh_shared_secret.nr",
      "source": "use dep::protocol_types::{\n    address::aztec_address::AztecAddress, point::Point, scalar::Scalar, traits::FromField,\n};\nuse std::{embedded_curve_ops::multi_scalar_mul, ops::Neg};\n\n/// Computes a standard ecdh shared secret: [secret] * public_key = shared_secret.\n/// The input secret is known only to one party. The output shared secret is derivable\n/// by both parties, through this function.\n/// E.g.:\n/// Epk = esk * G // ephemeral keypair\n/// Pk = sk * G // recipient keypair\n/// Shared secret S = esk * Pk = sk * Epk // see how this function can be called with two different sets of inputs, depending on which secret the caller knows (either esk or sk)?\n// See also: https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman\npub fn derive_ecdh_shared_secret(secret: Scalar, public_key: Point) -> Point {\n    let shared_secret = multi_scalar_mul([public_key], [secret]);\n    shared_secret\n}\n\n/// Computes a standard ecdh shared secret using the address public key of the given address:\n/// [ephemeral_secret] * recipient_address_public_key = shared_secret.\n/// The intention is that the _creator_ of a shared secret would call this function,\n/// given the address of their intended recipient.\npub fn derive_ecdh_shared_secret_using_aztec_address(\n    ephemeral_secret: Scalar,\n    recipient_address: AztecAddress,\n) -> Point {\n    derive_ecdh_shared_secret(ephemeral_secret, recipient_address.to_address_point().inner)\n}\n\n#[test]\nunconstrained fn test_consistency_with_typescript() {\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let shared_secret = derive_ecdh_shared_secret(secret, point);\n\n    // This is just pasted from a test run.\n    // The original typescript code from which this could be generated seems to have been deleted by someone, and soon the typescript code for encryption and decryption won't be needed, so this will have to do.\n    let hard_coded_shared_secret = Point {\n        x: 0x15d55a5b3b2caa6a6207f313f05c5113deba5da9927d6421bcaa164822b911bc,\n        y: 0x0974c3d0825031ae933243d653ebb1a0b08b90ee7f228f94c5c74739ea3c871e,\n        is_infinite: false,\n    };\n    assert_eq(shared_secret, hard_coded_shared_secret);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let shared_secret = derive_ecdh_shared_secret(secret_a, pk_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_from_address_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let mut pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let mut pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let address_b = AztecAddress::from_field(pk_b.x);\n\n    // We were lazy in deriving the secret keys, and didn't check the resulting y-coordinates\n    // of the pk_a or pk_b to be less than half the field modulus.\n    // If needed, we negate the pk's so that they yield valid address points.\n    // (We could also have negated the secrets, but there's no negate method for\n    // EmbeddedCurvesScalar).\n    pk_a = if (AztecAddress::from_field(pk_a.x).to_address_point().inner == pk_a) {\n        pk_a\n    } else {\n        pk_a.neg()\n    };\n    pk_b = if (address_b.to_address_point().inner == pk_b) {\n        pk_b\n    } else {\n        pk_b.neg()\n    };\n\n    let shared_secret = derive_ecdh_shared_secret_using_aztec_address(secret_a, address_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n"
    },
    "85": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/keys/ephemeral.nr",
      "source": "use std::embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul};\n\nuse dep::protocol_types::{point::Point, scalar::Scalar};\n\nuse crate::oracle::random::random;\n\npub fn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n\n    // Safety: we use the randomness to preserve the privacy of both the sender and recipient via encryption, so a\n    // malicious sender could use non-random values to reveal the plaintext. But they already know it themselves anyway,\n    // and so the recipient already trusts them to not disclose this information. We can therefore assume that the\n    // sender will cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // TODO(#12757): compute the key pair without constraining eph_sk twice (once in from_field, once in the black box\n    // called by fixed_base_scalar_mul).\n    let eph_sk = EmbeddedCurveScalar::from_field(randomness);\n    let eph_pk = fixed_base_scalar_mul(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n"
    },
    "86": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "90": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_notes` utility function PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_notes = generate_sync_notes();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_notes\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_notes() -> Quoted {\n    // TODO(https://github.com/noir-lang/noir/issues/7912): Doing the following unfortunately doesn't work. Once\n    // the issue is fixed uncomment the following and remove the workaround from TS (look for the issue link in the\n    // codebase).\n    // let utility: fn(FunctionDefinition) -> () = crate::macros::functions::utility;\n    // quote {\n    //     #[$utility]\n    //     unconstrained fn sync_notes() {\n    //     }\n    // }\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[aztec::macros::functions::utility]\n        unconstrained fn sync_notes() { }\n    }\n}\n"
    },
    "91": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "94": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_slice, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_view,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_SLICE_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args =  &[];\n    // serialized_args = serialized_args.append(aztec::protocol_types::traits::Serialize::serialize(target_address));\n    // serialized_args = serialized_args.push_back(fee_juice_limit_per_tx as Field);\n    // ```\n    let serialized_args_slice_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_SLICE_NAME = &[];\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append = add_to_field_slice(SERIALIZED_ARGS_SLICE_NAME, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n"
    },
    "95": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "98": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, &[], false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    }
  }
}
