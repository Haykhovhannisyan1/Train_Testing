{
  "transpiled": true,
  "noir_version": "1.0.0-beta.4+0000000000000000000000000000000000000000",
  "name": "Train",
  "functions": [
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [
        "aztec::macros::functions::utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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39bJ3n87RPz8IdbPHyJ9/hD584conz9E/fghXjz+6XoI9/lD+M8f4vNnd/382V0/f3bXz5/d9fNnd/382V0/fna7Zfn8IdznD+E/f4jfPrvvu8Vzu63ndkvndsvndivndqundnPLud3cud38ud3OVYk7VyXuXJW4c1XizlWJO1cl7lyV+HNV4s9ViT9XJf5clfhzVeLPVYk/VyX+XJX4c1Xiz1VJOFcl4VyVhHNVEs5VSThXJeFclYRzVRLOVUk4VyXhXJXEc1USz1VJPFcl8VyVxHNVEs9VSTxXJfFclcRzVRLPVcl6rkrWc1WynquS9VyVrOeqZD1XJeu5KlnPVcl6rkrWc1WSzlVJOlcl6VyVpHNVks5VSTpXJelclaRzVZLOVUk6VyX5XJXkc1WSz1VJPlcl+VyV5HNVks9VST5XJflcleRzVVLOVUk5VyXlXJWUc1VSzlVJOVcl5VyVlHNVUs5VSTlXJfVcldRzVVLPVUk9VyX1XJXUc1VSz1VJPVcl9VyV1FNV4pfl3G7u3G7+3G7h3G7x3G7rud3Sud3yud3Kud3OVcm57NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1b/IXuv+8t4tHHQHu72okpz33ar/abejFWc7fc/iNpyqajivsmKp4Thdw/G6hhN0DSfqGs6qazhJ13CyruHouipXVVflsKi6KodF1VU5LKquymFRdVUOi6qrclhUXZXDcvVV+e2nmG7jycrGU5SNp+oaj1uUjccpG89vX5vvu4Vzu8Vzux1ek27PTLclPG5PJtcGNJdy2L/um3J6LKxztNLBzZhvi8jc7qah8bfTsuwLYC3h8WPyunyNPykf/7psAqQ1hO/jz4OPvww+/jr2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",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "commit_public_user",
      "is_unconstrained": true,
      "custom_attributes": [
        "internal",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 48
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "src_receiver",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3559210201980528457": {
            "error_kind": "string",
            "string": "Function commit_public_user can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "commit_public_user"
      ]
    },
    {
      "name": "redeem_private_user",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "ownership_key",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6012086182631426650": {
            "error_kind": "string",
            "string": "NotAnOwner"
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/+xdB3wVxdbfkB6ICSAdpFnAupseK/bewN5TQUVBeidWBASkiaLYe+/9Pfvz+dTP3nvvvZen34zs3JycnLv33txzNjtP5vc7yd6d2f+cOXPmP2V3ZzOc1aFrgeOML1h9nKEk0//fQckAdM78h8fZRLqOxLlC4lwRca4zca67kmHoXH8i3QDi3EDi3CDi3AbEuaFK8tC5DYlzGxHnNibObUKc25Q4txlxziXOecS5EuJcKXGujDhXTpyrIM5VEueqiHPVxLnNiXNbEOe2JM5tRZzbmji3DXFuGHFuW+LcdsS57YlzOxDndiTO7USc25k4twtxblfi3G7Eud2Jc3sQ5/Ykzu1FnNubOLcPcW5f4txw4twI4tx+xLn9iXMHEOcOJM4dRJw7mDh3CHHuUOLcYcS5w4lzRxDnjiTOHUWcqyHO1RLn6ohz9cS5BuJcI3FuJHFulH8Ohgz//zD/f6lbUVbWUFnS4JV6NW5JdW1VuVtWXltR5VV55VXl9SVVpaUNVWVVldW11ZVutVdW2uA1lleXNrqrw9aZzVhuWqGkTlLPbdqsZ1kpPqN166IkC+iq7fCHfzzEaT4eCo638dOY64ap39sq2U7J9pnN503IRDZw0wvehoxYwzL56mYHNh9yXUn7bcSItS2j/Xa0xH4bM2Jtx2i/nRjtR3HDDoAbdgTHO4Hj7RE37Kx+76JkVyW7hcANmzBi7cxYN7tb4tubMmLtwmi/PSyx32aMWLsy2m9PYW7YHXDAHuB4T3C8G+KGvdTvvZXso2TfELjBZcTai7Fuhlvi2x4j1t6M9hthif1KGLH2YbTffsLcMBxwwAhwvB843hdxw/7q9wFKDlRyUAjcUMqItT9j3RxsiW+XMWIdwGi/QyyxXzkj1oGM9jtUmBsOBhxwCDg+FBwfhLjhMPX7cCVHKDkyBG6oYMQ6jLFujrLEtysZsQ5ntF+NJfarYsQ6gtF+tcLccBTggBpwXAuOj0TcUKd+1ytpUNIYAjdUM2LVMdbNSEt8e3NGrHpG+42yxH5bMGI1MNrvaGFuGAk4YBQ4PhocNyJuOEb9PlbJaCXHhcANWzJiHcNYN8db4ttbMWIdy2i/MZbYb2tGrNGM9hsrzA3HAw4YA47HguPjEDecoH6PUzJeyYQQuGEbRqwTGOtmoiW+PYwRaxyj/SZZYr9tGbHGM9pvsjA3TAQcMAkcTwbHExA3TFG/pyqZpmR6CNywHSPWFMa6mWGJb2/PiDWV0X4zLbHfDoxY0xjtN0uYG2YADpgJjmeB4+mIG2ar301KTlRyUgjcsCMj1mzGujnZEt/eiRGridF+p1hiv50ZsU5ktN+pwtxwMuCAU8DxqeD4JMQNp6nfc5ScrmRuCNywCyPWaYx1M88S396VEWsOo/3mW2K/3RixTme03xnC3DAPcMB8cHwGOJ6LuGGB+r1QySIlZ4bADbszYi1grJvFlvj2HoxYCxntt8QS++3JiLWI0X5LhblhMeCAJeB4KTg+E3HDMvV7uZKzlKwIgRv2YsRaxlg3Z1vi23szYi1ntN85lthvH0assxjtt1KYG84GHHAOOF4JjlcgbjhX/T5PySol54fADfsyYp3LWDcXWOLbwxmxzmO034WW2G8EI9YqRvtdJMwNFwAOuBAcXwSOz0fccLH6fYmSS5VcFgI37MeIdTFj3VxuiW/vz4h1CaP9rrDEfgcwYl3KaL8rhbnhcsABV4DjK8HxZYgbrlK/r1ZyjZJrQ+CGAxmxrmKsm+ss8e2DGLGuZrTf9ZbY72BGrGsY7XeDMDdcBzjgenB8Azi+FnHDjer3TUpuVnJLCNxwCCPWjYx1c6slvn0oI9ZNjPa7zRL7HcaIdTOj/W4X5oZbAQfcBo5vB8e3IG64Q/2+U8ldSu4OgRsOZ8S6g7Fu7rHEt49gxLqT0X73WmK/Ixmx7mK03z+EueEewAH3guN/gOO7ETf8U/2+T8n9Sh4IgRuOYsT6J2PdPGiJb9cwYt3HaL+HLLFfLSPW/Yz2e1iYGx4EHPAQOH4YHD+AuOER9ftfSh5V8u8QuKGOEesRxrp5zBLfrmfE+hej/f5jif0aGLEeZbTf48Lc8BjggP+A48fB8b8RNzyhfj+p5P+UPBUCNzQyYj3BWDdPW+LbIxmxnmS03zOW2G8UI9b/MdrvWWFueBpwwDPg+Flw/BTihufU7+eVvKDkxRC44WhGrOcY6+Yl4bp5CdTB8+D4BXD8Iqqbl9XvV5S8quQ1om46MNfNBg6fPV/ns6cH96bWuAOE7fA6o1+9IWSHN3w7ZCEbwJDBbJcMR4b/HV496yls9o3B32Sr2JJaST3fYtCzzK2trqguL5fU8+0261lShs9QBPwmINq3MulN199GBPyO+v2ukveUvB9C5ziUEesdRhL7wJKBH+dG9e8y2u9DS+zHuVH9e4z2+0h4cPYB4IMPwfFH4Ph9xA0fq9+fKPlUyWchcAPnJvgfM9bN55b4NudG9Z8w2u8LS+zHuVH9p4z2+1KYGz4HHPAFOP4SHH+GuOEr9ftrJd8o+TYEbuDcBP8rxrr5zhLf5tyo/mtG+31vif04N6r/htF+Pwhzw3eAA74Hxz+A428RN/yofv+k5Gclv4TADZyb4P/IWDe/WuLbnBvV/8Rov98ssR/nRvU/M9rvd2Fu+BVwwG/g+Hdw/Avihv/q30r+zFx9UpobODfB/y9j3WRk2eHbnBvV/8Fovw6W2I9zo/o/Ge2XmSXLDdq/DQd0AMeZ4NjJaskNWeogW0mOktwQuIFzE/ysLL66ybPEtzk3qs9mtF++Jfbj3Kg+h9F+BcLckAc4IB8cF4DjXMQNHdVBJyWFStYKgRs4N8HvyFg3RZb4NudG9Z0Y7Vdsif04N6ovZLRfZ2FuKAIcUAyOO4PjtRA3dFEHXZWsraRbCNywNSNWF8a66W6Jb3NuVN+V0X49LLHfMEastRnt11OYG7oDDugBjnuC426IG3qpg95K+ijpGwI3bMuI1YuxbvpZ4tvbMWL1ZrTfOpbYb3tGrD6M9usvzA39AAesA477g+O+iBsGqIOBSgYpGRwCN+zAiDWAsW7WtcS3OTeqH8hov/UssR/nRvWDGO23vjA3rAs4YD1wvD44Hoy4YQN1METJUCUbhsANnJvgb8BYNxtZ4tucG9UPYbTfxsK+vRHw4Y3B8VBwvCHy7U3UwaZKNlPi+r6d5afNdOKHYSzlKCn9q70J5YGf4+Z+QWCIw98euHUcaoGOG1qg40YW6LixBTpuYoGOm1qg42YW6OhaoKNngY4lFuhYaoGOZRboWG6BjhUW6FhpgY5VFuhYbYGOm1ug4xYW6LilBTpuZYGOW1ug4zYW6DjMAh23tUDH7SzQcXsLdNzBAh13tEDHnSzQcWcLdNxFQEeHV8cWuOxrSVly5f8rdGBW+A3Gh/Y9vsK32GlH4w5wVt8E6OC0vtklUZFSO+3Y4nDcejLuwiSqZ6Yj3IC5d+0p4XOAUkk9S0Ny1HT1LGu7niX4BHVHtCSL3vmoFJwvQ3dEy9VBhZJKJVXgjmgnUP4gm7jpBa+c+S6xCdVZggpXg25iGJNzaMhCJ5y93tZ2ZJkoTWzPHEBbbO7bfAt4vz7Dj3gTndvC79Zh4H7uYu30K7/Er3xvc8bnLrYQYkM8PExXT84yb0mUua2Y0I+29H0rFUbktAtHWUzYKktQYQ0eb/7QVvytGMf8WzM6m5QNtY4ZzDbcmpkMuMu9hV9urrmnweWs722YhyiGXDTuQGc1uWQ69ANof9e5Z3mWHXpydrY9gZ7DfLLe1v+/nf9/e///Dv7/Hf3/O/n/d/b/7+L/39X/v5v/f3f//x7+/z39/3v5//f2/+/j/9/X/z/c/z/C/7+f/39///8B/v8D8ehMF6AJndueOLcDcW5H4txOxLmd/UqA57QB8tC53Yhr9yDO7Umc24s4tzdxbh9Cl30JXYb7I1R4boTfAcBz+xHp9ifSHUCkO5AYBef6/4f5/930gjc81QbgxY8akRqWFxS5X9sbZivc/duKRWh4QPqEEUM9kLGTO8iSNZSD26ynV4rPUGsoB4G1kmHgeFtwfDBaQzlEHRyq5DAlh2fJvzGxHePA+BBGHzpCyIfY3xRktN+hjPY70hL77cBov8MY7XcU80Adc8MRgAOOBMdHgePDETfUqINaJXVK6kPghh0Z66aGsW4aLPHtnRjtV8tov0ZL7Lczo/3qGO03UpgbGgAHNILjkeC4HnHDKHVwtJJjlBwbAjfswlg3oxjrZrQlvr0ro/2OZrTfcZbYbzdG+x3DaL/jhblhNOCA48Dx8eD4WMQNY9TBWCUnKBkXAjfszlg3YxjrZrwlvr0Ho/3GMtpvgiX225PRficw2m+iMDeMBxwwARxPBMfjEDdMUgeTlUxRMjUEbtiLsW4mMdbNNEt8e29G+01mtN90S+y3D6P9pjDab4YwN0wDHDAdHM8Ax1MRN8xUB7OUzNb3JkLghn0Z62YmY92cKFw3J4I6mAWOZ4PjJlQ3J6mDk5WcouRUom6418pPY7PBXy+YxgLXzXoDXs5Y73P4yiz6zOrpbdczqfsYpwE/1GKO54DzpyP/nKsO5imZr+SMrOZnQbOccB5LlHpyjVvPuYx65gA9F/gVsdD/v8j/f6b/f3FW87O9OixRv5cqWaZkuZKzlKxQcraSc5SsVHKukvOUrFJyvpILlFyo5CIlFyu5RMmlSi5TcrmSK5RcqeQqJVcruUbJtUquU3K9khuU3KjkJiU3K7lFya1KblNyu5I7lNyp5K4sp+XNaK38ACfch4sXMncCJtydJajw3Vn8uPcwMqxUue8B3SETrhumsy0ScrZ7swQVvlfA2f4RcWfT5f6H5c52ppCz/TNLUOF/CjjbfRF3Nl3u+wScTULXe/yGwT3WvT/Lzka2WKiRPZAlqPADAo3swYg3Ml3uBy1pZJoM7hdoZA+FNHlKV8+H265nGT5BTXwXggnuInC8GBw/jCa+j6iDfyl5VMm/s+QXzRh7b+8Rxrb5GDPh4bp5DNTBv8Dxo+D436hu/qMOHlfyhJIns1ricfql5o+HBNrl/zHWtS77Wk44b4osEOITh1XPkio5bLckA9jWLLo8pezytJJnlDyr5Dklzyt5QcmLSl5S8rKSV5S8quQ1Ja8reUPJm0reUvK2kneUvKvkPSXvK/lAyYdKPlLysZJPlHyq5DMlnyv5QsmXSr5S8rWSb5R8q+Q7Jd8r+UHJj3jR5ams1m8KPE2ce4Y49yxx7jni3PPEuReIcy8S514izr1MnHuFOPcqce414tzrxLk3iHNvEufeIs69TZx7hzj3LnHuPeLc+8S5D4hzHxLnPiLOfUyc+4Q49ylx7jPi3OfEuS+Ic18S574izn1NnPuGOPctce474tz3xLkfiHM/AnI3Yaj/f5j/300vtCDNdDuOpxiwGhpXh6f5sOqf4cOqfpYPy3uODavBe54Nq857gQ2rynuRDcv1XuLCanC9l7mw6lzvFS6sKtd7lQtLte3XmLAaFNbrTFh1evsjJqwqhfUmE5bmwrd4sBo01ts8WHUa6x0erCqN9S4P1l99x3ssWA1/Yb3PglX3F9YHLFhVf2F9yIK1uq/9iAOrYTXWxxxYdauxPuHAqlqN9SkHlj82+YwBq97H+pwBq9bH+oIBq9LH+jJ9rNiePF+lj+UZrK/TxqpqNFjfpI9Va7C+TR/LjFe979LGqoxhfZ82VnkM64e0sbwY1o9CiyL4iaoozB0M1k98ZdafH2FfqNILhP8nsHD3M3Ndcz81p5/+eYqxbnQ9/yxgx18ssCOnjz8lZMdfGe2odcOL87qezCL8r1nJ7R75mzr4Xcl/9fms+IvzbnrB00+5PS1g053yZW8WpqufLvNvAuXeOV+mH8tirvffGPuxPxnbOKPfeLbUxVLGunCyZdpwlNoFxbF/Ai7VNkiGYzNUug5KMpVkZctxrH6K+BkBrtkl4hz7V5mz+XF3taRdZzC2xexsPr0Y/cazpS6WMXJsTrZMG45Su6A4Nhvwak6SHJur0uUpyVdSIMix+i2NZwU4dreIc6wuc64Ax+5uSbvOZWyLHRk5ltFvPFvqYjkjx3bKlmnDUWoXFMd2BLzaKUmOLVTp1lJSpKRYkGP1W3DPCXDsHhHnWF3mQgGO3dOSdl3I2BY7M3Iso994ttTFWYwc2yVbpg1HqV1QHNsZ8GqXJDm2q0q3tpJuSroLcqx+y/h5AY7dK+Icq8vcVYBj97akXXdlbIs9GDmW0W88W+piBSPH9syWacNRahcUx/YAvNozSY7tpdL1VtJHSV9BjtW7OLwgwLH7RJxjdZl7CXDsvpa0616MbbEfI8cy+o1nS12czcix62TLtOEotQuKY/sBXl0nSY7tr9INUDJQySBBjtW75LwowLHDI86xusz9BTh2hCXtuj9jWxzMyLGMfuPZUhfnMHLsutkybThK7YLi2MGAV9dNkmPXU+nWV7KBkiGCHKt3IXtJgGP3izjH6jKvJ8Cx+1vSrtdjbItDGTmW0W88W+piJSPHbpgt04aj1C4ojh0KeHXDJDl2I5VuYyWbKNlUkGP1Lo8vC3DsARHnWF3mjQQ49kBL2vVGjG1xM0aOZfQbz5a6OJeRY91smTYcpXZBcexmgFfdJDnWU+lKlJQqKRPkWL2L7isCHHtQxDlWl9kT4NiDLWnXHmNbLGfkWEa/8Wypi/MYObYiW6YNR6ldUBxbDni1IkmOrVTpqpRUK9lckGP1LuWvCnDsIRHnWF3mSgGOPdSSdl3J2Ba3YORYRr/xbKmLVYwcu2W2TBuOUrugOHYLwKtbJsmxW6l0WyvZRttMkGP1VyBeE+DYwyLOsbrMWwlw7OGWtOutGNvitowcy+g3ni11cT4jx26XLdOGo9QuKI7dFvDqdkly7PYq3Q5KdlSykyDH6q/svC7AsUdEnGN1mbcX4NgjLWnX2zO2xZ0ZOZbRbzxb6uICRo7dJVumDUepXVAcuzPg1V2S5NhdVbrdlOyuZA9Bjr0wq3kfZ4ibrk2PijjH6jLvKsCxNZa0610Z2+KejBzL6DeeLXVxISPH7pUt04aj1C4ojt0T8OpeSXLs3irdPkr2VTJckGP1VyLfFODY2ohzrC7z3gIcW2dJu96bsS2OYORYRr/xbKmLixg5dr9smTYcpXZBcewIwKv7Jcmx+6t0Byg5UMlBghyrv8L7lgDH1kecY3WZ9xfg2AZL2vX+jG3xYEaOZfQbz5a6uJiRYw/JlmnDUWoXFMceDHj1kCQ59lCV7jAlhys5QpBj9VfO3xbg2MaIc6wu86ECHDvSknZ9KGNbPJKRYxn9xrOlLi5h5NijsmXacJTaBcWxRwJePSpJjq1R6WqV1CmpF+TYS7Oav4MHcdO16aiIc6wuc40Axx5tSbuuYWyLDYwcy+g3ni11cSkjxzZmy7ThKLULimMbAK82JsmxI1W6UUqOVnKMIMdeltX8XVGIm65Nj4k4x+oyjxTg2GMtadcjGdvisYwcy+g3ni11cRkjx47OlmnDUWoXFMceC3h1dJIce5xKd7ySMUrGCnLs5VnN32mGuGnXdcQ5Vpf5OAGOPc6Sdn0cY1s8gZFjGf3Gs6UuLmfk2HHZMm04Su2C4tgTAK+OS5Jjx6t0E5RMVDJJkGOvyGr+7j3ETdemx0ecY3WZxwtw7BhL2vV4xrY4mZFjGf3Gs6UurmDk2CnZMm04Su2C4tjJgFenJMmxU1W6aUqmK5khyLFXKuAPBDh2bMQ5Vpd5qgDHnmBJu57K2BZnMnIso994ttTFlYwcOytbpg1HqV1QHDsT8OqsJDl2tkrXpOREJScJcuxVCvhDAY4dF3GO1WWeLcCx4y1p17MZ2+LJjBzL6DeeLXVxFSPHnpIt04aj1C4ojj0Z8OopSXLsqSrdaUrmKDldkGOvVsAfCXDshIhzrC7zqQIcO9GSdn0qY1ucy8ixjH7j2VIXVzNy7LxsmTYcpXZBcexcwKvzkuTY+SrdGUoWKFkoyLHXKOCPBTh2UsQ5Vpd5vgDHTrakXc9nbIuLGDmW0W88W+riGkaOPTNbpg1HqV1QHLsI8OqZSXLsYpVuiZKlSpYJcuy1CvgTAY6dEnGO1WVeLMCxUy1p14sZ2+JyRo5l9BvPlrq4lpFjz8qWacNRahcUxy4HvHpWkhy7QqU7W8k5SlYKcux1CvhTAY6dFnGO1WVeIcCx0y1p1ysY2+K5jBzL6DeeLXVxHSPHnpct04aj1C4ojj0X8Op5SXLsKpXufCUXKLlQkGOvV8CfCXDsjIhzrC7zKgGOnWnLvtCMbfEiRo5l9BvPlrq4npFjL86WacNRahcUx14EePXiJDn2EpXuUiWXKblckGNvUMCfC3DsrIhzrC7zJQIcO9uWd+QZ2+IVjBzL6DeeLXVxAyPHXpkt04aj1C4ojr0C8OqVSXLsVSrd1UquUXKtIMfeqIC/EODYpohzrC7zVQIce6ItzwsxtsXrGDmW0W88W+riRkaOvT5bpg1HqV1QHHsd4NXrk+TYG1S6G5XcpORmQY69SQF/KcCxJ0WcY3WZbxDg2JNtGTsxtsVbGDmW0W88W+riJkaOvTVbpg1HqV1QHHsL4NVbk+TY21S625XcoeROQY69WQF/JcCxp0ScY3WZbxPg2FMtade3MbbFuxg5ltFvPFvq4mZGjr07W6YNR6ldUBx7F+DVu5Pk2HtUunuV/EPJPwU59hYF/LUAx54WcY7VZb5HgGPnWNKu72Fsi/cxciyj33i21MUtjBx7f7ZMG45Su6A49j7Aq/cnybEPqHQPKnlIycOCHHurAv5GgGNPjzjH6jI/IMCxcy1p1w8wtsVHGDmW0W88W+riVkaO/Ve2TBuOUrugOPYRwKv/SpJjH1Xp/q3kMSX/EeTY2xTwtwIcOy/iHKvL/KgAx863pF0/ytgWH2fkWEa/8Wypi9sYOfaJbJk2HKV2QXHs44BXn0iSY59U6f5PyVNKnhbk2NsV8HcCHHtGxDlWl/lJAY5dYEm7fpKxLT7DyLGMfuPZUhe3M3Lss9kybThK7YLi2GcArz6bJMc+p9I9r+QFJS8KcuwdCvh7AY5dGHGO1WV+ToBjF1nSrp9jbIsvMXIso994ttTFHYwc+3K2TBuOUrugOPYlwKsvJ8mxr6h0ryp5Tcnrghx7pwL+QYBjz4w4x+oyvyLAsYstadevMLbFNxg5ltFvPFvq4k5Gjn0zW6YNR6ldUBz7BuDVN5Pk2LdUureVvKPkXUGOvUsB/yjAsUsizrG6zG8JcOxSS9r1W4xt8T1GjmX0G8+WuriLkWPfz5Zpw1FqFxTHvgd49f0kOfYDle5DJR8p+RhwrAkdmOu52OGz5wfZMr6dyVzmuYy+vZAR6xNG+2m/6eQ09yUwcPfXnHpDfT/NFlT402x+3M8YiU6q3J9lNxuYCfcvZ9OwHRx5Z4ON100zSOq5MEumUXwO/JZ/NxfGUZPWLdPX0SitHSXHCYeVOCsAOvYXfgP6UpdJogI+F2Cmz5m7ZqlydxAsd9qv1gjb0E0veNoxvxKYPn7N3L0bUtC4TT4uty2+FLLFN0K2+CbAFmlvbSBki+Xtu5xSl0A/MR84Kz/aPKA7vq8EuJSxvj1OG+pBRa5Djz6dFG2QyKcgpgR/c9kEDrC+DRoxuukF7yshQoRKp6izlygfrfO3AsSwIiJre6kMZNJ+vi07mgSzIl/GL78DHXVb6yeRzTnr53uA5ZWWqrZRX+k11jeWlldWl9R6FaUVFY1ljZUVVWX1jeVlNfWVDV5ZTWlJdUOl2+hVNTRUlpfWVVY0VtfXVTRC0vbqS0vL6qtr67zykoqaWreqvrTGbSyrLC1xa+pLK+vrS6sqKmpKS+srqhqrqqtKSmoaS6vc8srKareipLS6RKp+vvfrJ8yZ5lyhmeYP/kzzR1sIXEq/HwTI+iehjusnwVmNtsWPArb4WcgWPwvOaqT84pyIz2qkfGBlxGc1c4VmNYz17a1cM6vBwftBaFbzi42zml+EZzW/CBDDuX/DWc2v2dEkmHOFRs2/Wjar+Y1xVrOScVYjVT+/gVlNvE4hystRknpKdTC/29jB/C7cwfwu0MGcJ9TBZDPryUlg/2XE4lw24+yszhMiw/8m0Vmla9M/svk6hRbLZhHqrKTq54//oSW4Pw2J5BAPe7jpBS/eQw+cT/Gk/e0RxpGwRMUbG2ZaYsN0sTJyol0fusFoHbkHCR1yZMhK4zb5uNy2+Is0BGyRKWSLzBy55Vopv7gg4su1Uj5woQXLtbrc3Mu1jPXtXbhmuRaHv/ibyyZw4JeVIzibzhAiRKg092xa65wlQAwXWbJcC+ss3TJn50STYC4SmmFl58gv13LWT04O3wz4QsYZsFT95OSEPwOWet0hN2f1/zxbCFxKv1wBss4X6rjyBWc12hZ5ArYoELJFgeCsRsovLon4rEbKBy614NF6iVkNY317l66Z1eDg5TJziwkdbZzVdBSe1XQUIIbL/oazmk450SSYy4RGzZ0sm9UUMs5qLmWc1UjVT2FO+A+h/GnJQyhSHcxaNnYwawl3MGsJdDCXW/IQCieBFTFicS6bcXZWlwuRYVGO/EMoxTl8ncKF+dHsrKTqp5ioH+5nBBgfOvHOZNxHqjMjr4e5j1RnoU60S46gwl1y+HG7MhKzVLm75jQbmAk31H2kzrRkHynOJ9tgo1g7aGSZrtN1ZZy6QlY3Sv8vPFrYzW9A3alHCzkqYG0BZlpb+EYNV7k7CJY7XR17RPxml3bMHgJTrJ5C082egje7ugvZopeQLXoJ3uyS8ourIn6zS8oHrrbgEb4eAlzKWN/e1WtuduHwF39z2QQOsHpLrkX2ECLE3oJrkVrn3gLEcI0lN7t6MA6K+uREk2CuEVqf6hPCzS7O+unLeLPrasb1Q6n66dsOj/CdKTTT7OfPNNexhcCl9OsnQNb9hTqu/oKzGm2LdQRsMUDIFgMEZzVSfnFdxGc1Uj5wfcRnNWcKzWoY69u7fs2sBgevn9CsZqCNs5qBwrOagQLEcMPfcFYzKCeaBHOD0Kh5kGWzmsGMs5rrGWc1UvUzuB0e4euWI9Pubelg1rWxg1lXuINZV6CDudGSR/g4CWw9RizOZTPOzupGITJcL4RH+NZnfITv6vxodlZS9bP+/9AS3Ab+EtwQ6mEPN73gxXvogfMpnnSxGB8cEdm3yNiQ+xlRKRumizU04vWhG8xQgUHChkIDpg0Fl2uHCNliIyFbbCS4XCvlF7dEfLlWygdutWC5dqjAci1jfXu3rlmuxeEv/uayCRz4bSw5mx4qRIgbC86mtc4bCxDDbZYs1w5lHBRtkhNNgrlNaIa1SQjLtZz1synjcu2tjDNgqfrZtB1mwFKvO2zmz4BdWwhcSr/NBMjaE+q4PMFZjbaFK2CLEiFblAjOaqT84o6Iz2qkfOBOCx6tl5jVMNa3d+eaWQ0O3mZCs5pSG2c1pcKzmlIBYrjrbzirKcuJJsHcJTRqLrNsVlPOOKu5k3FWI1U/5e3wEMoGOTLt3pYOpsLGDqZCuIOpEOhg7rbkIRROAqtkxOJcNuPsrO4WIsPKEB5CqWJ8COXW/Gh2VlL1UyW4AnKfqugHs/g5qFp4FYyDe6qJZy3c9AJnP+RVM3La5hGvD72n4OYCfeEWzM+YcD/fpFdhOHVc6OM5vH4tsgK1yNeVu863ZPT1MPee21Jo4L1VjqDCW+Xw427NSHxS5d76b97IthGazXITLKcvDYt4Z3KSvm/KqONfdRySn6db9hFZq9sk9+0MTv/Z1tKOaT+h/R+3yxFUeDuBjmn7iHdMutzbW9Ix6Qa7rUDHtEPEn7/Q9bODAFFty+ibO0Z8tri/BWS/k6Vkf4AQ2e+cI6jwzgJkv0vEyV6XexdLyF432J0EyH7XiJO9rp9dBYhqJ0bf3C3iNhyWZc9se1uLdN3OIl23t0jXHSzSdUeLdN3JIl13tkjXXSzSdVeLdN3NIl13t0jXPSzSdU+LdN3LIl33tkjXfSzSdV+LdB1u07xA6bmjwPx394jP3XT97C5Q7q0jXm49P99NoNx7WFDfe/wN6/tAIS7SC7+FDv18Ovea0haMn388MP1F5Njj00TR2bChXff0628v85qzef5yT9+h4TmdaABSKtUXPBIpKVUhbcQqMW+37cm4+LhXDq+jSCxc7ylAaHtH/A7bFn65uZ+P5fRpTj/ch/GxGcgT+wCekCBsThsc6ONxP/u/RRZvR8uFxWm7fRmxoP/sC/xH4pGpPQVuTo1gbOPDLXgSQcKG+zPacASzDZnLWro/4jE3vfDXjXFdZu731Tj6robGv0LD/kKcmK5enJy4H1+dljggdGCuV84y78/8iDD7E4JKv/0FxrMHML+7YPq/A/z+j5oIc/OQ9oMRjO1S9136iUyu/XxNGx3xv9vezVyu1CECE3aLSf+B/qT/IDzpP5CY9B8UMBhz0wt/Pbo7XKBhPhztbYhKRwhNsLsU8JbbBK7JkU2NOe0NyIXqgmmAF1vYOpCxzAcxDgQY27DH2C48hnqNEX4yHTxH++CenFIdvJteKGUchJRyTqw4BvSrq6Kx3iECky+16OAP9jv4Q3AHfzDRwR9CrOpzk8zBjCRzSI7MQIGz841C5wGdjv0OQU7zYJHBT2LlPjRHptPknj1z+vNhEZ896zo5TGC171BGGx4e8VvluqyHC7SXI3LYBgqNYb5vdQTzyokJR+YIKnxkDj/uURF/30qX+6icZgMz4crctvZ15W5kNVG/HeOXm/12DKNv1kb8dswI5tsxZmXr77IMWsdnu1KqfjluPXHfbts7R2Y5nqtO6qPd5v6aWTNyq6c5pk6A/xsY7Wjrs43DLXy2sdEft4zEqyCNxCrISMuebRzO+GxjIyPpjIz4s42aYOsFSOLxiH/5Qg/mGgTK/URENvZPEFjb3ijGTovRb7wnIu6DmmdGCfjg0ULPYRwt+Byi5u9GgWeNh2fx1hdXeY8Relb0GMv67WP/JtxhAvfKO6dPjo74yrv2ldECfHmcEF8eF/DcWjx/cNML3vCItU1/Mb2RKLrIJOd4f5IzBk9yjicmOWNCIEupCkl3knM8I3GMYXSUVBpLBGbxJnjH8k30PKLoIo1lrN9YTsCNZSzRWE5IorFEtULSbSxjGRvLCcyOwt3L6h72eIFedpwlzzJw1vX4iI+odJ2MF7hVNo7RhhMi/iyDLusEgfYy0dJnGSYKPcswKUdQ4UkCzzJMjvizDLrck3OaDcyEK6LraF9X7kY2JeLPMphycxP0aEbfnBpSx+6mF1hnYtOY2zZ3WfXgl9G3PV3H0wTa33Tme8l5TvMSstZ1gNMysO9F6fD7PvselBbouLsFOu5hgY57WqDjXhbouLcFOu5jgY77WqDjcAt0HGGBjvtZoOP+Fuh4gAU6HmiBjgdZoOPBFuh4iAU6HmqBjodZoOPhFuh4hAU6HmmBjkdZoGONBTrWWqBjnQU61lugY4MFOjZaoONIC3QcJaAjDDzYJYLYzU+LaNsW+8cz1JrtTCWzlMxW0qTkRCUnKTlZySlKTlVympI5Sk5XMlfJPCXz/ftNZ+AnTmb4T5fAczOJc7OIc7OJc03EuROJcycR504mzp1BPP3C+qyy57qMi8ktFn3TXaRfIPR85ALCpqw3QryWuqdrh4VCdlgo7Vu8C+zeQkabLhKy6aIQfGsRox3OFLLDmSH4FuONEe9MRpsuFrLpYmnfUnaYEVE7iPmRak+MN69a3GRK135LhPxoSQgctYTRj5YK2WFpCBzFeEPPW8po02VCNl0Wgm8tY7TDciE7LA/BtxhvxHrLGW16lpBNzwqh/5sZUTuI+ZFqT4w3y1vc1E7XfiuE/GhFCBy1gtGPzhayw9khcBTjAwTe2Yw2PUfIpueE4FvnMNphpZAdVobgW4wPfngrGW16rpBNzw2h/5sVUTuI+ZFqT4wP57R4iCZd+50n5EfnhcBR5zH60SohO6wKgaMYH1jyVjHa9Hwhm54fgm+dz2iHC4TscEEIvsX4oJl3AaNNLxSy6YUh9H+zI2oHMT9S7YnxYcAWD+2la7+LhPzoohA46iJGP7pYyA4Xh8BRjA9Iehcz2vQSIZteEoJvXcJoh0uF7HBpCL7F+GCrdymjTS8TsullIfR/TRG1g5gfqfbE+PBxi4eE07Xf5UJ+dHkIHHU5ox9dIWSHK0LgKMYHsr0rGG16pZBNrwzBt65ktMNVQna4KgTfOooR6ypGm14tZNOrQ+j/ToyoHcT8SLWnGkb71Tp89rtGyI+uCYGjrmH0o2uF7HBtCBxVx4h1LaNNrxOy6XUh+NZ1jHa4XsgO14fgW4wv7njXM9r0BiGb3hBC/3dSRO0g5keqPTG+XNXiJah07XejkB/dGAJH3cjoRzcJ2eGmEDiK8YUz7yZGm94sZNObQ/CtmxntcIuQHW4JwbcYXxT0bmG06a1CNr01hP7v5IjaAZY5g7nMp1ii56mW6HmaJXrOsUTP0y3Rc64les6zRM/5jHrqTTrznZabdBY7LQO3/jME7Myt40wLdJxlgY6zLdCxyQIdT7RAx5Ms0PFkIY7n0LFKCFdK3zW4/1u4fNglEp9MMtixr1DAscptql3fruQOJXcquUvJ3UruUXKvkn8o+aeS+5Tcr+QBJQ8qeUjJwzlOy81lbstpveHM7cS5O4hzdxLn7iLO3U2cu4c4dy9x7iHi3MP+uaDvdXGT6T9yIu6M/oeZoC0eyVn9/1+40nVEHlKAe2XqHwyrKA2rl1G8RxhXZP5lyczHFj3/aYme91mi5/2W6PmAJXo+aImeHHxZ6WNBPfHqeLr8ybii4d0mVDfcZWZcIfFut6TMjCsu3h2WlJlxBce705IyM64IeXdZUmbGFSbvbkvKzLhi5d1jSZkZV8C8e0Mqs9u2EPvI8kOMc6VHhe7iQ1xmO5jgPcxY94+yzGV1aDk2y2D298cYykytzHLr+R8GPStq3OqGiopKST0fZ9CztraisqahqlxSzycY9Cytq2hoLK0skdTzSQY9a8rLGhvLS2sk9fw/Bj3LPbehvKSyUVLPpxj0rK51yyuqquok9XyaQU+vsaq0vrqmVlLPZzjqvbbBrav3qrVuXZ3WO8zDneXhjvJwJ3m4gzzcOR7uGA93in8MHJdmtf0YLrY/DI7/A44fB8dPgOMnwfH/geOnwPHT4PgZ//hZ9f85Jc8reUHJi0peUvKykldyVi/yr+U0r08H1b+bXvCejfoi/+pQJobtuS3uOGX5x68qu7ym5HUlb+CbCa/6NxPgudeIc68T597IaX0jIpvXWC0qNV2CeJVxIPgaE5Yu4+uMN1veYH7kKqzG+9yaxks23jeVXd5S8raSd3DjfZNolG8R594mzr0TQuN9jrHxvsnYeN9ibLxvMzbedyxtvM+vabxk431X2eU9Je8r+QA33neJRvkece594twHITTe5xkb77uMjfc9xsb7PmPj/cDSxvvCmsZLNt4PlV0+UvKxkk9w4/2QaJQfEec+Js59EkLjfYGx8X7I2Hg/Ymy8HzM23k8sbbwvrmm8ZOP9VNnlMyWfK/kCN95PiUb5GXHuc+LcFyE03hcZG++njI33M8bG+zlj4/3C0sb70prGSzbeL5VdvlLytZJvcOP9kmiUXxHnvibOfRNC432JsfF+ydh4v2JsvF8zNt5vLG28L69pvGTj/VbZ5Tsl3yv5ATfeb4lG+R1x7nvi3A8hNN6XGRvvt4yN9zvGxvs9Y+P9wdLG+8qaxks23h+VXX5S8rOSX3Dj/ZFolD8R534mzv0SQuN9hbHx/sjYeH9ibLw/MzbeX4QaAfe7SK/n8Dn9G4w+8iuj/WBb0bhNTogvyHm8ZSHUTRbbS4QNbfFbzur/v2Oi+o0gIJ3oRKQU9wOrvzM6139TqJDGBAHa4b+EHbi34/s1eTvUJbCD91uOTP24aQYx+7ktny1w0wsep0/+IUR4f7QD4f1hIeH96ROek+u0JLc/CcLTiaQJT+fBhZWRK0N4GbnyhPcHI+H9mSNTP26aQcx+qsyvMhIep092yJUhPI3b5IRLeB1y7SO8zNzV/7Mw4ekITHhZIRBeFqNzZQsRXnYIhNchl4/wMnNl6sdNM4jZj/dBL4/TJ3OECC+nHQgvx0LCy/UJLw8TXi5BeHkhEF4eo3PlCxFefgiEl8NIeLm5MvXjphnE7IeeknXTCx6nTxYIEV5BOxBegYWE19EnvE6Y8DoShNcpBMLrxOhchUKEVxgC4RUwEl7HXJn6cdMMYvZzW75i4KYXPE6fXEuI8NZqB8Jby0LCK/IJrxgTXhFBeMUhEF4xo3N1FiK8ziEQ3lqMhFeUK1M/bppBzH6qzG8yEh6nT3YRIrwu7UB4XSwkvK4+4a2NCa8rQXhrh0B4azM6VzchwusWAuF1YSS8rrky9eOmGcTsx/u+l8fpk92FCK97OxBedwsJr4dPeD0x4fUgCK9nCITXk9G5egkRXq8QCK87I+H1yJWpHzfNIGY/9LKsm17wOH2ytxDh9W4HwuttIeH18QmvLya8PgTh9Q2B8PoyOlc/IcLrFwLh9WYkvD65MvXjphnE7Oe23GnATS94nD65jhDhrdMOhLeOhYTX3ye8AZjw+hOENyAEwhvA6FwDhQhvYAiEtw4j4fXPlakfN80gZj9V5ncZCY/TJwcJEd6gdiC8QRYS3mCf8NbFhDeYILx1QyC8dRmdaz0hwlsvBMIbxEh4g3Nl6sdNM4jZj3fbF4/TJ9cXIrz124Hw1reQ8DbwCW8IJrwNCMIbEgLhDWF0rqFChDc0BMJbn5HwNsiVqR83zSBmP7Rnlpte8Dh9ckMhwtuwHQhvQwsJbyOf8DbGhLcRQXgbh0B4GzM61yZChLdJCIS3ISPhbZQrUz9umkHMfm7LDQfd9ILH6ZObChHepu1AeJtaSHib+YTnYsLbjCA8NwTCcxmdyxMiPC8EwtuUkfA2y5WpHzfNIGY/VeYPGQmP0ydLhAivxCc8SZt+zrgDzReM73eXCtm0tB06kVILO5EyvxMpx51IGdGJlIfQiZQzNtgKoU6kIoROpJSxEynLlakfN80gZj+35U6/bnrB4/TJSiHCq2wHwqu0kPCqfMKrxoRXRRBedQiEV83oXJsLEd7mIRBeJSPhVeXK1I+bZhCznyrzp4yEx+mTWwgR3hbtQHhbWEh4W/qEtxUmvC0JwtsqBMLbitG5thYivK1DILwtGAlvy1yZ+nHTDGL249123eP0yW2ECG+bdiC8bSwkvGE+4W2LCW8YQXjbhkB42zI613ZChLddCIS3DSPhDcuVqR83zSBmP/TNCje94HH65PZChLd9OxDe9hYS3g4+4e2ICW8HgvB2DIHwdmR0rp2ECG+nEAhve0bC2yFXpn7cNIOY/dyWH/xx0wsep0/uLER4O7cD4e1sIeHt4hPerpjwdiEIb9cQCG9XRufaTYjwdguB8HZmJLxdcmXqx00ziNlPlflLRsLj9MndhQhv93YgvN0tJLw9fMLbExPeHgTh7RkC4e3J6Fx7CRHeXiEQ3u6MhLdHrkz9uGkGMfu5rF9f8zh9cm8hwtu7HQhvbwsJbx+f8PbFhLcPQXj7hkB4+zI613AhwhseAuHtzUh4++TK1I+bZhCzn9vy05VuesHj9MkRQoQ3oh0Ib4SFhLefT3j7Y8LbjyC8/UMgvP0ZnesAIcI7IATCG8FIePvlytSPm2YQs5/b8ru/bnrB4/TJA4UI78B2ILwDLSS8g3zCOxgT3kEE4R0cAuEdzOhchwgR3iEhEN6BjIR3UK5M/bhpBjH7qTJ/y0h4nD55qBDhHdoOhHeohYR3mE94h2PCO4wgvMNDILzDGZ3rCCHCOyIEwjuUkfAOy5WpHzfNIGY/l/Uj7B6nTx4pRHhHtgPhHWkh4R3lE14NJryjCMKrCYHwahidq1aI8GpDILwjGQnvqFyZ+nHTDGL2U2X+mZHwOH2yTojw6tqB8OosJLx6n/AaMOHVE4TXEALhNTA6V6MQ4TWGQHh1jIRXnytTP26aQcx+qsw/MRIep0+OFCK8ke1AeCMtJLxRPuEdjQlvFEF4R4dAeEczOtcxQoR3TAiEN5KR8EblytSPm2YQs58q84+MhMfpk8cKEd6xgPDWAvak2qibXvAalW13zeLDG63rKqtZXy77OETgwS6Rw/ZW16vj1+sA/3i0qt/jlByvZIySsUpOUDJOyXglE5RMVDJJyWQlU5RMVTJNyXQlM5TMVDJLyWztK5rDlJyk5GQlpyg5VclpSuYoOV3JXCXzlMzHncNoonM4jjh3PHFuDHFuLHHuBOLcOOLceOLcBOLcROLcJOLcZOLcFOLcVOLcNOLcdOLcDOLcTOLcLOLcbOJcE3HuROLcScS5k4lzpxDnTiXOnUacm0OcO504N5c4N484N98/pwM3kWnSGc35wLbC0+Q4AOmZbqcxmqEDavhrGON6xzFh6fIez4K12nZj0scqMQOeselilTUPnk5ID8uFA7Fx6WCVtBzUjW87losHiBPaiFXR2HqwObFtWFXUwHVSW7Cq6EHw5NSxKuMNqKekilUZf3A+NTWskqCB/rRUsCqDJw3TGScgM5LFqkzIhd7M5LDcJHjVm5UMlpsUR3uzE2OVJ8n3XlMirLKk+w7vxECsssYU+iHvpCCsypT6NO/k+FhVKfaP3ilxsKobU+5rvVNpLLcN/bZ3GoXltmkM4M1pjeW1cTzhnY6x6ts8NvHmtsQqTWOc480DWCWNaY2ZvPmME209N+3kNK8YwsC6ioj0Tm+sV+9Bfc/IFVRYg3OtBBrlz+CrQG8Bg1HNYFzKhlrHDGYbLmBuBKEspbM23nrRlRpoi4V+A1uEV0sW+hULzy0Cs1oTuJdA+ZjE9RYyNqBFzJXL7Xy60SxkbIym3Ast7ZHmsflRdT3U98xcQYXPZO+RquvPZOyRFke8R9I2XMzeI1XXL7a0R5rHpnd1HaGuSI+0xG9gS3GPtITokZaG0CPNY+yRljA2oKVClct9c5yzzMsYycxx+HvLBT4Bca/5c04FljOSGWVDN73g6TpeLjCSWW7pSGYuG//UlkJ9z8oVVPgs9pFMbelZjI1/RcRHMtqGK9hHMrWlK4QbPweBLo84gZ7NbEMTuDteTh8/h7HthTkCnsumd20Joa7ICHilT8zn4hHwSmIEfG4II2C+Hsj1VjI65blClcvdEDnLfJ7wCNhNL3iaHM8RGL2tivioVdfLKgvKLeXjqxh9/PyI+3i8QQrH4IcL6wLmDjus2c7pbH1NVSPU98JcQYUvZJ/tVDVeyFiBF0V8tqNteBH7bKeq8aKIz3Y00V2QG20yvpiZjE3gLjOnj19i6WzndDa9qxoIdUVmO5f6xHwZnu1cSsx2LgthtsPXA7nepYxOeZlQ5XI3RM4yXx7xkaAmx0sERv1XRHy2o+vlCgvKLeXjVzD6+JUR9/F4gxQ3veBxDlKusvTezhy2vqbEhfpenSuo8NXss50S92rGRnBNxGc72obXsM92StxrIj7b0UR3VW60yfhaS2Y7nD5+naWznTlsenuNhLois53rfWK+Ac92ridmOzeEMNvh64Fc73pGp7xBqHK5GyJnmW+M+EhQk+N1AqP+myI+29H1cpMF5Zby8ZsYffzmiPt4vEGKm17wOAcpt1g62zmNra+pbzHbuTVXUOFb2Wc79e6tjI3gtojPdrQNb2Of7dS7t0V8tqOJ7pbcaJPx7ZbMdjh9/A5LZzunseldF9ps506fmO/Cs507idnOXSHMdvh6INe7k9Ep7xKqXO6GyFnmuyM+EtTkeIfAqP+eiM92dL3cY0G5pXz8HkYfvzfiPh5vkOKmFzzOQco/LJ3tnMrW11S02BPjn7mCCv+TfbZT4f2TsRHcF/HZjrbhfeyznYoW5XbTDFS5OYjuH7nRJuP7LZntcPr4A5bOdk5l07sitL1UHvSJ+SE823mQmO08FMJsh68Hcr0HGZ3yIaHK5W6InGV+OOIjQU2ODwiM+h+J+GxH18sjFpRbyscfYfTxf0Xcx+MNUtz0gsc5SHnU0tnOKXz3dqqgvv/OFVT43/z3dqr+zdgIHov4bEfb8DH+eztVj0V8tqOJ7tHcaJPxfyyZ7XD6+OOWznZOYdO7vpJQV2S284RPzE/i2c4TxGznyRBmO3w9kOs9weiUTwpVLndD5Czz/0V8JKjJ8XGBUf9TEZ/t6Hp5yoJyS/n4U4w+/nTEfTzeIMVNL3icg5RnLJ3tnMzW15RVQ32fzRVU+Fn22U5Z9bOMjeC5iM92tA2fY5/tlFU/F/HZjia6Z3KjTcbPWzLb4fTxFyyd7ZzMpndZFaGuyGznRZ+YX8KznReJ2c5LIcx2+Hog13uR0SlfEqpc7obIWeaXIz4S1OT4gsCo/5WIz3Z0vbxiQbmlfPwVRh9/NeI+Hm+Q4qYXPM5BymuWznZOYutrals8yfZ6rqDCr7PPdmq91xkbwRsRn+1oG77BPtupbVFuN81AlZuD6F7LjTYZv2nJbIfTx9+ydLZzEpvetaE9yfa2T8zv4NnO28Rs550QZjt8PZDrvc3olO8IVS53Q+Qs87sRHwlqcnxLYNT/XsRnO7pe3rOg3FI+/h6jj78fcR+PN0hx0wse5yDlA0tnOyfyzXbqoL4f5goq/CH/bKfuQ8ZG8FHEZzvahh/xz3bqPor4bEcT3Qe50Sbjjy2Z7XD6+CeWznZO5BsQ1xLqisx2PvWJ+TM82/mUmO18FsJsh68Hcr1PGZ3yM6HK5W6InGX+POIjQU2OnwiM+r+I+GxH18sXFpRbyse/YPTxLyPu4/EGKW56weMcpHxl6Wynie9Jtlqo79e5ggp/zf8kW+3XjI3gm4jPdrQNv+F/kq32m4jPdjTRfZUbbTL+1pLZDqePf2fpbKeJ72GnGkJdkdnO9z4x/4BnO98Ts50fQpjt8PVArvc9o1P+IFS53A2Rs8w/RnwkqMnxO4FR/08Rn+3oevnJgnJL+fhPjD7+c8R9PN4gxU0veJyDlF8sne3MZutrqlrsQP1rrqDCv7LPdqrcXxkbwW8Rn+1oG/7GPtupcn+L+GxHE90vudEm498tme1w+vh/LZ3tzGbTuzK0Haj/8In5Tzzb+YOY7fwZwmyHrwdyvT8YnfJPocrlboicZdaVzVWvjsPf4DQ5/ldg1J+RJ9txuekFT9eL1jHq5ZbycahnulgdIu7j8QYpbnrB4xykZDL6TZiznVlCs52sPEGFNTj3bCeLsRFkMzZOKRtm5/HPdrKFOw0OosvMizYZ5zCTsQncZeb08VzGMoc525ll4Wwnzyfm/Dyn5cwmL6/1bEcnkp7tzGKc7eQxOmV+nkzlcjdEzjIXRHwkqMkxV2DU3zHisx1dLx0tKLeUj3dk9PFOEffxeIMUN73gcQ5SCi2d7cxk62tqWuzJtlaeoMJrsc92aqrXYmwERRGf7WgbFrHPdmqqiyI+29FEV5gXbTIutmS2w+njnS2d7cxkm+3UhLYnWxefmLvi2U4XYrbTNYTZzkzG2U4XRqfsmidTudwNkbPMa0d8JKjJsbPAqL9bxGc7ul66WVBuKR/vxujj3SPu4/EGKW56weMcpPSwdLYzg2+2Uwb17ZknqHBP/tlOWU/GRtAr4rMdbcNe/LOdsl4Rn+1oouuRF20y7m3JbIfTx/tYOtuZwTfbKSXUFZnt9PWJuR+e7fQlZjv9QpjtzGCc7fRldMp+eTKVy90QOcu8TsRHgpoc+wiM+vtHfLaj66W/BeWW8vH+jD4+IOI+Hm+Q4qYXPM5BykBLZzvT2fqa+hb3dgblCSo8iH22U189iLERDI74bEfbcDD7bKe+enDEZzua6AbmRZuM17VktsPp4+tZOtuZzjbbqQ/t3s76PjFvgGc76xOznQ1CmO1MZ5ztrM/olBvkyVQud0PkLPOQiI8ENTmuJzDqHxrx2Y6ul6EWlFvKx4cy+viGEffxeIMUN73gcQ5SNrJ0tjONra+pa4D6bpwnqPDG7LOduoaNGRvBJhGf7WgbbsI+26lr2CTisx1NdBvlRZuMN7VktsPp45tZOtuZxjbbqasn1BWZ7bg+MXt4tuMSsx0vhNnONMbZjsvolF6eTOVyN0TOMpdEfCSoyXEzgVF/acRnO7peSi0ot5SPlzL6eFnEfTzeIMVNL3icg5RyS2c7U9n6Gq/FvZ2KPEGFK9hnO151BWMjqIz4bEfbsJJ9tuNVV0Z8tqOJrjwv2mRcZclsh9PHqy2d7Uxlm+14od3b2dwn5i3wbGdzYrazRQiznamMs53NGZ1yizyZyuVuiJxl3jLiI0FNjtUCo/6tIj7b0fWylQXllvLxrRh9fOuI+3i8QYqbXvA4BynbWDrbmcLW19S2mO0My5NUmH22U1s9jLERbBvx2Y624bbss53a6m0jPtvRRLdNXrTJeDtLZjucPr69pbOdKXwfoAxttrODT8w74tnODsRsZ8cQZjtTGGc7OzA65Y55MpXL3RA5y7xTxEeCmhy3Fxj17xzx2Y6ul50tKLeUj+/M6OO7RNzH4w1S3PSCxzlI2dXS2c5kvh2oq6C+u+UJKrwb+2ynqmo3xkawe8RnO9qGu7PPdqqqdo/4bEcT3a550SbjPSyZ7XD6+J6WznYms812qioJdUVmO3v5xLw3nu3sRcx29g5htjOZcbazF6NT7p0nU7ncDZGzzPtEfCSoyXFPgVH/vhGf7eh62deCckv5+L6MPj484j4eb5Diphc8zkHKCEtnO5PY+pqyFrOd/fIEFd6PfbZTVrUfYyPYP+KzHW3D/dlnO2VV+0d8tqOJbkRetMn4AEtmO5w+fqCls51JbLOdstBmOwf5xHwwnu0cRMx2Dg5htjOJcbZzEKNTHpwnU7ncDZGzzIdEfCSoyfFAgVH/oRGf7eh6OdSCckv5+KGMPn5YxH083iDFTS94nIOUwy2d7Uxk62uqPajvEXmCCh/BPtup9o5gbARHRny2o214JPtsp7pFud00A1VuDqI7PC/aZHyUJbMdTh+vsXS2M5FttlPtEuqKzHZqfWKuw7OdWmK2UxfCbGci42ynltEp6/JkKpe7IXKWuT7iI0FNjjUCo/6GiM92dL00WFBuKR9vYPTxxoj7eLxBipte8DgHKSMtne1MYOtrKl2o76g8QYVHsc92Kt1RjI3g6IjPdrQNj2af7VS6R0d8tqOJbmRetMn4GEtmO5w+fqyls50JbLOdikZCXZHZzmifmI/Ds53RxGznuBBmOxMYZzujGZ3yuDyZyuVuiJxlPj7iI0FNjscKjPrHRHy2o+tljAXllvLxMYw+PjbiPh5vkOKmFzzOQcoJls52xvPtUtBiB+pxeYIKj2Of7dQ2jGNsBOMjPtvRNhzPPtupbRgf8dmOJroT8qJNxhMsme1w+vhES2c74/l2KQhtB+pJPjFPxrOdScRsZ3IIs53xjLOdSYxOOTlPpnK5GyJnmadEfCSoyXGiwKh/asRnO7peplpQbikfn8ro49Mi7uPxBiluesHjHKRMt3S2M46trylpcW9nRp6gwjPYZzsl7gzGRjAz4rMdbcOZ7LOdEndmxGc7muim50WbjGdZMtvh9PHZls52xvHtQB3avZ0mn5hPxLOdJmK2c2IIs51xjLOdJkanPDFPpnK5GyJnmU+K+EhQk+NsgVH/yRGf7eh6OdmCckv5+MmMPn5KxH083iDFTS94nIOUUy2d7ZzA19fUQX1PyxNU+DT22Y5bdxpjI5gT8dmOtuEc9tmOWzcn4rMdTXSn5kWbjE+3ZLbD6eNzLZ3tnMA223FrCXVFZjvzfGKej2c784jZzvwQZjuMPZA3j9Ep5+fJVC53Q+Qs8xkRHwlqcpwrMOpfEPHZjq6XBRaUW8rHFzD6+MKI+3i8QYqbXvA4BymLLJ3tjGXraypaPMl2Zp6gwmeyz3YqGs5kbASLIz7b0TZczD7bqWhYHPHZjia6RXnRJuMllsx2OH18qaWznbF87+2E9iTbMp+Yl+PZzjJitrM8hNnOWMbZzjJGp1yeJ1O53A2Rs8xnRXwkqMlxqcCof0XEZzu6XlZYUG4pH1/B6ONnR9zH4w1S3PSCxzlIOcfS2c4Ytr7Ga7En28o8QYVXss92PG8lYyM4N+KzHW3Dc9lnO16LcrtpBqrcHER3Tl60yfg8S2Y7nD6+ytLZzhi+J9lC25PtfJ+YL8CznfOJ2c4FIcx2xjDOds5ndMoL8mQql7shcpb5woiPBDU5rhIY9V8U8dmOrpeLLCi3lI9fxOjjF0fcx+MNUtz0gsc5SLnE0tnO8XwPY7R4b+fSPEGFL83jx70s4jMUXe7LwMiDCVdkVqEJ5ZK8aJPe5ZbMKjj98gphoueokysEfDxMQj1OiFCvzBNU+EoBQr0q4oSqy33VGkJlw7raEkLl9MtrIk6ouk6usZxQR+fy2QPqe22eoMLXCjTWaxmd7bqIk7O24XUC0/vrIr4ebwPRX28J0XP6+A0RXyLRdXKDQHu5MeLLgJonbhQaxEn55Y2MfnlTxP0yHp+56QWPk89ujriP6zq+WWCCdiPzGMAE1tth6l7daL4ZdYvZebplvoXRb+AtRo3bpP6Hdt/W4y0LoW6y2F4ibGiLW33evw3ft73Vv0cLz+lEJyKluIn9NsYGdXsKFdKYIEA73E7YgbvB3pK8HeoS2MG7NU+mftw0g5j9eO/JeJw+eYcQ4d3RDoR3h4WEd6dPeHdhcruTILy7QiC8uxid624hwrs7BMK7g5Hw7syTqR83zSBmP9anxlyP0yfvESK8e9qB8O6xkPDu9QnvH5jc7iUI7x8hEN4/GJ3rn0KE988QCO8eRsK7N0+mftw0g5j9WF8KdD1On7xPiPDuawfCu89CwrvfJ7wHMLndTxDeAyEQ3gOMzvWgEOE9GALh3cdIePfnydSPm2YQsx/vnk8ep08+JER4D7UD4T1kIeE97BPeI5jcHiYI75EQCO8RRuf6lxDh/SsEwnuIkfAezpOpHzfNIGY/1i29XY/TJx8VIrxH24HwHrWQ8P7tE95jmNz+TRDeYyEQ3mOMzvUfIcL7TwiE9ygj4f07T6Z+3DSDmP1czi+2uR6nTz4uRHiPtwPhPW4h4T3hE96TmNyeIAjvyRAI70lG5/o/IcL7vxAI73FGwnsiT6Z+3DSDmP3clt+Sd9MLHqdPPiVEeE+1A+E9ZSHhPe0T3jOY3J4mCO+ZEAjvGUbnelaI8J4NgfCeYiS8p/Nk6sdNM4jZT5V5IiPhcfrkc0KE91w7EN5zFhLe8z7hvYDJ7XmC8F4IgfBeYHSuF4UI78UQCO85RsJ7Pk+mftw0g5j9VJknMRIep0++JER4L7UD4b1kIeG97BPeK5jcXiYI75UQCO8VRud6VYjwXg2B8F5iJLyX82Tqx00ziNlPlXkyI+Fx+uRrQoT3WjsQ3msWEt7rPuG9gcntdYLw3giB8N5gdK43hQjvzRAI7zVGwns9T6Z+3DSDmP1UmacwEh6nT74lRHhvtQPhvWUh4b3tE947mNzeJgjvnRAI7x1G53pXiPDeDYHw3mIkvLfzZOrHTTOI2U+VeSoj4XH65HtChPdeOxDeexYS3vs+4X2Aye19gvA+CIHwPmB0rg+FCO/DEAjvPUbCez9Ppn7cNIOY/VSZpzESHqdPfiREeB+1A+F9ZCHhfewT3ieY3D4mCO+TEAjvE0bn+lSI8D4NgfA+YiS8j/Nk6sdNM4jZT5V5OiPhcfrkZ0KE95lPeJI+OYPRpjMZd6D5XMimn7dDJ/K5hZ3IF34n8iXuML4gOpEvQ+hEvmRssF8JdSJfhdCJfM7YiXyRJ1M/bppBzH6qzLMYCY/TJ78WIryv24HwvraQ8L7xCe9bTG7fEIT3bQiE9y2jc30nRHjfhUB4XzMS3jd5MvXjphnE7KfKPJuR8Dh98nshwvu+HQjvewsJ7wef8H7E5PYDQXg/hkB4PzI6109ChPdTCIT3PSPh/ZAnUz9umkHMfqrMTYyEx+mTPwsR3s/tQHg/W0h4v/iE9ysmt18Iwvs1BML7ldG5fhMivN9CILyfGQnvlzyZ+nHTDGL2U2U+kZHwOH3ydyHC+70dCO93Cwnvvz7h/YHJ7b8E4f0RAuH9wehcfwoR3p8hEN7vjIT33zyZ+nHTDGL2U2U+iZHwOH3SyZchPI3b5IRLeJxlIdQVIbyM/NX/O+Q7LclNR2DC04mkCa9DPh9WZr4M4WXmyxOek89HeBn5MvXjphnE7KfKfDIj4XH6ZJYQ4WW1A+FlWUh42T7h5WDCyyYILycEwsthdK5cIcLLDYHwshgJLztfpn7cNIOY/VSZT2EkPE6fzBMivLx2ILw8Cwkv3ye8Akx4+QThFYRAeAWMztVRiPA6hkB4eYyEl58vUz9umkHMfqrMpzISHqdPdhIivE7tQHidLCS8Qp/w1sKEV0gQ3lohEN5ajM5VJER4RSEQXidGwivMl6kfN80gZj9V5tMYCY/TJ4uFCK+4HQiv2ELC6+wTXhdMeJ0JwusSAuF1YXSurkKE1zUEwitmJLzO+TL146YZxOynyjyHkfA4fXJtIcJbux0Ib20LCa+bT3jdMeF1IwivewiE153RuXoIEV6PEAhvbUbC65YvUz9umkHMfqrMpzMSHqdP9hQivJ7tQHg9LSS8Xj7h9caE14sgvN4hEF5vRufqI0R4fUIgvJ6MhNcrX6Z+3DSDmP1UmecyEh6nT/YVIry+7UB4fS0kvH4+4a2DCa8fQXjrhEB46zA6V38hwusfAuH1ZSS8fvky9eOmGcTsp8o8j5HwOH1ygBDhDWgHwhtgIeEN9AlvECa8gQThDQqB8AYxOtdgIcIbHALhDWAkvIH5MvXjphnE7KfKPJ+R8Dh9cl0hwls3v/UONNxts4TRpp8JPcDOXeZjGcu8LnPbwWV10wvetqq3HJ3Dh7ebwmvMad3Rplsn6zG3oS7O6oGC47elrVWj+sNp1tsc63zN8elZq4/NdeuruA2UDFEyNH/1eS0FTjO3UWEYTzlK/npOHmGzDnBUfTJiuVI6rifUP3Hrub6EntrhOirJBopzk4Ru0Ltn8eFpwtkuq1lfdqM4fNhV1ZXlVbVl9jmGgJ5elh16ZvJhtZg5bejPnDbCMycdMcBpGbgb4YaMI9KN+RzOg3bYmLADd+VuJNRYuEeRnGU+xrGjzBmMZT7WkjJ3YCzzaEvKzEiw3nEhldlNL3jHM9rv5Uw7OtIxjh16jrVEzxMs0XMco69rDG7+0ROSUTl8eHpCMj2H347jLanvCZboOdESPSdZoudkS/ScYomeUy3Rc5olek63RM8Zlug50xI9Z1mi52xL9GyyRM8TLdHzJEv0PNkSPU+xRM9TLdHzNEv0nGOJnqdboudcS/ScZ4me8y3R8wxL9FxgiZ4LLdFzkSV6nmmJnost0XOJJXouFdIzyvctl4VUZje94C1ntN/rltzPOsuxQ88Vluh5tiV6nmOJnist0fNcS/Q8zxI9V1mi5/mW6HmBJXpeaImeF1mi58WW6HmJJXpeaomel1mi5+WW6HmFJXpeaYmeV1mi59WW6HmNJXpea4me11mi5/WW6HmDJXreaImeN1mi582W6HmLJXreaomet1mi5+2W6HmHJXreaYmed1mi592W6HmPJXrea4me/7BEz39aoud9luh5vyV6PmCJng9aoudDluj5sCV6PmKJnv+yRM9HLdHz35bo+Zglev7HEj0ft0TPJyzR80lL9Pw/S/R8yhI9n7ZEz2cs0fNZS/R8zhI9n7dEzxcs0fNFS/R8yRI9X7ZEz1cs0fNVS/R8zRI9X7dEzzcs0fNNS/R8yxI937ZEz3cs0fNdS/R8zxI937dEzw8s0fNDS/T8yBI9P7ZEz08s0fNTS/T8zBI9P7dEzy8s0fNLS/T8yhI9v7ZEz28s0fNbS/T8zhI9v7dEzx8s0fNHS/T8yRI9f7ZEz18s0fNXS/T8zRI9f7dEz/9aoucfluj5pyV6akAb9MywRM8OluiZaYmeWZbomW2JnjmW6JlriZ55luiZb4meBZbo2dESPTtZomehJXquZYmeRZboWWyJnp0t0bOLJXp2tUTPtS3Rs5slena3RM8elujZ0xI9e1miZ29L9OxjiZ59LdGznyV6rmOJnv0t0XOAJXoOtETPQZboOdgSPde1RM/1LNFzfUv03MASPYdYoudQS/Tc0BI9N7JEz40t0XMTS/Tc1BI9N7NET9cSPT1L9CyxRM9SS/Qss0TPckv0rLBEz0pL9KyyRM9qS/Tc3BI9t7BEzy0t0XMrS/Tc2hI9t7FEz2GW6LmtJXpuZ4me21ui5w6W6LmjJXruZImeO1ui5y6W6LmrJXruZomeu1ui5x6W6LmnJXruZYmee1ui5z6W6LmvJXoOt0TPEUJ6dkB6Rum79Psxl5m7rNtlOc7oHD683RVeYw6/7+xviY8fkJG+LSsqqmoqy+o8SR/PZCzzgSG1aze94B2UwWe/9fPt8MeDLambQxjrxsuyo8yHMpZ5Q0v88TBLePxwS/Q8whI9j7REz6Ms0bPGEj1rLdGzzhI96y3Rs8ESPRst0XOkJXqOskTPoy3R8xhL9DzWEj1HW6LncZboebwleo6xRM+xluh5giV6jrNEz/GW6DnBEj0nWqLnJEv0nGyJnlMs0XOqJXpOs0TP6X/De4sz/oZlnmlJmTnvr82y5B7ObMb7GZtYcg+nibHMb2TawbUnWtInnGSJnidboucpluh5qiV6nmaJnnMs0fN0S/Sca4me8yzRc74lep5hiZ4LLNFzoSV6LrJEzzMt0XOxJXousUTPpZboucwSPZdboudZlui5whI9z7ZEz3Ms0XOlJXqea4me51mi5ypL9DzfEj0vsETPCy3R8yJL9LzYEj0vsUTPSy3R8zJL9LzcEj2vsETPKy3R8ypL9LzaEj2vsUTPay3R8zpL9LzeEj1vsETPGy3R8yZL9LzZEj1vsUTPWy3R8zZL9LzdEj3vsETPOy3R8y5L9LzbEj3vsUTPey3R8x+W6PlPS/S8zxI977dEzwcs0fNBS/R8yBI9H7ZEz0cs0fNfluj5qCV6/tsSPR+zRM//WKLn45bo+YQlej5piZ7/Z4meT1mi59OW6PmMJXo+a4mez1mi5/OW6PmCJXq+aImeL1mi58uW6PmKJXq+aomer1mi5+uW6PmGJXq+aYmeb1mi59uW6PmOJXq+a4me71mi5/uW6PmBJXp+aImeH1mi58eW6PmJJXp+aomen1mi5+eW6PmFJXp+aYmeX1mi59eW6PmNJXp+a4me31mi5/eW6PmDJXr+aImeP1mi58+W6PmLJXr+aomev1mi5++W6PlfS/T8wxI9/7RET6eDHXpmWKJnB0v0zLREzyxL9My2RM8cS/TMtUTPPEv0zLdEzwJL9OxoiZ6dLNGz0BI917JEzyJL9Cy2RM/OlujZxRI9u1qi59qW6NnNEj27W6JnD0v07GmJnr0s0bO3JXr2sUTPvpbo2c8SPdexRM/+lug5wBI9B1qi5yBL9BxsiZ7rWqLnepboub4lem5giZ5DLNFzqCV6bmiJnhtZoufGlui5iSV6bmqJnptZoqdriZ6eJXqWWKJnqSV6llmiZ7klelZYomelJXpWWaJntSV6bm6JnltYoueWlui5lSV6bm2JnttYoucwS/Tc1hI9t7NEz+0t0XMHS/Tc0RI9d7JEz50t0XMXS/Tc1RI9d7NEz90t0XMPS/Tc0xI997JEz70t0XMfS/Tc1xI9h1ui5whL9NzPEj33t0TPAyzR80BL9DzIEj0PtkTPQyzR81BL9DzMEj0Pt0TPIyzR80hL9DzKEj1rLNGz1hI96yzRs94SPRss0bPREj1HWqLnKEv0PNoSPY+xRM9jLdFztCV6HmeJnsdboucYS/Qca4meJ1ii5zhL9BxviZ4TLNFzoiV6TrJEz8mW6DnFEj2nWqLnNEv0nG6JnjMs0XOmJXrOskTP2Zbo2WSJnidaoudJluh5siV6nmKJnqdaoudplug5xxI9T7dEz7mW6DnPEj3nW6LnGZboucASPRdaouciS/Q80xI9F1ui5xJL9FxqiZ7LLNFzuSV6nmWJniss0fNsS/Q8xxI9V1qi57mW6HmeJXquskTP8y3R8wJL9LzQEj0vskTPiy3R8xJL9LzUEj0vs0TPyy3R8wpL9LzSEj2vskTPqy3R8xpL9LzWEj2vs0TP6y3R8wZL9LzREj1vskTPmy3R8xZL9LzVEj1vs0TP2y3R8w5L9LzTEj3vskTPuy3R8x5L9LzXEj3/YYme/7REz/ss0fN+S/R8wBI9H7REz4cs0fNhS/R8xBI9/2WJno9aoue/LdHzMUv0/I8lej5uiZ5PWKLnk5bo+X+W6PmUJXo+bYmez1ii57OW6PmcJXo+b4meL1ii54uW6PmSJXq+bImer1ii56uW6PmaJXq+bomeb1ii55uW6PmWJXq+bYme71ii57uW6PmeJXq+b4meH1ii54eW6PmRJXp+bImen1ii56eW6PmZJXp+bomeX1ii55eW6PmVJXp+bYme31ii57eW6PmdJXp+b4meP1ii54+W6PmTJXr+bImev1ii56+W6PmbJXr+bome/7VEzz8s0fNPS/R0Mu3QM8MSPTtYomemJXpmWaJntiV65liiZ64leuZZome+JXoWWKJnR0v07GSJnoWW6LmWJXoWWaJnsSV6drZEzy6W6NnVEj3XtkTPbpbo2d0SPXtYomdPIT07ID1L3YqysobKkgav1KtxS6prq8rdsvLaiiqvyiuvKq8vqSotbagqq6qsrq2udKu9stIGr7G8urTRx96Ascy9Qiqzm17wemfy2W/jfDvqOYvRfn0s8e1sxjL3taTMOYxl7mdJmXMZy7yOJWXOYyxzf0vKnM9Y5gGWlLmAscwDLSlzR8YyD7KkzJ0YyzzYkjIXMpZ5XUvKvBZjmdezpMxFjGVe35IyFzOWeQNLytyZscxDLClzF8YyD7WkzF0Zy7yhJWVem7HMG1lS5m6MZd7YkjJ3ZyzzJpaUuQdjmTe1pMw9Gcu8mSVl7sVYZteSMvdmLLNnSZn7MJa5xJIy92Usc6klZe7HWOYyS8q8DmOZyy0pc3/GMldYUuYBjGWutKTMAxnLXGVJmQcxlrnakjIPZizz5paUeV3GMm9hSZnXYyzzlpaUeX3GMm/FWGYFpV+pcZ73C3yMkmOVjFZynJLjlYxRMlbJCUrGKRmvZIKSiUomKZmsZIqSqUqmKZmuZIaSmUpmKZmtpEnJiUpOUnKyklOUnKrkNCVzlJyuZK6SeUrmKzlDyQIlC5UsUnKmksVKlihZqmSZkuVKzlKyQsnZSs5RslLJuUrOU7JKyflKLlByoZKLlFys5BIllyq5TMnlSq5QcqWSq5RcreQaJdcquU7J9UpuUHKjkpuU3KzkFiW3KrlNye1K7lByp5K7lNyt5B4l9yr5h5J/KrlPyf1KHlDyoJKHlDys5BEl/1LyqJJ/K3lMyX+UPK7kCSVPKvk/JU8peVrJM0qeVfKcri8lLyh5UclLSl5W8oqSV5W8puR1JW8oeVPJW0reVvKOkneVvKfkfSUfKPlQyUdKPlbyiZJPlXym5HMlXyj5UslXSr5W8o2Sb5V8p+R7JT8o+VHJT0p+VvKLkl+V/KbkdyX/VfKHkj+V6AfJMpR0UJKpJEtJtpIcJblK8pTkKylQ0lFJJyWFStZSUqSkWElnJV2UdFWytpJuSror6aGkp5JeSnor6aOkr5J+StZR0l/JACUDlQxSMljJukrWU7K+kg2UDFEyVMmGSjZSsrGSTZRsqmQzJa4ST0mJklIlZUrKlVQoqVRSpaRayeZKtlCypZKtlGytZBslw5Rsq2Q7Jdsr2UHJjkp2UrKzkl2U7KpkNyW7K9lDyZ5K9lKyt5J9lOyrZLiSEUr2U7K/kgOUHKjkICUHKzlEyaFKDlNyuJIjlByp5CglNUpqldQpqVfSoKRRyUglo5QcreQYJccqGa3kOCXHKxmjZKySE5SMUzJeyQQlE5VMUjJZyRQlU5VMUzJdyQwlM5XMUjJbSZOSE5WcpORkJacoOVXJaUrmKDldyVwl85TMV3KGkgVKFipZpORMJYuVLFGyVMkyJcuVnKVkhZKzlZyjZKWSc5Wcp2SVkvOVXKDkQiUXKblYySVKLlVymZLLlVyh5EolVym5Wsk1Sq5Vcp2S65XcoORGJTcpuVnJLUpuVXKbktuV3KHkTiV3KblbyT1K7lXyDyX/VHKfkvuVPKDkQSUPKXlYySNK/qXkUSX/VvKYkv8oeVzJE0qeVPJ/Sp5S8rSSZ5Q8q+Q5Jc8reUHJi0peUvKykleUvKrkNSWvK3lDyZtK3lLytpJ3lLyr5D0l7yv5QMmHSj5S8rGST5R8quQzJZ8r+ULJl0q+UvK1km+UfKvkOyXfK/lByY9KflLys5JflPyq5Dclvyv5r5I/lPypRHeoGUo6KMlUkqUkW0mOklwleUrylRQo6aikk5JCJWspKVJSrKSzki5KuipZW0k3Jd2V9FDSU0kvJb2V9FHSV0k/Jeso6a9kgJKBSgYpGaxkXSXrKVlfyQZKhigZqmRDJRsp2VjJJko2VbKZEleJp6RESamSMiXlSiqUVCqpUlKtZHMlWyjZUslWSrZWso2SYUq2VbKdku2V7KBkRyU7KdlZyS5KdlWym5LdleyhZE8leynZW8k+SvZVMlzJCCX7KdlfyQFKDlRykJKDlRyi5FAlhyk5XMkRSo5UcpSSGiW1SuqU1CtpUNKoZKSSUUqOVnKMkmOVjFZynJLjlYxRMlbJCUrGKRmvZIKSiUomKZmsZIqSqUqmKZmuZIaSmUpmKZmtpEnJiUpOUnKyklOUnKrkNCVzlJyuZK6SeUrmKzlDyQIlC5UsUnKmksVKlihZqmSZkuVKzlKyQsnZSs5RslKJ/ta8/o67/ka6/v64/rb3hUr0N6n19571t5T1d4r1N4D193X1t2v1d2H1N1f190z1t0L1dzj1Ny719yP1txn1dw/1NwX19/r0t/D0d+b0N9z099H0t8f0d730N7P096j0t570d5T0N4r093/0t3XuV6K/CaO/t6K/ZaK/E6K/waG/b6G/HaG/y6C/eaC/J6D36tf74Os95vX+7XpvdL3vuN7TW++Xrfei1uM1vYey3p9Y7/2r99XVe9bq/WD1Xqt6H1O9R6jef1Pvbfm2Er0no97vUO8lqPfp03vg6f3l9N5tel80veeY3s9L75Wl96HSezzp/ZP03kR63x+9p47er0bvBaP3WdF7mOj9QfTeG3pfC71nhN6PQe91oPcR0O/o6/ff9bvlepCp34nW7xvrd3n1e7L6HVT9fqd+d1K/l6jf+dPv0+l31fR7YPodK/3+kn43SL93o99p0e+L6Hcx9HsO+h0C/Xy+fvZdP1eun7PWzzDr53D1c6n6OU393KJ+jk8/16af89LPPenngPRzMfo5Ef3chH6OQN9X1/eZ9X1XfR9S35fT96n0fRt9H0MPlPU6t1731eugel1Qr5PpdSO9jqLXFfQ8W8879TxMz0v0OL3D6qGPo58z1uEYpzn4tPjX+FvH6+dy9XOq+rlN/Ryjfq5PP+emn/vSz0Hp54L0czL6uRH9HIV+rkDfZ9f3nfV9WH1fUt+n0/et9H0cfV9Dr/PrdW+9DqzXRfU6oV43G6BkoJJBSgYr0fNQPS/T8xT97PsQJUOVbKhkIyUbK9lEyaZKNlOiJ0uekhIlpUrKlJQrqVBSqaRKSbWSzZVsoWRLJVsp2VrJNs7q+cu2SrZTsr2SHZTsqGQnJTsr2UXJrkp2U7K7kj2U7KlkLyV7K9lHyb5KhisZoWQ/JfsrOUDJgUoOUnKwkkOUHKrkMCWHKzlCyZFKjlJSo6RWSZ2SeiUNShqVjFQySsnRTutwCzi+wv/f7f1te53wnyt2hOmuCoh7PSDuPf//qi6TmjY4Xrfi5jDE/zV9h61Kl7589WwYV+LHXXDVOrf1eb/DITCuLCBuy4C4rQPitg2I2z4gbveAuD0D4oYHxO0XEHdQQNwhAXG1AXH1AXEjA+KODog7ISBufEDclIC4aQFxpwTEnRYQtzAg7syAuKUBccsD4lYFxF0QEHdpQNzlAXFXB8RdGxB3a0Dc7QFxdwXE3RMQ91BA3CMBcf8JiHsiIO5pP+7uR6b/dtEr9x8L417y4+6pemS3l68o6g7j3vfjnhx+7vMHdJlcDOM+CIj7MCDuo4C4jwPiPgmI+zQg7rOAuM8D4r4IiPsyIO6rgLivA+K+CYj7NiDuu4C47wPifgiI+zEg7ueAuF8D4n4LiNPjSh2oPjXLj9v+v6/vfOOS04bAuIKA6zYMiNs4ANMNuG7vgLh9/bjHlz31rytPr6mHcSMCrts/4LoDA647JCDusADMIwKuOyrgutqA6xoC4kYGYB4dcN2xAdcdF3Dd2IC4cQGYEwKumxRw3ZSA66YHxM0MwJwdcN2JAdedHHDdaQFxpwdgzgu47oyA6xYGXLc4IG5pAObygOtWBFx3TsB15wXEnR+AeWHAdRcHXHdpwHVPBFyXnxX/us4Bcb0C4gYGxA0NiPMC4qoD4rYNiNs1IG7fgLiDA+JqAuKODog7ISBuakDc9IC4kwPi5gfELQ2IOzcg7pKAuGsC4m4JiLsnIO6hgLjHA+KeC4h7LSDuvYC4zwLibsqJH3dXQNwDAXGPBcQ9ExD3SkDcOwFxnwTEfRMQ90tAXEZu/Lj8gLjOAXG9AuIGBsQNDojbKCCuNCBui4C47QPidg+IGxEQd2hAXF1A3LEBceMD4qYHxJ0cEDc/IG5pQNwyP+6Q/zy6ck7VmBEwbnlA3HlxMIv8/9cOXP0/3/9tFtH0eqvuHof5v930gpcPcLnxq9ya0nynZWDW/y98gymAX2Lws2TwXd8NnIuaWuI7KN9C/3cGsKW5xsTBhdaL/bg8P94c+6edfIQnUe9QJ267dSX07wDKpsP2Tbx5V9S41Q0VFZUGfwdm/Nraisqahqpyg78jM35pXUVDY2llicHfiRm/pryssbG8tMbg78yMX+65DeUllY0Gfxdm/Opat7yiqqrO4O/KjO81VpXWV9fUGvzduO1T2+DW1XvVpr3v7uObPHQwee/BnLcfqjNQfo7Tks8clH8B0pW7f8tA+UF9oH0Mdxjb7dnUWtdiIg5yDI7LJM6ZfCisHRixdmTE2okRa2dGrF0YsXZlxDLtWratlbn5KG/mtlNm8PcSwS+tMvh7i+CXxHh8nyYnFpqxvdKqitKSqoqSkvoGt6a+orKxurTSLa0tL62uq/Xc0vKSqvrKmlLXbShtqCtz6yuqy+sbaqrLSxtra6orDPa+JHZpQ62CKq+pqKr1GmsqGt3assqq0prGysr6mvrqsobKcrfeq6vw6kpUn1BVU15eU1de7XmNDdXljVUx7OEidnFj/f8IEfzS2PhlPxn9Y3OW/UXwS2L98wEi+F6s3R4oY58Gg3+Qj++0HdvDJwz2wUB3xv0HY/iHyODHfOdQGfxY2zqsKW3btwoG+/AmAb/xmvGPkMD35+o6HAnwMwTwj5LBj/lOjQx+zHdqZewfmzfVieB7sXlxvY/vAGyvqrSkpLJUv1dUVe96ZfV1JVWq560tc+vcmrqShuoyr7qxrKSstK6+rraqrKrGa3Qba+qqG6tWoxvsBhHdS2NjnUZCdzedANrVyCYJvymNjRdGpa67lwjdYB+dOnaiEBsnHBMfu81uY7CPJbBLakrr3OpGtV5RVVOp1ltUl+mqg9qqhsaKkppaNdgrqfc8r6FM/SlpqC+rrq2v8GorGipLymtVdjGbjG5qrk/GdhQbtx4H8BntHtP/eICfIYA/RsQ+zfhjZewT4/kTfHwJ7HEyto/x2HgZ28fa7AQZ/BiXTZTBj/VRk2TsH5vTTpbRP4Y/RQa/2uBPlcGPrQ1Pk8GPzd2my+DHuHmGDH69wZ8pgu/F7DML4PP5f0mMm2eL4JfG8Jtk8GP8fKIIflkM/yQZ/Bj/nyyDH+P/U2TwY/x/qgx+bG3kNBH88ti4c44IfkXMf06XwY/NQefK4Mfm6PNk8GP+P18GP+b/Z8jgx/x/gQx+bPyzUAY/Nj5ZJIMfG5+cKYMf6x8Xy+DHxg9LZPBj44elMvgx/lwmgx/jz+Ui+JWx8cNZMvgx/lwhgx/jz7Nl8GP8eY4Mfow/V8rgx/jzXBn8GL+dJ4Mf47dVMvgxfjtfBj/GPxf4+E7bsUvxCYN9YfrYZfiEfj9dPx9X32U1HvVcIeM40TXP7GU1FyW2jmXyzgbnGeeA9RkoP8dp/YwOzL8A6co85/UyUH5GH2wf+IyOjsshdC0m4nAd5hD55BD5FBNxeFyZDtZZjFhnMGItY8TiLOMSRqxFjFhLGbEWMGLNYsTitD1nG1oRUaw5jFicPsFpe07/mseIxdm2OX1iLiMWJ0evZMSKav9oxuuyYyu3opDI2wQTlwvyhmMqHDLRb6i3Hqse06UZF6czoZPT/Bzq+KnH1+01ZkLDeCfgAh3MA5P4fNSMl4Hi8pIog+MkNuysJAyLB/BQt0KECa/NILCoB+SxM0ObZ8XRAWKYusID4WH+bzet4JUmUw6Yf1iTCIokqEmEsU+ujH1KMhA+1CeXsA/2YVx3GU5zQ84GWDB9LigjTA+PzfXw3Fv+/2KndTsyDzJmEHGZxDljX637K6hssG6wn8rUQ5mXrJ+a/AscyXbT7KeUX1CdWb7Tup45XyJIpl4pbssn4gyWeakH+ilMnwfKCNPDY3M9PPeF/7/Yae3T2E/zifLAc9BPP/KP8+OUZ5j/200rVFZS/RRuB9BOnA+VJdsOTP4FjqTfNbcDqp4oPjG2KyB0LSbi8KJPAZFPAZFPMRGHB6LpYC1jxJrLiDWfEWtFRLEWMWItZcRawIg1ixFrMSMWp99H0V5B/WCqWDpw+urZjFgLGbE4fZWzjHMYsaLatlcxYs1mxDI3JvE40+A7TvNYCff3w/zfblph9dwN5mfKAc/B/AuQrrz6NI+VKLtSY1pjn44y9onp05HQpyNhH1OXnYg4g2XWWuCcAabvCMoI08Njcz08V+lXWDHC1AHPGToR5YHn4JzBTCzxuNTg6RBGPcD8jN7wHMy/wJFsN26gX1DtP99pXc+cL9omU69QX1OXhUScwVrL/w39FKbvBMoI08Njcz08tyPyU+jT2E8LifLAc9BPt0F+CusG+6lIPXiNSfupyb/AkWw3zX5K+UVHwo75Tut6ZrSPm0y9Qn1NXa5FxBkss5EY9FOYvhCUEaaHx+Z6eG4E8lPo0/iFsrWI8sBz0E/39HHz45RnmP/bTSuUl1F1yYdf6RUS5cTtDNqaz69Lk25nJv8Cp7VfSLSzIqRPPD8wtismdC0m4rCPFBP5FBP5FBNxeF6TDtZ8RqxZjFhzGbEWM2LNYcRaxIi1hBGL0yfmMWKdxoi1ggmL4ud09DqLSS8dzmbE4mzbqxixOLmQsz0uZcTirMfzGbE4fYLT9lxt22EuI6dPLGPEiipPcOr1dxgzrenT2s/2nO3xDEYszjKeG1G9OMcTnGXE9wfg3DLD/5/vtG57jPPshgyUnykHPAfzL0C68urTPM+m7FpE2NXYrjOhazERh+fZnYl8OhP5FBNxuM9IB2s+I9YsRizOMi5ixFrKiHU2Ixan7VcxYq2px9SwzmfE4vSJeYxYyxixOPlrBSMWp+05fZXT9lHlL05f5fSvJYxYnPXI6V+cbYjTv85ixJrDiMVZxqiO5TjLyDmeiGo9RnUsdy4jVlTHOZxjzDXjif+NNsTJE5x6cfmXPsbrqunodQ6TXjpw2p5zDGD6Wvy8m8HXQXYNrSTpZ2zxGprIM1gJ1tCoZ+vyndZ+yGgfL5l6hvqauuxCxBmsrv5v+EwYTN8ZlBGmh8fmenhuZ98oxQhTB/xMWBeiPPCcsa9+JmzbDi3LBusG+6lkPcD8jN7wHMy/wJFsN26gX1Br6PlO63pmtI+bTL1CfU1ddiXiDNba/m/opzB9F1BGmB4em+vhuf2Rn0Kfxn7alSgPPAf9dG/kp7BusJ/K1EPyz4Kb/AscyXbT7KeUX1D9VL7Tup4Z7eMmU69QX1OXaxNxBqub/xv6KUzfFZQRpofH5np4rg75KfRp7KdrE+WB56CfHu7/KHLit89UeZoaj2EbwutwexCpb6/BTbY9mPwLHMn22dweuiZpV2OftUXsU9+YjP9AfU1ddiPiDFZ3/zdsDzD92qCMMD08NtfDcxNQe4BtB7eHbkR54DnYHo5HvA3rBvupSD24bmOyfmryL3AkebLZTym/oPq/fKd1PTPq05BMvUJ9TV12J+IMVg//N/RTmL4bKCNMD4/N9fDcSchPoU/jd3i6E+WB56CfzvB/5McpzzD/t5tWaPCouuTDr3HzCVvz4ZdU5xP1xYdfW2Xwe8rgVxj8XiL4VbH67S2CXx6zTx8Z/HqD31fGf2L69xPBLy01+OuI4DfE9O8vgl8Wwx8ggl8ba78DRfCrY/4/SMY+sfodLILfWG7w15WxT0z/9WT0j/H/BgCfcy3C4A8VwXdLjT2GOM0hkyiTyd+MRdYH6TPi/DdYOM7kVYCwpMZ9VNmg/njeNwToA20QD2tIilj5RJxEnW4QUG6Yf2GArrgcOuC9MdpqEx3mMWKdyoh1FhMWNbZNR68mRr26MelFjX/TwerBiJXJhKUD/gBZOnr1ZNJLH/eKKFZvRqw+jFh9GbH6MWKtw4jVnwlLB/xhmHT0GsCo1/ImPr0GMumljwcxYnH1Hfp4MCPWuoxY6zFh6YDXTqOCdZSPJbveVVYtu95VWiO73lVWL7veVV4qu95VVim73lVWZ8bqpj80eUDfgv0b37yiLOl3xEz+BUhXXn2a53d9kT7YPqZdGtv1I3QtJuJwG+1H5NOPyKeYiMPP+KWDtZIRaw4j1mJGrEWMWPMYsWYxYi1hxJrPiLUiolicvrqAEYvL9lS/HRVf5WyPZzNiRbU9nsOIxdmGomr7hYxYnDzB2ddycjSn7TntFVX/4hybcNYjp+3/DjyxiglLH+M5bDp6ncyoVw8mvTixdDixiU+vnox6cdleh9MYsTh9Aq+lp4OVyYSlA5dP6HAqI9ZJjFic/sWpF5evRpkLOzHqxemrnPXIyatRtRenr+K11ai0bU7+Op8Ri3P8dQYjFueaAueYnHOuwLn2aMb3Zh27N4jL8P/L3gNw23wPoLeMPoH3AHoTdqWeh2XUpz6Zeob6mrpch4gzWOZePny2H6bvB8oI08Njcz08t9SvuGKEqQN+tn8dojzwnLGvfrZ/QWbLssG6wX4qUw/JfxvS5F/giLYbL8gv+hJ2pPzCXFtMxOExfbL1RdU9fvYtHaxljFhzGbHmM2KtiCjWIkaspYxYCxixZjFiLWfE4mxDnPW4khFrDiPW2YxYnG2b07842xAnr/4dbL+EEYuTow0XUu9RMY4/XOo9J0b82DsH/QNsAfPHz+KYeOq/wcJxJq8ChMVcNi+obEFzNzgOx8/2Ulj9U8Si3o2TqNN1AsoN85d9F7C8RPZdwPIK2XcByxqNzw8E9sxAthssUpdVSe+lYvIvQLpKtanBSB9sHzwfWpfQtZiIw8/urUvksy6RTzERh/vtdLBWMmLNYcRazIi1iBFrHiPWLEas5YxYZzFicdo+qr56NiPWfEYsTv/i5JxljFh/B9svYcTiLOOKiGJxtu0FjFhcttfH+LncqPhqVMcAnFhr+u01/bYtfceafntNv72m3/7ftH1UffUcRixOe3FyDqftFzJicbYhzn47qhwd1fEEZxk5x76c9chp+78DT6xiwspwWj+fkw7WOoxYXOvk+rg/E5YO+NnjdPTqxKjXyUx66XAaI9apTFj6eIDDh/W/bnt9jN+dSAerByNWTyYsHTjtNYhJL05f1YGzDUXV76Naxv91LuTUS4c1fYf9fYcOpzBh6WPOZx647KWPezHqdRKjXlx9rQ6c/SOnvaLYd+hwPiMW55zvDEYszns6nOsAnOsTnM/n4PfbBoO4DP8/tV+8zmeY/9tNL9RnoPxMOeA5mH8B0pVZHy/IroMJu1L73TPqU5eB8KE+6xH2MXW5ARFnsMw+mfD9Nph+PVBGmB4em+vhua+zVv8vRpg64PfbqL3S4TljX/1+26dZLcsG6wb7qUw9lCT9fpvJv8ARbTdekF9Q7Z/yC3MtVV+430+2viisRYxYKxix5jJiLWPEWsmINZ8R66yI6jWPEWsWI9YqRqzZjFjnM2Jx2mspIxZnezybEYvT7zm5kLMez2DE4uQcTp9YwojFafs5EdVrOSMWp09wjk04+23Oeowqf3H6F2d7jCpHc2Jx+tcCRixjezNfgfObDP+/8DfgyjJQfqYc8BzMvwDpyqtP81yPsut6hF1T+b6Y0dUcwziYT9jf8dJhGSPWXEas+YxYKyKKtYgRaykj1gJGrFmMWFzfRtJhDiMWZ3s8mxGL07847bWYEYvTvzjbECevcvoEJ69GtW1ztkfONrSSEYuzPf4d/GsJIxbnGMD0tUV+HBxvw/1IYBzMJ2jMD6836QqJ6zL8/7Lf8K1Oer8Ok38BYROJMf+QJO1qbDeU0LWYiMPPrgwl8hlK5FNMxOG+KR2slYxYcxixFjNiLWLEmseINYsRazkj1lmMWJy2j6qvns2INZ8Ri9O/ODlnGSPW38H2SxixOMu4IqJYnG17ASMWl+31Md6vIyq+GtUxACdWVPttTttzjgE4OZpzPBFVX13Tb7dfn7ZmTJ4a1poxefv515pxYfv5VxTHhTpw2iuqvnoOIxanvTg5h9P2CxmxONsQZ98RVY6Oap/GWUbOsS9nPXLa/u/AE6uYsDKc1s84paPXiYx6rcOklz7uxIjFeX+I0169GPU6rYkP61QmLH08wOHD4vIJHU5u4sPisj1n2+Zuj1xtSB/3Z8LSgbM9/h38C+83lA5WD0asnkxYOnDaaxCTXpxcqAMnR0fV76Naxv/1vpZTLx3WjE3s7zt0OIUJSx9zjsm57KWPOcfkJzHqxdXX6sDZP3LaK4p9hw7nM2JxrimcwYjFed+Kc52Jc/2L8/lCvN9QJxCX4f/Pd1pznc5nmP/bTSt4Se83ZPIvcFr3VXz6ND/nu7bT2q6dCLsa23UjdC0m4vDcuBuRTzcin2IiDt/zTQdrGSPWXEas+YxYKyKKtYgRaykj1gJGrFmMWMsZsTjbEGc9rmTEmsOIdTYjFmfb5vQvTr0465FTL06e4PQJznpcwojFyfeGV83YCo8Jhvm/3bRCebkZm8CxjBlT5Tv02IQnb68qA+XnOPS4zuRfgHTl1ad5XEfVG7QPHtd1J3QtJuJwHXYn8ulO5FNMxOG2mQ7WmYxYnHotY8LSx7kODxZ3GWcxYi1hxFrBiLWAEYvTXmczYp3HiLWcEWs+Ixan7RcxYs1jxOIs4ypGrNmMWGadD48tdBjm/1fdYWlVRWlJVUVJSX2DW1NfUdlYXVrpltaWl1bX1XpuaXlJVX1lTanrNpQ21JW59RXV5fUNNdXlpY21NdWVsmOH8up8h+5fefA9z+D3kMEvMfg9ZfBLDX4vGfwyg7+ODH65we8vg19h8AfI4FcZfJm9D7yY/w+Vwa8x+BvK4Ncb/I1k8BsM/sYy+I0GfxMR/BLX4G8qgx/jt81k8GP85srgx/jNk8GP8VuJDH6M30pl8GP8ViaDH+vfy2XwY/xZIYMf489KGfwYf1bJ4Mf4s1oGP8afm8vgx/hzCxH80hh/bimDH+PPrWTwY/y5tQx+jD+3kcGP8c8wGfwY/2wrgx/jh+1k8GP8sL0Mfq3B30EGv87g7yiDH+O3nWTwY/y2swx+jN92EcEvi/HPrjL4Mf7ZTQY/xj+7y+DHxm97yODHxm97yuDH+HMvGfwYf+4tgx8bv+0jgx/j531l8GP8PFwGP8bPI2TwY/y8nwx+jJ/3l8GP8fMBMvgxfj5QBL88Nv48SAY/xv8Hy+DH+P8QGfwY/x8qgx/j/8Nk8GP8f7gMfoz/j5DBj/H/kTL4Mf4/ymkOzdilDbXqVkJ5TUVVrddYU9Ho1pZVVpXWNFZW1tfUV5c1VJa79V5dhVdX4jVWVdWUl9fUlVd7XmNDdXljVUz3GhI7ndC87l8rYRevMcYLdQA/g03/qhh+vUi9NuM3iNinvlF/O3Kyf7Pe7GHcCPLKRnYb6f8238XUYUxTc5pGEA/T31Ww+r/Ob7qfXyEojwPy0cGUO0vErl51BsrPcehnYUz+BUhXXn2an4XJQvpg++BnYbIJXYtRnA743mg2kU82kQ+FdT4j1ixGrOWMWPMZsZYyYs1jxFrEiMVZxgWMWFH1rzmMWGcxYp3NiMXpX5z2WsyIxelfnG1oGSMWp09w8qp5Zi7fad0X8vXNFZ7pa2uc1sHEwfFrBoqrA+n3bWpOh0Mm+g3LlKdkYZdmXJwO6wPHTbUAP96YQQdjxxwQzznGMfj5MvilxvZ5Tkub4jLlx7GViaf+GywcZ/IqcFrbXWJ8SJUN6o/bSx7QB9ogHlZeilj5RJxEneYElBvmXxigK1UOPL+h+Igaf5v0+QF6wfRFRN7mWmPDAhDHaMOSIBvCtmjy7wT0rG+onThyjzEjHRQykR2M3XqidPs1NdsB+2BeHCwH/e6JzmUCPBhk54zt2w+YMqXaD0Db1qK4tvKeDpgbsM110HX9ClpbyCTKhH0o3tpCJoiH6d/Mbc7vDf+4I8izU0CehUhvmF6H/Zpapl8LlC2TSNMJ6WjSv+frpevvfL/+KNsZffLR9f9LvmzKlKovw3rEuhlM4zu4buPVy1egXi7q0qwzzq8woBzm91FEfkb3YpRWB1PHncF5xjWupL/XZfIvQLoy90OxMUxnpA+2j+EWbcOO/vHoMTX129eMHT9xdEMHZMoicAzhixGcSQPTwlAMVHLipMPVrsMBTa2vw8GYsshp3ayLUV4QP5M4h6m3mNDNuLmxTTe/r9W09TtafsVurEO+09q2jK5Ql6xrmvwLHEk6bHbNIqRPPNsb+wg1ldoMp3WzyCTyNPqauuxMxBksn91aUCRMD9sLTA+PzfXwXIHvW8VO6+Z9WFNLHaimD88Z+2o/zfJxi4jyrIXKRtVbEYFbTFyPbQjb8XFNLeOyibKZuJyAuLyAuHyiXCauAFw3Bl3XkcDUOtTkNePFsw30KzN8obgpHrfGwxqOsOD1nRFWlwRYRyAseH0XhNU1AdaeCAte3xVhrZ0AazzCgtfj7ce6JcCagLDg9d0QVvcEWBMRFrweb8/ZIwHWZIQFr8dbhvVMgDUFYcHr8facvRJgTUVY8Hq8ZVjvBFjTEBa8vjfC6pMAazrCgtf3QVh9E2DNQFjw+r4Iq18CrAMRFrzeXFtIYOFxgMxrZ8mPA0z+BUhXqXHAOk5ru0L74Nuw/Qldi4k4zFv9iXz6E/lQWF0ZsdZmxOrGiNWdEasHI1ZPRqxejFi9GbH6MGJh3krUX9c2rf4f1F+b66DvwnSZIA3VR0OMeOMBOGeD5/slUR54DtumX5z84ukHbWPmm0HjjyJ0HaVzcYJ8gnQ26agx89imlnFwiR2Pb+FyMB6Hw6XyzigunygXHjPDesVjZmg3OGbORuWp98/LLse5LvS/eLbC6xLUf8dJbrmWWnKXzqdDSPng8qzFmA/EMsue7bfE5zYkUw6Yv/QSn7FF1wBbyGwnVZb0cifetrSrkC2MLyaat+FbitTcjOpL4PLoyIYJ6ibddlP3qxmZC5JCWsXqFKJ0ndHvLnHUGobS4Z3MzPAP6wGxYMB6BC2/UvlTNGKOs4nzOlDTWrwMm+qOL/D67gH5dE0zn65EPrK7pzQ/uSGzu0nzXX5qKQGWyeSPd4Iz8dR/g4XjTF4FTus6kqABqmxB9QynGMksufRMEUt2R5zmOu0RUG6Yf2GArlQ54N1iyHO5/thQD+sW57XEprhC9umx0opk/dHkH9aT5sk+6UIN1c21xShOh1OamtPhuEziXIcArGWMWOcwYi1lxJrHiDWLEYuzjJz1yFnGuYxYnGVcwoi1nBFrMSPWfEassxmxFjFicfoEZ3vkbEOcPsFprwWMWCsYsThtfwYjFqftz2LE4rQXJxfOYcTitFdUuZDTXpyc83cYM3H6BGe/zWV7fYx3HI+K33PafiEjFqffc5aRkyc4xwCc9lrFiJXM29jUvN6kp95godal/i5vsJSjdObxuHTeYClH5zId+g0Wjf0KejwXv/2ig+x6bGlJBsoPl9FB+RcgXZnrP7ZmRT0eRq17Gtv1JnQtJuIGgWMYB/PpTeRTTMThfjsdrCWMWMsZsRYzYs1nxDqbEWsRIxanTyxlxJrFiMXpE5z2WsCIxWmvMxixOO11DiMWp6/OY8T6O9TjWYxYnPbi7IfmMGJx2iuq/RCnvTj5ntO/ODmHsz1y+gTnmInL9voYr8FExe85bb+QEYvT7znLyMkTUR1/rWLEOt/Hol4lwq8wUHPYXgH5wOt7JYFFzYdNeurVo6C1HurVI7P2IPQKTklQfVCvL7VlrcfYzUPp8FoP5LY+cbAc9NtD5+Kt9eDnlqb5C1myX1qjHzXHzyvCZ0aLUflSfdUWXl8UkE/XNPPpSuQja8vUd9EoRnF1IA6/4lAPsOAuKDhkot+wvLpdXJrCDhuwPmrjYGYTaTNQnEl7Rn6zHjf6esg+dxhenZhXnZOtE1NebYtb0qwT6kvIRm/qdelkXuOmXsMvJq7vHJDP4DTzGUzkU0hclxHnv8kHn8P5UDoHrbe3NR+IZdqw7Np96v6P7Qz9Hz+bC3e5xrvoNYA4eB8IB6ptGFvotvFTEm1D9n5TeDbEr7xBG8K2jQNlQ2OLZG1Y5LS2IW7bRUQ5qHYPMdrS7ikdotZPdEVxsI7XRnGwjruhOFjH+H5VI4jLQHEjQVwOihsF4vBOiEeDuAIUdwyIg3WNQ6L+bL2uzbg4nYPyhH6TTH9GbaFicGVfKSstTYb3Yf4FSFdefZrvg1KvCFM7dxrbdSN0LUZxOpzU1JwOx2US5zoEYC1ixFrBiDWXEWsZI9ZKRqz5jFhnRVSveYxYsxixVjFizWbEOp8Ri9NeSxmxONvj2YxYnH7PyYWc9XgGIxZnPXLyF6e9ljNizWHE4rQXZxviHE9w2msxI9YaXm0/XuWyvT7G90Gj4vectl/IiMXp95xl5OSJBYxYUR2vNjFimfGquQ7O8eE9S+F9DGJf5uwtgx/bJyHoXi7MH8/pTTz132DhOPzcdjeZsgU+tx3kB3BtPJktQnuliNWe+5lAW+P9TChdqXKszWiTZL6AQq0tpVq3QVu2Crex2DMFawfYCeafzvsjJSiduU/YwWlddz3jYDnodwk6F++ZgiKndZ3mx9HT5IvPYV+B12cH5FOQZj4FSeZTnGY+xUnm0zXNfLommc+a+mmZT3vWj+FhuGeRuW+r77nUFdB5wi314V5N+JkJk34l+BpuY0H8Mmai8kOeMFsRyn6BK/X7ZNiWdUR5Mggs6h6TKVOqX4qB7+hB3SBmvC/F5IB4mH58QbMuB/WhMTMAJnxX0TxXZtKbNpvjNJcbpsE6mPSTgQ7mK0IYMytOufLiYC4AvjitgMZ0CEyqXAWoXFiHfKSDST8LlOtQsNc6TGN+Qz85oamlbh2JvJw45zCndYwTF5Rvomv1MfyKEI7DvoLtBa+PZ1PsKyb9nABfgfkZTFheXK9YB5ymII4O8wkd4LaVdWPGTvW/6uOggD9Olo1+46rEVZBD4MQLxgz6mgUFNA5MZwJ2P9gV5xF5FMTREV6rzWOqt75hdMOEhjgG6oDAsuNk1sGhg+zXPmX6Der5Csi9OFB9iimvvu6IPs24OJ0J8J3sNeOqto2rMBY1XtJhj6bmeJj+csAjx/WhMTvEwTyiqWV6qk+jnk0y6ak5Y9CYG/ojnqdTeUNbYt7tlqKuidYb8pGu1Fw0WV2Hh6xrdoq6FhB5w75HkevRkxrG7TVmQmwXbYdQw0HHuN/BaXB/kRdH1U4oXRH6jbdVxvTeBf3uSOhHBawzpUumkziYJmpsdTtoomPjNFHHoZuocXs8/YLXwumXcYmxRDqT5wmoPDA9zNOkHwfyoYY4Y1G5Tfp/EkOcYkIno08+up63260sNTYc77QOJm6C07LsMG4iSL9PU3M6HKiu1ZRJ22JWCtM1WI9YN4MJuwxYt/Hq5T+gXvCHPWF+Jzjxy2F+ZxL5YVuaeB1MHU9EGMP8325aobwmA+XnOA65zG/yL3Ba21ZimX8i0gfbh6LhgA97jgfHEP5gBGfSwLQwHAxUcuKko6q9G3EdDsaU2Ujnz8Cs+nlEW7Dp4+8RQx0yiXN4tJVF6E/lk5NmPjlJ5mNzefBT2DrgD0COJMqKn8LWAX+s8WgQhz8AeQxRLhN3bADm6ADM4wLijg+IG0PEaZ1GdWrWEXcvVFM3XSdVd/HadTws/FFJeP1EhDUpAdYRCAtePwlhTU6AhT8qCa+fjLCmJMDCH5WE109BWFMTYE1AWPD6qQhrWgIs/FFJeP00hDU9ARb+qCS8fjrCmpEAC39UEl4/A2HNTICFPyoJr5+JsGYlwMIflYTXz0JYsxNg4Y9KwutnI6ymBFj4o5Lw+iaEdWICLPxRSXj9iQjrpARYtQgLXn8Swjo5ARb+MBq8/mSEdUoAlj7Gb0TD609BWKcmwOqBsOD15tpCAivD/2+Gk6eB83zDNy/pt1xM/gVIV159moeTpzmt7Qrtg99ymUPoWkzEwb4IxsF85hD5UFjjGbEmMmJNYsSazIg1hRFrKiPWNEas6YxYMxixZjJizWLEms2I1cSIdSIj1kmMWCczYuG+LGhcr4/xW8DUuN5cB/kML3dlomtgeogRb96Q6dDzgVOTKA88h21zapz84ukHbWOeJEt3nqKP10FYbZ2n6OP+CCudeUpdU0usts5T9PEApFdb5yn6eAjCaus8RR8PRVjpzFNmNrXESmeeMhphtXWeoo83dFpitXWeoo83Qlhtnafo440RVlvnKfp4E4QFr8fcflICrE0RFrw+lXmKPt4MYaUzT3ERVtA85bQEWB7CgtefhrDmJMAqQVjw+jkI6/QEWKUIC15/OsKamwCrDGHB6+cirHkJsMoRFrx+HsKanwCrAmHB6+cjrDMSYFUiLHj9GQhrQQCWDvs3tcSC1y9AWAsTYO2NsOD1CxHWIie4jFVOSyx4/SKEdWYCrGqEBa8/E2EtToC1OcKC1y9GWEsSYG2BsOD1SxDW0gRYWyIseP1ShLUsAdZWCAtevwxhLU+AtTXCgtcvR1hnBWDp0NDUEgtefxbCWpEAawTCgtevQFhnO8Fl3MZpiQWvPxthnZMAaxjCgtefg7BWBmDpsFdTSyx4/UqEdW4CvbZFesHrz0VY5yXA2g5hwevPQ1irEmBtj7Dg9asQ1vkJsHZAWPD68xHWBQmwdkRY8PoLENaFCbB2Qljw+gsR1kUJsHZGWPD6ixDWxQFYOpinuYqI6y9GWJck0GsXpBe8/hKEdWkCrF0RFrz+UoR1WQKs3RAWvP4yhHV5AqzdERa8/nKEdUUCrD0QFrz+CoR1ZQKsPREWvP5KhHVVAqy9EBa8/iqEdXUCrL0RFrz+aoR1TQKsfRAWvP4ahHVtAqx9ERa8/lqEdV0CrOEIC15/HcK6PgHWCIQFr78eYd2QAGs/hAWvvwFh3ZgAa3+EBa+/EWHdlADrAIQFr78JYd2cAOtAhAWvvxlh3ZIA6yCEBa+/BWHdmgDrYIQFr78VYd2WAOsQhAWvvw1h3Z4A61CEBa831xYSWBn+f3Of6w5wnu++UpmXgfIz5YDnYP4FSFdefZrvc93htLYrtA++z3UnoWsxEYfXHO8k8rmTyIfCmsSINZkRawoj1lRGrGmMWNMZsWYwYs1kxJrFiDWbEauJEetERqyTGLFOZsQ6hRHrNEasOYxYpzNizWXEmseINZ8R6wxGrAWMWAsZsRYxYp3JiLWYEWsJI9ZSRqxljFjLGbHOYsRawYh1NiPWOYxYKxmxzmXEOo8RaxUj1vmMWBcwYl3IiHURI9bFjFiXMGJdyoh1GSPW5YxYVzBiXcmIdRUj1tWMWNcwYl3LiHUdI9b1jFg3MGLdyIh1EyPWzYxYtzBi3cqIhdccEz0nd5h/HPScnLkOrjvhVzMz0TUwPcSI9xxepkM/X3d7EuWB57Btbo+TXzz9oG0O94/Tfe5PHx+BsNJ57u9IhAWvT/W5v24Ii3rur4i4Dj8nOiEgHx2CnhOdEJDP7WnmczuRD/We4timlnEjndZlpb4Wg999hF+LGY/ijiHKhd9ThG0Ev6cIfRC/pwh9Cr+nCH0Ev6cI6xy+p2jexzU2OtY/n4/KZtruMP+3m2boAnDj2RHWW0ac/47T+t6EDtg/gr4YJJVPh5DyweUZz5gPxDLbHFDtF2/fkWr7hddPiINltjbQAX7pcRSIh+ln+r6sscejrTaoZ9Th1qX7BZTVXGvaCO7fhvm/3fSCZ/CnyOCXBvWPsEyYU6DtUvEvmFcBwuK2XVDZoP7YD2F/ncw4YnKKWPlEnESdTgooN9WHULpS5YjXNmE+QbsgTwnQC6YPGj8ZG8IxDKMNS4JsSI3B2rILsrFbH5TO8E4Hp7UPTo6D5aDffdC5TCd4F2RYp/lx9DT5JuJxeD0eh01AelH/TT74HM6H0tnkA/ezgLvSnov2ZjB+B7fMge9R4V1pTfrhXZoxz/cxqfe84rWVDJAf3AsDbqME84u31dKoOPpdAvo9vKPlKKLM3QN0NphwvxGos9n3A+twJRpHCvWR5DjS5FWE9MX1g8tC1Qn2u3GEHeLZVgc4ToHjGJj++hTHKdC/8TgF6mSupeb8eDdGKp+gfrKAyCfd8QGVD6UznrvpANv5naidG3+APg+vNfshZKP0w0A7vyegnePnh/CYBnMfbucmv3jtHPuNSX9/QDunxswHNMXX2WDCdg51xu3cpH8EtXOhcQ3Zzk1eVD+G23mq/RjF41Q+HdPMpyORj3R/2RHlM4kxH4iF92GK116fQ+3V1CvVXnG/DdN3BO31RdReob8H1SfuOyYR+eI24zjJrVEGvZuMOUqHoL7DpH8zoO8ImgPoEDTHDVoThulgmqB108yAPKA/wfNmzAr7tFEo7WSUdlJA2njzOX1c4x/Lzrkrq01bgGu/Jpi4aYTOJg6+k13f1JwOh0z0G5ZJ+8qkJHZ0puaG0+JgYpvqgHd/N2XuQOBOQbiQA7C9DmtqGWfS/uG3Bd3+v+tE42E/0eFoH092XllZg+sXBly/2D44UPVr9Nb1e1kK9QvrcDqKg5yN9/iDfaTB0LbP8zONaltqS3u5LM32QtkT34uA9jQY0J7ZCGOjwuY0BYUtdTJpcH+hg2k/ps0a+2UR1+uAx34m/Vp+nto+3/Sh8w9qb45D8wK0A95rdJpD60KV2aQdgvwRtjE+fyyL7eQ/A+kM854plHcy4zWYfyGhj9G7gIjLSkPXcq+ysqSirL68sbaiqry8IQPhG13xObx2SO3VUUSkN7aeLWLr0nrT1DKbmvFnAbvqkAXiZqK4bBBndNRt6Ps+LfWfJaR/MvaH+RcT6fGu9snWZTGRD56rpYM1qY1YXZyWbYDqC+HYBveFcPxi+FXz8s5xeDkZrjPchnkflhPz4A6I62D/x+hDZdR4FHPdDKG8k+U6k3+hE79uC4i4dLiuvrzMK2usLq+tbyxtqK9szHBa9wmZxDnMdZTfrkWkF+YKl+I6zGdZIG4GioNcZ3SkuE6mXyx1k7E/zL+YSI+5Ltm6LCbywVyXDtakNmIZroPjIDxOhVyHx6lTiPJArsPzst0QJ8l80oFeI8ScCvXVob6pOW4KsBO2L8aB5+C4GV6D12xM+uFg3L53Ia2fKcNhhH7Us0uwXPsVxk83hUinp8pmHDWyYcKIUTXjGupHNNSNa5iQ6dDq4SLi4uPplIPS6YC/XHYc+o2Xb/A9VdMFJ/vlMvMfYlFVB7Fx13sQmPL8iShsFMprmP/fTTNQU0fc1crcXitJelph8i9wWrucxGMd1NImtA/uHmVuS5S4+sNN+JaBDoc3tbYN1sP4C3XrDtoPt4VkblOOJPKhPr+QEee/yQefw/lQOpvfQVQbjxqnAGo8urA5PeaaZB7ZSuZWPDwH09ehOHiLLiMAHy+3jAF8cShaQoJDKlOO2MdJQRxne9Z6dOjbrAf2Wzhci9fOqM+FmPRBj5L9ZY+m1f+DHi2ifAv6kvERqp6D2pTErX8qn8I08ykk8pFuu4Uon3i36k6J0ybj3arbBMTD9L93bsacg+ozHnf9Va6m5riQ2kxJqm2G4qmgNpPo1Q1jQ+oW68imlnGUv2O76rB7U0sdRhI6UP1pMXG9SZfMOAXqx1dHXtLjFJN/WOOUUUna1dhngox93CDfnEDYBz8agOsOcjds+9T0h7rdB/sJPF28yG/sQY8UBLUd6hb8X4//oWmR9DgIty34+tSmAMt8Hkn6sQ/Il7g+GH2/zJR7SkC5cf5a4G0g6nFbnB7PeTA+fkXKXA8//E75FvbH28CY9IZCGtNxgsek2CY5Dt1f4tveJv0txDiSqmN42/A21K9CW+JHjSYTdvjrUbok+nvqNj7u7+8H/f09SC+Kf6hxFR7DpzquovLBWMk+ImjSPwjqBX9wOdFn0ZJ5NB7a1uhD2SbeYximbehgeAa3nXh+CdvGnqj8Jv1joPzno6+HwvYX73GgeK80ZjrB/pWBBC/d6TCpqXX+1G0RLcP8326aAXNZFshjGmEPfPvmedTezPJtJlFWyq7TiXzhErCxSTZK/zyox559W2Ia3To6rdsZVSf4sXTcFsY1tYw36V8FPPsy6qvjPdL/diGdd4FD+2G8dgJ1he1wVlPLeJP+TWCvPnHmBlAfSleqjcKPsKfaRo9Aupr07we00SBfosZ0+FEeqo1ivTPQ+WT9wqT/HPjFpwFjOOgXvyJb40cKdQjiBzx2GOb/dtMMuC5hO6X4Etfl96hcpv1mEmWl6nQakS+8hYv5YRrKl+IH+Eqf0aMe5BvPj7MJnXXAbc6k/zmgzY0iykz5AdXHBr3SAV+ZptLjspj0fyS57mfGA7JrGB657gfbTnZTy3JTnwmmxlbYTk4cO5mxS7GTmJPhY1zUfMlsx4/vzXT174//9cjcWi3LGrQmIXQ7sjoD5WdsA8/B/MNak0i1bicQ+pv1Hyo91caoNQ89JcBruMUAy+SbB85NQeeodQq8HhVvbtNjrZZ6U2tg0O/MXA7nqcPuTXSeEBfmSa1dY55M9VPd1O1q2XWlyirq8ScT8OO50M+ox3PxK8nw8QQ4r8eBenQX+s46gPdwOqwrrA+jd1j3EjjXpai5dTHSOdVXlai2Kb1mVYzymUzkI7xNQtI8bvIvcFpzgASPB41loF2D+uhJAempLYWo7Q4gjxudoK/A1xIchG3OUXyIx66p8iG8fhyKo8aLie59bbkWrU+8NSPzGXd8j3sZWAvbBvUH1HpX0H3Ottom6D4RzKdzmvl0JvKh5vTpcgalM8WBuDypciC8PiwO7Izyieef+yL/bOtrzxOBf+4X4J9BfhP0iiX23VTrYFSS+YT1CvD/Wnn+l9vIMUxtpA60keNQG6HugQa9YttWOyebz/9CfU5mzIeaDybymxnIb+C6TzJ+Y9LvDvxmdhJ+Q9km3vZMMN+w/C0IK2hsSd0bCxq7UmNdan6F55wGQwfZV2KSfwbF5F+AdOXVp3meQH3Geyphu05O8xy5pmG8V1K1Q0PduKljJ+DKMIDFTksjT0OAJr2DfuPrtFJZKM0EIg8djINjR8KTWzwRwfjJ6JQobaJ4qhFOjVNOx0muEcLr4zXCeHtI4HdnTfplPhElu4cEdJ5U9pCIRyCZRBkKHJpI4E0bqgOHOlFlNunPDSjz5ARlHo7KHG+PNvgbp6Nu2OQ5rX0AYlA27uK01D1Vf4LXh9W5d0H5xOt0r0CdbqJ9YRpAPExfBTrdq1Gnm+y+MHjvl1TtTOUjbWe8/9fkgPKkurcltZdkUD01gDTxbghmEZg64JdxTPq7/LoU3g+SfK/M5EW9YwVfFriHyYc3BD78T+TD1EP0lA/jekrVh5PNJ15byXDa3lbCKk8QFtUeMpDOML3VA1qvwU2Gg2D+1g9o38poaeRkB7T4uqABLU6LydA4UroDWkqneGlTHdDCFSs8oE31Thh1d1D2znxJq6fh4ZNMsDHhFbeJoAzUQC3eXcGMOPiYKOELxZTt8BPKJv1rYDD7in+3k6qrrnH0c5zk6gpeH9abSV1RPhJ3DXTAbxYk8o1NkF7xBrEfoQEAtekwHADASRxM/2pxM+anaACQ7BPUyazYY190nOTu9AS1g2T9Gtsoi8DUId6mwzn+W+yyb0WXu+13N7o86U4ZbxZAPelZQMSltdFTZaPnVlRUljaW1FQ1lFfgvsvois8lc6e6D5FedkWvjNzoCQ78dcgCcVNQXDaIg3e88eYnMgOmsvpk7A/zLybSx3uDhcLSoYMAVhenpd/itg35IdmPhMSekPI5I9nNtycQ5QnaFDoT/cZchrlKh2H+/0Q13JggOMhuuYQu+Kns2IIqsMvrfVuWhXrSzHBHZkAeDnEuw4lvO5wHtSB4UFPLuMlJ6EYt2EGMeE/laQxq0t0blSXVxZTehD6Sd75gnonGL/2Lmq+B7TPena8ZTc3xMP2/wfhlkI9JvfEdb1Kf4dBjB8wp8OlvakEY84BJvwHw90QfTYDlxDpCzGQ/mmDSb4zGL0JPtJELWiavsHYjwVhZTvNbCZAfD25qaSuT/gffVrqeS4pSwzwkDuaRALM8RcxD42DuAzCrAvx+badlfqm8kY+vx2/6yrx13/yBqmNk8GMfMzqasAUsk8k/6Gn/ZDgT5hXW0/hU2YLqGX54ELclCuvoFLHyiTiJOg3aGQHmXxigK1UOPK6g8lmbsIlJf2yAXjC9acPQ9821xobwg46MNiwJqm/4gUmTf1s+UGXs1gOlwx+ogrY/Jg6Wg373QOcynZZv5pnw1y5Q/riB6pc6xdHZ6JCoX4LXY/+X4czKCurtEROot0egjjhkot9Qb13fx3RpxsXpIAb243gf/aU4Nx4GtfaZqN3rABfvTTsdP2HMuIZ9xh09qWZCw46TGo6fQPhvntOyfNjvjkO/j0Fp8U5DJg7fnD0a/T4e/R5D6IMDtgkMhUS6eCFR+1gPHLelfcDrg9YV+6WZTz8inyCs9QisIP7uR6T/u/D3YJTOzO3S4e/B6Fw8/sa6wPkT3FQXr3mb9Cei+ZDMmKS6tNBpzWmmLCbvY4XyzkD5OQ49LjX5FxL6GL0LiLh01nNLqko9r0rdCm5wy9yaejeojcFzuE2OJtJvQKQ3tj5extbkZtajgV11yAJxx6K4bBBndKTWc2V4ozop+8P8i4n0eL0k2bqksIa3Ecus50LuNW1btq2nPv7CbxMH7aIE71vAtWccqHGbKa/2p0uTGLcF7XwgOy8Pz4bQV3GgbGjKm6oNoa9hG8q05fBsCNsoDpQNTXm1DW9JwYbQ1/AaNuQm/BHnqNg3A8XB+1D7NjWnwyGRDRemYENqHTzTaW2nkQQWnoccRehjyjnGaak/rD8d8H0teP0YhDUuARZ+WBpen8wbbRDrCIQV9PzCpARYeyKsoDdlJifAGo+wgnbgmZIAawLCCtr9bGoCrIkIK95ua1qmJcCajLDg9Xg3tekJsKYgLHj9dIQ1IwHWVIQFr5+BsGYmwJqGsKgPhFBrHXCMU0icM21d9mMnXsofAaPmCxJr3JTdqXGhsd0sQtdiIg722zAO5jOLyIfCGsWINZERazQj1hhGrHGMWBMYsSYxYk1mxJrCiDWVEWsaI9Z0RqwZjFjHMGKZdWRqHfRYlE+q66Dw+mTWQSkO7eQ03zP4a918+5qx4yeObnBQgONWkwf8fXyc/IuJ650ALHhNUFmCdk02PB9v12T8TIdJ/zl4puNQtEYjc1+3sox6qcsEE4f7BxgHx61m3kHNV6B/4EDNSUx5tS2OSOJjttS9BegTfVEZjkf543PY1+H1Jh2VT7808+lH5BOE1ZfAMumpOUXQvQXqOTLh3ddj9xaoOR41L2nLvQVjtz4oHb63QM31MJaDfvdB5xLdWzC6xHsBGN9bMOl7+L6dT+jKVx9VpUHvLcg+p16V9L0F/JF56vnOAiIunXsLjVUlbl1pY4NbXlpbW+fWB7WxVHeSGEikl32mroq8twDXwXTIAnGTUFw2iIO7XOJ7CzK8UeUmY3+YP/V1DtxvJ1uXnFjm3gLkXtO2Zdt6dO8twGcSUlkXh/0l3oQA2nAwOIZxRh98Dtf7YELXQuK6jDj/TT74HM6H0jnRTuJDipuvgX4Fn3+G105vao6H6W8Hzz9vFPDMBp6jY1+FvqEDbifwS2nJ9IcmvevrRD3/TL1bMb0pvs4mj2Tf3zLpy1GfLNMv0s8/m7zC2m1RtoyVldT7AyZQfIOfoYVrDPjZA7hmMBrFwTUAvK6H5/QwDq6JHo/iqLU1EzcbxOF3UptAHPRRHCjOhJuyrNe1GRenc1Ce1O7weE4I7Us9h7QuOIZxRld8DvsbvP6YONdhHhF+5skTbtOx54qpd7ZgmfBYl1qnT6Z/gXmFtY5OlS3oWQ24zoDXkSmsiSli5RNxEnU6OqDcFCdQulLlwOuCVDtbl7CJST8pQC+YntpsKOz1AMqGXOsBxm4boXT4WXHogxPjYDno90boXLz1AIpHR8XR0+SbiEeTfccEjhcbiuk8k33f36RfBcaLo8AxXpODWI1Oy7hGEDfePxZ+vqqEWu9wkO3Gg7zxHGgCUZ5k+2z4DNWsNj5DBXWDmLD+TgBp4q09TwLj6YP60JgZDj2HwGN64xPJvtNo0k8LGNObNFlxynV0HMwzgS/OjOPrDoFJletYVC6swzFIB5P+RFCuQ8GCIeZf6EM6nNDUUrfRRF5OnHO4zxkdJy4o30TX6uOx4BjHYV/B9tJi7k/Fsyn2FZN+XoCvUO9yBD1TinXAaY6No8NCQgfdH3X04+vGjJ0a53ZWFjjG9ExVJa6CUQROvGDMoIt3ZjGNY34HuR/1+Cu89tg4OsJr4R5X9Q2jGybEu9/XAYGNjJNZB4cOsu9FVdRQz+CbQD1HiPsN2JYbUdxxIA5yLw5UnwLfp0r2vtnk3NXHYY1Jkhlr6LBHU3M8TH8JaHf4K6bHAD0oTPjFQtywgtZGTPpE8zWTv7ElNe4Pypt6rtGkn5SirtS9BjiGHo10DdokM5Guw0PW9ZgUdaWeY4Bcrcjo6EkN4/YaM6EBNg+shoOO89E5nAY/5npsHFU7oXR4GRlvMYL7B/ya33GEflTAOlO6ZDqJA96v+BbQRMfGaaKOE/w4BfWYMRxaNqCpBXULJcgdk9mWg/pYvA542xCT/p4Aakr2Q3MmPfW4LFwCxUvAsBngbZ/gbT64pKtDFohjnMrXaxvgjzhCG2Q3JV9eyj7UI8DU9ozFKD20FXWrBS+Dwi4M7pU7BPlf0MdpqbIFPUIE9wHPJDAObGqOh+mfDPA/6jFnar9Zk556lBkul+MlYWhfcy3lf/CVCh2yQByj/zVQ/gdtgP0vqLyUfajHhOEtA/wRUXjLYBqKg/5i8qT4D37g1Wx1RN3GzYjz3+iKzwXd2j6sqWU+Uh83MbfZMF9SQzl9vIl/bIb60Pact99w+4FLEDMIffDHyj9Gyw6zgH0oXt/EaZl+JpEvvMU0EuU7E+Wr20FP1A7geAIuB36KdJ0OsPGye1CZc8D+318gnqSGmXhrzK+B7m/1jX897gPhWA1vARBvqzVof1hO6JuYb036H4Ge76IPd0LOg8vnOmSBOEZfbUy1z6X6hKA+N1GfgPtV2D7w9IeaSkGbx5v+5BDpIR4ei2b4vgiX36jp6RSk+7gUdU92DBvb/tVpvd1uUH1QeswAWFR62H5h+gLCJhgTtgVYx9PiYBYCzPEpYjbEwSwGmHg8Q/W/1L7qmHdhetgnG32o16lmoTioO+53Z4L8cZ02NrXMn3r9yyHydQL0xX12In0x55q4DQBn9/GP853W/Y3ELVOqLtcnypNsXU4MKD/Ggv0r9leqDc0k7DWoM42ZnSLmesDfTb9HjZXGNjXnvQHKm+IQyFeYmyYSesGxADW/wbcBjW6bEO213eYAXoNL9YfQjrg/pOZpQd/RSDQHxXMAmP74ppZxQd8KoZbHku1v4Baj9yTxLRaTZ9B6hT7ujtKbckOOhz5TC+Jh+q0COJ6yL/XYR5Dvw3kp3jYU1hWcd/11fVNzHNxmQYcsECftr0HjN8o+U9KwD/ZXar5P+St+XZDLX69A/kpxEFWXuP0k206xnXLipMdjIJN+3yTGVVCHoFcFkl1foPq4mQ6dN2yb0Cb4A6Am/YFR4nPX86j2Ae2K20eQDXVIdYyI122o10mp9jEDxVFrtcnwrg5BbcdcCz8CG/TB1lTbK9aRmi9TXG/SjwrgeqrvDeL6RG0avwIAucNc235zddqXoQ2S4fqg+U46XI/nwtSjwIm4+5gA/4u3/gJ1HRVQtkT3RjA3JntvpD3rPsx7I/HGpdhW0CYQi+IGat0Ej7faOt7UAX9LN9F4E69NmvRzUhxvBvmh1ePNNvhh1MabFAfBdcJ9AzgIP9pC+V/Q+IyDgzIJvWBfTL0GqsMw/7+bZgi6pyP8ndLyDJSfsQc8B/MvIOzIqI8XVK/UGoDs55zcMk1T1P24w5ta2yYe72AON/fSdNgT4ODH06hPzen2dClaa6LGgfBakwceB14N1s6uQJjU62rJjn/h64RbJjF3DKrzoPHKNJAPlR72TTD9DQHzQ4org9aeEt2LwZ/Po+7P47yp5w2ovtSkvy1S88MSr73v+eM+K2juCH0Qb0VE9UWwXeA2QI25YHul5hcZcf6bPPE5fO8+3ivesKzw3j30ZcMLUbh3D/XB/v044ibq3v00Agf7S7x79/hezEyUL3XvHj6zA7n5yTj3AWCbnpBEmd8G3Py0f5zMpzshv+A1DWqsDv0Brz+Z9C8kyS9Gr6jN2ZP99nOynB50fx1vjZbom+B43gbHw3iOT83btH/cWZhY/2nEtbh95MRJD9ctYfr3A/pReO+N4uhN42B+Avz+I8SbsB7NfRud7pvOPHl/HjAnpdYkgx6lnk2kp7aqK3Ja91HmWlxuXFffIF6g+kBskwKH5t5JTS11pe6TZoD4eO1qJlFGbMMcJ/jefzZK/3PAsyNT4+gZTz9qGwzqNUJ47+HJJPjX5Bn0aUgdsJ9QYwxquxdq7ow/HRs+F5eUpHpvN6i8lH2Snd9T/oC39aS4OGgNjdomn5rvQC4+xa8MfE++0H81jXouh3rOnVpza/W5VYCZzDp+kB8mu1ZJraNMC7iOWkeBeQ3z/yf+MG1yn6017TaX0CXe/cKewI7ms7XUukJLfdMLQXOBfIfmXZ68S5L+HLjJv4CwpcSaT7LjNNn5itcI13yg/8I1n3hbhsN7Wpjv4DxhEHpdluIAyHMbg3iYfkiXZsz14mA6Tnr3/5/r1BKX+x5Y0P0J/DwgNY4Neh7Q6JDo2Ud8r9SkdwE3vAv6ub/K0tR8vdFL9tmUxna/947vrwdtfU35H/SFeO/b5DjB8y68nrcFqCM8Pgy6/z8pRd2pz9Ljdo7bjmnn1PhtYhJ5pnP/vzuIh+l3DHHcsOb+f+v0bb3/D/0l2fv/d/rcTb23kcznT6j1zqA+C/p3DxAP0x8Y4H9ReT/T2EnY/0ra+xkEU7/JvJ8ZdO+X2rZa+9+5vv9J2rGyyo2NaU0dwm0nYcgC8TD90b5PFoBymP9pbVlcWeM1ltY01pTX1NeX1dXgbSR1MHWmX4PX/lDfpdlmxk7cNtPB4GfL4MfeK4D7o2QSZTL5G1/C245Q/x2HnrOYvAoQFnPZvKCyQf3x/ZospI85joeVlSJWfpy4YTzljtVpZkC5cf7x0lNtwJzPCcCH6Q2vQx/OQbbIlbFFSVC95YA8Tf5t2SbP/O6L0uFt86G9s+NgOeh3X3Qu06G3ycO8VOi0Lre5RphTSpLlAZN/gSPaHmI8kI30idd24XYno8fU1Ps7L2HKw1UHzQnhcLFx1cW6RXQOuwPewckM9aguFOuZQWBQJjCYRU5LHeC1FJVkxsnXcZrdFdNHIixznBmgSzyMDIRRGICxpumsaTpEWNN0kms63KPxkqqqiuqSWressr6usb6sNNFonDv/utqK2rKG2roKr6yitMytT2U2gEcbcNadSdgvG6W/MuAOVIcATB3wTksm/TUBM3lqVESVMxkagPoUOa39Cs8gwvKnypqq2uq66rKasgq3zq2saEt9UuWGtjcfGDXpzcgyxwmeTWWj9HcSq6QYE86aZzS1xsQ6w/qBI3b8sQaT/l6gwwdo1QPaAXeJcDTN2AXVZaD8HIfuEk3+BY5oF+3h+jD6YPvgO2FCM5zaDIQP9ckl7GPqMo+IM1hmJQhyDUyfC8oI08Njcz089x/ft4oRpg5m96QMIi6TOGfsq3V/GA3dYN1kxPlvcPE5PIOHtsEcBvkT3jl8Kg5/QHvCaw1/4Lb4Drhz+Cy6S0H5Pub1DCfxOAHmF4+vcH9l0r8EuAJvLoz7K1hOrCPML4vIVwfMVyb962glTqjdkx+XMXlR/V2GQ9vDcZJbhaL6x0IiH2Ovjk7wSksQTwSteJk2lxMnvcHLRuk/DOjL8sA1mYReeCxj0n8SMJbJJ8pFtWtzvoBIn0+Uq8hpzX/mWuquhLG98A5WddRdCWjD7KbE9slNwz7GB4pRemgrikNzUT6Jppb4Li61igY5F47fioj8cTmp9pBDlDOoPVDlw7773xTHdvBDXLlxdEh2bBfz3a7NOnwcMLaDfVlm12BdMd/AuQ9MX9C1GTPHPzb1Q62CUjyYieJgXRobQR7MIXCp9ox9gmorMD0eaxvfz4mTHo6nYPpiUB/YJwrANdT4Eo8ZTPquABNzZEendbngPAbboRORvqPT2g5FTmsO6OTQecPyQDvjD+yZ9L2I8lC8C+8o6JAF4hh5l9ytF9oV826QDXXANi8k0kNbmvIVo/Qt/Mpp3XY6ojiYbx7SIdHcBnMyNd6A3EEtr0IbGD3zifLy1V2dl4HyM+WD52D+BU5rn5eYSybrI8Y+hTL2cYN8sJCwj9FnLRF93NhHlouJvI2u/oP/LXgFpi8ENoTp4bG5Hp7bHHwcUJ8vAtcZ/GIUpwOex8K4TOJch3bCKiawoN1Mnep2vBmyBd75nvpvcPE5rCOsT+PzQRzR1nwglhnfUO1JyzD/t5tWKI19NGstohwmb+hXfG2nvDJZrjP5FziibdkL8mFoHzzXLSZ0LXZa+/CJTc3pEvk3zIfCOjuiWPMZsZYwYi1nxOK01yJGrKWMWAsYsWYxYnGWcRkjFqdecxmxONsjZz3OY8TibEMrGLE465HTV1cyYnH611mMWOcxYnH6fVQ5h7OMqxixZjNinc+IxWkvzrEJp39FdVzI6fdRHcvNYcRazIj1dxjLRdXvOccma/q01LCiOpaLKhdyjuU4uZCzHjntFdXxVxMjVlTHX2cwYnG2bc42xGkvzn6Isw1F1fac/MW5LhfVtSFO/+Ic+3L61/9636GP8T0rjr6DutcLn1HMJ/TgvN9r8LsI4RtbdQ6wFcwf3/s18dR/g4XjTF4FCIu5bF5Q2YLuEcP74dAG8bA6p4iVT8RJ1GlxQLlh/oUBulLlKGS0STYjFn62jXpmg7qvatJ3IdJTflJE5G2uNXXbFcQx1m1JUN1CjjD5t+XtbWO3A1C6I5qa7YDbRuc4WA76fQA6lwnwYChyWvtaXhw9Tb74HPYVeH0h0sP8Ns+8wGdg8Vesw392oaI0WW79X3l24eSm5nTp9uXnMmJxrp1zjoejus7AWUbOe7hRvZ8S1bWnMxmx/g4+seZeQ/vZntNenGt1nGXkXGeI6r1SzrUnTr9fyIgV1XV4Tp9YM/763+Bozr72NEasvwMXRvVe1umMWOcwYkV1vZuzT+Mc5/wd7i3/He7rc7YhTntxcvSavuN/o+9Y8xxE+/lEVPuOqK4pcJaR812BqM6HOG3P+ZxzVNcLOcc5a3ii/cYTa3ii/WwfVZ5IZvwF9/Hbz09v7oFT+ywYrM4JsIYjLHh9Z4TVJQHWEQiLev6hkMDK8P+H8WwEzM+UA56D+RcgXZn1id0j7+q0tiu0D75HvjahazERB+se/qaeYTihqWUeXdG1OuQTefDZo7Q22fox+Rc4ov4Sq5+1kT7YPrh+uhG6FqM4HU5pak6H4zKJcx0CsOYwYi1ixFrMiDWfEWseI9YsRqyzGbGWMWJxlnEuIxZnGZcwYi1nxDqHEYvTvzjbI6d/cXIhp15LGbE4/f7v4BMLGbE4/WsFIxZnGTltfwYjFqffn8WItYYn/jd4grOM5zFicY4nomr7VYxYa9pQalinMWKtaUPtZ3vOuTvnHNmsceI1JB2G+f/dtEJpeSGRb4bTMt/u4Hx7rC2a/AuQrsz6xNauuiN94tWZsV0PQtdiIm5tZFf++nRL8okyMGHH3pvtwY9dZmwJvwcBvw8wuluzHbVQ3z6D+8J3APEw/RPdmjHH+Mf4W2GO07oNdADn+XyuxE22DZj8C5CuUm2gA9IH2we3gUxC12IUp8NJTc3pcFwmcS4IaxEj1gpGrLmMWMsYsVYyYs1nxDoronrNY8SaxYg1J6J6nc2Ixen3nHpx2n4xIxZnPXLa/gxGLM4yrmLEms2IdT4jFqe9ljJiRbVtc/YdZjxBfbPPfIuC+i5VR5Qf9c08HYS/h+oZ/DwZ/Nh+Kom+i2byD/o2LP5vsHCcySusb7dSZaO+3VqM0mMbxMPKTRFL+BuxsToN+q4TzL8wQFeqHPgbeal+VzovQC+YvojI21xrbAi/Uchow5IgG1LfemvLXjTGbv1ROvOMXAentQ/mxsFy0O/+6FwmwIMh6Pvc1PdHTb7wu3s9QTzex6YnyCuTOIfbC7y+Zxwsaq1Bhz2amuNh+mf99QXqG3m9CP2CfLc3kb4XSGP0oWzTO4nrdCgk8jI6Gb/vA85zcwfMz+gLz8H8C5CuUhzeB+mD7YN9ti+hazERh9tRXyKfvkQ+FFYvpAP0rZDqr6St9ddLRp/A+utF2DXV+sNruX1FyuHVG736Oa2DiVsH5I19oT+Ig20Fh0z0G5ZJ89dn4FuUOB3WB/qY0a3IaV3fMF08TqTqqpi43qTLd1rbhLE+GrFdHaL8A8C5C5qa9cCBsrnRW9v8zxRsDu06AMXBeh+I4qDfDkJx/UDcYP+4yInvcxkozpQRn8P1CK9fJyCf3mnm05vIp5C4LiPOf5MPPofzCWqPvRjzgXbrjfLpzZgPtFtflE9fxnygL/ZD+cCxPrwvVNS9+Rp4HRyrwWvN+xbZKP2OfZoxu/iYhksGAL34uKTEM2Ub6LQOJm4QyBv77GAQh/1sXRCHfWM9EAdtjgPFTwP8Y81PA/o14+J0uBywH8I8EzReERrfJT1eMfmHNV4JGufrEDReMddS7cncsy0i7Ir5m9KBGvO2lYdkx0zJ163JP6y5RN8k7UqN6/oim8M4c6+/yInvE0E6BM0zKO433Gna/fb+ZFNzZ0n3lmnM+1NV3ZvTlHVvWU6Y/3FNDmkDHfCesQOIOI3/do9mnSHfZIEyw2/Cm/f5slH64agfgHzL5x8VlZizTR4w7/WE8k62rZj8qT7E6F1AxGWloWtjXZVb6lZU1DdUlNWWlzVmIHyjKz6H107WJ9JT++kaW2/giNi6xLSXzKZm/PWBXXXIAnHrobhsEGd01P3w931a6r++kP7J2B/mX0ykPwKUIZW6pLCGM2FBPuDAym0jVhenZXuCnCPLQSVlFAeZQLX5IhQHfa4YxcH2BNeUcaDGm6a82s+rUxhvwnGz0VuWS0sqsC0cQi9oi/6E/kG2WA/Y4t4UbAF9ZgMUB31tiH8syyMlldgWDqHzEJA39rWhIA772oYgLlVfM+VN1degP0G9IWYWODcYYBzZtPp/Nkp/AhgvjUHjpYEgD5O3TvcDSrcBoXc+oWd7rOOb/AscyT63eew9BOmD7YPH3kMJXYuJOPytjaFEPkOJfCgszFMydVRSXUjo5aDyw3aE1xY2AnGw3nCg2pgpU6pryrCNGd2KCB1gOlzHQfVO9eMmnakPWG7G+qgzZdzYaR1M3CbgXKprykbvVNeUoV03QXHQNzdFcdCnN0Nx0K9c/7jICfYrGGfKiM/heoTXbxSQz5A08xlC5FNIXJcR57/JB5/D+VC2CeL5tuYD7TYE5TOEMR9ot6Eon6GM+UBf3BDlA8dpcE35ErSmbK6Da8rwWrymbNK7YF3kcrSWANtBe3EJ5bObgjjsZ5uBOOwbLoiDNseB4idji1TXlOH4FJYJ6p7suMukvxXVk9A4ye2CykXZdM34TX78Buc/mHtSHb8Zf4za+A2vybfH+A221aDxG0yH6ziZ8Ru8fs34rTluzfiNzmfN+K1t+URh/AbXUOH47cMkxm/UmjQev/UD47dP0LhAaG3MyvEbXDcb0MZ1M8xPA0EctcaVgfKON86raVr9H6+v/QrW137uHl+vgSDvWT1aplszPrNrfc3U5Zr1tdb6wPYWND6D6XAdJzM+g9evGZ81x60Zn9H5rBmftS2fKK+vbYyez2nr+loBGJ9t5mOuWV9rGaAtwlxfw+Muk34rVE/tub42mCi/7DNAyY/fTP4FSFdmfTxcn0YfbB88fhtC6EpxD15fo8aJQ4h8KCy8vhaV5xPw+hpsn7DecEg0l0pl/EY9x1FE6IDrYzDSJ169FxPX42eTYLkZ66MGj20covxwLJDq+M3oner4DdoV8zz0zY1RXKrjviIn2K9gnCkjPofrEV4/NCCf9dPMZ30iH+lxyGCUz2DGfKDd1kf5rM+YD7WOHfZ4dCC4Do7fxqDxm7kOjt/gtXj8ZtL/1KMZcxwaF0CeaS8uoXx2YxCH/QyOkbBvUOO+ZPnJ2CLV8dtAEIf5KdEal6kHOO7kq4fS2LtPntM6mLgSkDf8Xg8OlM2M3tpm09ZpxsXpcJ6wfZegOOiTpSgOttcyFAfruxzFQb6vQHGQ0ypRHJzfVKE46L/VKA767+YoDvrvFigO+u+WKA7OW7byj43/eCCO0X9KsI/AYOJKQd64rZaBuHVRXDmIg/WKA+V3prza797u34yL02FdYTszeuu9Pcx7WyMbJuzeMPWAmtFH19dMOHrM8cMbTpjYMH5CFoLFXR1+pWT9OOpCHCdAXR06oDgXxZtXcTo4dCgkrjN5GLeBTb89pl8m/wJHkgabp18lSB9sHzz9KiV0LSbi8OOQpUQ+pUQ+FJbxlSICuxvKJ9XXJ7oROkeNQrqhOEgh0D9wSEQTbX0M1uhWROiA691F+sTzL+oxWJPO1AcsN2N9lGP6dYjyV4BzqU7zjN6pTvOgXXEXDX0Td9GQw3AXDf3KdNFFTrBfwThTRnwO1yO8viwgHy/NfDwin0Liuow4/00++BzOh7JNUH/S1nyg3TyUj8eYD7QbHm6WMOYDfREPXQeC6+A07yk0zTNji2SneSb9+2Ca9yyaXsgsa6bGJZTPVoI47GdVIA77RjWIgzbHgeInY4t0pnmYn+Cr1WObWsbBV8gHoesGgDiDD1+tNunglnx4axBqGyATB7eWGQDwM/21VOxDHwIf+h75JRzjBo01THrqdeB1ifJSy6d4CVpmmSJa/mviNgdxqS5rwyWMDQc04+J0JlD1TC1VDwTnzPaFVLsYDHANr+HlqF+Aj+X2bJn3hkTe0O+wj1G3ueGUHfsYdZtb+FZmLbV0bgK1XICXwjYBcXh6DZcL8FIYXC7AS5uw34U2wSHRbc5kfQzXM3V7KlkfGwJwxyAfM7p1Arese6O8N06QN/axTYj0sL6M3Yuc1n5krs0nrmP0sfpCQlcTKF/By5Sp+go1Lsd+C/tlaBMcKB8zdkrFx3onwSWwT8I+Rj06Dx+jwD7WH/jYJkn4GMw7VR8z/ewaH2sZF7aPbZKEj8ExEfYx6vVa+Cg19rES4GPDkvCxoPHYGh5rjouyjw0T4jH8uqWZK8TbrgnPM036w339ZLfta96uaaDT2lYm70FCeWeg/ByHXr/G8zmoj9G7gIiT2K5pENIVn8N8QI3zg7ZrkpmD0ds1wXGuDlkgbhCKywZxcP6Dt2uSWQNp3q4pyP4w/2IiPd6uKdm6lMSCfMCBldtGLLNd00Bw/QD/mNq+tgvKJ9Xta+H1Jl3UtijFj106qIwwQL11u6gf0IyL0+E8qbWrfKd1fTDaogSXl7IFbMt42yLIU8UoDo6/8FoZ7DdzwDEOlH2NLbR9Rw9oxsXpcDkGgDj8mJ8MX6W+BVmq22fB9dV727i+irdBhL4fztpgSTm2hUPoDH0G+yF8HAX7IVxzwX4IH0dJ1Q9h/5eKH1Jrr5g/4SPoAwGG2eKhyGldH3jLW2oNmVrfo7a8NemofHqnmU9vIh887l0I5mJn+Md4/R/aUqfr2atluvC3Hk3+WQyTf4Ej2a6an8Wgnl2g6ohqa+Za6jFO/CojdR+CWouhsExdUvcosG9T4+mgR7x7EflEbetE/MpkvFcOcKC4CW6r+FkbH/82ulEcANO1hQPg9SZdlF5h1SHVZzHga6p/tvE1h3jbAejjdB/Hp+7LpPsqS9ArGjCf9dLMh9qOspC4LiPOf5MPPhf0ag5+hHJdxnyg3eJtQ82RD7WFMcVL6eYT9Gg/nP/BZzEeQmtv5jr4LAa8Fq+RmfQl4DMX/0LrZTKvvKX+Ojz2Wfg4M/Yz6l4EXqvFNseB4ie4vfaANm61C8sEdU80Xs1G6Z9H9SQ0HiNfmcQ2XTNOlB8nwjkl5h7OcSKem6Q6TuxN5BO1cSJ+NXPNOHHNOHHNOLH19WvGicnnE+VxYn6v5mvgdamOE/uDcWInH1N4/dfKcSJcU05lnAjvX2B+gmt2Jh1cs8P9dbzxJN6Cw6Tv16sZs0+v+Hr1BXlftGa9EAer1gtNXa5Zx2utD2xvQeMzmA7XcTLjM3j9mvFZc9ya8Rmdz5rxWdvyicL4DM6b4fhs7yTGZ/DaeOOzTmB8NhyNz9as4zWnaY91PDzuMumPQvXUnut4A4nyyz63kPz4DX9OcqCMPh6uT6MPtg8ev61H6EpxD17HS+eTglF9Bgevr8H2CesNh0RzqVTGb9DO+H0EqAOuj4FIn3j1Tj0zaNJFaSs6HVIdv8Ht5v5s43bB8bZVhH1FW8d9RU6wX8E4U0Z8DtcjvH79gHwGp5kP9eyS9DhkIMpnIGM+0G6DUT6DGfOh1rHDHo/C96bh+G0JGr+Z6+D4DV6Lx28m/S+9mzGXo3GBzLsDqW9riX2W2kqdGvdh36DGfcnyk7FFquM3ONfG/JRojcvUAxx3MtZDg9FjU6d1MHHwfaFUtz4zeqe69Rls33hbceiTLoqD7RW/Tw7rG79PTu1lQ40jbNtOzfgPfB+M0X8asY/AYOLgO2W4rcJ3yvB7QvCdMlivOFB+Z8qb6tZnsJ0Zvduw9dlA9HsQ+j04jrrpbH22CYpPduuzTYg8jNvApt8e0y+Tf4EjSYPN06/NkD7YPnj65RK6Utv2QJqHcTCfoC2wIBbeiRdi463PUn2tpxuhc9QoBG99BikE+gcOiWgilWketDn+sgXUAdf7JkifeP5VTFxv0kVpKzodUp3mwe3mUpnmQbviLhr6Ju6iIYfhLpraTq3ICfYrGGfKiM/heoTXewH5bJpmPpsS+RQS12XE+W/ywedwPpRtgvqTtuYD7Ya/PLMpYz7Qbni4uRljPtAX8dA13jTvWzTNG+inSXaaZ9J/CKZ5P6DpBeSZ9uISymfhFnvYz+DOuNg34HZU0OY4UPxkbJHONA/zExzX4a3P4NZkA9B1cGsyOD3EW5MZ/J7+eeF6jW1BMcBpbRPZV19L65NpezB/ako5wD+mlvXT2XagpKG2rqKmprG0rtGtq2lswG3W6IrPdQD5axlEpO9KpBfeurDG+D3cdgBO03TIAnEDUVw2iINL6njbAZllptKaZOwP8y8m0u8HypBKXVJLlfj1/mSxzOv9A8D1+JVYPAfVQZYHkp/HmfwLkK7M+sTmcdS8J4uwa2GAXYuJOPwY1AAinwFEPhSW4f2obZuAH4OC3ALrDQeqLx3gH6czvzK6FRE64PlVFtInXr1T8yuTTnjpuxTb1SHKD28tpDq/gsvUqcyvoF3xrQ74Gi6+PTEAxOFl+oEgDj/OBu0L84Zxpoz4HK5HeP2ggHx6pZlPLyKfQuK6jDj/TT74XNDt3SyUTxZjPtBuuN33YswH2m0AymcAYz4DQJqBKJ9486vdejdfA69LdX71HJhf7YnG4bAdtBeXUD4Lb3tgP4O3PbBvwNseA8AxDhQ/GVuk85g65qegsQ/0vfYY+5j8wxr79EL6xOsDKf4211LtCW5xg9ttqmMfvLYsMz4tcSmOcVD5YdvEjxDF66NwSLSOkMrYB/qr0Y0a++C+LNWxD7wej32E+Cqlbat0SHXsA7mlrWMf/MgAte0NxUnJjIuoR8Hw2Geg07KM+FxQHz4wIJ/eaebTm8iHmltkxPlv8sHngubLYY19cLvvzZgPtBues6/DmA/0xQEon3hjn7lo7GOuS3bsY9LfD8Y+Z6CxD1wXbS8uoXwWjouwnyX7WCm0OQ4UPxlbpDr2obZBwrpnE2l7ojiT9hxQX//wj6k+ppPTMq4niOsIjmG+0Hd6Os1hjyZaz/P9/LVN3u1LY3aIg2n8kVqnhH2aDlkgjs8P6zytdwfQ12D+yG5qWSbYnjKJ9HgtmFrLgm0Kj9mgT+IxGzVGgONFuE3yX2mamq83OraHPaGOydgTpk/VnsZGlD37IKzeBBa0cZA9jY7tYU+oI7ZnnwRlwvak7A/tZGxEvXrYD2FRcxfY3vFavMHOIdJjToLp7wacc2iflvp1AtdjX+hIYEMODWpnBUQ5ClEcvFbjju7WUv8BftyDgL+fRnlTa1pB7WEwkR7Oe0x9FSEd4LVRWjOl+vpk1zlwXw/XOfDYDT7eOQAc45BojTbZLe+fjjNWM3ngtoh9rC+hLxwD4vWsF4CPvYfypnyGeq7MpKdea4JjM+xjA0Ecfj1Z5l5n6q8b4bU06EfYx5J9zXwAiqMec0/Wx+D91mR97L04a6Emj1R8bCDA3S2Oj30MfOzHJHgsyMdS5TFoz3B4LFrPw5g4+Hm2VH2sLTz2o5CPmeek8OstvwEfy+/TMu8NiLyp+z8mPfXaPGzb2Meo1+aFX42uKiR0NYHiFXzPjvo0nImDrx/gdTL4+gFeJ9sExEGb4ED5GHxtOlkfw/VMve6arI+tB3CXIB8zuq0FXoHvi/IemiBv7GPUp2xgfRm7Fzmt/chcm09cx+hjNYWEriZQvoJfe0rVV/Azn5TfUp81StbHjJ1S8bG+SXAJ7JOwjw0m9IXbMmAfGwh8bLMkfAzmnaqPmX52jY+1jAvbxzZLwsfgmAj72DqEvnBrNuxjZcDHtlvjY38LH9tOyMfMNtHGx8xaz87Ax/ZHefcn8obrUdjHBhDp4ZqnmYcVIR3gtfnEde15DxqvMyT7bB5eu6C2C6PmsdAmOFA+ZuyUio/heu6H8oB1pQP2sSxCX41b5H+urwDla64Z5v92Uwwl9fUNXplXWV3VUFZWX11OfUrK+GJHgfzLymsq62oqPa+6zGso8xLm/9cnq7rQ9jT+bEIhcc7gmraQja4d1sZyYLNmoPwch35mxuRfgHRl1if2zEw20gfbBz8zk0PoWkzEYf6h6iTDae3/yTy/kUnkE4RFlaeT07zePX7CmHEN29eMHT9xdIODAvaVDPS7Q5z8M4jrnQAseI1Eu6orr6itU43LbfD+8sew23V5fW2VW1lSU11fV1FfWl4Xdv4NtWXVlbXVdeVuvVvtVZemwiuSz2DocELT6v+Gg2A74uQgg5+L9GPCjz1vn03YyeSdJ1K2xsZk+dXkX+CI8n2MX/OQPtg++H2mfBn7NHR2mn0PclYOYRusRy7SsUBIR+pesdHJxGWBOKOHTrPbwJY6dhDSUbaNNtZTYxT43NJ8NJ40dQOfPYF+3wHEw/RngrnIQv+4yGnZL0Ge6gjic4l489vUVwciLX4HLBfZkLIrTG98MidOWXNQWU36s/zyad3O70JjQvtBvTrEwTwHYB6H6gTe7w5q8yZ9RyI9bGNGnyKnddvsiK6DusPPdeNzVP1koLS4Dzb9FLwu3u98AieeDnkEDvWsIv7cMMyTGuvhuVQmkQ9sU7DPzyfyZ+wfyqm+0gRqrJ2B4mDZj2lqTocDNY81ZdLlndSnGRenw/pQbY1zbGTOZ4PzOF88Hs9BafF7ilDHbAYdi4l8chBuboD+GQgni7iu0KHbI/U/WX0zCH2D5sNtzQdiHdvUMh9Yz7BPuw/xJ+TxTOLamU3N8TD9w6BPezDJPg1zCSzD6Kbmc5iz8TgWt0n8vBbuu3Aa2I/D9I8RfRfmB4ilzz2exBiBGvfhMcJnwJ7/h+xJjQGKnNa2wT6cj/KC42PTv2AbvAj0eK5P/LyMXQsDyqjPvdyHTgd1gOkwBtV3GgyqXZvrigi9cNvD3JETkAfVn1F5ZKO4dOuH6rfhWIMaw1DxsD+H+eBzHYj0icYfBXGwKdwcAofi+TwUl0HEYQ6D5YUchscm1JwMciPV7uLVXdDYm9I9mXFVToDulP0gD3Gv5bhVrufWVZY3Nnr1FTW1ZYnWcsz53KaW5frrPziXDcqlQx5Mj+LyQVxWU8v8C/zfWSAfiPX/7X1rjFzJdV7d6ekhZ4bDGe6QS4q70pIQkjiy43T39Mz05IHQWJK71Eqr1eqxeu2uenp6dpmsufEuKWltyekECGzFSQT4EcVS4CQI4sA2AjsB4h+JYCcQ4CAG4gQwYAQJjARwYEOwfxiGDf0wIHiLvGf666+/qr6Xc6unh8sCBn3n1rmnTp2qOnXq1KlTRked4L8Dbe3TAnxj36+J8heo/BG6xTvsa4yrJt4ZvG/Tb+c0prDRtTZ3Ot2d3Uaztd9qbXS2JrWr4hPaDnwyXmNbLIi61Ql+4fFhnU/Sebq6KM/DnY/AZYHfuzjEu/nB6DvVRth3Dd7KXhqM02h5y5BXp3JO5f8jvxCX0VEn+LN53a1NsL/Z92ui/JNU/gjd4h333WUBvyzgffus5DRav8W6V237u1sm4cd3TJv1nRTjaqu91ex0up3eVm9/p93bnbbtvbeztb+zsbHb3NjZ6+80t2bF9o7zYOo1ouUp/SyjZ6U7LETKwe8NTtn6K+zjbSv3JNDJeo7SV1BHqblx3elEgBdZAH9Id5kP8M7WnbzWeRnk/V+ms3ixOvr0wYGuI457hOG2t/G2EKD5g0SzwbdzOpVdU62hUQ/+OOE0+G3AWcSuqfq/vZ9k14yti9iuieePuM0VboSvBfAsER6up+nRPn1uMI7bxtgK4bmS/984ZDJ8tk+NVx2tiLrWCf4a9eNV4mmMZ/7vtCjXcCBP6gR/DfrQBaLBaFt22hbBbcI2fe5XbwxG8w3+GRjPN+gMIK5v0A714cd12UtA66kIrcuCVhwzPzwYzTf4DwG/HgvQivQgrWrPzPps2vOVTXm+EuVWnWhS8kPNa2XlhzqjGNtHYPkbW6vH5piFADz3WYN/EdqZz14qe7L/fRn0aqadbd11qENsHlE2hzqU2Xtc4w3ZY18YjNbX4H8dxuB+AKfpAT59fjCEOViHuvFxUKEe0+A+gHqDsgmznLlF9bK+gm1QF3gM/qQoF21lxhO2x90SMlbtiaI+q/auXYW8LOL/kagddzIqz/iB77D8afl/KFtazP8jjX9Mo4P+H2hzfnEwzhumg/eLQvs4b9FYwDGj5Mbzg2E+wv89kBtfJPmHMov3HXhsKVoyNz5OnIuvqXhfAfPYzojwcy6+XlAyndem3H98MnnL/MB2U/4gPoXkyY9G9H5lu4/5M6h5Xq2J1H4E61SqbLXHz2WHfER4f8PgvyLmZsZZd8VktMH/eISnSreJ8fSUgFdrolU3zsdThGsST21cMq1FeWrwPx3hKerKRXhq8P8swlPFoxhPVwT8KVGvVTfOb17zTeKpxethWovy1OD/VYSnSt7GeGrwP3uEPMU6r9B3an8Q5Te+X3K6zrZGVTiXAjiV/Ar5RobaUsk0bstfirSlqtdSwXotV1Sv5ZL1MvhfTlSvWqBetZL1WppQL9b1Df4bBeql/Ah9Ynubwf+qGHtqTY92XZ/mB6P0XsnfNw6V9Joe7Yb1wWi9ldxD+LK6Aa/beYxinvKxiPWJovvvB3s1bqjTmrzC9QLrapP8lkI2198o2Aes7Fmz60zyFwjpqAivfG7XBPzrVLY6v6TaOWYHKmoPqfxMSntjd7+5v7O9u7Hf2Og0p34mp9to9dvN3d3NZr+7s7M/9TM5zWZzf6u929nqtRr7e1M/E9Te3+5u7W83Nlt77X5rrzvt8rvb/Z321kart7G/0+00OtMuf3dvq9fY2Wjudbvbje2tTpl92cyNjiefcE62ZONP6XtFzu7NRXBlEVyT5MLzhAu/t2+VvcPKTHxetJ1ReVYPR/Xm86Jpzr3Ez4sif+aId0XPi7LtpuweeJX76coeM8n2o3wWYv2Gddkr+f+Nw6XC/cbeTavfTNLHuN+o88Lq7KTd9RuTIbGzxKlxKbnH+pDiTcw2qXTVImfbU51lKdrnrPxpnW0vehac9y3wW96f84n7iZKJykZyXHChnFP+V98/GM1TMjG2roqdcWRZWmbdpeZwpJfXXX8+D6iReo+R9SosK7EesaXWb5aUjwG3O66ruW2VbcbyVFzfTNBQo/+RF77sFy8P8TKcJdVHMspbEPVQPvU812SCrtg56tjZDDVP2J2oGeF0TusqMR14kj4S25dNFHOg8F1B6GuTcDw0WWYYPSHZGPPDWXPh8ZNRHpZzQpSjcDENyENuv0T6W+G4NVb+kuBDivZT4yQTfFXrkJi+XyO+JtJRSstlXpOqM1yZwKXkq73zOH7q8hAvwzE9yq83JocyN94usbZaC3yPNMTGQKK2Kqzf8poq9RioFeSr0m95nkPZh+f8Oa+sTjrruFKegVb9F+d+9J155d2j39h3uJeA3/J9RAb/8+8e4vyb+bPynTEap7U+Taxjd9RelSXWV336F4MhHZyUzDS6y96vpvb0lY1jifJwrC5THs5XfE+R0mXvVxdROmzs/Pf9lhOLgcDnetWvlcPvYrpVEbtJFeN/Wve4sX6Q6hwT75nhdyjP/iHJM7U3it/yGReD/xrIs6/Qej2RzltKlqg+q/asLQ99M7hvoJ8M8pyTkk/Gi7L3q2GfsDqhL6Paq1V228yNy1jlW2HlqXW5fZvYF3ZHzQfMFxV/SbUht6+6Q8ny0GeMx+tpyGP/bEyq7Y1PRePS8pg0vDwm2UciEzTiWFdrAZ6DlM6m4t/G5pJY/5vkW8A+wypGCJeNMgvpZ5ll8P8+58ckfw7jU1p/jsam8udAvtaJphgPfSo75tluhrKziN1M6Uvon/EK8NtsXo6+YT3ZJ7OX1wn2mzDn/Od3j9KAfe/lwWie0vs9js/nga0X3fj48H9X8v8bh0rbXbXPUx3+1t7R2RHbvYzKc+7BtSP69PcHQ7iQHCxiR/TpJyvE9U8rxPVjFeL64Qpx/eMKcf1Ihbi+WiGuKvlVZR2rosu+r4quKvvqP6kQV5Vju8o+8RMV4noovx7Kr5R1rJL3X64QV5X9/qcrxFXl2J7V8ViljJ7VubbKdvwHFeJ6J8xD74Q6VklXlXJ1Fudt/3zYfZRU/atKfn29QlxfqRBXlbrJrM5pD8fj0dVxVuftd8I6rco+8aMV4prVfv9TFeKaVVvH1yrElVJGZ/l75X/vk/kP8/7GbdpzSHP2o72n/BiNhrQ+P+29jMpzTu8JWPkxG/yS0/rYlfukdbe5v9Fv7O62W7t7m1tbW2X7hsHPxv1h7V21fxm7m+sE5dUhz2j03//xY6P0p9nzb+8W4T+Wr8Ymnz0v2paPuNG+huNR7SveGozm4Z6/7VnivuL9nsMJnRPA8ngsJzpD1i86lmf1DJn3+7D7i1/p337uzu5rN3vP9N968/tu7T3XfeP2ze5r37e390b/zTexNtwTuLbIDQXDcAxvefUJteBTJWqn3XAtTMDFJ6uV91hsBCGulwiXumlCeRywB01spGO+ws/tMSnSE0d3KxKJJoTrTcIVil7k/5Yn4LpNuFTkX/suFOUWYdALSkWJCkUWRppXJtB8ZzBKM9LFEbhOT8D1ecKF358mXKsTcH2BcOH3HGV5LVAOwqzC+zVRtsLPvDwzgea3BqM0I11nCNcjE3D9IOHC7x8hXOsTcP0Q4cLv1+m7s4FyEGYd3p8VZSv8zMtzE2j+4mCUZqTLvi0ym56D9xXOXoU1Yyt/WrPpJL6y1vKooHVN5LHl9FFRzqOiHIWrXiGuExXiOlkhrsUKcS1XiOtUhbhWKsS1WiGutQpxnakQl8lCXrX7dCX/bRwqbbTZg9rKxnKR10exwrDyl9x4/04hE5WugfzhFf56Gnr2YvP1uuCPteU5kcf9ET2oEX4d6sj9Efttnd79Zr7UWhM4WeaqOQffGX+97v/faUWNYyAL/Bpefhfb6eMTXbj6x1M0/+s9o3VRUXPxW9OlOCLnbzwxxPl/cpzq5J/ROK3TZBXKmj1+YbgfpTrcJ35KzW1ru/NuPFneBVHnTMDX6H+ku+yJQ5RXFygPx+e7KA/H+EXKw/Fll6KqPsK6QNk+om7wUOWsHrKcVVHOtMf8coXlIN9YPq9WWA7ybZ3KWa+wHOyLvJ4KycrvkKy070Ky0tZwdYL/FZCVWf6cdr3W3OL1DiaWM6rPopzhfvYuyOO+cRHyeC2MSckn40XZE4fY/ucpT429RTfexyvUewpHqLHy1U5RCr1Q2fOUTFOy3b5V45bncaV/ropyFC6ze3AEDlcdP/aPcM1QOPrNrK4Z1Nxu3ypZW5sKX5sbas5wRDPa1FimhfR9TkpuHdxQ+/bf799nJAejbdp68lkq50r+f+NQqbnJfHWi/jg3/fPBkA5OiudGd1ldFvn6KOXhGON5BPst68DY321uVHZcXkcqWzK+i+l+ZyPlLB+ynGVRzor4Lgv8Wjn8jstRvHmoM08uJ6Yzh3TZa08Mv8HvQrosRwMy+F8AXfZp0mVnZV3MfRb1Ve5nqK9y33gM8niPDNOktXYZXRbnoQuAn/sXwqkbQrhvO6dlg5r37P/VQPk+vTq497so8q7kv9SQrd5+c2Ozv73Z2Oq2N/e2Nlp7re3GXntzv9nsNFs77c7Gxn6v3dnrtDb2W9utXkzmJN7vKhz1mve70syn8f0uJcvL7Hf5xJHQZmH/xieODBzT2RP1hY377QupdXbVF2I6e9G9zyr3GHkejK3HE625Co9lXnOlXo+rNZcay9Po36F2ju0bnU9DT8vouSDoUescv2e54Mb7EPIL+yTSjXOsvQu1DZbN/m1K9zNcZyfgYv82ZQ+JjXnExf5tyo+kTnlfBZ3uS0+MwhzcZgkwfyd/VnoZj2nUy45iTFv5Sy5pn23G+izyB/vsCRfvO9h2IZ+/JVHXIn0ZaTpsX0ZcZfryJF7F+jKvwWNrPLWfrOZEw+/7+E88MV386E3NaxRsT967QNvDo4D/6xH8JyP4FyP4lwR+pplPjWDZHNXsZ3Icnp6fuxymiSNELgiaVJS9NcpDmkJRNBV/cOytUB7yNRQxU/EVx/BpysPxd4bysB+eojz0dTKfxGU3vob/tyDL/xPZBYr608V0BhwPBr/qwv111vbC2H6g9tyVbYHlAtoWWC6gbeEw+2RFojOqdlY+OWj/sTlB9fN1wMt2JdUfYv3nvIBHmcn9B/uIfTurfhkp+ojlPQ55yBNOk2xTZaJ7KtlQtM/Yt7ivrvQNXnuuFizzKOUXl432OKQ/5B/wWzAPxqJ7Gp8SR/fsq+ieyNf6YLTeMR76VHbM834iyuZ1ysP+EvLrQJzoA4cn1YwOdaMB4sR3NkYS33hTeK3DJ09raeiJRqpUY61MpMqM6oR5WE6R08/cBw6LC29L5rwK+Vv65oGye6dGd9m9U2wX1meRzyluHjhsn8DvY36Ah+0vsXVcqj3NjMrJKiwHvwudAK6inCLrqCrKid08ELpJZfnS8Bv8ruhNKgZ/8dIQ5+n8OfEp6EpvHuB+hnob943D3DxgvDiMHyDLJ+wvBjfpVoKY3jgpQnksKvxxvJWA2x7bl9t+BfJm9VYCdUOAsgXhrQQmB9RtourGtyI321id1I01PvFNowbfvHTvN22UDn3TKJ/1OwF1qLlxnrM8NPhnLt379bDtS6M8U7dvx+ZrdTae2wHp5nawcYAy/WSkDgb/Vy/d+520drP6JF67tdXaDWMC1Aej9VY+wQjPck+dy0c5wdFOQvMA/o+4kOe8tsexqGSu4eN59/qle78e9tOPjdKH/XqJaFe6nPKp5NsosG8tAs29S/eeE68Xt5W+aUnZtFm24zhh2V72JqJM0KBku/Gi7A29VcgJjpcyK+MW520etyrOB8LzuJ00zk3fVb6M3L/VXFBmzPj0USpP7b/gmOHIQpnAWXOj9GE5sRsLWd9jOHXDWKhs5jviULqowYciJ00/Clpxfycrf8kllWdN1jOQ38gfllUnBa1rLiz/Mjc+B6l5aS6Ci2lAHnL7zaXh1wNzw7KS37Eox4nX0qXnVbYvsN7s3Gj9kTeYsE6HuWGZ97VjfTMRDwv3TY7Klrpvqqhssb6pIu+tuXGZxLcCq9s6E+uDhW+b5v2DRH0gun+A/Lmf/QOf2Jf5fm3+xwFXTE8o0u6qnFhUSVyzoY30Zy4Nv8HvQjcd8nra4DuXhzj/ZY5TxRA0GlVMQF7bl73VW8UqTGxn6aq1uiVeX/lU9rZpjJBaZs+n7N6NGqvsM4VzpNkDlY2G7QXK5qrWPMrWvxgpZ+GQ5SjbrlrDHXZcKt5Me48klZyZ1l4Z60Ch83LfvDT8Br8LnZfjm1sN/rsuD3H+Wo4zsd2/lCxRfVbZ7JRtn/sG2vbLnqFG236ZPR+U1RxzdAZ9OQqvrR8UX46qbqDB9lwN4MZnpc/PR8rJBM2LTvejK/n/jcOlLSVTLSk+Z5Sn9jqKjjerU9mYBWqfatWFeZhRntHD72I6GI/Nh343es/7OPvd1A5ZTk2U86D43fA+S63CctQ+1rR1ypAOtnB5+A1+VzRmgcGfuzzEuZg/Pyh+N9w3jsLvBm2MMb8b3OvgNjoPbfTnqN2VPV7N5RnRgPDKRv9O8M3h/jErvjmqnZUOWvR8AfoGsNxQe6Wx/hPbK1X9B/sI+ujzdxX2n11lE7Kk+gGPy7L9wPJicS4xDjXyhJPqP8ansr5dSjYU7TO4z2zr/Zit0cpUukldlBmTR0gj97/Y3j6Wpfofzxv2nYoR4xPbLQz+yuV7v5P8mnCt5NM85FW5h3GU/hHIM+UfwT5PMXtgXeBE+/mBv9BgCJdi/834VXPD8Tifv8Pyrc1PQp7BHcyVaWhtGK1LOX7rw1gm1mWO4Pm5Tu8+A/ME1tHqge8Qv8EvQ96BLwm8MxoPzh5B3vKgHK6ThOvEIXAZXWsC/sR90qVwLRCuRYEL3xl//Xh4Nm+bkF9MaB/qswGdoug+lMF//vIQZy9/VntNVjelS7KeoNa7k/zRWG4d8NIl1S8K7xlb+UtufJ5KYadUcl35ACWO8ds2epQ/rJpn/Dn+0268zdSdV6ib8t1fam7hvj6JN2o/iW242Mbs/6fWezE7TMzHb9nFfehZ51LjmL8N8ULpaOyT/sXL937vxuigca9sP2r88rjnMYF52BfY5qn6lvJDM/gVAa/sAerc9UoBXCciZau70lYiZSNd+C2XHRojShc13hyFLor6Y30wypuYz7xPRXip2nGN4JF3MfurGscc3xvHH49x7KcYE8bGi9J1cX1uc7Ty553kh8X+vEhnEb8PxMWximJ3VCpccxG6lPxU9k6ezxPtNRU+Q36gI7vxPpJiPp/E15jfHY+D2PxRdm5UPlBV4MqoPsh7tI/yHZlGx5X8/0bJtN3qbXY3Nncavf7mdndrm891OSp/J39epLyq+8GiqGdV+DuNrR22r1ZM/0bafYTWZmK50LA54epgiF/JwRrB8Tc+X+2DGUxKn/dOo52YT62NaZy5CMkWZTOK+RMXlfWz6u+r5GaRO6OLyuApxfHYKFJvbtO7MINh3hzlzUPeAuWh3on+HZcAjscg2xrQNm8xvj2O7wZ835M/G/9Syu6EOkhj3YXnYHuHdjZl/zKeKztpjfLQ1jU/GC3HbJJ2hppxGR1sw3xf/r+yMbJtDstn29wI3eId86WMLe+9+fOyG9rzNgBfaIwoPVDZ4PCMZsLx3IqtUZQvq1+zWUyqN2+//kb/xq1rX+j37ty++fqtJ7u9V/uOEjt2ZFD50MSMFVU4avC9Sr5BUi6YtztDQ74NiDrR6aj8OsF38v+rVor3t7vN/Y3ufnezu7fX7nUnKcUWkO94K8XtzrSU4lSL2cROulIpVgLH+vD1wZCX1wejNBnMUwDzFMD4FFOcldHgGuXhWLpOeSisrFwvgC2wrH+2fp92Qr/X745qQreJxwSyF86X8udbr9++uf/WtVs/cKd/p7/33J3d1272rt+51bsnqF97zVFipTuj/9nAwzJ5XuDhhN9lUIdZl9UW0PSoZfWX84xjbsDYOt4GjORzwYGsfmbgRvqZc9qAYRtq+Gw0KTlseJUc/gDl4Tgx3F7m/AU3fG644Tc+PQs0ZJT3IcjjheBzg1HaMe/DkMfBTZ6HvDrlfQTyeHGJTk28YP0Y5J2kvI9D3iLlvQB5S5T3CchbprxPQh5vCH0K8lYo79OQd5ryPgN5q5T3IuStUd5LkHeG8l6GvEco77OQt055Xcg7S3m7kHeO8nqQ9yjl7UHeecrrQ54FsrZxi8GrK9QF+ob/YgL8b4vlzrqg/yLUzacnBynKvqef+nQ1Df6W4b+WBv/BnIZ6bUW4G4b7qTS0bxj+p6ujvdkg2m9Uh/ugBMP9/jR82TH99xdyfMoQifPXonhXDS3Dy3rVAZO0a7vmfQfTTqS/RI3jKkiBn+9sPvRGpe4r/ef73T0kHdGti6ph1RGm7LKG4WsCTywlXg6WPl/J+/Toa4OilhMvj7BOHse/A7wMx/RgO/F5OfYTwec5ooff8X6IWiInbo9u4qVGZe3NPOCk2hvPTpVpb+UvF4tVd7/tjd9ze69QOVfy/xuHS30+T+JE/fl+MeeK8/xgz+Xtvz8BvAzHZSJf+c4V7Jt8fxROSbF7mR6hPOxXfI8Lmg/43iE0ofDdFugTx/eYo68Y35EzK3cs8ZSLSbU13nlUpq0zwQt1Borvk0OfundRHvbZi5SHZ6Aeo7wzkPc45aE5692Uh3P4eygP78R7Ap6RZz4plcLmNOVLd46+436Dz8pPQZXNd1YrfHynTk18w9/V3HjfM/W/JvAWoT92522M/vOHoP98hP7Y2FH0qzt2zgfoR5ouHIJ+vM/xBtH/Lqfpr4nvET6E40IA38UI/Rcm0H8R8pn/FwPluQD9FwX9FwP0I02PHYL+xyCf+f94gP6a+B7hEUctQGcIB7dRRu/nAt/VIuXWAzjrAid+xzIc+1JGeY+J8lZE+bF7IjnehvK1V/MQ6yM417DOgfMJ6xU4Z7DugHKY5z1sM9Yr1B3Kam7neS+DPPbnjfkihXyk8H//HLsDlNsd+0Qotpl/DsVx88+xezf5Lk/UI1ifRF2BdUbUB1gvxDnfZMpx2Br8pfz/o94aRDNY5kb72l163Wjf9AnNcigHFgQ84qsT/C/nv56G3ZzAtFtkzTE/xNAZqlgcZVcZPff6EY7h0Fl75qHBfwN42M+JU+4OGdUnkbtIN6PynCtmUjyu8XXRxYXzauLd3ENcD3HdBy5lz8sCv1YOv4v5gU8pbnxD+aW66vA3lW5jdfH1/d/wnuUq68o+2VzHsZn/L+D87fxZnXczHuPZ3lg8ldjdazyvoi62EIDHWK0I///zX5x7Gae6/wnnScb5e4DzVcKpzqqrvmnvJ8UgMXrUuWJ2kTiCGC1dT9/fovkY27Y+mMyfk4fgj/UBFaOFz8orfQ/HwLXBKC7ss7zumzTulL5ZE+VnovwiewGTzsxeJVyK3iL6U6It0MJ3QvDZ1NT6kzqbGtOfyp5NnbX4sqzvO6o/JqTb9++/C+Oe4bhMtecV4znieGpw77fIme2FCbieJFxl455P47yJc5PHxYNyD9OUzuWVjs1ZNhYixvktMy7UfQWJ166bmeAFjxUsX8VC4fkwNlYSxdMsPFas/GmNFcXX2FhZFLSqeD0npsPX0nFKDxM3tMxYUfbfxGNlKxO8KDJWsG3YrhwbK4liaRUeK1b+tMaK4mtsrCwJWtdE3snp8LX0vRtlx4rRXXasxOLTJmrT7UzwoshYwbbhfZ3YWEkUB6/wWOE4eKnHStE4eKrf8T3Hap08a/GLy44VjCdcZqyofb7EY6WTCV4UGSsqjmDNhdvbP8+78f4SKjs0r88DbTGafTJb4mqkTEUz2wgVP1TZKtaSPZfdj65RXhG7iX+O+QzE9rFje86xveqYH4K1YYqYUu3N7navu91s7rSb/XZzc9K+a+X7vu1Wv7/Zae/uvv3U3GtOu/ze5tZu720mNPp3T4i0JpWvYnSgndanE/n/GAcE4Q1fneBfzxH4fvEDJO/qojwPN4jAZYHfuzjEu/nB6LvFwTg8xk0xeCt7SdBoeRhTuE7lnMr/R34hLqOjTvBfyhFYm2CsE/texTTGGNFcliqf/chVPOVlAe/b53P5R9Zvse5V6xR3yyT8+I5ps74T8qeowr49aS+o7vS8oMoOnZ3wOGLzgq/fX8mfj/dR8u2NaR0lr6XB30q9T6vCfqg5v0Zw6hvuUwjDuoZPNh78WDKfLv+MvnQ+8T475j0FeXOU9zTRh3k3II+Pi6PfE9vXi9qBU9qoOo32btp1fauj9lT5CPw85PEReJTbuIb/i8SfFPbut/mzldZG2NpbF/RjfG//3AaeYL7BIx8SteNOEV0Gy19Kyre43Uvtg/v1qPl+vtK/fS9OzdXu7e4LN2/f6r/5JttHavQ/7+2yPz9/z3tzRud35b9qXzGUjB6WiYhvjuAz+n8uAIf1VHN5bB1XZq1W1Fe5yFpt2Y3r/M5pXdnkh8mTaccYtFh9sxxj0GJSHgc/aIutfNR+0OYbf8zD2W0/1Gvjqaheexid1c45+GcOn6N01sTxoLcSt1lzPUC/T6bz2Bkczl9w4fVmbP46DrLNzg8dtWyzs7APZVs0baQch42cPwnHoZRtMRu+km0svzjE1zXAzWvu66LclHXGWPeJ5ovWugvPERw6yxUvtzmpYJObppco+x+OM3UPNK8HXACHkr1cRk3gs3qvRGi7332m4yDfLf7AUcv3y/nzQ/keTQ91V/dQd6VUSHfFWALI57oLyzY+L2Tnxb2+ux7AV0QXrgW+w/Ur43AV8ism65GO4667X8r/P2rZPpdnHPP9tu7xDt3cak0rdDPuW8VCNxscf4PjDMN+Ph2AuQEwNwIw7weY9wdgngGYZwIwHwCYDwRgQiGpEeZZgHk2APMhgPlQAOY5gHkuAPNhgPlwAOZ5gHk+APMRgPlIAOajAPPRAMzHAOZjAZiPA8zHAzAvAMwLAZhPAMwnAjCfBJhPBmA+BTCfCsB8GmA+HYD5DMB8JgDzIsC8GIB5CWBeCsC8DDAvB2A+CzCfDcB0AaYbgNkFmN0ATA9gegGYPYDZC8D0AaYfgNkHmP0AzCsA8wrA1ADmVYB5lWCUnlL1WiKdvG41ji7GRquZUXnOjepjjsqfxRgbd2EGQ3oyypsfjNdD+RDgucsnAY77Fq+NcP1j/Zd1W5/w3rdnoayPuFHa8Zsale/cuD0sRVvgPXGJ4uc0VNuhXdGnechjH5oibefTWwA3HVvikHdpxkmzGbMlWl85MXAHqUa8Rv4d1f73B/P/Z3n/+3r+jOvMJ6H86tq03Uh8vUF72tcbVC0vzIZi8R9Sr6OO7ox6s/C8PKtn1NP6xjUPYp2pc8DqXLw6+8F+WAf+4IBLnRueI3h8tu/xXS//VeeN2fdT+azhO5RNL1LdsG2ywK/h5XdzRKOKWca62aR9ojrB/yDQfpNwxmIV+YQyF3lSNlbR9+e/Pv//OY0zVK8QzjeAlr+dPyvZYXXw775AZfM4CfG0aP3nArR+zg3r/zsBWpEepDXmk+d/vxiBqwu4jGitOa3rXx1oOg2H+jV8/I77OdaZZVcaf9lGm+WNqjeX7/+WoQ41Ny6DGF71KcS/TPAHdnSnZWkoVtc/yn89L38kQINz4/3aJ9RFQv26yBj8sfwXx3UsxtQC0K3iCfDdx3xO9kr+2zhcaib2zW6o88ZZdfQf4F9Og7+j9vVRlvwklWtni4vKcIP/GuD8av6sYvAV8V1eduMxqJ07vKxaARjWG07DN2qcXR3c+7X2whjJVerMRo+t6VCWrAl66gT/r6lejwB/alRXxGPwZ0S5uC/G8+IZKtf3j9/Nn9V5eex7/4ZoXQXcNfo2Vuf/CDh/Pn9eFWXzPTYYA3uFaDmwkTjdH64TLQb/i/mv58O38mdlp8Ez/D7NQ16V6yBPxx8AHTym6oPReq9CXk3A43jlPlkjHMizNTc+bk4TrlMCl5rrlI69QnVEOg2vkneK/tPiWx4fCwF4w8fj41fyX6U3n4FveKyjXGSc3wRa/osbrT+2wRLA/Y9A2Vj/mqgPy5OQ3nyGaDX4/+rC9V8T9cc7BBYJp8H/OuD8VoBOrJeaG+z9uoB/RNRr1Y3zhe84QN4bHPJe4WD5Y+UtOd0nOEYF5mH5WHc1ts8IWmNtfUaUw239W/mv0iVXAnSG6EOZYONfzSsHNlA3nFdm3a/F4hYftV/LgxZ/o9XpbO20dt/eedzr7e+1N6Zd/lZ7q9npdDu9rd7+Tru3+06O//GHBvv23x/lz7z/hOXd9bvLwnBZ4PcuDvFufjD6btbjf3wn/3+W43982/Dlv1j3qm3md8sk/PiOabO+4/u1ITje/npbvePtr9ecmr8e+sPF/PVCPnQ1gAn50CFMyIcOYUI+dAgT8qFDmJAPHcKEfOgQJuRDhzAhHzqECfnQIUzIhw5hQj50CBPyoUOYkA8dwoR86BAm5EOHMCEfOoQJ+dD5/MT+Vt1p+J3gGHNQl7T+Vs2H/laQhz47LYDjvhXzt7L+q/ytrN96/H8dyrrmRmlHfLG1dlqfoc1e4nlM+ltxu84PRsvGPGw7vJe7RfxJc35nyJ8U/Pf8iZ3f4XWEc1r/Nh4dlU/VX8v/n2Wfqs38Ob1P1dDn6Woa/K3j7lNl+J9KQ3/f8D+dAn+zcUD/jTT0b5jP2QKs6UO6Q5G53SfeU0B5j3MpzpFVlIP6lOWp+MEZPSvdYCFSjtJj0vrLDX0qTgKdav83FHsL901PRuBZL2T8i9Op75j/Wyj+NN9nwWv9iuhpJvYz6NSpvubv4ev6SSoT9xa4jXxiX7JT1EYMw2NjBcpW48G+5b3Vl/JfX4dT2ShO5VOHcbh5v9bgu4BzNdN0OhfXa+39aQGP+x1Gj5IZp+m72B6kwo3wtQAe3mPies7BuyWBW/k+VNhHpe9DJso0etgP4HWiC30fMhfnmf87I8pF2/kSlXuGyvV96BHqQ0bbstPy5UCXdXqsXMn/bxwutZmPeF4e+bBA+QZvfo8+/3b+zDEzUV56uC9RXXBNrnwFmBenk/CiNdbPkBeqf3A/+6H819f7XBbmxYLgRWz9Pw1fkAtEL8rdOtGk5J/SW8rKvzU33r58p1TsXlalTyl/j4xwh3wiuc8b/JfzX///92aj9Kk7+fyvzatKxrPPGdqlY/PgJB++rwTwhnyXbK3Cd8B/G3D+eP6c2Hbf4TZFPZLLRHqW09AT1QuXBT3cZ77uRtviYLw7Lf9rBH9KlKv8Ftn/0srFOagmysD+pc6YuAp5WeT8T6J2LBxT2cqf1vmf2N0wPrGt9FQaejped1lzo/3DJ7QzYNsgHXyvi1of+jr9LLznMaPk0tXBMB/hfxFw/lz+rO5nmKc8HluKlsyNjxPn4mtytOtyHvpVcFkh32K+7zV09y3y3gFetD3xnGxtWHdaHrA8Mfj/kP+qdZHy04zpBUqPUGvGVTfe73jNosrGdrs20GWH/BXR3x3hv+GG9f/eTOOsB+pTD+D8VcDJPFW6U4ynyldOrRlX3Tgf2e9uEk+vDjStRXlq8L+W/yqeoq5dhKcG/98AJ/NU8SjG00m+zMxT5fdblKcc3wf9F4vw1OD/pxvWn3mq5G2Mpwb/m4Bz2jzFOq/Rd0g76w0s75YC3y1FcK4EcCr5FZobQ22pZBq35W/nv6otVb1WCtbrdEX1Ol2yXgb/O4nqVQvUq1ayXisT6sW6vsF/q0C9cOzh3M32SIP/A8BpY0/ZDNAu7dP8YJTeK/n7xqGSthmgDlsfjNZbyT2EL6sbsF2Axyjmxc5mqj6hzpYonda+RZ3W5BWuUVlXi53z9ilkk/7T/HdSH7CyZ81upM6sxuYItSbCNSnr4ti2vL9UF7hiZ4hi96NMsrfM+vmC5RzBg3a+4Kj9+8v61z9w5wt2tvZ3NjZ2mxs7e/2d5tZRni94PEfgx+V7SFbWRXke7i9F4LLA710c4t38YPTdrJ8veF+OYJbPF7yX5BbWvWqb3N0yCT++Y9qs78zCuSm7r+l4n29od473+YZ7PnKsC1a5J6FizcfONxgcf+Pz2WaJMInjx28m5lMrsc/QBuv1xnOuE8e4uF9fNyxr1vzYVWwY3t8s6/emcB1lmyKv+V7Voj7gRf33LwEcj0H238c1gNn+PY7vBnzfkz8nPmvSSSkzfFoX9LNuYbqgc1rnMp4flU/5+/L/Z9mn/L3587Ib3rWxAfhCYwTX1uwTq3wkEo/nltE6L2hVfp3e1nQuf37z9utv9G/cuvaFfu/O7Zuv33qy23u17yjh4MOOOefCEzNWVOGowfcqHYdLOjr5/0dtbLCgjsdcKZ7aod9EDg+bqR24De+1wRC/GuDWh83Yis9Gk8GELulAmBsAg5t4Pinl2ujjiR3piE3sSol8mvJQzhhNd50T3fD5AtDoE18egnl44JkdUnjT5Ur+f+MQCQ+tzsLlgSkWJj5dTYO/aRP234B25Ak7c6PtmFKhxvKc0wubWQ287BUCC+jU67722nNv3Pxc93b/+p1bPa8TYBUQ7ZyoIk/nbMNUcCwiWCywKMDhj3hD3/M7K1vFamS/W25Sfhdbz8VEZBb4tXLchHIUzUrc3m85ac/NNhprRCuWlVgsbqopxBEPY+2IYoTHgBP8dQCDZ6CvAV6GY3qwHRYAP9ZDtZda16v9QjVF2PvENqwtJbq5/rzniXlq37Roe6A9okx7hOwkPDZrlKdsHMdhqXM1//+olzo45cd8XlfdeDvxHrw6M4DzjKlGqeM585mED+S/vq4vEM3KHlETvCqiAmB9lf3iRIGyVcx1LnvBaTnEZ1AM3u428vX/VP4c80lWcwnPifid1fFB3Ccvu5+GZ499Okf8vV86KB2YDs6mwd/Afu6oLlgum0hchTQYPvSd48T68IFNk+jLqqev6Sgp/c+SLQfOwjtcWiOt2IdTLCFTnXtSfQbvZFmmPGu7efFdFvh/jn5jsFkE74rIM5zWVkiv1cPO62I8YcNbJS/xDoYE+A/kR6olvOoL+I7HK7YVz0ksUyumtZsJ+mpUJtOIMKr/ztH/8/S+VgBW9V/LO9jriXzH9xjxO95XdALecOGdDQrXCchHePYxTtWG64Imo/3PABfTodRWWw4A",
      "debug_symbols": "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289u23522/az24b2QRvbd9F+7bbt127Xfna79rPbtZ/drv3sZtmr9jponW/fRfu127Vfu1372e3az25qP7up/eym9rqb2utulr1qBVDt125qP7up/exuv1fNtt+rZn173e3b6+72e9Vs+71q1ref3b797G6/V82236tmfXvd7dvr7qu9ajb6owtnw+suPB2kPNHj4dPTi2M2u0Exu29HHd8tMtNZZKezyE1nEU1nkZ/OojCdRXE6i9J0FuXZLIrTvbPjdO/sON07O073zo7TvbPjdO/sON07O073zo7TvbPjdO/sNN07O033zk7TvbPTdO/sNN07O033zk7TvbPTdO/sNN07O033zs7TvbPzdO/sPN07O0/3zs4s7+x43Fbm05Z/duJ7dBJ6dMLysnzcv+afr187Okk9OsntO3Hb1qMT06MT2z663OZ6dEI9OvE9fBJ6dBJ7dJJ6dNJjxpseM970mPGmx4w3PWa86THjje/RSejRSY8Zb3rMeNNjxtseM972mPHW9ujE9eiEenTSY423PWa8jT06ST06yR06cVuPTnrMeNdjxrseM971mPGux4x3PbJ612ONdz3WeNdjjaceM55Mj056ZPXUI6unHlk99Zjx1GPGU48ZTz1mPPWY8b5HVu97rPG+xxrve6zxvseM9z10vO+R1fseWb3vkdX7HjM+9JjxoceMDz1mfOgx43l2Lpc66bHGhx5rfOixxoceMz700PGxR1Yfe2T1sUdWH3vM+NhjxsceMz72mPGxx4yPPbL62GONTz3W+NRjjU89ZnzqoeN5dk2WOumR1aceWX3qMeNTjxmfesz43GPG5x4zPvfI6nOPNZ5nz12pkx5rfI89dy730PG5R1afO2T1tG09Oukw42mzPTpxPTqhHp34Hp2EHp3EHp2kHp10WOPJ9JjxxvToxPboxPXohHp00mPGmx4zvseeO+qx54567LmjHnvuqMeeO+qx54567Lkj22PGW9+jk9Cjk9ijk9Sjkx4z3vWY8T323FGPPXfUY88d9dhzRz323FGPPXfUY88duR4z3vXQ8T323FGPPXfUY88dUY8ZTz1mfI89d9Rjzx312HNHPfbcUY89d9Rjzx312HNHvseM9z10fI89d9Rjzx312HNHvseM9z1mfI89d9Rjzx312HNHPfbcUY89d9Rjzx312HNHoceMDz10fI89d9Rjzx312HNHsceMjz1mfI89d9Rjzx312HNHPfbcUY89d9Rjzx312HNHqceMTz10fI89d9Rjzx312HNHqceMTz1mfI89d9Rjzx312HNHPfbcUY89d9Rjzx312HNHPc65ox7n3FGPPXfUY88d9dhzRz3OufM9zrnzPfbc+R577nyPPXd+ox6d+B6dhB6dxB6ddJjxfuug432PPXe+x54732PPnTc9ZrzpMeN77LnzPfbc+R577nyPPXe+x54732PPne+x587bHjPeuh6dUI9OfI9OQo9Oesx422PG99hz53vsufM99tz5HnvufI89d77HnjvfY8+ddz1mvIs9OumR1ffYc+d77Lnz1GPGU48Z32PPne+x58732HPne+y58z323Pkee+58jz133veY8b6Hju+x58732HPne+y5877HjPc9ZnyPPXe+x54732PPne+x58732HPne+y58z323PnQY8aHHjq+x54732PPne+x586HHjM+9pjxPfbc+R577nyPPXe+x54732PPne+x58732HPnY48ZH3vo+B577nyPPXe+x547n3rM+NRjxvfYc+d77LnzPfbc+R577nyPPXe+x54732PPnc89ZnzuoeN77LnzPfbc+R577nyPu2V9j7tlfY89d6HHnrvQY89d6LHnLvTYcxc26tGJ79FJhxkfttijk9Sjkw5Zfeix5y70uFs2mB4zvseeu9Bjz13osecu9NhzF3rsuQs99tyFHnvugu0x463p0Ynt0Ynr0Qn16KTHjLc9ZnyPPXehx5670GPPXeix5y702HMXeuy5Cz323AXXY8Y736OTHll9jz13oceeu9DjbtlAPWZ8jz13oceeu9Bjz13osecu9NhzF3rsuQs99twF6jHjqYeO77HnLvTYcxd67LkLPe6WDb7HjO+x5y702HMXeuy5Cz323IUee+5Cjz13oceeuxB6zPjQQ8f32HMXeuy5Cz323IUed8uG0GPG99hzF3rsuQs99tyFHnvuQo89d6HHnrvQY89diD1mfOyh43vsuQs99tyFHnvuQo+7ZUPqMeN77LkLPfbchR577kKPPXehx5670GPPXeix5y7kHjM+99DxPfbchR577kKPPXehx92yoceeu9DjnLvQ45y70ONu2djjbtnYY89d3GyPkbgenVCPTnyPTkKPTmKP6Eo9Oumwxkez9eiEZcbnFPZOcko/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XLYtfXv63knu0Mn5j/q5OzE9OrE9Ounh+IvDmJk78T06CT06iT06ST066THjXY8Z73rMeNdjxrseM971mPGux4x3PWa86zHjXY8Z73rMeOox46nHjKceM556zHjqMeOpx4ynHjOeesx46jHjqceM9z1mvO8x432PGe97zHjfY8b7HjPe95jxvseM9z1mvO8x40OPGR96zPjQY8aHHjM+9JjxoceMDz1mfOgx40OPGR96zPjYY8bHHjM+9pjxsceMjz1mfOwx42OPGR97zPjYY8bHHjM+9ZjxqceMTz1mfOox41OPGZ96zPjUY8anHjM+9ZjxqceMzz1mfO4x43OPGZ97zPjcY8bnHjM+95jxuceMzz1mfO4w4+O29ejE9OjE9ujE9eiEenTie3QSenQSe3SSenTSY8abHjPe9JjxpseM77H1KpoeM970mPGmx4w3PWa86THje+y5iz323MUee+5ijz13sceeu9hjz13ssecu9thzF3vsuYs99tzFHnvuYo89d7HHnrvYY89d7LHnLvbYcxd77LmLPfbcxR577mKPPXexx5672GPPXeyx5y722HMXe+y5iz323MUee+5ijz13sceeu9hjz13ssecu9thzF3vsuYs99tzFHnvuYo89d7HHnrvYY89d7LHnLvbYcxd77LmLPfbcxR577mKPPXexx5672GPPXeyx5y722HMXe+y5iz323MUee+5ijz13sceeu9hjz13ssecu9thzF3vsuYsce+7clvefxTtrSk/H3aD4+AE9uS9r4lTWpKmsyTNZw7EvkNEaM5U1dipr3FTW0FTW+KmsmepdnKZ6F6ep3sVpqndxnupdnKd6F+ep3sV5qndxnupdnGd6F6fzTX7Guf2QJuOSOVqlcPLnyT2OdnwyhdJXD9S8B9+8h9C8h9i8h9S8h/zrHvxjFoSTHs7387H2YH7fw3F2rI/5pAfbvIffz2mfd0+HzZ30QM178Jw9GHPSQ2jeQ2zew+/ndIhm7yFtJz3k1j3Y38/pkPYDCEOmkx5M8x5+P6fjtq/o0aSTHlzzHoizh6eDsB89+OY9hOY9/H5OP07nvuVGJz2k5j38fk6ng1I6iyW3Ne/h93M6uf2A5ET2pAfbvAfH2YM/ebc6at6Db97D7+d0Nvuz+WxOu9i8h9/P6ez2VTTTSSbgcuse6PdzOh+5dw4nlMg078Fy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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "build_msg_block",
        "attach_len_to_msg_block",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "get_htlc_public_solver",
      "is_unconstrained": true,
      "custom_attributes": [
        "view",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "key",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "is_solver",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "Train::HTLC_Public",
            "fields": [
              {
                "name": "src_receiver",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "amount",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "token",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "hashlock_high",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "hashlock_low",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "secret_high",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "secret_low",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "timelock",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "claimed",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 8
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16480166116992993320": {
            "error_kind": "string",
            "string": "Function get_htlc_public_solver can only be called statically"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_htlc_public_solver"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "772057049813214347": {
            "error_kind": "string",
            "string": "HTLCNotExists"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2570651705007895968": {
            "error_kind": "string",
            "string": "HashlockNotMatch"
          },
          "2722406262643068352": {
            "error_kind": "string",
            "string": "HashlockAlreadySet"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3559210201980528457": {
            "error_kind": "string",
            "string": "Function commit_public_user can only be called internally"
          },
          "3564161243949231814": {
            "error_kind": "string",
            "string": "Function refund_public can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "9323748002447105156": {
            "error_kind": "string",
            "string": "NotPassedTimelock"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "15001264570739363109": {
            "error_kind": "string",
            "string": "Function lock_public_solver can only be called internally"
          },
          "16480166116992993320": {
            "error_kind": "string",
            "string": "Function get_htlc_public_solver can only be called statically"
          },
          "16870384257694633552": {
            "error_kind": "string",
            "string": "Function add_lock_public_user can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17814817983036354427": {
            "error_kind": "string",
            "string": "Function redeem_public can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "lock_public_solver",
      "is_unconstrained": true,
      "custom_attributes": [
        "internal",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "src_receiver",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 48
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "15001264570739363109": {
            "error_kind": "string",
            "string": "Function lock_public_solver can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7V3bjiQ3jv2XfvaDrpToXxksDNvjGTRg2APbs8BiMP++qsoKRXRLSlayFSxlSC9G2Y6TRzwidaFu//n0919++vc/f/j82z9+//PT93/7z6dff//5x78+//5b+rf//Pe7Tz/98fnXXz//84fjf/6kXv6hjYNXxJ//+vG3l//w518//vHXp+9DiOG7T7/89vdP30etQ/qNf3z+9ZdP32P87/98l1BesVCegwLNQrG4AsuuwNIwsrgiyy5kcaGrobRN1f8G09ZGf8R9V36ujNm+Vs7sH/vKxw5Av33sIKj8MdjKx9ErvxXfG338+FZ87FJ8xO1rrVGu+Fb1Ud/HrH4k1Nc+bP6gwdr7xUePm60I1hXF16Zz8bX5ovivJEZJkFRDLjkDZphRGu6TuGjd5hrxEAYN1wgmu0YMhba2brY5hJr5Itbi2c5q36ORc183MdYpJi7ycN7WcJg+3nxZ211vrytSgPH27WMw4AjdUG3VHtGYQjcfyfI4OJbnFVXv3ChUvXMjUSyuaFkoWg0fChRaBsopzUJVu3o0anM7NJT/7H1u3D9Ut5/X6tyf96f+vDm39MZ9889r7XJL70uCeDKBtScT+A4WWJu7zpIgfrsHGb1FmNHmawLfIcCM2UZsBlRB0CHECIK6m4LLDQsER9SBArsPOveB2GuLVBm2wVYctQtqXwar5ZAf3daPB8T9l83L2LD4OnUZ2wjhMMIzqqqJ3n7YmMPY0bypUh8gzK5KffgzvSorgmqqxKVKqUpjQD+7KstXKqqAWapUVIGlSqlKWD1zTZXVM9dUWa1tRZW4WtuaKmGpUqqCeqlSUWXNmUtVQK2euabK6plrqqyeuaKKXnPmmiqrZ66oYlbPXFNlzZkrqtjVM9dUWT1zTRVcqpSquNUz11RZPXNFFb/yKzVV5uyZrd6KbKyBQhWYcxRHqbJ8paLKpCsflCpuqVJRZc78CqHKpCsflCqrta2ogqu1raky58rHfVXCpCsflCqrZ66pMmd+hVBl0pUPSpU58yuEKpOufFCqrJ65pspqbSuq2NXa1lRZc+aKKpOufFCqzNkzh2yfCd4Vqky68kGpMmd+hVAF5pwzU6q4pUpFlTl7ZkKVsFrbmiqrZ66oMunKB6XK6pkrqvRY+dBxv+7HeUIV73H76bREt/+0VtXfRr/pojHsKqaFrLfyx6cuf1Tw3OXvcc/Gh5afzBmlBZ/75U9zRpenj6C/4Kh87cNmrYHDT9e/dqC3W04cHG7Sqn8dfNxKkobcu5LVS7HCfoNW+tMdP35VxtilTEOZuJSpK2OXz7SUWT7TUMYtn2kps3ymoYxfPtNSJixl6srQ985MqwwsZerK0PuNZ1UmqqVMQxm/lKkrg8tnWsqsdqalzMrP1JVBPbHPRJWVicU1+GjnbYEt5GUEGyrKXCuawq6MIZ5OsGmY+/axNWa/WtracJPmYmmIrtJcKw/RUxp/rUllV2muNavsKQ19EHxeaa7Vd3eVZnXeLWkulqfpKc3FEjWPSGPAZGmiqkgzr9eQ0szb1lDSXCxX01Wa5TV1aYxSy2ua0iyvaUlzsRxfV2nmTUpQ0lxs515Xaa61PaKnNBfLmveUxs2bryGlmTfLR0njJ/aavEffWr3/9Is0j319E3LilqmrkDBxLqivkG4J2UfIiUfxXYUME4/5uwoZl0e+S0it8onV9Od+aYr1NyH1zGmdx4QEnYUMqhRSr9DuJOTEk/+uQpp5d710FvJ5Z8+v5bfPO6G4lf95Z5a38o/ex4ZtC7MLKhJfa7BbQkWDxz1aNNysdW4qa0cfiHa1dviNlH2tnapuYfQBbF9rp6rbMFXchtHHa12tHX7rYF9rRx8L9rX2WiPHGDZrg46ltcPv2etr7Ux1a9S1RheUtaPnsLpaq0dfQu9r7bVGF4S1Zqq6NdcaXVDWTtUDDX/rXV9rrzW/Jax1l5rfBo/Z2ugq1l5qdEFZO/wGvb7WXqoHoqwdfqtbX2vnqttLjS4oa4ff2dXX2ql6oDhVD3StDCtp7VStFE7VSuFMrZRVM7VSVl2rlcKtJDoeNrdla/W1xsmUtW4qay+VqaGsHf7Uc19rp6pbe60sHGXtpdaBKGvdVD3QtfawktZO1Updaw8rae1UrdTF8smUtVO1UtfasRutytbacuefvdYeVsraa+1hPVp7PHObrb1U7oKydvj3RPpaO1Ld3ko0Uob7pUROjdRv3Uo0Ut/yWiI90ij1VqKRsumvJRpqb+KtRKNFvxvq7O+tRMNF/1B75V5LNNQzJ7cSDRf9Q+0Lu5VopDH7a4mGmg/fSjRc9A+1T+m1REPtJbqVaLjoj8ONj+Jw0T/UzOtWouHGR8PNjvxQJ+VuJRptfOSHmx35oU6FvZZouNmRH2525Ic6AfVaouFmR3642ZEf6rTPrUSjjY/8cLMjP9TJltcSDTc78sPNjvxQq26vJRpuduSHmx35oU4s3Eo03PhouNmRH+r+k1uJRhsfwXCzIxjqro/XEg03O4LhZkdgRot+GG52BMPNjmCoOxxuJRptfATysyOwOpfIW+Jr7832FG6aElC/HXzcShJA+fx19drnYOO2lSM4Y+5/rLUNW0G0dgqPn9+EjIMLGbeCeDDU/dlGZ22MxnLjSuKbytpL1W0yd/vtNM8urYVL1a3RIVsL5WZCCPpK1lqVf9tqXbEWZrI2TlW38Vp1a3wuSeWyU8Br1e2hJMFWrMUrWevUdpGtcbq0Nig3lbVT1a2+Vt2aPLpwPlasvVbd5smYcaHsgYL8S8ynWot5nOxVpW7t6FPnvtZOVbfDp0Uestab3CYfkyi7tZeqW2/yb3so57dBfmn5VGvR7gm+8uqbIL9s/aHWTlW34VJ1C3teKmVTK9Zeqm5hz0sBVNrkeKks3H4lc5rLhoq1l8qwUtbiVHWLl6pbok2O6lIjR6Juo7rUyJGyVk9Vt/paM777ealoLpVPJua30VxqrYCy1k5Vt/JXzUHMazVBK+JrUPlrUPjFRory4xjtZmyMvth1EZ3+UFvxi69vJYLRSuSH00j+6HNwmEsUqHjUCFtBjFLHvsK8lh/lt3Hh3p6gLxVF+SsAyBINp5G811ElAvHIRMhxgIcxX/3r6HJBovtiDd5Vo0blHXLo9Bdf36yFmawNMz1Wg2GmZyDwWhfQkdZOVbfXuoCOtHaiurVKTVS3ydqp6vZij15Q1k5Vt0Mdvzrf2qnqdqgrB8+3dqq6vdgzEJS1U9Wtn6puZ3po16qZHtpN1k5VtzPlpZK1U9XtTHmpZO1UdTtTXipZO1Pd6qnyUnqqvJSeKi+lp8pL6anyUnqqvJSeKi+lp8pL6anyUlo+L9Vt38Wt/Pjc5Ze/K6lz+cNzl/+Jd1ndyv/k8QtPHr/hyeM3PHn8xieP3/jk8RufPH7xyeMXnzt+jXru+DXquePXqOeOX6OfO36Njs9dfmOevPzS5w5elpTfvn5ZgSS+Bu+22T4AeXoO8w3HiIeTguhr5fD5/En60xSZASOe43oeZfysykS7nWuxsbwvN9k0rc+g2X7ZotUVZab1GUoZv3ympYxbyjSUiUuZujJgljINZcJSpq5MWD7TUmba2QGlTJy21475/oqkjK8os2YHL8pAqQzOO9LzezTFis/gvLODiFmZ8p4xa9W8PkMps3ympQwuZerKiGfLn0eZeWcHhDJm3tkBpczymYYy4ncqPo8y8/bafrtj1SlVzijtvGsH+7wpKWMqyszqM05pzMqAKpWZdu0gyeGyMqHiM35enyGUgeUzLWXcUqahzKzrTaQy064d0MrMOjsglYnLZ1rKzLreRCoz7dpBGgPHXRmoKLPWm16UKefabtq1A6cwR5M2vqLMtLMDbfKMUtuKz+hpfYZUZvlMS5lZ15tIZcys6020MtPODihl7LSzA1KZ5TMNZdys6020MvPmgfNbnE67ckbp5j13cJg3aWcrysw70stvezmjyvUmN+/agVF5Rml0JZpgWp+hlAnLZ1rKuKVMQ5lp15soZeZdOyCVmXZ2QCmDy2dayky73kQo4+ddO9D5xsikTKgos9abXpSJpTLTrh2kFf3t4ySSrSjjljINZaY9q0IpY5bPtJRZPtNQxi6faSkz7Y0ZlDJu2vNNpDLTnm+ilPHTnqMklVntTEOZaXfX08qs8UxDmTDvXJtQZuL7Zyhlpr2ziFIGpz2VTCqzRnp1ZUCt2UFLmTXSaygz7y0rpDJrpNdQZmU7W8rMew85qcyaHTSUmXY/MK3Mmh00lPFrpNdSZs0OGsrAGum1lFmzg4Yy0+56pZVZs4OGMhPfKU0oM++d0qQya6RXVyaoNTtoKbNGeg1l9JodtJRZI72GMtPefkArs0Z6DWXWDsaWMhPfD0wpM6vPuCTB28fOVpWZ9mYeSplpdzDSykx7jpJSBqa9ZYVUZtrbD0hlVgvcUCasFrilzGqBG8rE1QK3lFktcEuZ1QI3lEG3lGkos3ymrkxUq9duKTNvrw0hK1N53TVOu3ZAKzPt/TOUMmba+2dIZebttSllpr01jlJm3julSWVWC9xQZtr1JlqZ1QK3lFktcEOZaXfX08qseVNDGVg+01Jm9doNZebNkDuV7+10h1/elMFpT7I7F/LL4y5iRZk5ounV1knuKL3ZOsea0M3WK2XstbJbSbTyQMR3WsfZSpIWLvbMtImmVu6Qn/iwu45G1QQxevthYw4p7/Txq+aXmiE+i+ZXiuln0Xy1LeKaX2p/5rNofqXszZNofqkT9M+i+ZUyTk+iebhSXuJZNF9jRXnN11hRXPO4+lB5zVcfKq75pd5xexbNr5QbfwrNnbrU23PPovkaK8prvsaK4ppf6m7qZ9F85RXFNTdrrCiv+RorimtuV15RXvM1VpTXfI0VxTW/1D7/Z9F8jRXFNb/U2YRn0Xzlz8U1D8vPT9Dc75oDFJrjyrf01zxk9UzwrtR89aHSmutLnS55Fs1XvkVc80udn3kWzd3SXFzz1YeKa36p9wKeRfPl5+KaX+o2nmfR/HnHiq/lf+KzlrfyP++a0a38g6+/gNG5/C4QX0cVNmujinsUgq0VxLi4FeSY4Xk7eu306Ef1PlKawXvXD5Rm9INvHynN8pqWNKM/GvCR0iyvaUkz+gGhj5Rm8HXID5Rm9OM2HynN4LOpj5PGKLekaUgz+trBR0oz+PT4A6UZ/Sb4j5RmtTVNaVa+piXN6Ntaz5Qm7tIcbsLM0oz+juGJ0li1FdtabSvSzBtQ1qssja94zej3rHygNHHeORQpzbwzb0qa0TeNfqQ082b5CGns6NsBP1CaiWfelDT2WtJYyNL4eF+aEPa9GMHB8eNXZR4+ivWKevgw0Q0VOKiHH2S/oTwHFRQL5VgolvIPr3LcUCzlkaX8w2njF5RTioVyLBRyUNqyUBzlnTEsFEt5y1LeehaKpbxjKc9q2Vy9ZdNKxQ2W/kZzv6/wBrcW2qeeYP/YvJGAAEm93XyUxOaeKf0ZShIvQFJvlXuTSFgSJSyJIpagAEl9itibJJ5P4usdVW8SgTrxWsC7vFESJCBAYrUESRAgcUaCRCIYvZUgkQhGkGhWJLpfL9H9+igRjFGiWUGJYESBZgWUlSCRsERrCRIB74JO3S9uCTPvlC5JvAQJCpBYJ0EiYYmTsMRJWOIlLPESloCVIIkCJMEIkESJtitKeFeU8C6UsAQFvCsogTgJuoslzsRMYlVB0qepd3nhx6fUQEHiusjloskkh1W6TBL6kGzPYXuvi9FK6JOypUhAgASUBIkXIAkSlgQnQdIn4sMe8dEVJH36E4IEtQQJnE8SlZEgCQIkfbKpFEmX/sTnB+bTn7EgMUGApE82NaXNMglgSeIFSJySIJGwxEtY4kUsQQGSPtM5iiQKkPSZzlEkQYAkSjQrffLCBAlKBCNKBCMKBCMqJ0EiEIyorQSJQDCiMRIkAsGIEqMVlBitoMRoBZ1EMDqJZsVLBKOXaFZAIhhBolkJEsEYJJqVKBGMUaJZiRLBiBLNCp4fjF4pK0ESBEi0kSABARKjJUi8AIlVEiROggQFSJxEMDqJZsVLBKOXaFZAIhhBolkJEsEYJJqVIBGMUaJZiRLBiBLNCgoEo1ZGgkQgGLXWEiQCwaiNkiBxEiQCzYq2fYIR8wIzFJstE0kUIOmzeZ8iAQESryVIJCzps9uDIukTjPlKpcTnCpJOoxWCJAiQRCNBEgVIOg0k7pIYpSVIuvSM4PY4gSJOGtdWPkxisyXgSkv6ZCQIEmMlSKIASZ9kAUWCAiR99kESJH16Rgh7nBQ7OhNJECDp02lRJChA0meKTZD0WRCgSKIASZ9jbcHkTWTBxJIknk9i+3RaBEmfTosiAQGSPml0igQFSPrMGQPkuz1CrJD0cWGfgzFAEYy2z3o8QdKn06JIQICkz1I5RRIESPp0WhQJCpDELsEYTQ7G6LAkCQIkfXpGiqRLnKDavk5/FjOtxk1fvUm8AImWsERLWGIkLDESllgJS/pMTCkSFCDps4pNkPTp4ykSCe8CCe8CEUskvCtIxEmfTWSYH7j1CF+flvW+U1MftiO5oJQvSXrIBcrvJB5KktiFBLavIa1cFiRdcpAkSRAg6bKHmyQBARInYUmXE2ckCfaJE73HSdGseO8FSLrMGUmSIEASrARJFCCJIEDS5ZwWSdKlP9E+P5qtQ9mfdMmmEiR9LgkjSbrEiTFbRgKMLRZp+lwSRpKAAImRsMRIWGIlLLESljgJS/r08QRJl1PlJIkTIOnTx1MkEt4VJLwrSFgSJbwrCsRJUH0sgTyQMLEYSIQ+Tb1V28IZWGtKki5y2biTlAvMocsSYPrlXCfOlZZ0SQ+SJFGApMu2UZIkCJB4CUu6rDNSJF1ykGDzlUGJr2xW+vQnBEmfOSNFEgVIopMgQQESDOeTRKUlSLr0Jy6fEAAXsSRBAZI+eWGKpEucpBWljcS/fPEVSZe7PUiSIEBiJSyxEpY4CUuchCVewpI+fTxB0uUgK0niBUj69PEUiYR3RQnvihKWoIR3oUCcYJ/ZLyjcSFLqtCRxEiQoQKIlLNESlhgJS4yEJVbCkj7JAoKky14ikiQIkPRZ+6VIJLwLJLwLJCwJEt4VJOIE+1ji8mJmWpH5igT63OYDweZUVLBYkHS5ngaCz318QFuQ9BnVxz2NHotTGy8bpbqQ2Jx8ToOsgqTPqJ4i8RIkKEDSZfcgSSJhSZdjCCRJ6BMndo+TMuL7tF33SXSfUT1F4gVI+uz2oEhAgKTPgJsi6dKfoMobYMv9wqD7ZO5Q5xVTDKokCQIkfXZ7UCRegKTPbg+KRMQSFCDp8oZACo6dRMWSBAVI+uz2IEiiliAJAiRoJEgELOlzcwxJ0op4DztJwPskMW4fp6jMn74cNi0+tSF3PTaYfSpjbXwrEA5WoGZG8MMKNJpCZjSFzGgK2dEUsqMp1MyMfliB4mAFaiZ5PqpAzV1WH1YgGKxAzd3AH1ag0RSKo/lQHGw8ZMUHaFFt36Y/Q1kgI91S74ebLepagULfAhl1LNArhTXnU5xvhTvfCne+FV6fTwGnU8D5VsD5VgR1PoU/nwJPp4jufIrzrcDTrWhffdSR4vS4cNqcT9GlpQ0qU9j73XBa+N8GKhgPS/ZbeYwZrDwwVnmsHqw8g+kjngCINg+84+EM0TasdOIJAKpAfjSFfJAuUM58pz91WSDQY01NHITBChTcaAXCwQokngCgCoRqtAINp9BgPuTVYCkSbwS2Ovo++19CNhsCmoKkz9aUgJkkKluSBAESJ2FJl/eGKJI+d4QQJCAhV597wO7v1u10DxhB0uf6DorEC5D0OYpFkcD5JKC0BImXIEEBkj4XW90/BAB9DgEA7j2jciWJFyBxEpZ0efAAYL+8ErAk6bPVkSIJAiR9Oi2KJAqQdDpbRJBIWBIl6qTPDZn3SUKfKx/vXmyVSPrcdpJTSakxLHYhBm0kSCQsEbgHLJEEAZJOV3QRJChA0md/PkHSp9OiSEQskaiTPvvzCZI+r77dvfceOl1slT7fLFFWlyQoQIISlvR5Wu7uMwFpau8ESPq8eU6RgABJlzunSJIgQGIlLLESdeKUAEmfp0qdyY+uOls0kH1uavIu30ye/owlCQiQBAlL+jwt55zfSco6iVqCJAqQ9HnEmyLB80n6XKJEkkhYoq0ESRAgqU+CMCXb3lAYlLpPYazZxo/Gwj4g0hBrS3kK8qYLFTzxdUow6T27GYiv04rHtvoR1aHlqa4ppnW4rVUPMXzx8U0ZnFeZ3IBXlXET+0yOvfQnlspM7DP3lfHLZ1rKxHmVsZiVQXX/Y61d3l+ptTfFBsvGPWeTC/mqTH0w/LTKBJuVicSmXGvi1smnP/fg0+jfpPHTSmN1PgdnD7PaLE19X96S5kWa5TVNaa41BHpIGuWyNNp+LU0ye2KvIaSpr48uaV6kCUuahjT1k9pLmhdprjWr6CmNXV7TlGa1NS1p3LxzKEqa0TMY/rBDVivia63ybgitPHxhbWXmjTm9HvCwxddEUyt3Pk3qDs84vpx9rgkSsiDWHz9+1RwGb8Quqfnyc3HNw+ATg+fUXNssyCGRmjUffBRwRc1HT9FeUvPB8zGX1Hzw9OAVNcc1VpTXfPWh0pprtfpQec1haS6tuV5+Lq/5GiuKa26vNPfHuBUEDydd64o7l18PdO7wy2nt/U2ZK7W6jymTH0BLf4ZSmdH3pp6ojNNZmcOGsV2ZK828uioz+t7UD1TmShnvrsrAvC0woUxY0dRSZt4W2Pi9164oc6lMbFdlcN4xMKXMlTJsPZUx6kr53r7KzDueIZTRy2dayszbzoQ9CxEryph5e21CGTv40ZkPVGbeFphQxs3bAmPO6flKtrPxUuVSJhi/fKalzLy9NqEMzNtrE8qEFU0tZSbutff1psP58axMnDfbSSiDV9ql0FeZedcO7itj1bzZTkqZibMQ95UZ/ej4Byqz2pmGMkZ6JS7NR7Z7aAwoylYHOucKwDni6+DDVpIAXz6kWqkig5uN1ur9p+3LZpria63y1q/0575Dy/pwE1L8LPXTCpkP3Gp19Ehf+zrmUsfDHrr6tz5uru4PB3n3CgqrgoauIPFz5auCvu6HzFYMOBxA3Sto9RVjV5BfTdzYFQRmVdAHV5DeK6gyioMVQWNXUFgRNHgFwaqgD64gvz+rbMoKEs/Trwp6sILWMHvsCsI1SBi6gpxag4TBK2gNEsauIK1WBb2vgvKTuqmuVEXI5el9hDRrfaWTkHEJ2UVI8QfDLivkmvD0EdItj+wk5Goj+wjp10ysj5BwrTYy7kIe3iquP+ll9lfjTNTHj1+VCdcaGD6ijNOb06RhXUWZa7VijyhjEe4pE+f1GRvtroy5/7HWaTlna5a0U1gKOW+zZPMOz7ToVbqY+MNoz6KMv1h2tqcy11pY6KiMnrjBJpSZuJO/r8zFMoY9lVntTEMZe609yB2VaaREjNqKj+ZwC2ldmbxzyOh95Olvd9z6RqrgIQKbCQ7312SC8O0E+ZyO8bogAHM2wdkWBN2VAEsC+HYCg3vAFARRn01wtgXozibAcwmgcetaPwKjvplA27ywftionQm+vQ6039peDbYk+PY6SG3+RhCgILDubIKzLXC2J0F0JUHsUMnZi2LpRd6eTXC2BQAnE3TocAgCfy5BrO+U8W57yy8NnDLGbBjHwODjGMPgMQwey+CpX392H+MYPI5hj/ePY4DhB/XwSmOYDRNNgQmKgfEMTFU30NskAawtMPW0OoGJj2OQwYOP86CyDEx4HKMZPJphT709IDCP+wFa/zjGqccx9VjQKs/Wv9g0mVGOharqrQ/DPB2KKML6bIFC1acAJAofR0VV93GtY174MQoLVN2TtMtPb+vj4lJGRQ6q/vgNiQIOqu6FJIpll2eVEKojplTJuZb9IXuTUYGDakQKhUIOqn7xPYVCxULxuBp2YR4egv66jUrDw8BB1a/yoVBGsVCehWKpUb8lhUSxNHT1+LLHmX8RX9prFsqzUMhB1R+8J1GBgwosNQJL+cjiiizlI0t5ZCmPDeX35ISNRWvTeLqAQtVnoyTKc1BGs1DAQdVnmCSK0y8bZ1goTm9uPIurHssm5BGsSes1BaoRy5AXiXRQJVejNydQMXBQ9SdeSFRd+TRkz2kb/fWTitHWn8glUZ6FQg6qPiskUYGDMiw1DEt5y+KyLOUtS3nHUt6xlPcsNTxLDc9So35NduoMc6+HrkTVt+USKNeISrR6Rx3eukyt3A2GLFg9D0vCjOHBAgk7vpW2waxnwZxlwbzmwaotgVE6b25QX1wW8garJ01pmGfBAo8t8Ngij61+PQcJQx4bsmzz9TClYSwv8fXJMA0LLFh92xgNiyyYdTwYsmCOV91e8WC86gaecwGvugPPuQKvuiOPLbJsA9Vgyxlhow4b1DKsFQH5KuH0Z6zAIovNNgoZfYahr8ACC+Z4bK0IoGCeBQPLggXNgzXCNC8PJljFuaLmwXhsrf6N8EkEDiwoy4NFFkw7HgxZMMNjMzzbLK8CfKOQiDsO8bCijnADguECgQkM3KK2uhASGLk2troREohcRmQyRmW4QGY9NjbyuJBPErpoazDPgyELVu+aaVhkwSyPrd41kzCnmTXnkAn0lgkEblFbM1cayLWR2zw1NgC9Axi5jJHLiNx6RJanYr1xomHAgvEaJuQ1TGh4bPVRBQ1j9oFomc18Y5/Re4COC2S6NXIHQei5jMBlBG49Bl4oBV7g1ucsNIwXSsgLJWSycUYUqBSv7USlNRfouUBkAo3jArmMlstouYyOW48usPzGGx4MWDBQPJhnwQKPLTgeLDJrLgITiIoL5Lo1Mt1aK8cFchk1l1Ez61EbVihpwwpcbTUPxgol7RQPxmRj9YGaOQ9EzZwHJuDD9lXOJTmV98W4w3VkLzeMvZI83oxxSCQsicwGS0duTKL5drNCPtof0JZGPT75fJTCqNOtMPWQe5lav6HSnzuFjjdUPeJIVOSg6pOaNPfcREhTNH9EVY4jx3w5gomHjYaZAk+nCOdbUR+IdKWonxDrS3G+FXi+FXi6FVadbkXj3d2uFPWdi30pwukU9vy68I0GJKhMcTgetqEa722pfPMkfvG88YYKHK7YqMqYm3c89EAZBY0S5leS1WFIsaEat2zcR7UeFiFQjccUKJTnoBqXXhGoxrVHFKqlvNlRhR86p1koFpdXJMqWdvmG8tZnlCv8sLGX8YtIOd7YtKEaXC7u8VWWsHHnrcqnzWtR2boP9n4st+5KpVCBgfKNfbxpTnA4D3E82vA2XPeNnbzvAEYm0BguMDCBlsvYPApLAZunYUmg5wK5DlCfULwHyHUA4DIC1wEaB3jeAeQ6QOQ6QOTGY+Q6AHIZkekAjd2V7wEyHQC05gKZ8di4aes9QDYj0wHAWi6Q6wCO6wCOGY/guQ7guYzAdQBgxGPtmjadzyZZW2YGAbAHDeR0YDjck5lJGvcgpKkHZhILZRYR6jv13gMEJhC5RW00gyQwKGZRQ+usMg3kFtUwqyNYblGt4wK5NjbOfb0DyGX0XEbPZQRuPQLXV1v3INBAzwRGrstFrsu17kQggch1AG6b09gd/B5gYAK15gKZLheN4gI9F8h0gMht5Ro7pLQyuL+GZLDIFLYuyKJxyMFppRrn/pXN93Gnv4sU2QsQmcBGRoMGNmb7yrr9KVlbZKISsH4/tlYunzJLfxtfAhvNMc0IraLur84oGyuMjeb4HUAuY3RcIDKBjWtjSKBu+ioFbAzIElAdgFABeibQcBmNewcQKzYaZAIb08sUbns8OqUqwNgAegLoLBfIDOTWLVbvACIP2LivKEB+8Q2+vscmgVqPNGytDQaogDwHhAxQ4+JqAtSqszuXUiZYIyFAwoAFAx4b8NgCjy3w2CKPLfLqDXlsyLLNKsWDOR4ssmCNKw9JWHi8BWlsGkCTF/hcDQSPx3XjUiCCyXOK11i1JEDIAAGjgbMQGaDAYapvPsD8iuhxE0EG1TN1FIjDhFTvVQUxfK+1W4EAMbq8xkVKBKjxigcBYnTjznKYLMcmy/By5zj15Dge0bqWb0+ygzlcvnDLfydc48JcGockzroS5xs9D43j8UHjInGfX6HR3pkazjNxyMM1ZqE0jsmHTD7k8TXu3biL+2/61//98Y/PP/706y9/JtDL//33bz//9fn3397+9a//+9f2f3764/Ovv37+5w//+uP3n3/5+7//+OWHX3//+eX/fVJv//ibxjRn0WjxpUTp341y8J1R4NK/v5Quefp3OpjX8r78q0tLR+kf4eU/3L63Pn1vQypZKt3/Aw==",
      "brillig_names": [
        "lock_public_solver"
      ]
    },
    {
      "name": "refund_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "is_solver",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3564161243949231814": {
            "error_kind": "string",
            "string": "Function refund_public can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "9323748002447105156": {
            "error_kind": "string",
            "string": "NotPassedTimelock"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "refund_public"
      ]
    },
    {
      "name": "add_lock_private_user",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17476367995570638746": {
            "error_kind": "string",
            "string": "NoAllowance"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7b3druy8cp57L+t4HYhk8S+3EgSB43gHCzDswHY2sBH43nfP2UPqHqup5myOEslivT4wxlyf2Kp6qiTWW5LI//uX//lP/+P//K///rd/+X/+9d//8l/+6//9yz//6z/+w3/87V//5fav//sXCr//t3//3//wL7/++e//8Q//9h9/+S/WU/zrX/7pX/7n7c9g7H/+9S//z9/++Z/+8l9y+s+/vh5sadsPtuFxcMiFg92W/dfBzoT0/mDjs9ntuP3ttuNwm2zp+ODTfniI8XF0Lv66C24/msz27ej/9te/UASZEzIJZE7IZJApk/EbyJyQMSBzQsaCzAkZBzInZAhkTsh4kDkhgxr4jAxq4DMyqIHPyKAGPiETUAOfkUENfEYGNfAZGdTAZ2QIZE7IoAY+I4Ma+IwMauAzMqiBz8igBj4hE1EDn5FBDXxGBjXwGRnUwGdkCGROyKAGPiODGviMDGrgMzKogc/IoAY+IZNQA5+RQQ18RgY18BkZ1MBnZAhkTsigBj4jgxr4jAxq4DMyqIHPyExeA3t6kHk6vEzGGht2Swz5n5HJk9fAA8lMXgMPJFOugSmZBxn3ngwZs5tPxj/OcIP06wTu6hNQ6QTGWb/HyziX/PtT3A43x9E+PA72hYNzzsfdb9sMPRtUChf5p3g9WfJlvxdufyjbn4w9LMrRPNv/a1Rx5qctPiK9PS4yb0o+b4/MNk85ZHwsXmWHE08/7EzpmomZ9ss35uwq16OLe6DIPVjarcQyPm4i0VcONvERpmRC5eDt+GWzpfx88C/aCbQ70s6g3Y/27RYG3D1xm5/jNunQA/apginj9j7v9oRkH57eLClNbnGfCHNKT7+c78Zbyca7qvHGvzfebWY/g9sofjtF6ejkjjLWPrlq090gms0g39ugcJSmLkT7alDobVA8biEuPd1DfhlUyM5tx+npUVebX+NefznH/LhInuzYSjeRZM1+30vW28p977q7pDO7h9bZ2o3POfcoou3P7pIRgdcZ+ITADw38sLooI/AqA2+2uQMfdjt8TpXAk/V7lpBNT7/szN1Vo8dVq8dVN7WraTtuL9FVXL3N9fvBlshU7i7q71yEwOsMvEfgdQZ+7n5EPp5iZe8rgfcPo/2tNfY6q82twNPRybpV1aGW5CYcSW5dRJK/T/K5JTgif13ku2vwRI/IR1+7vcW4Pzq4KexvD9JLkX//3N3YTZOzZeV5u2gOZ2N4dvb3oLKGs8kfmfz0YsLZ0x6/90J+Pfl5ejjki88D3P7Ww+2nH78932t0xjrAOYdDgHMOxwPOOZwAOOdwIuCcw0mAcw4nA84pHLcBzjkcAzjncFAhv4GDCvkNHAKccziokN/AQYX8Bg4q5DdwUCG/gYMK+RwOoUJ+AwcV8hs4qJDfwEGF/AYOAc45HFTIb+CgQn4DBxXyGziokN/AQYV8DsejQn4DBxXyGziokN/AQYX8Bg4BzjkcVMhv4KBCfgMHFfIbOKiQ38BBhXwOJ6BCfgMHFfIbOKiQ38BBhfwGDgHOORxUyG/gTF8hj1v01ITpK+SRcKavkEfCmb5CHggnslTI+Vg31mSXK3COb8zIPX75ZtzdHo6iNNMjWDmH9/aY7PNxE8/B/PSzt2jFe+D6exDt8ZFofl5BoOhB9v74bfu8lMotp2//+h//9rd//ue//a///s//+o//8B9/+9d/+fdfQ7df/+/kOyibt8c3leHp+95te/OBUHVUbBqVmkblllHljxCqo0zTKNs0yjWNoqZRTbnhmnLDNeWGa8oN15Qb1JQb1JQb1JQb1JQb1JQb1JQb1JQb1JQb1JQb1JQbvik3fFNu+Kbc8E254Ztywzflhm/KDd+UG74pN3xTboSm3AhNuRGaciM05UZoyo3QlBuhKTdCU26EptwITbkRm3IjNuVGbMqN2JQbsSk3YlNuxKbciE25EZtyIzblRmrKjdSUG6kpN1JTbqSm3EhNuZGacqO8o5vbDpHotvy8oKy7j0pNo3LLqPIuWdVRpmmUbRpVzA1ntmOpeWvzt1GlRlAIRzP5aW+r38v5vhxNx5JU3j3F1N9jWt5h6UN7Hmv63a6zVLHHh7gf7UN6CHhPd4P8bAaF2QyKsxmUZjMoz2WQLW9jM9IgM5tBdjaD3GwGTXantlv/O3WkfeLzz2sP+uLqiv6xS4R/bkOXDk7+sSrt87KNxd0ib025oyvuHz9MxR56epRU3w79TTCA4A8JRhD8IcEEgj8kmEHwZwTNBoI/JGhA8IcELQj+kKADwR8SJBD8IUFokp8ShCb5KUFokp8ShCb5KUFokh8StNAkPyUITfJTgtAkPyUITfJTggSCPyQITfJTgtAkPyUITfJTgtAkPyUITfJDgg6a5KcEoUl+ShCa5KcER2gS8yCY3kMx6XiD1WTrKj9tKB+fb/pon3/6t6+kyFevyNegyNeoyNekyNesx1faFPlqFPlqFfmqqG4iRXUTKaqbSFHdRIrqJlJUN5Giuskrqpu8orrJK6qbvKK6ySuqm7yiuskrqpu8orrJK6qbvKK6KSiqm4KiuikoqpuCoropKKqbgqK6KSiqm4KiuikoqpuCoropKqqboqK6KSqqm6KiuikqqpuioropKqqboqK6KSqqm6KiuikpqpuSoropKaqbkqK6KSmqm5KiuikpqpuSoropKaqbkqK6KSuqm7KiuikrqpvySnWTzWH31W1P23CekYmPHUHN02+nkiVh2zd/DPbpc8fk7hgJGDkwrlTtDcS4UiE5EONKNepAjCuVvwMxrlRZD8PotpWK9oEYV9IDAzGuJDUGYoSKYcFIwMiBESqGBSNUDAvGlVTM7U4fD4y5Zogx0R4/bvL29Ou/QnAt9pVUjyDsK6kkOdjNSqpKEPaVVJgg7CupNkHYV1J5grATsI/AvpKKFIR9JdUpCDtU6hDsUKlDsEOljsBuoVKHYFesUu3md0uMvXlcwW5vYfo63Jr0BCWF0tFxO46O9vFuX7hjV6xSR2JXrFJHYidgH4FdsUodiV2xSh2JXbFKHYldsUodiV2xSh2I3SlWqSOxQ6UOwQ6VOgQ7VOoQ7ATsI7BrVqkupQM7Ua3xa8Nhiw3BP47OpmSLsfuP3x5YPx39K2CvR7t4WO6y+3b07zBpVrWCwqRZBQsKk2bVLChMmlW2nDAttQnowmHSrOIFhUmz6hcUJs1dAkFhIoRJQpjQhRARJnQhRIQJXQgRYUIXQkSY0IWQEKalttReOEzoQogIE7oQIsKELoSIMBHCJCFM6EKICBO6ECLChC6EiDChCyEiTOhCSAhTQBdCRJjQhRARJnQhRIQJXQgRYSKESUKY0IUQESZ0IUSECV0IEWFCF0JEmNCFkBCmiC6EiDChCyEiTOhCiAgTuhAiwkQIk4QwoQshIkzoQogIE7oQIsKELoSIMKELISFMCV0IEWFCF0JEmNCFEBEmdCFEhIkQJglhQhdCRJjQhRARJnQhRIQJXQgRYUIXQkKYMroQIsKELoSIMKELISJM6EKICBMhTBLChC6EiDChCyEiTOhCiAgTuhAiwoQuhIAw0YYuhIgwoQshIkzoQogIE7oQIsJECJOEMKELISJM6EKICBO6ECLChC6EiDChCyEhTAZdCBFhQhdCRJjQhRARJnQhRISJECYJYUIXQkSY0IUQESZ0IUSECV0IEWFCF0JCmCy6ECLChC6EiDChCyEiTOhCiAgTIUwSwoQuhIgwoQshIkzoQogIE7oQIsKELoSEMDl0IUSECV0IEWFCF0JEmNCFEBEmQpgkhAldCBFhQhdCRJjQhRARJnQhLgqTJX8gTLUwUT7C5Lctv4YJXQgJYSJ0IUSECV0IEWFCF0JEmNCFEBEmQpgkhAldCBFhQhdCRJjQhRARJnQhRIQJXQgJYfLoQogIE7oQIsKELoSIMKELISJMhDBJCBO6ECLChC6EiDChCyEiTOhCiAgTuhASwhTQhRARJnQhRIQJXQgRYUIXQkSYCGGSECZ0IUSECV0IEWFCF0JEmNCFEBEmdCEkhCmiCyEiTOhCiAgTuhAiwoQuhIgwEcIkIUzoQogIE7oQIsKELoSIMKELISJM6EJICFNCF0JEmNCFEBEmdCFEhAldCBFhIoRJQpjQhRARJnQhRIQJXQgRYUIXQkSY0IWQEKaMLoSIMKELISJM6EKICBO6ECLCRAiThDChCyEiTOhCiAgTuhAiwoQuhIgwoQshIEy3/w1hkhAmdCFEhAldCBFhQhdCRJgIYZIQJnQhRIQJXQgRYUIXQkSY0IUQESZ0ISSEyaALISJM6EKICBO6ECLChC6EiDARwiQhTOhCiAgTuhAiwoQuhIgwoQshIkzoQkgIk0UXQkSY0IUQESZ0IUSECV0IEWEihElCmNCFEBEmdCFEhAldCBFhQhdCRJjQhZAQJocuhIgwoQshIkzoQogIE7oQIsJECJOEMKELISJM6EKICBO6ECLChC6EiDChCyEhTIQuhIgwoQshIkzoQogIE7oQIsJECJOEMKELISJM6EKICBO6ECLChC6EiDChCyEhTB5dCBFhQhdCRJjQhRARJnQhRISJECYJYUIXQkSY0IUQESZ0IUSECV0IEWFCF0JCmAK6ECLChC6EiDChCyEiTOhCiAgTIUwSwqS5CxE2c4QpPhteDNPtJ80B5TlMJ0FN2x7UaHLtaLvl/Whr47ejf4dJcxdCUJg0dyEEhUlzF0JQmDR3IeSEKWruQggKk+YuhKAwae5CCAqT5i6EoDARwiQhTOhCiAgTuhAiwoQuhIgwoQshIkzoQkwRJnJuP5pS7ZFKIPt1cAiPkLpQCk5+PKzZnswoHxzMcXSwfqscbaIJO+/b39nVfj0fvEM2T7mYCgen26Olr4OTDfb54F95m9CWQd5KzFv0qZC3EvMWjTvkrcS8RScTeSsxbwl5i7wVmLfodSNvJeYtmv/IW4l5i6chyFuJeYvHQ8hbiXmL52XIW4F5m/G8DHkrMW/xvAx5KzFv8bwMeSsxb/G8DHkrMW8JeYu8FZi3eF6GvJWYt3hehryVmLd4Xoa8lZi3eF6GvJWYt3hehryVl7dhw/My5K3EvMXzMuTt44etj0feptpPmxQOq3/9Td+O/51deKqF7Louu/DsCdl1XXYRsgvZdVl24TkOsuu67MLTFmTXddmFZyLIruuyC08ukF3XZReeLyC7Lssug6cAyK7rsgu9emTXddmFXj2y67rsQq8e2XVddhGyC9l1WXahV39RdsXj3ZTbn9+P/g0ebexB4NHhHQQezc9B4NEXHAPeomU2CDy6SYPAo9EyCDx6EIPAE8CPAQ/lOgg8lOsg8FCug8BDuQ4Cr1i5Ohf3HrJx5G0FpbkZc7R6TYqPD/NCEfxmD/DWPh37C7tTrFtHYlesWkdiV6xZaYuH3WQoVrCH7fHpb3gcm+7PkpxiDcoLkgCSB6RijcgLUrHm4wWpWMPxglSsyXhBKtZYrCBJsWriBalYB/GChLJhAgllwwSSAJIHJJQNE0jNyiZQPkCG6kvN1sWdpHX5qVuf4sdNN9KsgwZi16yaBmLXrLHGYfeaFdlA7Jr120DsmtXeQOyateFA7ATsI7Br1p0DsUOlDsEOlToEO1TqEOxQqSOwB6jUP8ZO5liygWj7hv03SihPNpRQk2wooRDZUBJQcqGEkmNDCXXGhhKKiw0lVBQbSigjLpQRaocNJdQOG0qoHTaUUDtsKAkouVBC7bChhNphQwm1w4YSaocNJdQOF8oEtcOGEmqHDSXUDhtKqB02lASUXCihdthQQu2woYTaYUMJtcOGEmqHC2WG2mFDCbXDhhJqhw0l1A4bSgJKLpRQO2wooXbYUELtsKGE2mFDCbXDhDJuUDtsKKF22FBC7bChhNphQ0lAyYUSaocNJdQOG0qoHTaUUDtsKKF2uFAaqB02lFA7bCihdthQQu2woSSg5EIJtcOGEmqHDSXUDhtKqB02lFA7XCgt1A4bSqgdNpRQO2wooXbYUBJQcqGE2mFDCbXDhhJqhw0l1A4bSqgdLpQOaocNJdQOG0qoHTaUUDtsKAkouVBC7bChhNphQwm1w4YSaocNJdQOF0qC2mFDCbXDhhJqhw0l1A4bSgJKLpRQO2wooXbYUELtsKGE2mFDCbXDhdJD7bChhNphQwm1w4YSaocNJa2E0tGB0sVQOzqknaS7PZh5Ojrf0SylXnjRLKVGeNEspS540SylFnjRLFX9s6IJS1XzvGiWqs550SxVbfOiWap65kVDQHOGBtXwKRpUw6doUA2fokE1fIoG1fAZmrX2kudFg2r4FA2q4VM0qIZP0RDQnKFBNXyKBtXwKRpUw6doUA2fokE1fIZmrb3GedGgGj5Fg2r4FA2q4VM0BDRnaFANn6JBNXyKBtXwKRpUw6doUA2foVlrL2peNKiGT9GgGj5Fg2r4FA0BzRkaVMOnaFANn6JBNXyKBtXwKRpUwydo0lp7FfOiQTV8igbV8CkaVMOnaAhoztCgGj5Fg2r4FA2q4VM0qIZP0aAaPkOz1l62vGhQDZ+iQTV8igbV8CkaApozNKiGT9GgGj5Fg2r4FA2q4VM0qIbP0Ky11ykvGlTDp2hQDZ+iQTV8ioaA5gwNquFTNKiGT9GgGj5Fg2r4FA2q4TM0a+2FyYsG1fApGlTDp2hQDZ+iIaA5Q4Nq+BQNquFTNKiGT9GgGj5Fg2r4DM1aeyXyokE1fIoG1fApGlTDp2gIaM7QoBo+RYNq+BQNquFTNKiGT9GgGj5Ds9ZeerxoUA2fokE1fIoG1fApGgKaMzSohk/RoBo+RYNq+BQNquFTNKiGz9BgL7pzNKiGT9GgGj5Fg2r4FA0BzRkaVMOnaFANn6JBNXyKBtXwKRpUw2dosBfdORpUw6doUA2fokE1fIqGgOYMDarhUzSohk/RoBo+RYNq+BQNquEzNNiL7hwNquFTNKiGT9GgGj5FQ0BzhgbV8CkaVMOnaFANn6JBNXyKBtXwGRrsRXeOBtXwKRpUw6doUA2foiGgOUODavgUDarhUzSohk/RoBo+RYNq+ARNxl5052hQDZ+iQTV8igbV8CkaApozNKiGT9GgGj5Fg2r4FA2q4VM0qIbP0GAvunM0qIZP0aAaPkWDavgUDQHNGRpUw6doUA2fokE1fIoG1fApGr3VMLnNfh1NzodvaAqWUNyRGG+eLEklu8OWvg4O9umXk/sNXfEudwOh663gB0LXqw0GQterOgZCJ0DvD12vUhoIXa8GGwhdr7obCF2vbhwIHYq0P3TFO00OhA5FOgA6FOkA6Gsp0rQf7cj6b0f/dpY0ObuWAqs4u5byqTi7luKoOLtWpV9xdq0K+72zi+0aWXF2rYqy4uxalVzFWU0V1GK7L1ac1VRBLbZDYsVZTRXUYrsYVpzVVEEtttNgxVlNFdRiuwFWnNVUQS22Y1/FWU0V1GK76lWc1VRBLbbzXcVZTRXUYrvTVZzVVEEttoNcxVlNFdRiu7xVnNVUQS22E1vFWU0V1GK7pVWc1VRBLbajWcVZTRXUYruOVZzVVEEttjNYxVlNFdRiu3dVnNVUQS22w1bFWU0V1GK7YFWc1VRBLbZTVcVZTRXUYrtJVZzVVEEttuNTxVlNFdRiuzJVnNVUQS22c1LFWU0V1Fq7G5F7OFv9JtDE/bs9uz1+2SZTODYdPJLLlWPzQTzn78f+Br5UFScBOAF4X+BLVbMSgC9VUUsAvlRVLwH4UspCAvCl1M38wM221nZcIogvpfNEEIfY7E0carM3cVqKeDoWWUpkasRtOpZNco6ejk6l3/bmiKZP27ej7yTX0pEjSa4lEEeSXEv5jSS5lqQbSXItrTaQ5FqbwA0luZa2GklyLc00kuRaWmgkSQJJJpLQOFwkoXG4SELjcJGExuEiCY3DRHKtDfiGkoTG4SIJjcNFEhqHiySBJBNJaBwuktA4XCShcbhIQuNwkYTGYSK51pZuQ0lC43CRhMbhIgmNw0WSQJKJJDQOF0loHC6S0DhcJKFxuEhC4zCRXGtzv6EkoXG4SELjcJGExuEiSSDJRBIah4skNA4XSWgcLpLQOFwkoXGYSK61/eZQktA4XCShcbhIQuNwkSSQZCIJjcNFEhqHiyQ0DhdJaBwuktA4TCTX2iB3KEloHC6S0DhcJKFxuEgSSDKRhMbhIgmNw0USGoeLJDQOF0loHCaSa21hPZQkNA4XSWgcLpLQOFwkCSSZSELjcJGExuEiCY3DRRIah4skNA4TybU2mR9KEhqHiyQ0DhdJaBwukgSSTCShcbhIQuNwkYTG4SIJjcNFEhqHiWSGxuEiCY3DRRIah4skNA4XSQJJJpLQOFwkoXG4SELjcJGExuEiCY3DQ9Js0DhcJKFxuEhC43CRhMbhIkkgyUQSGoeLJDQOF0loHC6S0DhcJKFxmEgaaBwuktA4XCShcbhIQuNwkSSQZCIJjcNFEhqHiyQ0DhdJaBwuktA4TCQtNA4XSWgcLpLQOFwkoXG4SBJIMpGExuEiCY3DRRIah4skNA4XSWgcJpIOGoeLJDQOF0loHC6S0DhcJAkkmUhC43CRhMbhIgmNw0USGoeLJDQOE0mCxuEiCY3DRRIah4skNA4XSQJJJpLQOFwkoXG4SELjcJGExuEiCY3DRNJD43CRhMbhIgmNw0USGoeLJIEkE0loHC6S0DhcJKFxuEhC43CRhMZhIhmgcbhIQuNwkYTG4SIJjcNFkkCSiSQ0DhdJaBwuktA4XCShcbhIQuMwkYzQOFwkoXG4SELjcJGExuEiSSDJRBIah4skNA4XSWgcLpLQOFwkoXGYSCZoHC6S0DhcJKFxuEhC43CRJJBkIgmNw0USGoeLJDQOF0loHC6S0DhMJDM0DhdJaBwuktA4XCShcbhIEkgykYTG4SIJjcNFEhqHiyQ0DhdJaBweknaDxuEiCY3DRRIah4skNA4XSQJJJpLQOFwkoXG4SELjcJGExuEiCY3DRNJA43CRhMbhIgmNw0USGoeLJIEkE0loHC6S0DhcJKFxuEhC43CRhMZhImmhcbhIQuNwkYTG4SIJjcNFkkCSiSQ0DhdJaBwuktA4XCShcbhIQuMwkXTQOFwkoXG4SELjcJGExuEiSSDJRBIah4skNA4XSWgcLpLQOFwkoXGYSBI0DhdJaBwuktA4XCShcbhIEkgykYTG4SIJjcNFEhqHiyQ0DhdJaBwmkh4ah4skNA4XSWgcLpLQOFwkCSSZSELjcJGExuEiCY3DRRIah4skNA4TyQCNw0USGoeLJDQOF0loHC6SBJJMJKFxuEhC43CRhMbhIgmN82ckycb8dTQ5bytHG4rHb3vzZHcqeRm29HVwsOHpWPcVI6in6WMUocvmjxEU3/wxgpacP0ZQqfPHiBCj6WMEZT1/jKDZ548RugHzxwh9hvljhD7D9DFK6DPMHyP0GeaPkeI+gzsMMWFzFerWbtvX0Zbc9xjdSSruBjCTJJBkIqlYWTOTVKx/mUkqVqnMJBVrSWaSihUfL8msWJcxk1SsnphJQuNwkYTG4SJJIMlEEhqHiyQ0DhdJaBwuktA4XCShcXhIug0ah4skNA4XSWgcLpLQOFwkCSSZSELjcJGExuEiCY3DRRIah4skNA4TSQONw0USGoeLJDQOF0loHC6SBJJMJKFxuEhC43CRhMbhIgmNw0USGoeJpIXG4SIJjcNFEhqHiyQ0DhdJAkkmktA4XCShcbhIQuNwkYTG4SIJjcNE0kHjcJGExuEiCY3DRRIah4skgSQTSWgcLpLQOFwkoXG4SELjcJGExmEiSdA4XCShcbhIQuNwkYTG4SJJIMlEEhqHiyQ0DhdJaBwuktA4XCShcZhIemgcLpLQOFwkoXG4SELjcJEkkGQiCY3DRRIah4skNA4XSWgcLpLQOEwkAzQOF0loHC6S0DhcJKFxuEgSSDKRhMbhIgmNw0USGoeLJDQOF0loHCaSERqHiyQ0DhdJaBwukktpnOQPknmjb0ffvSVV3i6lFareLlXPV71dquauertUXVz1dqnateZtWqq+rHq7VA1Y9XapOq3qrapaaq09z6veqqql1to7vOqtqlpqrT24q96qqqXW2su66q2qWmqtPaGr3qqqpdbaW7nqrapaaq09iqveqqql1trrt+qtplqK1tozt+qtplqK1tp7tuqtplqKNlLlraZaitbaC7XqraZaitbaU7Tqrapaaq29Oaveqqql1trjsuqtqlpqrb0iq96qqqXW2nOx6q2qWmqtvQur3qqqpdbaA7Dqrapaaq299Kreqqql1tqTruqtqlpqrb3dqt6qqqXW2iOt6q2qWmqtvcaq3qqqpdbas6vqrapaaq29r6reqqql1tpDquqtqlpqrb2Yqt6qqqXW2tOo6q2qWmqtvYGq3qqqpdbaY6fqrapaaq29aqreqqql1trzJRt/eBtqR5uYvg62Tyvg2GQKx6aDR3K5cmxOu8k5fz/2Tnypek4C8bX2kBFBfKm6NsfdbDK0VY620dkdeczPR/sS89v9YIduTfh29J3kUjXzUJJL1eNDSRJIMpFcSkcMJbmURhlKcin9M5TkWtpqJMm1NNNAkmvtNTOUJDQOF0loHC6S0DhcJAkkmUhC43CRhMbhIgmNw0USGoeLJDQOE8m19poZShIah4skNA4XSWgcLpIEkkwkoXG4SELjcJGExuEiCY3DRRIah4nkWvsdDSUJjcNFEhqHiyQ0DhdJAkkmktA4XCShcbhIQuNwkYTG4SIJjcNEcq19yIaShMbhIgmNw0USGoeLJIEkE0loHC6S0DhcJKFxuEhC43CRhMbhIenX2h9wKEloHC6S0DhcJKFxuEgSSDKRhMbhIgmNw0USGoeLJDQOF0loHCaSa+3bOZQkNA4XSWgcLpLQOFwkCSSZSELjcJGExuEiCY3DRRIah4skNA4TybX20x1KEhqHiyQ0DhdJaBwukgSSTCShcbhIQuNwkYTG4SIJjcNFEhqHieRa+1wPJQmNw0USGoeLJDQOF0kCSSaS0DhcJKFxuEhC43CRhMbhIgmNw0Ryrf3nh5KExuEiCY3DRRIah4skgSQTSWgcLpLQOFwkoXG4SELjcJGExmEi6aFxuEhC43CRhMbhIgmNw0WSQJKJJDQOF0loHC6S0DhcJKFxuEhC4zCRDNA4XCShcbhIQuNwkYTG4SJJIMlEEhqHiyQ0DhdJaBwuktA4XCShcZhIRmgcLpLQOFwkoXG4SELjcJEkkGQiCY3DRRIah4skNA4XSWgcLpLQOEwkEzQOF0loHC6S0DhcJKFxuEgSSDKRhMbhIgmNw0USGoeLJDQOF0loHCaSGRqHiyQ0DhdJaBwuktA4XCQJJJlIQuNwkYTG4SIJjcNFEhqHiyQ0Dg/JsEHjcJGExuEiCY3DRRIah4skgSQTSWgcLpLQOFwkoXG4SELjcJGExmEiaaBxuEhC43CRhMbhIgmNw0WSQJKJJDQOF0loHC6S0DhcJKFxuEhC4zCRtNA4XCShcbhIQuNwkYTG4SJJIMlEEhqHiyQ0DhdJaBwuktA4XCShcZhIOmgcLpLQOFwkoXG4SELjcJEkkGQiCY3DRRIah4skNA4XSWgcLpLQOEwkCRqHiyQ0DhdJaBwuktA4XCQJJJlIQuNwkYTG4SIJjcNFEhqHiyQ0DhNJD43DRRIah4skNA4XSWgcLpIEkkwkoXG4SELjcJGExuEiCY3DRRIah4lkgMbhIgmNw0USGoeLJDQOF0kCSSaS0DhcJKFxuEhC43CRhMbhIgmNw0QyQuNwkYTG4SIJjcNFEhqHiySBJBNJaBwuktA4XCShcbhIQuNwkYTGYSKZoHG4SELjcJGExuEiCY3DRZJAkokkNA4XSWgcLpLQOFwkoXG4SELjMJHM0DhcJKFxuEhC43CRhMbhIkkgyUQSGoeLJDQOF0loHC6S0DhcJKFxeEjGDRqHiyQ0DhdJaBwuktA4XCQJJJlIQuNwkYTG4SIJjcNFEhqHiyQ0DhNJA43DRRIah4skNA4XSWgcLpIEkkwkoXG4SELjcJGExuEiCY3DRRIah4mkhcbhIgmNw0USGoeLJDQOF0kCSSaS0DhcJKFxuEhC43CRhMbhIgmNw0TSQeNwkYTG4SIJjcNFEhqHiySBJBNJaBwuktA4XCShcbhIQuNwkYTGYSJJ0DhcJKFxuEhC43CRhMbhIkkLkSRzHE0mh29H371dSYfUvV1JK9S9Xamer3u7Us1d93alurjq7VL719e9Xam+rHu7Ug1Y93alOq3uLanyVlUttdS+5HVvVdVSS+3vXfdWVS211D7ZdW9V1VJL7Tdd91ZVLbXUvs11b1XVUkvtf1z3VlUttdQ+wnVvVdVSS+3HW/dWVS211L62dW9V1VJL7Q9b91ZVLbXUPqt1b1XVUkvtV1r3VlUttdS+n3VvVdVSS+2fWfdWVS211D6UdW9V1VJL7edY91ZVLbXUvoh1b1XVUkvtL1j3VlUttdQ+fXVvVdVSS+13V/dWVS211L5xdW9V1VJL7b9W91ZTLZWW2ses7q2mWiottR9Y3VtNtVTaSJW3S9VSZNzubTRbwdulaqmqt0vVUlVvl6qlqt4uVUvVvF1qv6S6t0vVUlVvl6qlqt4uVUtVvSVV3qqqpZbaB6furapaaqn9ZOreqqqlltqXpe6tqlpqqf1N6t6qqqWW2iek7q2qWmqp/Tbq3qqqpZbat6Lurapaaqn9H+reqqqlltpHoe6tqlpqqf0I6t6qqqWWWte/7q2qWmqp9fHr3qqqpZZaZ77urapaaqn12uveqqql1lr3vOqtqlpqrXXPq96qqqXWWve86q2qWmqtdc+r3qqqpdZa97zqrapaaq11z6veqqql1lr3vOJtHtA9D3E/2ofknr29WzTgTrI9+G/h1aJyRli3B8K5mCoWuZC3/ei0vW5LlU8ahMwnST1Okjuc5KQLxXwS0+MktsdJXI+TUI+T+B4n6XHFU48rnnpc8dTjivc9rnjf44r3Pa543+OK9z2ueN/jivc9rnjf44r3Pa543+OKDz2u+NDjig89rvjQ44oPPa740OOKDz2u+NDjig89rvjQ44qPPa742OOKjz2u+Njjio89rvjY44qPPa742OOKjz2u+Njjik89rvjU44pPPa741OOKTz2u+NTjik89rvjU44pPPa74xHHFp3gcnTfzepK89TiJ6XES2+MkrsdJqMdJfI+ThB4nicwnMbZwEo4rPh2Pf1y227eTvB6djkcsyT2esNhkCsfebq1fx+b8/di78Vms8XbbNsnGG8nGW8nGO8nGk2TjvWTjg2Tjo2Tj5c6wN+Mlz7BG8gxrJM+wZu4ZNuzHmlstULB+7im2Zv3cc2zN+rkn2Zr1c8+yNevnnmZr1nPMs9nGw3ofK9a/f8fwZlGezSK7TWeRmc4iO51FbjqLaDqL/HQWheksitNZNN092013h3T975Bv31S/WeSns6j/tRbtwyIbXy2K01mUprMoz2YRbdNZNODqp3BY9OvjoIdFrwdbOgyxRPRqvpVtvpNtPsk238s2P8g2P8o2P8k2P09uvk0P818LMr/JNn/2Wbdi/uSzrvd7zWN9cO8PDtu2v04Wbr3tV18nn6I/8dXnmN/6Ovl87o/er/XRvD84bfsPJ3r60NqlL1cnn/s5XZ28TuB0dfKagtPVyesPTlcnr1UYXQ2T1zWcrk5eA3G6Onu9xOjqSvOq3xvnKYZvrhZ+2LjdZmv844fJlg5Oe83mtm+H3hGuNF8PQrhSHTAI4Ur1xSCEK9UtYxDGleqhQQhXqrMGIVypfhuEcPY2mgCEBIQ/RQh18mOEUCc/Rgh18mOEUCc/Rgh18lOECerkxwihTn6KMGvNwi3bA+HTS7tFhCntRnxbpqL4w7+WWtp/+deKSE8fA+XwxVxr2o5krlWFj2SuVbaPZE5g3p251sbASOZaOwkjmWttPYxkrrVXMZK51ubGOOZmgw7tzxw6tD9z6ND+zKFD+zMnMO/OHDq0P3Po0P7MoUP7M4cO7c8cOrQ7cwMd2p85dGh/5tCh/ZlDh/ZnTmDenTl0aH/m0KH9mUOH9mcOHdqfOXRod+YWOrQ/c+jQ/syhQ/szhw7tz5zAvDtz6ND+zKFD+zOHDu3PHDq0P3Po0O7MHXRof+bQof2ZQ4f2Zw4d2p85gXl35tCh/ZlDh/ZnDh3anzl0aH/m0KHdmRN0aH/m0KH9mUOH9mcOHdqfOYF5d+bQof2ZQ4f2Zw4d2p85dGh/5tCh3ZnPvnfwksyhQ/szhw7tzxw6tD9zAvPuzNXq0GMH9V+L2Lxn/nbZfrPUttyDEKpViWwIRW02m94fHMN+bIzh1VNJyfIzTyUJ+Z95OkI+m4enFePf/fRv+4dsb8ppvxFuvxVuvxNuPwm33wu3Pwi3Pwq3Pwm3X/j8m4TPv2nu+Zc2t+sU2nKu/LSjsHcdHKUns/325e3cszW3t3PP7dzekipv564buL2du8rg9nbumoTb27krGG5v5653mL3Nc1dH3N6qqqWy3Frqbr/c6uhuPwm3X24Fc7dfbk1yt19ulXG3f/K6wRwPNMgZqvx02ujr4OQevt4evBWOzWn/4Zy/H3vnMnmFMYiL3SavRYZxmbxqGcZl8vpmGJfJ66ZhXAhcilwmr/OGcZm8fhzGZfK6dBgX1LtlLqh3i1wM6t0yF9S7ZS40OZfjjXIy9rUfYM3sdUbN/tnrgZr9s8/bNftnn19r9s8+D1bst7PPVzX7Z59XavbP3u+o2T97X6Jmv/D51wqff63w+dcKn3+t8PnXCp9/nfD51wmff53w+dcJn3+HLIrNab/w+dcJn3+d8PnXCZ9/nfD5l4TPvyR8/iXh8y8Jn3+HLAbKab/w+ZeEz78kfP4l4fMvCZ9/vfD51wuff73w+dcLn3+HLILGab/w+dcLn3+98PnXC59/vfD5Nwiff4Pw+TcIn3+D8Pk3CJ9/g/D5Nwiff4Pw+TcIn38nX0mwav/kKwnW7Rc+/06+kmDdfuHz7+QrCdbtFz7/Tr6SYN1+4fPv5CsJ1u0XPv9OvpJg3X7h8+/sawNW7Rc+/86+fl/VfuHz7+xr7FXtFz7/zr4OXtV+4fPv7GvVVe0XPv/Ovp5c1X7h8+/s68lV7Rc+/86+nlzVfuHz7/TrydXslz3/uunXZ6vZL3v+ddOvd1azX/b86zbZ86+bfp2vmv2y5183/bpZNftlz79u+nWoKvZPv15UzX7h868RPv8a4fOv8PWvnPD1r5zw9a+c8PWvnPD1r5zw9a+c8PWvnPD1r5zw9a+c8PWvnPD1r9z0619dtq5o2I8122a/HXwHo3ah6xoYtStd18CoXeq6BkbtWtcVMNMvXjYMjNxdTO72y91t5G4/CbdfblVzt19u8XG3X26NcLdf7lR+t1/ujPvb/ulXFavZL3e3hrv9wuff6VcVq9kvfP6dflWxmv3C59/pVxWr2S98/p1+VbGK/dOvKlazX/j8O/2qYjX7hc+/068qVrNf+Pw7/apiNfuFz7/TrypWs1/4/Dv9qmI1+4XPv9OvKlazX/j8O/2qYjX7hc+/068qVrNf+Pw7/apiNfuFz7/TrypWs1/4/Dv9qmI1+4XPv9OvKlazX/j8O/2qYjX7hc+/068qVrNf+Pw7/apiNfuFz7/TrypWs1/4/Dv9qmI1+4XPv9OvKlazX/j8O/2qYjX7hc+/068qVrNf+Pw7/apiNfuFz7/TrypWs1/4/Dv9qmI1+4XPv9OvKlazX/b8S9OvKlazX/b8S9OvKlazX/b8S5vs+ZemX1WsZr/s+ZemX1WsZr/s+ZemX1WsYv/0q4rV7Bc+/06/qljNfuHz7/SritXsFz7/Tr+qWM1+4fPv9KuK1ewXPv9Ov6pYzX7h8+/0q4rV7Bc+/06/qljNfuHzr+DFv+72C59/BS+ldbdf+PwreGGqu/3C51/h61+R8PWvSPj6VzT7+lfB5d3+9Ovkb3/6o4Xl0u5hzt+PvXOZfF4fxmXyemEYl8nrkOu4vF+gkWZfYGwYmNlXLhsHZvKSbByYyWu9cWAmLyLHgaG5waTjpylRDUwM7uvgGMNxLNkvVycvZDldnbw25XR18nLzjat3+ycvC6v2T1691eyffXm6qv2T10JV+ycvWar2z11ZeEN+P9iEQntn8uXp6vbPPavX7Z97qq7bP/f8W7d/7vm3bv/c82/V/smXp6vbP/f8W7d/7vn32X5rbMF+OfNv2X4582/Z/snn32jicXDKBfsnn3+r9k8+/1btn3z+rdo/+fxbs3/y5enq9k8+/1btn3z+rdo/+fxbtX/y+bdqv/D5d/Ll6er2C59/J1+ezie37QfnkCo/Tflw9vlVprR9+Tr5XM3p6+TL3vH6OnkNwOrr5PUCq6+T1xasvpIiXyevWVh9nby+YfV18lroI19v7a79YEoFX1eqm2q+rlQ3VXydfLlCXl9Xqptqvq5UN9V8XaluqvlKinxdqW6q+bpS3eT9UTelQt00+RKPvL4uVTdVfF2qbnrrq598mUleX5eqmyq+LlU3VXxdqm6q+EqKfF2qbqr4qqdu8pMvzfnO17v9cmuhu/1y65vf9k++NGfYtt2Q4IIp2D93HVK3f+7aom7/3PVC3X4Sbv/c83rd/rnn6rr9c8+/dfvnnn/r9s89/1btn3xpzrr9wuffyZfmrNsvfP6dfGnOuv3C59/Jl+as2y98/p18ac66/cLn38mX5qzbL3z+nXxpzrr9wuffyZfmrNsvfP6dfAnNuv3C59/Jl6Ss2y98/p18gce6/cLn38mXS6zbL3z+nXzxwbr9wuffyZcJrNsvfP6dfO2/uv3C59/J1/6r2y98/p187b+6/cLn38nX/qvbL3z+nXztv7r9wuffydf+q9svfP6dfO2/uv3C59/J1/6r2y98/p187b+6/cLn38nX/qvbL3z+nXztv7r9wuffydf+q9svfP6dfO2/uv3C59/J1/6r2y98/p187b+6/cLn38nX/qvbL3z+nXyNvrr9wuffydfSq9svfP6dfM27uv3C59/J16ar2y98/p18Dbm6/cLn38nXeqvbL3z+nXxNtrr9wuffyddOq9svfP6dfI2zuv3C59/J1yKr2y97/g2TrxlWt1/2/BsmX9urbr/s+TdssuffMPm6WnX7Zc+/YfL1r+r2y55/w+TrX1XtF77+VRC+/lUQvv5VEL7+VRC+/lUQvv5VEL7+VRC+/lUQvv5VEL7+VRC+/lUQvv5VEL7+VRC+/lUQvv5VEL7+VRC+/lUQvv5VEL7+VRC+/lUQvv5VmH39K0r7wcEbW7B/8vnXxYP/bWDlp9NGXwcn99hn2SZTODan/Ydz/n7sncvk8/owLgQuRS6T1yHDuExe3wzjMnndNIzL5PXYMC6T13mjuMy+ftswLpPXpcO4oN4tc0G9W+ZC4FLkgnq3zAX1bpkL6t0yF7X1btiPNdtmC2DUFrwVMLOvmDgOjNqStwZGbc1bA6O26K2BIbFg7vbLrU7v9sutIu/2y6327vbLrcru9sstnn7bP/uqlFX75ZYid/vlVgx3++VO7Hf7hc+/s69KWbVf+Pw7+6qUVfuFz7+zr0pZs3/2VSmr9guff2dflbJqv/D5d/ZVKav2C59/Z1+Vsmq/8Pl39lURfcq7/cHUGmPG583t7S6fjTuOD1/eTn63euPt3f7J71ZV++e+W8UY94NjfHqGV/5pG4P/OtrG6J5/+u7s3Lc2Zmfnvg8yOzu3aGF2dm6Fw+vs5IsUMjs7t3ZidnZuocXs7Nx1zqfOZrs7m56qisNZ0uTsWhVUxdmVKihnt704dtbGV2dXqqCqzq5UQVWdXamCqjgbJ19m8mNnt7fOrjTPOjL70Y7s9ursSvNs1dmV5tmqs0vNszVnl5pnXU6Hs2Z7/9M+x/3W7XMu3M2WmpQ/IRO24z4fttdCNE6+9mSfnCmSmXxVy09vHe6obcibn11Nk6+X2YdMOWdWasU4Op6wOcrp1dm1SsSKs6TJ2bVKxIqza5WID2f901cRh7NLlYg1Z5eq+mrOLlXIVZydfMXTT6vWhyHexPc/bULa63kT6WkxNJe+0CxVgsRj6TcXs/tZ2Tr5MqcXkqmJwMkXUO2TM2UyS1VCj592f/dQqnCj2fLxwplxW+FGs1TdlCwdaApF4uRLxDI7u1TdVHN2qbqp4uzkK9UyO7tUm6rm7FJlX83ZpSq5mrOTfwfB+h57nH2tVWZvJ//Ggtnbyb+IZPZ28u8neb2dfQ1TZm8n/zaT2dvJv+Rk9lbul1Qt3tJa3jp6eOvtk7flo+3T0eGFzWKVFyubxeo0VjaLVXUfsCFzvIFD9ulZxk5msQqQkcxi1SIfmdnXCh1IZrEqlJHMYhUrI5nFqltGMgQyJ2T01sE1Mnqr4BoZ1MBnZFADn5FZrQY+U4mF307Ha12355Zb7bdz2p28YXza0dNvd5Kzrz0riORqNTYPyTub1apsTjar1dlvO14na82aYzl/Z22ueGvStq/8YZJ5ZhOL3m4Pb7fw7O3dotjfIvuwqPBF9cl6sCMtyrNZdLJm60iLzHQW2f4WUXjcWSrvjVo6bnGW6PWN2pNlVcWYT7LN97LND7LNj7LNT7LNz6LNT9vk5tv0MP+1IEtGtvmzz7oV8yefdb3fax7rww+/ZkqTT9Gf+Fr7PilNPp974w5fY2VxhbTtP5zoyeb9e6M0+dzP6erkdQKnq5PXFJyuTl5/MLqaJ69VOF2dfWb9xFW/m5Fi+OZq4YeNe3TOn9bN+fVN+uvBj09yt2+H3hHOPmELQLhSHTAI4Ur1xSCEK9UtgxCuVA8NQrhSnTUEYdpWqt8GIZy83yUB4eQ9NwkIoU5+jJCA8IcIjdbSenvsAmKeXlIpIkxpNyIbW/lhk5M5XsjJyT6Otzl8Mddai49krrV4H8lca7U/kLnVKg9GMteqJ0Yy1ypARjLXqlhGMicw785c6xObkcyhQ/szhw7tzxw6tD9z6NDuzB10aH/m0KH9mUOH9mcOHdqfOYF5d+bQof2ZQ4f2Zw4d2p85dGh/5tCh3ZkTdGh/5tCh/ZlDh/ZnDh3anzmBeXfm0KH9mUOH9mcOHdqfOXRof+bQod2Ze+jQ/syhQ/szhw7tzxw6tD9zAvPuzKFD+zOHDu3PHDq0P3Po0P7MoUO7Mw/Qof2ZQ4f2Zw4d2p85dGh/5gTm3ZlDh/ZnDh3anzl0aH/m0KH9mUOHdmceoUP7M4cO7c8cOrQ/c+jQ/swJzLszhw7tzxw6tD9z6ND+zKFD+zOHDu3OfPatW5dkDh3anzl0aH/m0KH9mROYd2cOHdqfOXRof+bQof2ZQ4f2Zw4d2p35UttyS2EOHdqfOXRof+bQof2ZE5h3Zw4d2p85dGh/5tCh/ZlDh/ZnDh3am3neoEP7M4cO7c8cOrQ/c+jQ/swJzLszhw7tzxw6tD9z6ND+zKFD+zOHDu3O3ECH9mcOHdqfOXRof+bQof2ZE5h3Zw4d2p85dGh/5tCh/ZlDh/ZnDh3anbmFDu3PHDq0P3Po0P7MoUP7Mycw784cOrQ/c+jQ/syhQ/szhw7tzxw6tDtzBx3anzl0aH/m0KH9mUOH9mdOYN6dOXRof+bQof2ZQ4f2Zw4d2p85dGh35gQd2p85dGh/5tCh/ZlDh/ZnTmDenTl0aH/m0KH9mUOH9mcOHdqfOXRod+YeOrQ/c+jQ/syhQ/szhw7tz5zAvDtz6ND+zKFD+zOHDu3PHDq0P3Po0O7MA3Rof+bQof2ZQ4f2Zw4d2p85gXl35tCh/ZlDh/ZnDh3anzl0aH/m0KHdmUfo0P7MoUP7M4cO7c8cOrQ/cwLz7syhQ/szhw7tzxw6tD9z6ND+zKFDuzNP0KH9mUOH9mcOHdqfOXRof+YE5t2ZQ4f2Zw4d2p85dGh/5tCh/ZlDh3ZnnqFD+zOHDu3PHDq0P3Po0P7MCcy7M4cO7c8cOrQ/c+jQ/syhQ/szhw7tzNxtG3Rof+bQof2ZQ4f2Zw4d2p85gXl35tCh/ZlDh/ZnDh3anzl0aH/m0KHdmRvo0P7MoUP7M4cO7c8cOrQ/cwLz7syhQ/szhw7tzxw6tD9z6ND+zKFDuzO30KH9mUOH9mcOHdqfOXRof+YE5t2ZQ4f2Zw4d2p85dGh/5tCh/ZlDh3Zn7qBD+zOHDu3PHDq0P3Po0P7MCcy7M4cO7c8cOrQ/c+jQ/syhQ/szhw7tzpygQ/szhw7tzxw6tD9z6ND+zAnMuzOHDu3PHDq0P3Po0P7MoUP7M4cO7c7cQ4f2Zw4d2p85dGh/5tCh/ZkTmHdnDh3anzl0aH/m0KH9mUOH9mcOHdqdeYAO7c8cOrQ/c+jQ/syhQ/szJzDvzhw6tD9z6ND+zKFD+zOHDu3PHDq0O/MIHdqfOXRof+bQof2ZQ4f2Z05g3p05dGh/5tCh/ZlDh/ZnDh3anzl0aHfmCTq0P3Po0P7MoUP7M4cO7c+cwLw7c+jQ/syhQ/szhw7tzxw6tD9z6NDuzDN0aH/m0KH9mUOH9mcOHdqfOYF5d+bQof2ZQ4f2Zw4d2p85dGh/5tChvZmbDTq0P3Po0P7MoUP7M4cO7c+cwLw7c+jQ/syhQ/szhw7tzxw6tD9z6NDuzA10aH/m0KH9mUOH9mcOHdqfOYF5d+bQof2ZQ4f2Zw4d2p85dGh/5tCh3Zlb6ND+zKFD+zOHDu3PHDq0P3MC8+7MoUP7M4cO7c8cOrQ/c+jQ/syhQ7szd9Ch/ZlDh/ZnDh3anzl0aH/mBObdmUOH9mcOHdqfOXRof+bQof2ZQ4d2Z07Qof2ZQ4f2Zw4d2p85dGh/5gTm3ZlDh/ZnDh3anzl0aH/m0KH9mUOHdmfuoUP7M4cO7c8cOrQ/c+jQ/swJzLszhw7tzxw6tD9z6ND+zKFD+zOHDu3OPECH9mcOHdqfOXRof+bQof2ZE5h3Zw4d2p85dGh/5tCh/ZlDh/ZnDh3anXmEDu3PHDq0P3Po0P7MoUP7Mycw784cOrQ/c+jQ/syhQ/szhw7tzxw6tDvzpFaHxvxgHt8zt8nsNDbzfOgdoVpZyYdQrUrkQ6hW9PEhJCD8KUK1kowNYZZU7af3B8ewHxtjePVUUo39M08lVbY/8dQO2Y/ePDytGP/up+/2G+H2W+H2O+H2k3D7vXD7g3D7o3D7k3D7s2z7jfD51wiff83s868PR0PQuspPG8q7qjE+2uefvjs7+2TN6uzsMzurs7OXAZ84a1M85E3KuXK0szntTjrzUE7hi8zsBcY4MrOXLuPIzF4UXUjGhXyQSfGJzOuxZA6KdMumF4qzl2YiKNrZC8TPKG5xp5jNVjk6HT4m93Dx1o0tHJvTbkbO34+9U5y9TJVBcaVieRzFlarwcRQJFBkorqUbRlFcS2OMoriWHhlFcS3tMoriWtplEEUH7cJBEdqFgyK0CwdFaBcOigSKf0Ix7MeabbMFjBAvLBihXlgwQr6wYIR+YcEIAcOBkZZSMPnxVGqrYjQUDzbePP12KlkStv0hVrBPL98n98VxKQ0zkONSKmYgx6V0zECOBI4sHJeSMgM5LlU9XsmR9oODN68cPebrP+QY9g/2Q0gFjorna28Os72jbxzvbBTPwVU2iufVKhvFc2WVzVK9vA/v24chNza+ct++nT7Rw5T88t6lX6qdN5Sk5pqMl+RSTb2RJIPmvh4vSS1K4e6tlnr+7q2WCv3uLS3krdtcPLzNNUOMCX4//Pb300o75hep119///1UWKlCH0typXp+LMmV6vmLSfJ9vRZWqv3lUF9JJ3xKPdrjx03eXIU669OHuJKqkMR9JQ0iiftKakgS95V0mSTuBO5DuGuu3S/l/v4tgIR65iLu798aSKhn/ph77YloQo3CxxJ1Bx9LAks2lpr7zZ/OU6xP/5Lm/vRY8qiJR5HX3NMeSx597UHkM5RgmfydDvTaOzpQYO/oKNZUdvPHTcrePK7c025POh/7LqYnKGm/SxFYsrFUrKnYWSpWSewsFesedpaKlQw7S8XahJmlm35TOkksFWsTdpYEln/K0h6P9O3t7wJLzON/zNLTtrP0vsQS8zgfS8zjZZa/6Uy/Xd1YOphr39FR3Ae01hz7t1n7fN9p+JbFLbWP31iSBJJMJDX3Cz8kyfalj1tqd0M51DVrl2/UgynM85rVSJ2OZn1RpbPUboef0nEpHXSIam942GCPDktwT0dn88VSsxr5CctYYKlZu/yAJdkCS83q5VOWhy02BP+NZcmWsB22hOf+dS76GQ/BnpKrHJ3s7mYi8+3Ye0wJMV0uppoV3aox1awXV42pZjW6akw1a+hVY6pZ+S8a06V2OEVM7zFF30RgTP3+6lbysRBT9G8ExpSO6/QJ4COm6COJjmlwhZhCn84QU+vdDsV6bwtxguacI07x2BgzGF+IE3SkjDhBG4qI01L7wa4cJ2g4GXGCLpMRJ2gtGXFCXT6FJs6PF91yqce41D61K8cJdbmIOHnU5TLihLpcRpxQl8uIE+pyGXFCHXFRnCz5A2HylTi5kNx+dEj5NU5L7Qu7cpxQR8iIE+oIGXFCHTFDnMgdG8OQS4X3IzTvUTxTnPLRh6WcCu8mad4Bec44+W0r3ffwvpGMOOG5how44bmGjDihHyEiTpp3lBYVJ/QjZMQJ/QgZcUI/QkacCHESESf0I2TECf0IGXFCP0JGnNCPkBEn9CNExCmhHyEjTuhHyIgT+hEy4oR+hIw4EeIkIk7oR8iIE/oRMuKEfoSMOKEfISJOGXX5RXEyx+4Azvjqe8vuiNOva6cQJ9Tl08UpF95bzoQ4iYgT6nIZcUJdLiNOqMtlxAl1uYw44TmhhDjRhueEMuKE54Qy4oR+hIw4oR8hI06EOImIE/oRMuKEfoSMOKEfISNO6EfIiBP6ESLiZNCPkBEn9CNkxAn9CBlxQj9CRpwIcRIRJ/QjZMQJ/QgRcbKoy5viFG0lTjHsC77GGI5jyX5hR5k9BDuq5iHYUQT/MfYY98Nt2lwFe3ZpR5jp1/mP23txLkj5MRc8HVyy2+ZkDi83+/7gmyvxCI75BiV9ZQAhAxgy4M4SJfAfs0w2Hyz9VmCJNv+fswx0sAzhlaXTfJf37rDb+mgqLHPcV5k3m3m6ud4Mv6PUfLsMmzlQxmfDiyhvP3lMVPZZPZ1UNWnfVej227l2tDHHrdhQrByd8g4lm8Ktxmm+ba8aU81djlVjqvkNDakxzdkdE+qWvgX19eCQDy9DNhXVlG6l0dfByQb7omyc5goS6fJxumh+XwXp8mm6kOb2PNLl43TR/FgB6fJxumh+HIJ0+ThdNDf4kC4fpwshXZAuf54u6I8ulS73oKJBumBQ0SFdMKjoYy4YVHQb1wuqR09wwaCicycvqGaz2xFV+v4suXB0Dsf7Vjkv82qnJ2SuvMx16bgfuWwL9yOo8RWjCjkuPaq5EFXo8RWjCkG+YlShyBeMaoAkX7BaCtDkK0YVL72sGFW8m7JiVAlRXTCq6C2tGFX0llaMKnpLK0YVXYgFoxrRhZg9qvc4oa8gI07oFMiIE7T/FHGy27HYkrWlOBHiJCJO0Ocy4gTFLSNO0NAy4oQ3LkTEKUE/zREn8kec4laIEyFOU8TpeN/bur+z5B4n1HtTxMn543r6tlb/ESfUezLihHpPRpxQ78mIE55WiYhTxvMnGXGCfpIRJzx/khEnPH+aIk7k9vcjLCVXOTrQvgVDCI8ekwul4OTHRhnbkxnlg8kdn/oTPQH5dfQ9XQjpgnT583RBdwbp8kG6oEmEdHnExrj9WYo3iSpHh+C2ww5nCsmFzhaS67LkQjsOyXVZcqGHiOS6KLn8hsYnkuuy5EK3Fsl1WXKhxYzkuiy50BdHcl2WXITkQnJdlVzouSO5LksudOiRXJclFzr0SK7LkgsdeiTXZcmFDj2S66rkMujQI7kuSy506JFclyUXOvRIrsuSCx16JFdjckV3ZEm8ESkkFyG5kFxXJRc69Eiuy5ILHXok12XJhQ49kqs5uZw/ksvHQnKhQ4/kuiy50KFHcl2VXBYdeiTXZcmFDj2SiyO5gi0kFyG5kFytyZUeyZVTIbnQ50JyXZZc6HMhuS5LLvS5kFyXJRf6XEiuq5LLoRWB5GpNLrLH45+b/YXkwis3SK7LkgsFPZKrNbmS34HEFErJhYIeyfWIDR27NHn6deqXdEGJjnT5IF3wcBnp8ufpQtBoSJen2Bh7xMb5QrrgATDS5YN0wUdXSJcP0gU9HaTLU2yO/rJPW+GrOyKkC9Llz9MFr4AgXT5IF/SAkS5PsQnbkS621gM2Nofjx922Fd52JHSBkV4Xphe6xkivC9MLXWak13Xp5dGVRnq1ppfbjgfwt79LX5p4dLGRXhemF7reSK8L0wtdcqRXe3rZ8JRerlqrPUJ/+zuY2vHep/2Fg9vfORfSl5C+SF+56YunCEhfwemLpxpIX8Hpi6cmSF/B6YunMkhfwemLpz5IX7npG/BUCekrOH3x1ArpO3H6bkf6hq3wpVnAUzGkb7/0Pbz8lb41awylR4AomcJTt4DOA9J33vT16ZG+sbAWU0DnAekrOH3ReUD6yk3fiM4D0ldw+uKNM6Rve/omOtLXWFtNR3MsWXP7mwrLBERCOiId50lHvBGGdJwoHfGGF9JxonRE3xTp2C8dw1M6psKqHhF9UKTjROmIvibScZ50TOhTIh37pePjS9dbOtaPrz6jT1DiSN950zfER/rGWEhfKHekr+D0hdJH+gpOX3QGkL6C0xedBKSv3PTN6DwgfQWnL77NQvoKTl98m4X0FZy+eD8V6Ttv+tZer86E9EX6yk1fPHVD+gpOXzx1Q/oKTl/0fZG+zelr7GMnFuNfV20JG/qySK8L0wt9U6TXhemFvibS68L0Qt8R6XUSm1hIF0K6IF3+PF3QV0O6fJAu6GMhXT5IF7ytjXT5IF3wdjTS5YN0QVca6fLn6WLQZUa6PGKT/Q7Q5+QL6YK+C9Ll8cNb2iMZjCndXQjpgnT583RB3wXp8kG6oO+CdPkgXdB3Qbp8kC7ouyBdPkgX9F2QLn+eLhZ9F6TLB+lCSBeky/HDhuKRLsEV0gW1C9Llg3RB7YJ0+fN0cahdkC4fpAu+NEC6PKXLcXSwf/dq9+vRydKeJcmGx0d7N5L33MJnBsitq3ILz7qRW1flFiG3kFsX5RaeoiO3rsotPHJHbl2VW3g+j9y6KrfQEEduXZVb6J4jty7KLUKrHbnVmFsmeHfsOhh8eN22LRBa80ivC9ML3Xmk14XphQY90uvC9CKkF9KrOb2ieaRXKqUX2l1Ir+b0Co/Vj0PcCm8MEzpeSK/m9Ir2MTlGCoX0QtML6XVdenn0vZBeF6YX+l5IrwvTC30vpNeF6YW+F9LrwvQipBfS67r0wuupSK/29ErhkV5PwB/phTdUkV4Xphe69kivC9MLXXukV3N6pW070isZU0gvdO2RXtelV0DXHul1YXqha4/0aq+9nl7ISaa6/7N9hP72dzC1471PR+PD+5wL6YunAkhfwemLpw5IX8HpS0hfpK/c9MVTE6Sv4PTFUxmkr+D0xVMfpK/g9MVTJaSv4PTFUyuk78Tpezy28GHbXtM34qkY0rdf+h5e/krfmjWG0iNA9Pe/f09fdB6QvvOmr0+P9I2FN6oiOg9IX8Hpi84D0ldw+qLzgPSVm74Jb5whfdvT1z+97R9K6YU3wpBeF6YX3thCel2YXoT0Qnpdl17oOyK9Lkwv9AWRXhemF/p2SK8L0wt9NaTXhemFN26QXs3plQ7et799fE2vjDdikF4Xphe69kivC9MLXXuk14Xpha490uvC9EJbFenVnF758XJ8yIEK6YW2KtLrwvRCYwLp1Z5e4TE55vj6pVncCOmF9GpMr2jNsSfb7W9fSC88FEJ6taeXd4/0SlshvfBQCOl1YXqh9kJ6XZdeBg+FkF4XphceCiG9/ii97umChzxIlw/SBQ9tkC4fpAshXZAuxw9bH490SfEHR9+TC0/4kFyXJRee7yG5GpPLpPD4QP/2NxXSCx1ypNeF6YUOOdLrwvRChxzpdV16WXTIkV4Xphc65EivC9MLHXWkV3N63bpaR+CjN4X0Qgce6XVhehHSC+l1XXqhZ4/0ujC90LVHel2YXujaI70uTC907ZFeF6YXuvZIr+vSy6Frj/S6ML3QtUd6XZhe6NojvS5ML3TtkV4Xphf6Xkiv5vRK27ExdUqm8BmHg3JEejWnV366e2VXuHsRlGP/9LqTh6gaRR56YxR5lOIXkY9EB3nyBfIE8oPI47WLUeShzEaRx8P6UeTxHHsUeQj1q8jHR1UZzSt5Dw07ijw07Cjy0LCjyEPDjiJPID+IPOr5q8jnR1WZwyv5gNrmIvKJ9ucuNnlXII/aZhR51DZl8nc6qD/e0SHQeUMHveh3dNAvfkcHNeA7Oui7vqOD3ugbOhE1/js6qMPf0UGt/I4OauV3dEgxnWyPF29tzvEbndfjw/ZYbP2pS5O+3qKMmutqXpKaa3BekprrdV6Smmt7XpKadQAryaS57vuQ5PHiTnj6futBEnP3H5MMj89aUoEk5u4yyTsdzMfv6GCOfUdH8bzpXNzvOsaRt5V7lLkZc6wSbFJ8fFIZ7iyz4m4bO0vFvTl2loorOnaWivt+7CwJLNlYKtYa7CwVqw12loq1CTPLtKG+/IDl8cG4MXkzTyxfj84m7pZn87T2xc4dc/5F3O22/3i2Nr1wJ3Afwh21xBjuqDvK3O90UEm8o6O4y/kHdDR3Ob150PFPVeVBx2iuK+t0NHci63Q09xbrdDQrhzodAp03dDRX4XU6mmvlOh3NtXKdjuZauU4HtfIbOpp3Mf8DOppr5ZCPTpCL5judwq/bvL+G6Zyhv+8Fad5vmpmk5hqclySB5J+SvB1/kPz2ROn1WDIHdbLm5emT5s11B1LXrC++UbeleV6zvggpP9EJBTqa9UV05kHHmx/OOJq1CCtJzfs4MpPUrHE+JMk3H2veyW8gdc3a6Rv18Lp2ZXKkugpKT3QKz9ydYt1CWzzsJkOxcsW+/yI3ad4HkJmkYt3CTFKxxmEmqVjj8JLUvOMgM0nFdd+nJN+uAZE07xT1Kcm3a0AkzTs/vSV5p4P5+B0dzLFv6Gje5YicO551kPu7fRJej7cx7r9++/PlCw7NuxYxk1Tc72MmqbmW4yVJIMlEUnNvkJekZn3xGUkTgzv8jIFeWWpWGNwsNesRbpaa1QszS827nrGzRGX55yzjY22X29/5hSXm8Q9YxvRgmcILS8zjfCwxj/OxxDzOxlLzzkbsLNG15GOJviUfS9SXZZZ3OgQ6b+igw/iOjma1QY+7DnlLBTqa9UOdjmZFUKejucav0kmaq/Y6Hc11eJ2O5sq6TkdzrVynQ6Dzho7mWrlOB7XyOzqold/R0VwrBzrWSaCQ3Dc6r8ffQOyGW7c9vaWa4hdLzZU1M0vNO5Wxs9RctXOz1Fzj/4ClsQWWmhUBN0sCSzaWmtXGhyzdUWBal32BpWZtws1Ss5LhZgndw8cSuoeLZda8gx47S+gePpbQPXwsoXv4WBJY/ilLT7ub1j+vFnewRH3JxlLzjmUfsrz12ezx689HHywxj/Ox1DKP373VMtPevdUyF969XapL5+jw1sVQO/qxwLuL7qkq2vIXm6W6bsxslqpymNks1RVjZrNUl4uXzVp7jjGzWap6ZWazVDXKzGap2pWZDYHNKRvUxedsUBefs0FdfM4GdfE5G9TFp2zW2tOKmQ3q4nM2qIvP2aAuPmdDYHPKBnXxORvUxedsUBefs9FbF5OJOxsyefvGpvDbb3fszGvtsDSO41r7Kw3kqLc2/5Aj206mmfTW/OOY69USZJ07yMRUYU4p779Nt6c2laN93H/a5yd86Qs6AXp/6HrVz0DoemXVQOh69dpA6IqF4GfQs39AD/lVUq+1EeBIkmttGngpyXxc29vzIkEHScVy8FOS9iBJqUBSscj7lORh9uZDgSSkGxdJAkkmkopFltv2Ox+5v2NTsITijsR48/yZUsnu91vB57U2GBRDXbHMGkhdsc4aSF2xJhtHfa2NEMVQV1xXX0md9oODNwXqqGEuoR72nw4hFaijhvlD6t4cTnpH36jfSaIu4SKJWoOJ5FobMA4lqbj/++HsdJh9I+krs9PN2EQPw/PL6ylrbdUoiDtq4DHcCdyHcEffegx3Larv7q0WtXX3Vosiunu7lmpJ+9GOrH/1dq2N/tLxHs2v5VQL3q40O5A5jiaTC5m81IZYt+nqeL4dzVbwdqXrturtUptK1b1dSbVTfLypkbatcnQ6fEzu4aJNpnBsPm72OX8/9k5xpXv9OIorKepxFAkUGSguVc8Mo7iSdh1HcSVNPI7iUjX7MIpLaYExFGlbagOncRShXTgoQrtwUIR24aBIoMhAEdrljyiG47nb7SZYwAjxwoIR6oUFI+QLC0boFw6MS+1cNxDjUrX3+6emN2+XqpGr3pIqb5eqOe12rBpiKRW8Xao0rHq7VAVX9XapQqvq7VL1UM3bpbYgq3u7VH/U+d1sos1Wjg7h+H41PQo6a/IXmaXqLlYyS9VorGRIyXthBRlzrAFoTH76adrRLFX88aJZ6n32928B37xd6n32qrdLvc9e83atbary8TXrr9UsKkebuM8MdnOVlg/jc5y1Nr8SQXypbzZEEF/qK9o5iFeazmvt/yUD+VLfzspAvtRnszKQL6V1ZCBfSnDJQL6U6svHSmlkqNbssNHt6yDY+G0LJl+Cbo7l7JI14dvRv0mutRHbUJJrKcWRJNdSgCNJrqXsRpIkkGQiuZYOG0lyLXk1kuRaqmkkybXE0EiS0DhMJNfaX2woSWgcLpLQOFwkoXG4SBJIMpGExuEiCY3DRRIah4skNA4XSWgcJpJr7cE1lCQ0zh+SzGG3JOVkCiShcbhIQuNwkSSQZCIJjcNFEhqHiyQ0DhdJaBwuktA4TCTX2ifwQpJ5s9vX0Xl73v3oIAmNw0USGoeLJDQOF0kCSSaS0DhcJKFxuEhC43CRhMbhIgmN86ckY95J/t659O9JJmgcLpLQOFwkoXG4SELjcJEkkGQiCY3DRRIah4skNA4XSWgcLpJ6NY57rDzubAoVkiY+LImBns3+DXKpzZ2HgtSrcJhB6hU4zCD16htmkASQPCD1qhtmkHrFDTNIvdrmQ5A570fbbauYHbZtf0QRNlOgrlcHXUjd50M0lalDM/0p9WPlb7s5+95setpz5GlDBZeKLuaHjymHp00VcvgdJLPURtjLBglaT0CQoCMFBAkaVUCQCEGaP0jQ1gKCBN0uIEjoCQgIEloIAoKEjsP8QVpq5/plg4SOg4AgoeMgIEjoOAgIEiFI8wcJHQcBQULHQUCQ0HEQECR0HAQECR2H+YNk0XEQECR0HAQECR0HAUFCx0FAkAhBmj9I6DgICBI6DgKChI6DgCCh4yAgSOg4zB8kh46DgCCh4yAgSOg4CAgSOg4CgkQI0vxBQsdBQJDQcRAQJHQcBAQpIUjzBwkdh/mDROg4CAgSOg4CgoSOg4AgoeMgIEiEIM0fJHQcBAQJHQcBQULHQUCQ0HEQECR0HOYPkkfHQUCQ0HEQECR0HAQECR0HAUEiBGn+IKHjICBI6DgICBI6DgKChI6DgCCh49A1SL+hB3QQBkBHR2AAdCj8K6C7fdcniqkAHYp9AHQC9D+Cbs3hpDVPlnj6AgmVzAQSSpYJJNQmE0gowj8F6dwBMudXkFBtPCAjlBgTSKgrJpBQTEwgoYKYQBJA8oCEsmECuVRB7tKBhqz/dvTd26Wq5qq3S5W2NW/TUvUnuYe3MVSOvuX1o/d2HGuTKRybDh7J5cqx+UCe8/dj78SXKlRFEF+qohVBfKnSdw7iYT/WbJstICcg7418qXJaBvKlHinIQL6U1pGBfCnBJQP5UqqP0v5agUtkashtOtg4R09Hl17pc94c4fRp+3b0b5J5LUU5kuRaSnEkybUU4EiSaym7kSQJJJlIrqXDRpJcS16NJLmWahpJci0xNJIkNA4PSbtB43CRhMbhIgmNw0USGoeLJIEkE0loHC6S0DhcJKFxuEhC43CRhMZhImmgcbhIQuP8GUmy7vExv7cFktA4XCShcbhIEkgykYTG4SIJjcNFEhqHiyQ0DhdJaBwmkhYa509JxryTdH9HsvDbdHyaabx5sjuVvAzb/spnsE+vhyb3FSOop/ljBF02f4yg+OaPESFG08cIKnX+GEFrTBAj2g8O3rzGyKGumyBGwe4xCqkQI9R1l8TImwOJf/7tRF/cUauN4U7gPoQ7aqox3PGc4Jo5+HDyxt1X5uCbaw9Tss3xOD58RQnPICRECZpDQpTw7ERAlAjPZSRECQq+FKU7GyjnczZQt+dsSC8b97g7hc1V7mW3Z/f7dji3hCo82yfFmpKZpGKVyExSsZJjJqlYbTGTVKyIeEl6xaqFmaRiZcFMUrEOYSapWLUwkySQZCIJjcNFEhqHiyQ0DhdJaBwuktA4TCQDNA4XSWgcLpLQOFwkoXH+kKS3+9G3IrxEkkDyz0iSywfJsFWO5tujygZop9kjBE02e4Sg9WaPEDTk7BGCNp08QhGad/YIQUvPHiFo9NkjBO0/e4QIEZo8QugpzB4h9BRmjxB6CrNHCD2F4RF6v52xjWgqzB6ihK7C9CFCW2H6EKGvMH2I0FiYPkSEEP04RHeS6ABwkYRS5yIJMfCHJH2IB8lcX10rb27/cZ+f1lr8Wh8jy5347vbLnRXu9k9+L87uSJ9MVPnpW+dyN+TWInPPP313dvLbJa+zk/cIeZ2dvN3G6+zkcxWns272beR5nZ28mcLr7ORtCV5nJ69zPnQ270ti3+QxvTpLmpxdq4KqOLtSBeXslh9mx1dnV6qgqs6uVEFVnV2pgqo5O/sm1Z86u711dqV59taY2X/akd1enV1pnq06u9I8W3V2qXm25uxS86zL6XDWbO9/2udjaWKfc+FuttSk/AmZsB33+bAVCtHZ93ftkjNFMrPv1/rhreN4buPoaYespqtp9l1Su5Ap58xKrRhHMRxkcnp1dq0SseIsaXJ2rRKx4uxaJeLDWf/09s3h7FIlYs3Zpaq+mrNLFXIVZ91StdntqjycNbHy0yHt9byJ9PTaiEtfaJYqQWI6FG/M7mdl6+wbXV5HpiYCZ9+KskvOlMksVQk9ftr93UOpwk9v+fhp47bCjWapuinZw+xUKBJn3xaR19ml6qaas0vVTRVnZ9/rjtfZpdpUNWeXKvtqzi5VydWcxVcev3679xv1DjuRDeKONRnGcMdKCxdxd/Tg/rR+czg52j4dHV6ihO+rBEQJu7OJiBKWXBgfJTLHOxtkn7rfe4yw5sL8McKiC/PHiBCj6WMEpT9/jNAVmD9G6CDMHyN0G+aPEXoN08cIeyQKiBH6DPPHCH2G+WOEPsNVMTrrkxZ+O7nj1VwTQu238+HlLaBPXvrtK6aEmC4XU/Qx5o7pPUroZEiIEnoZvaP0m7vmffhsOko256hC8tf+D3vN5nyVO8VHOfj0DopJxe8WaD84PH2Za5L7ipFiXTVPjOLOLyRfiJFiXSUmRop1lZgYEWI0fYwU656JYmSOGIVCjBSrHjExUqx5xMRI8fPbeWIUdg0bQirESPHzWykx0rwzn5gYoc8wf4zQZ5g/RugzzB8jQoymjxH6DPPHaCl95OiI0a2DUjn61440D+rPR+efU3//RGit3Qfnof6+75mX0jBiqC+lSsRQX0pniKG+lHKYiPrbHq/gPVklU1+quhdDfanngvNQf6+SZt9bd1Hq0KYjqEOb9qdOs297vCh1aNMR1KFNR1CHNh1Bfal6fXMH9S3XDDEUaH+scfs7Pf36rz3vXo63Pu1f1d7+fIKS4hfLparwwSyXqq0Hs1yqYh7LcvbNq0WxXKq6HcxyqZr1WpbxWErDRtoKLJeqRAezJLBkY7nUE43BLKF7+FhC9/CxhO7hYwndw8Zy9h3ZZ2IZ8m747U9XYIl5/I9ZprQfbvPmCywxj/8py1uT+fHrtqAhZ9/UXBRLzON8LDGP/znLaI9fT9/nns+O/k1+9v3hFyaP3ug15EPyx6cv6WnVzfDFHXXuGO7ouY7hTuB+Dfd8QAnZxhfu0IBjuEMvjuEObTmGO3ToGO7QrEO4ExTrGO7Qq1dxfyzVkP0rd+jVMdyhV8dwJ3Afwh16dQx36NUx3KFXObj/ZulRk/8py+/v4VCBJepsPpaonflYoh7mY0lg+ccs7YOlqz51t8e+qM4Z+vs536PGHcMdNe4Y7qhxL+LuQj64p2dt8cmx9xjh+c38McKznuljFKBBx8fo/b70FKBt548RNPP8MYIW54jRnSWB5R+zfOwcHmMqsIS+/nOW6fiGMObCNzEBmrkpL4ssoYP5WEKvsrGMqIf/mGXyu5u3P0ssUbfysUR9yceSwJKNJerLP2dJ9j1LzON/zrKyRsVa+0ePZbnWPs+DWaK+5GOJmoiPpebehnPbwdLlUGFpYvRuP/729wPLVy84ae5tcLPUXBNxs9RcE33MMqYHy6dd175YrrVv7GCWmmsibpaae27cLDXXl9wsCSzZWGruuXGzhO7hYwndw8XSr7X344cst2NHdUOGYoVleHxU6s1TZ8N9kdRcXX5I8u1O9n6tPRqHktRcWfKSJJBkIqm5qvyUpDlIhgJJzTUlL0nNFSUvSc199A9Jvt2916ve2ZOVpOp9PXlJQuNwkYTG4SIJjcNFkkCSiSQ0DhdJaBwukorrSeeOZeyMI28rJI1J6eiym7w976zxenQ2cbc8m5fVCbxVXH0O5a64Vr2WuzU7lGztK3fFle1Q7orr4KHcCdyHcFdcY1/M3ZmDu8sv3BVX5EO5K35GMZS74icaQ7lDrw7hrnlf4KHcoVev4r7ZRx2ZXrhDr47hDr06hjuB+xDu0KtjuEOvjuEOvTqGO/TqGO7Qq0O4a94VeCh3xfW7zfZYFcfmXH0z4/2XY5r3Pf2U5PtvSzTvZMpMUnHVzExScR3MTFJxZfsxybdf6ZDiWpWXpOb9b5lJKn7+8SnJ92/6at77lpkkNA4XSQJJJpLQOFwkoXG4SELjcJGExmEiqXnHSRs2c5CMz4YXSd5+0hxQgq8cbWN+7Kv3dyuQ3clrrj8vJZ/s3r63yaUCec316ljyBPKDyGuuh68lvx172CUTC+Q1189jyWuut8eS11yfjyWv+ZnFUPJR8zOOseShYUeRh4YdRR4adhR5AvlB5KFhryIfH3vhxkL3IELDjiIPDTuKPDTsKPLQsFeRPyy/kc+v5DXvLT2YPDTsKPLQsFeRp3SQ965AHhp2FHkC+UHkoWFHkYeGHUUeGnYUeWjYUeShYQeR17zn+rXkw7Eswu23c+1ocm4/mpKrHB3o8Zbyo/PvQik4OR179W5PZpQPDtbvAINNtZ/+tfLD8XJ1Sr9MfTr+nl4QLUiv9vSiR+Cf716P9CKkF9LruvSC/ER6XZhe0NhIL570CraQXmgkIL1+kF70SK/oa7+eD94hP7+NlAoHJ3v8drJPmXs7+J646MMgcUUmLtpYSFyBiRs2vMmCxBWZuHgRCIkrMnHx3AWJKzJx8UQHiSsycQmJi8SVmLh4CoXEbU7cbA+At7/Dt+Pv6YVuK9Kr/b6YH28A5e31DaBgoNCRXu13L/MIfHamkF6E9EJ6XXf3Qu2F9OKpvVwpvfAGENLrwvTCG0BIrwvTC8oR6XVheuFtGqRXe3q5R8M2E72ml8U7L0ivC9MLfS+k14XphfdHkF4Xphfe8kB6XZhehPRCel2XXujaI73a06v2zNGia4/0ujC90LVHel2YXujaI70uTC907ZFe16WXQ9ce6XVheqFrj/S6ML3QtUd6XZhe6NojvS5ML/S9kF6PHzbH0bdM22rpFa07fjzeXCikF/peSK8L0wt9L6RXe3oF90ivmAvphb4X0uu69CL0vZBeF6YX+l5IrwvTC30vpFdzerntiE68JUohvdD3QnpdmF6E9EJ6XZdeeFsV6dWeXvSUXt4X0gtde6TXhemFrj3S68L0Qtce6XVheqFrj/S6Lr08uvZIrwvTC117pNeF6YWuPdKrPb3cc3oVFh736NojvS5ML0J6Ib2uSy907ZFe7el1+Pjr78IbEx5de6TXhemFrj3S68L0Qtce6XVheqFrj/S6Lr0CuvZIrwvTC117pNeF6YWuPdKrPb3iU3rlrZBe6NojvS5ML0J6Ib2uSy907ZFezelF5lh4PNJTeB7pha490uvC9ELXHul1YXqha4/0ujC90LVHel2XXhFde6TXhemFrj3S68L0Qtce6dWeXttzehV2RIvo2iO9LkwvQnohva5LL3TtkV7N6WXTY3VCcr52PDlzHE/FBZsiuvxIx37p6PwjHb2pHp/8YTylmArpi6cISN9+6evpkb6hpHzx1AHpOOZuWkxHPKVAOs6TjglPNZCOE6UjnoIgHSdKRzw1QTr2S8cYHumY7c+VeMJTGaRvv/TNj7vpreVeSEdCOiIdR9xNy+mIpz5Ix4nSEU99kI4TpSOe4iAdJ0pHPMVBOnZLRzLxkY7OMShxPPVB+vZLX/d0N6XCyusZT32QjmPupsV0xFMfpONE6YinPkjHidIRT3GQjhOlIyEdkY5XpOM9vfBUBul1YXrhKQvS68L0wlMTpFd7evlHetm0FdILT0GQXhemF55SIL0uS6+44akD0uvC9MJTBKTXhemFpwJIrwvTC11+pNeF6UVIL6TXdemFrj3S68L0Qt8L6dWaXrdnPscj7VuDPhfSC30vpFfz3Wt7BP72d3hNL4O+F9LrwvRC3wvpdWF6oe+F9GqvvfL2lF62kF7oeyG9LkwvQnohva5LL/S9kF4XphfeVkV6XZheeFsV6XVheqFrj/S6ML3QtUd6XZdeFl17pNeF6YW+F9LrERvj8h4bk6hydKSw//btz8IDbUtILiTXVcmFnheS67LkQscLydWaXMHscY/BxkJyod+F5LosudDtQnJdllzodSG5rkouh04Xkuuy5MLbqUiuy5IL76YiuS5LLnTokVyXJRf6XEiu1uTyac+S6HPh2aKDWkRytSZXzLvRMTnzmlwEtYjkuiy5oBaRXJclF9Qikuuy5IJaRHJdllyE5EJyNSZX8uZIruAKyYX3uZBclyUX+lxIrsuSC+9zIbkuSy68z4Xkuiy50KFHcl2VXB4deiTXZcmFDj2S67LkQoceyXVZcqHPheRqTa7n97lKHXqPPheS67LkQp8LyXVZcqHPheS6LLnQ50JyNSdXON6KCDG9JlcgJBeSqzG54sEvRkOF5IJaRHJdllxQi0iuy5ILahHJ1Vxz5fhILl9ILqhFJNdlyQW1iOS6Krkini0iuZprrmOH4tufhZor4usfJFdzcj19/WNc5WhDyR+mUCr1xSIhGZGMjcmYTDiSsdTRj+iLIbk47nTF5EJfDMl1WXKhL4bkuiy50BdDcl2WXOiLIbmuSq6Er4WQXJclF/piUySXpR2htXH7dvQ9ToQ4zRAnZ/ffto5cIU7ovsiIExoZMuKEnsAc81N6xOnvLLnHCfJaRpygVEXEKUP0yYgTVluQESe8XCQjTuhHyIgTIU4i4oR+hIw4adZPm3/E6eZxlSUdjXjrn2xJoWSLzXt33bmnr3HCF3fNemgc97Rp1jeXcnchH9xTfOL+ybH3GGnWNlJipFnXSImRZk0zS4zIHPMRWfMaI0KMpo+RZi0jJUaan6t+GCP3eOfDPb/zUYyRj3tAfX4CmL6wa35MOhA7VPsQ7BDtI7AbaPYh2CHD/xg7Pdqs9PzrRewhH/3hkJ9KmV98Xg5OlnbeyQb7GiUIcQlRghSXECVClARECXJcQpQgyCVECfpdQpQg9wVEyUIv/XGUvD3axN76b1G6sySw/GOWdLwQ5P1WYIl7/J+zPA63PqQCS9yJ+Viim8rG0qFFynG/bLi7Osz6o8ij83kN+ZD8jjCk+Fi8YeeOXuYY7gTuQ7ij33gR93xACdm+vNLj0EEcwx16cQx3aMsx3KFDh3AnaNYx3KFYx3CHXr2K+/FgJmT/yh16dQx3Avch3KFXx3CHXh3DHXp1DHfoVQ7uv1l6xTW5ifb4cZM3V2FpKO5QjDfPnxiWLA+PFPbm6Vj3xV1xTX4t93hIoeQL3BXX5EO5E7gP4a64Jh/KXXFNfjH348XZX7XjC3fFNflQ7opr8qHcFT9DupZ7eOxnk165B8XPkIZyh14dwx16dQx36NUx3Anch3CHXh3DHXp1DPeV6nebH8vqbWarcefsp8eV6vFLOb7vW8WV6uuRHFeql0dyXKn+HcmRwPEvDP22uFJ9OpLjSvXmSI4rPe+4lOP7Ojyu9PxiJEfoGRaOCXqGhyP0DA9H6BkejtAzPBwJHDk4lre1NHHf8sI+tUNtMoUTpAN5crlybE47lZy/H3s3xs9kTJjJmDiTMWkmY/I8xuTyJn+jjDEzGWNnMsbNZMxEd+C8TXQHzlvfO3A4ZtVtswVr4lTWpKmsyTNZY7aprDFTWVO+21DOR0np7fvaNm37VZvoqcR26esM/vIzhMvPEC8/Q7r8DPnqM9jt52fwuwK7PRH4doaCStryLmWs2R5Hky39cNrXec7G1n7Y5d1PS9vj4Zk7HDVaHLVaHHVaHK3f7+M3R++jfNOo0DLKbVffp5y5/Az28jO4y89weWXgLq8MXFByWbuoxdGkxdGsxFHaWmYJMk2jbMuok7UZ7LEPtHPmsfBG+BrkWgZRy6DyK0gfbGl9fuz9BOHqE8SrT5B+eoL3u37nk88u+U5w8n0h4wlOZpBPni3djvg62D8/bPt6tpRDuv4U+fJTxO36UxjWU9BWOIW9/hTu+lPQ9afwPz9F2PYrL9hQOEW4/hTx+lOk60+RLz9F2q4/hbn+FPb6U7jrT0HXn+L6qztdf3Wn66/udP3Vna6/uvP1V3e+/urOHNfF28/ncubIqLdvGuWTt0a8Od7B8o6+neI+LDcM89vJmxjVYaZt2Mn993hj7DbMV/CZbNNBO9v8dxX77SSux0mox0l8j5OEHieJPU6SepwkdziJsRffyW6n4KhT3n1LdzsFXX8Kf/0pwvWniNefIl1/inz5KSxHnfLuQ7HbKcz1p7DXn8JdXKfcTkHXn8Jff4pw/Sni9adI158iX34Kt11/CnP9KcpJu8Vj2K+/899P+SePZLeYj5J6Sya8DIttw1LbsNw07ORR1pacewx7WnV9H2bahtm2Ya5t2Enc8mP9+S0H8zLshOSt0bYPM9v2QtJvbcNM2zDX5Fv5aV192MmFk7N7MtK/DAttw2LbsNQ2rBzu26H5Mcw+B+Cvn4er/CyM+ySmx0nsz0/y9rne7RTu+lPQ9afwn57iPiy0DYttw1LT3Se03SJj2y0ytt0iT54XVoe5tmHUNsy3DQttw2LTsJPHP9EfN9YYnz/5LJVmNm7H2zrR2pdT2OtP4a4/BV1/Cn/9KcL1p4jXnyJdf4p8+SlOHv+wnuL6qztff3Xn66/ufP3Vna+/uvP1V3e+/urO11/d+fKr22zb9af4+Oq+D7Ntw1zbMGob5tuGhbZhsW1YahuWm4aZrW1YW5aYtiwxbVli2rLEtGWJacsS05Ylpi1LTFuW2LYssW1ZYtuyxLZliW3LEtuWJbYtS2xblti2LLFtWeLassS1ZYlryxLXliWuLUtcW5a4tixxbVni2rLEtWUJtWUJtWUJtWUJtWUJtWUJtWUJtWUJtWUJtWUJtWWJb8sS35Ylvi1LfFuW+LYs8W1Z4tuyxLdliW/LEt+WJaEtS0JbloS2LAltWRLasiS0ZUloy5LQliWhLUtCW5bEtiyJbVkS27IktmVJbMuS2JYlsS1LYluWxLYsiW1ZktqyJLVlSWrLktSWJaktS1JblqS2LEltWZLasiS1ZUluy5LcliW5LUtyW5bktizJbVmS27Ikt2VJbsuS3JQldtvahpm2YbZtmGsbRm3DfNuw0DYstg1LbcPasqSt92rbeq+2rfdq23qvtq33att6r7at92rbeq+2rfdq23qvtq33att6r7at92rbeq+2rfdq23qvtq33att6r7at92rbeq+2rfdq23qvtq33att6r7at92rbeq+2rfdq23qvtq33att6r7at92rbeq+2rfdq23qvtq33att6r7at92rbeq+2rfdq23qvtq33att6r7at92rbeq+2rfdq23qvtq33att6r7at92rbeq+2rfdq23qvtq33att6r7at92rbeq+2rfdq23qvtq33att6r7at92rbeq+2rfdq23qvtq33att6r7at92rbeq+2rfdq23qvtq33att6r7at92rbeq+2rfdqT3qv+Xh579auM4VhJ1kS4zEs22/DSivOMu1ncTMnzmVOmsucPJU5Z73tUeaYucyxc5nj5jKH5jLHz2XOXHflPNddOc91V85T3ZXdNtVd2W1T3ZXdNtVd2W1T3ZXd1vuu/HYrpps9fjJ7wmT2xMnsSZPZk+eyx3x8b74PM23DbNuw4j3p9hRzX8Lj9qzQV6CZEN2xu2+I4bGwTmmlg5tU3heRuc0XrvLbYduOBbA29/iYPG9f9tPk9vttD0Dwzr3a74XbH4TbH4Xbn4Tbn2XbX34BQ5D9Rrj9Vrj9s8+/NfuFz79W+Pxrhc+/Vvj8a4XPv1b4/OuEz79O+PzrhM+/Tvj864TPv074/OuEz79O+PzrhM+/Tvj8S8LnXxI+/5Lw+ZeEz78kfP4l4fMvCZ9/Sfj8S8LnXxI+/3rh868XPv964fOvFz7/euHzrxc+/3rh868XPv964fOvFz7/BuHzbxA+/wbh828QPv8G4fNvED7/BuHzbxA+/wbh828QPv9G4fNvFD7/RuHzbxQ+/0bh828UPv9G4fNvFD7/RuHzbxQ+/ybh828SPv8m4fNvEj7/JuHzbxI+/ybh828SPv8m4fNvEj7/ZuHzbxY+/2bh828WPv9m4fNvFj7/ZuHzbxY+/2bh82+WPf/SJnv+pU32/Eub7PmXNtnzL22y51/aZM+/tMmef2mTPf/SJnv+pU34/GuEz79G+PxrhM+/069/VbNf+PwrfP0rEr7+FQlf/4qEr39Fwte/IuHrX5Hw9a9I+PpXJHz9KxK+/hUJX/+KhK9/RcLXvyLh61+R8PWvSPj6VyR8/SsSvv4VCV//ioSvf0XC178i4etfkfD1r0j4+lckfP0rEr7+FQlf/4qEr39Fwte/IuHrX5Hw9a9I+PpXJHz9KxK+/hUJX/+KhK9/RcLXvyLh61+R8PWvSPj6VyR8/SsSvv4VCV//ioSvf0XC178i4etfkfD1r0j4+lckfP0rEr7+FQlf/4qEr39Fwte/IuHrX5Hw9a9I+PpXJHz9KxK+/hUJX/+KhK9/RcLXvyLh61+R8PWvSPj6VyR8/SsSvv4VCV//ioSvf0XC178i4etfkfD1r0j4+lckfP0rEr7+FQlf/4qEr39Fwte/IuHrX5Hw9a9I+PpXJHz9KxK+/hUJX/+KhK9/RcLXv/LC17/ywte/8sLXv/LC17/ym+z51wtf/8oLX//KC1//ygtf/8oLX//KC1//ygtf/8oLX//KC1//ygtf/8pPv/7V46dDzObZ/tLBu9UhhccPJ/fl6+xzNaevs8/rnL7OXgNw+jp7vcDo6/Rre3H6Onkd4rNPD1/te18p5t2O2wPmdBxscyiabeJhtaPjaOfiF5vJa5yhbCavn4ayocnvH9t23BM2F15qs7nWRrubNFUJdTdpqkrnbtJUBcndpKnqht8mzbV02N2kqWbhu0lTTX53k6aac+4mTXWrv5s03917rsWy7ibNd/eea0mru0nz3b3nWnjqbtJ8d++5loe6mzTf3XuuRZzuJs13955rqaW7SfPdvedaEOlu0nx377mWLbqbNN/de67Fhe4mzXf3nmsJoLtJ892951qo527SfHfvuZbTuZs03917rkVv7ibNd/eea2mau0nz3b3nWkDmbtJ8d++5lnm5mzTf3XuuxVjuJs13955ryZS7SfPdveda2ORu0nx377mWH7mbNN/de65FQu4mzXf3nmspj7tJ892951pw427SfHfvuZbFuJs03917rsUr7ibNd/eea4mJu0nz3b3nWgjibtJ8d++5lmu4mzTf3XuuRRXuJs13955r6YO7SfPdvedaoOBu0nx377mWEbibNN3dO8z1sf/dpOnu3mGuT/LvJk139w7bdHfvMNe38HeTprt7h7m+WL+bNN3dO8z1Xflvk+b6VPxu0nx377k+6L6bNN/de67Pru8mzXf3nuuD57tJ89295/p8+G7SfHfvuT7GvZs03917rk9V7ybNd/ee68PMu0nz3b3n+9YyzPetZZjvW8sw37eWYb5vLcN831qG+b61DPN9axnm+9YyzPetZZjvW8sw37eWYb5vLcN831qG+b61DPN9axnm+9YyzPetZZjvW8sw37eWYa5vLV+PflpWJyaTj6OLy+rc3NkXyvEpPv906ehkYv46+vbL8TjaJvvFZvKl5YaymXwpuqFsJl+6biSbub7HnYyNnKXx+rORszRefzZylsbrz4bnXrw9FuCLJj6x+X2Szz/AvA9zbcOobZhvGxbahsW2YaltWG4a9vkHavdhpm1YW5bEtiyJbVkS27IktmVJbMuS2JYlsS1LUluWpLYsSW1ZktqyJLVlSWrLktSWJaktS1JblqS2LMltWZLbsiS3ZUluy5LcliW5LUtyW5bktizJbVmSm7IkblvbMNM2zLYNc23DqG2YbxsW2obFtmGpbVhblpi2LDFtWWLassS0ZYlpyxLTliWmLUtMW5aYtiwxbVli27LEtmWJbcsS25Ylti1LbFuW2LYssW1ZYtuyxLZliWvLkvJLCxSOYXS7bxSG2fIw8xhmt/98L7fTRruk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",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert"
      ],
      "verification_key": "AAAAAAAEAAAAAAAAAAAAEgAAAAAAAAAQAAAAAAAAVgkBAAAAAAAAAAEAAAACAAAAAwAAAAQAAAAF\nAAAABgAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAAAAAAAAAAAAAGE0XFjoa\n/2uH1TkeOWNWPHneNHbwwV7wFM+3IIAKx4wr9jNc4w/oj8HqBabIxdyDnVU0AZwwmnA3Nj6rksKP\nyS6v5VEqS/qWJx7T6cfauu2/qBZkWbjXqelyN+Q9MStzHxA4siBCAHrgyisJeBKxU86UnXGMWh6X\nW6anEv0I24YdAyohRGmO1XaJDJdFl/OF96ll3M8JGgrNnMMCWcGd1xpDKkDyaBZoc1lSWYOipBAW\nqGrI1rjY7MMJ/Hggaf+ULDy+stCMq1nMCfPnUxh+fwc4kes5dHCc7jGMwJzC+couI/D3OOlw9fZJ\nMz9k9mPkLW9O523vSKg3icrQqA4RhBYuYUR3h/xnGW+KpUCKaDhsrez2AAyWwkNWkl7QLZNOFKqA\nJBa875K4KzISY6NyXfZp+yYPW1/+YWeFPGyfiisj5RvqxMRXBtA5eqfde/9LHLuL8jgpeHK7wJH/\nfEeBKQM5X+Gde4md+ehrfk53kKIJWG04wkOTOkGtCYQx4DpOIuSmLVifXcWOAD4X0sKeZqqcjXq3\nWBuYEO2nPlPhfd8OP4PTyf+mJHwLpRXOLm9SrLCVbfb6d5ltuCSwof5icCmMMxH8kXD5LelAsEKq\nuZDVPGo7JjOc2mtz35IIMUFZB7BfQIphKEclkBa5IErkvzdTfrGWsFwdmPpRAWqbrLsBDLnYpLU7\nt9czT2t/X/Gq8TuSScYX9bFELI82T4ywxRYgD4DDNUvXwg/INyHNASwsDIXpHgIh0pH0/XIelc+4\nCl0XyXMNyvQD9kY8BZuDOR3iHs5exSpykZmQF5yF3d8bUu7dx7Y0Y2g56y9dyqrC1P9NDhOZDoPm\nqs1vYxwh3iHrSJuRmKhkLL92LlSOA5ve52T8+85x9jwkt2+sZv9oEf1BtfmTbZMquuTG6TPg05wk\n6o4uDu5wKlMm81nJR8AUoX18ClXS1F7o7fbsFlwRPSgrmEfVYv1BQCIOR+GCrxpw0tC/U/KBmNxu\na015bsn0E4YWuRKVxKct3D6sKlhhLtQPb5+ipkKh1bmzX8CWR4AJhqehhLA7qpGTBLSEbK8kds9C\ncn4cjY/Jo03wX+F9zcmC3scxjhB078MAthvCQQP2QHzfk01/l/z6Ti6plhsXB0AyK7xOvtkDa7l3\nhDKuJsFOXXeNZkHqEPUtoFrjnGvjKfXbDPE3iRTXh0I5k0kAaHxLIXNgFhpYyUmDG/h7FMfu3G1s\nxqPCh1yCJPks0wVznjHzhM5qc7d5jONAzzaTqm5BJWW3AzNWoOI9A/MZEAjZgs5wZfFBhM2ddQYJ\nXFbVf123uWQ+h8CnxmJ5BX0MZlf2ZhP8oib9sdrJxyIC+xZemihd4Eelv1Hq8QbxGwgAkyK+sLRI\nVvELoVMwHFAhd+DDm44eQqsaB8UmioRdF4Np8s2xV7aQiysb+mV21F5+1WQzQvwFKtl5l8BWK8Ao\n66fpNX6vSOMkmFoXOn822NDSt2jzLyhAZtxuHLLBqAf1Bf9difNOUYoCNwhOW85G4v+J5FkHUoGO\nC+0uEFMOF1YTz9yEOSDNkuuaZuYXWpqYMUwt/KRXdVDoQXCRJ1kB62Z+UT7Crh9P6s8cJQOvcWWH\nFLrBeNYPug4CQrl+YRzXoVHbPbkfirP7LSxAlVK16J4wpOzjMTNRQkIDSukuA4TsNcTnjXkqsNNK\nJ+b47tHQhIYjz/PV8Ek5BTynPwQOPg32d3I1Zr7X5+UD2kZ//CcH2EGifOJr9GZXPq26ahQlFosY\n+lf1QmMRU/b8aBrhmGkpdjUJGeIMLfxzJeUyItsvujQQwoPJLmYWiB1FGSz4GLL+fU4o26xohxi6\n8vcRVG74Ii7W8a9bK33Gtr27UyldWC//yE9cg+8SQNF7KwrcicSNdbVxY29bvrSoBvb0WWICMBtq\n5OsOu+rdIDNABm8oE1dI8RljHD/gf6nXAANOPidFTvmStL+EuXuqdHEuJXg1Ud9QwATsfNH03Ys7\nZKZvKsSXm2XlZWjFoxsU7Rj3bPDO7MtHmN50GuibZOglj4RHfBtiVlpVm6e7OIMuLSmftoZ40BUL\nzFsW3IJSNT1D+nDpkjnBwcZ+JxoO6sUV06xaGZq7dJM6TvyYxZsoFO3nzSfa7QDDPBKGC8SwRi04\n1tS6Hkdjp07NsRyh80aWgMJw5VFRU0RZL1kYj6dlEts56JKCazJhDuCCUeAF/OkXwNXcoBlHfFL2\nB1MythIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAACA8i25mfOy8TMe7DBPSAaZV3uk9Tj4Zp9HowSsJikRZIeREtF5w1dBClTHsyM\nOAlniDjqrM+EaVsDFFN+exFQSADENyb3W2/aDeIs4ODfq2vMegX/lalrKJQkxfczZw2WL5tuC04s\nAZaN5cMkgqp9HQoJ1xeOyTuteFj5bmTwtI0dWKphxkrVIgQ9ecSAIhnlW6GXUa3+bDYyTT+2wtoJ\niS18GKk8Pa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "add_lock_public_user",
      "is_unconstrained": true,
      "custom_attributes": [
        "internal",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "2722406262643068352": {
            "error_kind": "string",
            "string": "HashlockAlreadySet"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16870384257694633552": {
            "error_kind": "string",
            "string": "Function add_lock_public_user can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "add_lock_public_user"
      ]
    },
    {
      "name": "redeem_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "is_solver",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "772057049813214347": {
            "error_kind": "string",
            "string": "HTLCNotExists"
          },
          "2570651705007895968": {
            "error_kind": "string",
            "string": "HashlockNotMatch"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17814817983036354427": {
            "error_kind": "string",
            "string": "Function redeem_public can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBICIJwAABAMnAgQEIicCBQQAHxgABQAEgGYdAIBngGcCHQCAaIBoAh0AgGmAaQIdAIBqgGoCHQCAa4BrAh0AgGyAbAIdAIBtgG0CHQCAboBuAh0AgG+AbwIdAIBwgHACHQCAcYBxAh0AgHKAcgIdAIBzgHMCHQCAdIB0Ah0AgHWAdQIdAIB2gHYCHQCAd4B3Ah0AgHiAeAIdAIB5gHkCHQCAeoB6Ah0AgHuAewIdAIB8gHwCHQCAfYB9Ah0AgH6AfgIdAIB/gH8CHQCAgICAAh0AgIGAgQIdAICCgIICHQCAg4CDAh0AgISAhAIdAICFgIUCHQCAhoCGAh0AgIeAhwEuCIBmAAEoAgACBIBnJwIFBCAtCAEEJwIGBCEAEAEGAScDBAQBACgEAgYuBAACgAMuBAAGgAQuBAAFgAUlAAABcS0MBAIuCICHAAMlAAABtyUAAANOKAIAAQSAiCcCAgQAOw0AAQACAQCAA4AFgAcuAIADgAguAIAEgAkLAIAIgAeACiQAgAoAAAG2LgGACIAGLgKABoAJAQCACAACgAgBAIAJAAKACSMAAAGFJikAgEMEagnmZykAgEQEu2euhSkAgEUEPG7zcikAgEYEpU/1OikAgEcEUQ5SfykAgEgEmwVojCkAgEkEH4PZqykAgEoEW+DNGS4AAAGASygAgEwEAAkBAAABgEwAASgBgEsEAAEBAIBLAAKATC4AgEyATS4CgEOATQEAgE0AAoBNLgKARIBNAQCATQACgE0uAoBFgE0BAIBNAAKATS4CgEaATQEAgE0AAoBNLgKAR4BNAQCATQACgE0uAoBIgE0BAIBNAAKATS4CgEmATQEAgE0AAoBNLgKASoBNKACATAQABCgAgE0EADgoAIBOBAAQKACATwQADigAgFAEAQAqAIBRAAAAAAEAAAAAKACAUgABACgAgFMEAAMoAIBUAQAAKACAVQQAACgAgFYGAAAoAIBXAAAAKACAWAEAASgAgFkEAAEoAIBaAAABKACAWwQAAigAgFwAAAIoAIBdBAAFKACAXgIACCgAgF8EAAgoAIBgBAAJKACAYQQAEygAgGIEAB8oAIBjBAAgKACAZAAAZSgAgGUAAGYmJQAAHS8tCAEEAAABAgEuCoBUAAQtCAEFAAABAgEuCoBXAAUtCAEGAAABAgEuCoBcAAYeAgAHAB4CAAgAMzgABwAIAAkkAgAJAAADnyUAAB1YHgIABwEeAgAIAAo4BwgJJAIACQAAA7slAAAdaicCCwQMLQgADC0MBA0tDAUOLQwGDy4IgFwAEC4IgGQAES0MARIAEAALACUAAB18LQQAAC0MDQctDA4ILQwPCS0MEAoeAgALBRwMCw0EHAwNDAAcDAwLBCcCHwQgLQgAIC0MByEtDAgiLQwJIy0MCiQAEAAfACUAAB9sLQQAAC0MIQwtDCINLQwjDi0MJA8tDCUQLQwmES0MJxItDCgTLQwpFC0MKhUtDCsWLQwsFy0MLRgtDC4ZLQwvGi0MMBstDDEcLQwyHS0MMx4MOAseBxYMBwgcDAcJABwMCAoABDgJDAsEOAoVDAA4CwwVHAwHCwYcDAgMBgQ4Cw0eBDgMFg0AOB4NFgQ4CQ4NBDgKFwkAOA0JCgQ4Cw8JBDgMGA0AOAkNDgQ4CxAJBDgMGQ0AOAkNDwQ4CxEJBDgMGg0AOAkNEAQ4CxIJBDgMGwsAOAkLDBwMBwkFHAwICwUEOAkTDQQ4CxwJADgNCQscDAcJAhwMCAcCBDgJFAgEOAcdCQA4CAkHLQgBCAAAAQIBLQ4VCC0IAQkAAAECAS0OFgktCAENAAABAgEtDgoNLQgBCgAAAQIBLQ4OCi0IAQ4AAAECAS0ODw4tCAEPAAABAgEtDhAPLQgBEAAAAQIBLQ4MEC0IAQwAAAECAS0OCwwtCAELAAABAgEtDgcLJwIHAAMkAgADAAAFxCMAAAdtJwIVBBYtCAAWLQwEFy0MBRgtDAYZLQwHGi4IgGUAGy0MARwAEAAVACUAAB18LQQAAC0MFxEtDBgSLQwZEy0MGhQeAgAVBRwMFRcEHAwXFgAcDBYVBCcCKQQqLQgAKi0MESstDBIsLQwTLS0MFC4AEAApACUAAB9sLQQAAC0MKxYtDCwXLQwtGC0MLhktDC8aLQwwGy0MMRwtDDIdLQwzHi0MNB8tDDUgLQw2IS0MNyItDDgjLQw5JC0MOiUtDDsmLQw8Jy0MPSgMOBUoERYMERIcDBETABwMEhQABDgTFhUEOBQfFgA4FRYfHAwRFQYcDBIWBgQ4FRcoBDgWIBcAOCgXIAQ4ExgXBDgUIRMAOBcTFAQ4FRkTBDgWIhcAOBMXGAQ4FRoTBDgWIxcAOBMXGQQ4FRsTBDgWJBcAOBMXGgQ4FRwTBDgWJRUAOBMVFhwMERMFHAwSFQUEOBMdFwQ4FSYTADgXExUcDBETAhwMEhECBDgTHhIEOBEnEwA4EhMRLQ4fCC0OIAktDhQNLQ4YCi0OGQ4tDhoPLQ4WEC0OFQwtDhELIwAAB20tDQkPDTCAVgAPABAkAgAQAAAHhiUAACLdLgmASwAPACgPAg8uBgAPgEstCAEPJwIQBBEAEAEQAScDDwQBACgPAhAnAhEEEAA4ERARLQwQEgw4EhETFgwTEyQCABMAAAfeLgqAVQASACgSAhIjAAAHvS0IARAAAAECAS0ODxAHIIBjgEwADy0IAREAAAECAS0ODxEnAhMEBAcwgGMAEwAUBDgUExUDMIBjABUAEgsoABKAVQATJAIAEwAACFIjAAAILwEoAA+AWQATDjgPExQkAgAUAAAISSUAACLvLQ4TESMAAAhSLQ0RFCcCEQIALgiAVQATIwAACGYMOBMUFSQCABUAABvTIwAACHgtDRAULQ0UEAAoEAIQLQ4QFA0oAA+ATgAQJAIAEAAACJ4lAAAjAQAoFAIVADgVDxYtDRYQAzCATAASABUPKAASgEwAFiQCABYAAAjJJQAAIxMcDBUXAhwMFxYEHAwWFQIFMIBeABUAFicCGAIACjgYFRckAgAXAAAJDAY4FhUaCygAGoBeABkkAgAZAAAJDCUAACMlGjgQFhcnAhACBAw4FRAYJwIVAiAkAgAYAAAJOCMAAAktLgiAVQATIwAACVgYOBcWGAw4FhUXJAIAFwAACU8lAAAjNy0MGBMjAAAJWAMwgFMAEgAXDygAEoBTABgkAgAYAAAJdSUAACMTHAwXGAIcDBgSBBwMEhcCDDgXEBIkAgASAAAJoSMAAAmWLgiAVQAWIwAACfoFMIBeABcAEicCGQIACjgZFxgkAgAYAAAJ1QY4EhcbCygAG4BeABokAgAaAAAJ1SUAACMlJwIXBIAYOBcSGAw4EhUXJAIAFwAACfElAAAjNy0MGBYjAAAJ+gA4ExYYDjgTGBkkAgAZAAAKESUAACLvLgQAFIADKACABAQAESUAACNJLgiABQATACgTAhYAOBYPGS0OGBkNIIBjgE0ADyQCAA8AAAqIIwAACkwtCAEPJwIUBAkAEAEUAScDDwQBACgTAhQBIIBLAAIAFgAoDwIYQD8AGAAWABQtDA8SLgiAVQAXIwAACp8BIIBjgFkADy4IgEsAEi0MDxcjAAAKny0NEg8AKA8CDy0ODxItCAEPAAABAgEtDhMPLQgBFAAAAQIBLQ4XFC0NExYAKBYCFi0OFhMnAhgEBAY4FxgZBDgZGBoCOBcaFgsoABaAVQAYJAIAGAAADBMjAAAK/AcoABeATAAZAzCATAAWABoPKAAWgEwAGyQCABsAAAshJQAAIxMNKAAZgE4AFiQCABYAAAs2JQAAIwEAKBMCGwA4GxkcLQ0cFhwMGhwCHAwcGwQcDBscAgUwgF4AHAAbJwIeAgAKOB4cHSQCAB0AAAuHBjgbHCALKAAggF4AHyQCAB8AAAuHJQAAIyUaOBYbHQw4HBAWJAIAFgAAC6kjAAALni4IgFUAGCMAAAvJGDgdGxAMOBsVFiQCABYAAAvAJQAAIzctDBAYIwAAC8kuBAATgAMoAIAEBAARJQAAI0kuCIAFABAAKBACFQA4FRkWLQ4YFi0OEA8AOBcaEA44FxAVJAIAFQAADAolAAAi7y0OEBQjAAAMEy0NFBUHKAAVgEwAFC0MFBAjAAAMKA0oABCATwAUJAIAFAAAG30jAAAMPScCFAIBLQgBFScCFgQJABABFgEnAxUEAQAoFQIWLQwWFy0OERcAKBcCFy0OERcAKBcCFy0OERcAKBcCFy0OERcAKBcCFy0OERcAKBcCFy0OERcAKBcCFy0OFBcAKBcCFy0OERcuCIBVABAjAAAMrA0oABCAWwAWJAIAFgAAGc4jAAAMwS0NDxUtDRMPAigPAg8tDg8TLQ0VDwAoDwIPLQ4PFS0IAQ8AAAECAS0IARMnAhYEIQAQARYBJwMTBAEAKBMCFicCFwQgADgXFhctDBYYDDgYFxkWDBkZJAIAGQAADS0tDhEYACgYAhgjAAANDi0IARYAAAECAS0OExYtCAETJwIXBAkAEAEXAScDEwQBACgVAhcAKBICGAAoEwIZQD8AGQAYABctDRMSACgSAhItDhITLQ4TDy4IgFUAECMAAA2ADSgAEIBfABIkAgASAAAY1iMAAA2VLQ0WDy0NDxAAKBACEC0OEA8nAhMEFS0IABUtDA8WABAAEwAlAAAj1y0EAAAtDBYQLQwXEi0NCA8tDQkILQ0NCS0NCg0tDQ4TLQ0MFS0NCwwKOA0QCyQCAAsAAA33JQAAJNkKOBMSCyQCAAsAAA4JJQAAJNkKOAwUCyQCAAsAAA4bJQAAJOsnAhAEFi0IABYtDAIXABAAEAAlAAAj1y0EAAAtDBcLLQwYDCcCEAIDJAIAAwAADy8jAAAOUCcCFgQXLQgAFy0MBBgtDAUZLQwGGi4IgFwAGy4IgGQAHC0MAR0AEAAWACUAAB18LQQAAC0MGAMtDBkHLQwaEi0MGxQnAiYEJy0IACctDAMoLQwHKS0MEiotDBQrLQwPLC0MCC0tDAkuLQwNLy0MEzAtDAsxLQwMMi0MFTMtDBA0ABAAJgAlAAAk/S0EAAAtDCgELQwpBS0MKgYtDCsWLQwsFy0MLRgtDC4ZLQwvGi0MMBstDDEcLQwyHS0MMx4tDDQfLQw1IC0MNiEtDDciLQw4Iy0MOSQtDDolIwAAEAwnAhcEGC0IABgtDAQZLQwFGi0MBhstDAccLgiAZQAdLQwBHgAQABcAJQAAHXwtBAAALQwZAy0MGhItDBsULQwcFicCJgQnLQgAJy0MAygtDBIpLQwUKi0MFistDA8sLQwILS0MCS4tDA0vLQwTMC0MCzEtDAwyLQwVMy0MEDQAEAAmACUAACT9LQQAAC0MKAQtDCkFLQwqBi0MKwctDCwXLQwtGC0MLhktDC8aLQwwGy0MMRwtDDIdLQwzHi0MNB8tDDUgLQw2IS0MNyItDDgjLQw5JC0MOiUjAAAQDC0NCgQtDQ4FLQgBBicCBwQhABABBwEnAwYEAQAoBgIHJwIIBCAAOAgHCC0MBwkMOAkIChYMCgokAgAKAAAQWS0OEQkAKAkCCSMAABA6LQgBBwAAAQIBLQ4GBy0IAQYAAAECAS0OBAYnAgQEDy4IgFUAAyMAABCDDSgAA4BOAAgkAgAIAAAYTCMAABCYLQ4FBi4IgFUAAyMAABCnDSgAA4BOAAQkAgAEAAAX0SMAABC8LQ0HBC0NBAUAKAUCBS0OBQQtDQIFACgFAgUtDgUCLQ0EBQAoBQIFLQ4FBC0NAgUAKAUCBS0OBQItCAEFAAABAgEtCAEGJwIHBAYAEAEHAScDBgQBACgGAgctDAcILQ4BCAAoCAIILgqAVwAIACgIAgguCoBXAAgAKAgCCC4KgFcACAAoCAIILgqAVwAILQ4GBS0NBAEAKAECAS0OAQQtCAEBJwIGBCAAEAEGAScDAQQBACgBAgYnAgcEHwA4BwYHLQwGCAw4CAcJFgwJCSQCAAkAABGfLQ4RCAAoCAIIIwAAEYAtCAEGAAABAgEtDgEGLgiAVQADIwAAEbcNKAADgGIAASQCAAEAABeEIwAAEcwtDQUDLQ0GBycCCAQSLQgAEi0MBxMAEAAIACUAAC8HLQQAAC0MEwYuBAADgAMoAIAEBAAGJQAAI0kuCIAFAAcAKAcCCAEoAAiAWQAJLQ4GCQEoAASAYwAGLQ0GAy0IAQQnAgYEIAAQAQYBJwMEBAEAKAQCBi0MBggtDgMIACgIAggtDhEIACgIAggtDhEIACgIAggtDhEIACgIAggtDhEIACgIAggtDhEIACgIAggtDhEIACgIAggtDhEIACgIAggtDhEIACgIAggtDhEIACgIAggtDhEIACgIAggtDhEIACgIAggtDhEIACgIAggtDhEIACgIAggtDhEIACgIAggtDhEIACgIAggtDhEIACgIAggtDhEIACgIAggtDhEIACgIAggtDhEIACgIAggtDhEIACgIAggtDhEIACgIAggtDhEIACgIAggtDhEIACgIAggtDhEIACgIAggtDhEIACgIAggtDhEIACgIAggtDhEIACgIAggtDhEIACgIAggtDhEIACgIAggtDhEIJwIGBBItCAASLQwEEwAQAAYAJQAALwctBAAALQwTAy4EAAeAAygAgAQEAAYlAAAjSS4IgAUABAAoBAIGASgABoBbAAgtDgMILQ4EBS0NAgMAKAMCAy0OAwItCAEDJwIEBCAAEAEEAScDAwQBACgDAgQnAgYEHwA4BgQGLQwEBww4BwYIFgwICCQCAAgAABP0LQ4RBwAoBwIHIwAAE9UtCAEEAAABAgEtDgMELgiAVQABIwAAFAwNKAABgGIAAyQCAAMAABc3IwAAFCEtDQUDLQ0EBicCBwQSLQgAEi0MBhMAEAAHACUAAC8HLQQAAC0MEwQuBAADgAMoAIAEBAAGJQAAI0kuCIAFAAYAKAYCBwEoAAeAUwAILQ4ECAEoAAKAYwAELQ0EAy0IAQInAgQEIAAQAQQBJwMCBAEAKAICBC0MBActDgMHACgHAgctDhEHACgHAgctDhEHACgHAgctDhEHACgHAgctDhEHACgHAgctDhEHACgHAgctDhEHACgHAgctDhEHACgHAgctDhEHACgHAgctDhEHACgHAgctDhEHACgHAgctDhEHACgHAgctDhEHACgHAgctDhEHACgHAgct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",
      "debug_symbols": "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",
      "brillig_names": [
        "redeem_public"
      ]
    },
    {
      "name": "lock_private_solver",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "src_receiver",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 48
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6418028854678020178": {
            "error_kind": "string",
            "string": "FundsNotSent"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7L3bjiOxkmX5L/VcD07S/ML+lcFg0DN9QQGFqkF3zVOj/30iUyGX8oRTHuFpMhrJVQ+FPOd4SOTaRtH2don+v/7pv/zX//v/++//17/823/79//5T//p//hf//Sv//7//Of/+Jd//7eP//S//imE8Pu//J//73/+t1//+X/+x3/+H//xT/8pzrL+8z/913/7Lx//XEL83//8T//tX/71v/7Tf8rb//7nrxdHme4Xx+Vx8ZIPLk5Tnj8vTmHZXl8c5hzu4/j4d5r2y+MWj65f5u1++bKuj6vz4aunJd2vljD9cfX/+c8faCJoSmgSaEpoBDQlNDNoSmgW0JTQrKApodlAU0KTQVNAEyfQlNDQDRfR0A0X0dANF9EIaEpo6IaLaOiGi2johoto6IaLaOiGS2gS3XARDd1wEQ3dcBEN3XARjYCmhIZuuIiGbriIhm64iIZuuIiGbriERuiGi2johoto6IaLaOiGi2gENCU0dMNFNHTDRTR0w0U0dMNFNHTDJTQz3XARDd1wEQ3dcBEN3XARjYCmhIZuuIiGbriIhm64iIZuuIiGbriEZqEbLqKhGy6ioRsuoqEbLqIR0JTQ0A0X0dANF9HQDRfR0A0X0dANl9CsdMNFNHTDRTR0w0U0dMNFNAKaEhq64SIauuEiGrrhIhq64SIauuESmo1uuIiGbriIhm64iIZuuIhGQFNCQzdcREM3XERDN1xEQzdcREM3XEKT6YaLaOiGi2johoto6IaLaAQ0JTR0w0U0dMNFNHTDRTR0w0U0dMMFNHGiGy6ioRsuoqEbLqKhGy6iEdCU0NANF9HQDRfR0A0X0dANF9HQDZfQBLrhIhq64SIauuEiGrrhIhoBTQkN3XARDd1wEQ3dcBEN3XARDd1wCQ3PoiujoRsuoqEbLqKhGy6iEdCU0NANF9HQDRfR0A0X0dANF9HQDZfQ8Cy6Mhq64SIauuEiGrrhIhoBTQkN3XARDd1wEQ3dcBEN3XARDd1wCQ3PoiujoRsuoqEbLqKhGy6iEdCU0NANF9E474ZneaB5uvwYTQxxuY8kyPy3aJx3wzXRHHfDsoUHmvQajYRwH7+E+fEWH5R+v0N+9zscPxktpI//4T71lLb59Xt8XB72q+flcfF8cHHOeV/o0xTkeURHisn8JNnTSO4TCK1PIB5PYAtxH1Jew/MEfv/ZYQ+wbtt92uuWH2rP4fZHcuWP5it/tFz5o/XKH21X/uhwYa0f0n7+0ZZSfP6jg5oJ23y/+uPf29PlR1Xz8Vly1zOtIXjeDY+fDwOcG5wAnDKcCJwynAScMhwBThnODJwynAU4ZTgrcMpwNuCU4dAhl+GsdMgv4NAhv4BDh/wCDh3yCzgCnDIcOuQXcOiQX8ChQ34Bhw75BRw65DKcjQ75BRw65Bdw6JBfwKFDfgFHgFOGQ4f8Ag4d8gs4dMgv4NAhv4BDh1yGk+mQX8ChQ34Bhw75BRw65BdwBDhlOHTIL+DQIb+AQ4f8Ag4d8gs4dMhFOGmiQ34Bhw75BRw65Bdw6JBfwBHglOHQIb+AQ4f8Ag4d8gs4dMgv4NAhl+EEOuQXcOiQX8ChQ34Bhw75BRwBThkOHfILOHTIL+DQIb+AQ4f8Ag4dchlOpEN+AYcO+QUcOuQXcOiQX8AR4JTh0CG/gEOH/AIOHfILOHTIL+DQIZfhJDrkF3DokF/AoUN+AYcO+QUcAU4ZDh3yCzh0yC/g0CG/gEOH/AIOHXIZjtAhv4BDh/wCDh3yCzh0yC/gCHDKcOiQX8ChQ34Bhw75BRw65Bdw6JDLcGY65Bdw6JBfwKFDfgGHDvkFHAFOGQ4d8gs4dMgv4NAhv4BDh/wCDh1yGQ7P1HsFhw75BRw65Bdw6JBfwBHglOHQIb+AQ4f8Ag4d8gs4dMgv4NAhl+HwTL1XcOiQX8ChQ34Bhw75BRwBThkOHfILOHTIL+DQIb+AQ4f8Ag4dchkOz9R7BYcO+QUcOuQXcOiQX8AR4JTh0CG/gEOH/AIOHfILOHTIL+DQIZfh8Ey9V3DokF/AoUN+AYcO+QUc8Q5nlgecZTuBE0NcPi+PQea/heO+Q64JR6VDznGHk1M+gbPeC1/SA83H4G7j0WhKszzEynl5PZ6Q57wvxbyEB9HlGL/MT/y3Py7/PYOt+Rlk+xmscdpnsK3p9QzyPO+vHR/rJaTfNS3Hz2zbZA738cuaT8Y/PZZNCI/hhHk9XMI7z+kBJoWjBblmuQ/+g2g6WexpnfbFIo9rpyNZV7lfG9f55OKw5n232sJycvG0v3KYtvx88W/cAdyWuCO4LXEncFvilr/H/dGg3d8hPjVIx7jnOd/Hs2zxMdMwHb12Xu/jyNvTxjN/bjxzy4NfTgef5fXg40fvca+aZY5/vMVRH5LvLx1/l/fLq7e4v/YWn177uNQ7XBgr8niWZ1OQZ5FdnhxOgH+4xvumMj8v58OG+cO+7jPN0/r00vE2+mw8+mXa7gWwhKdt7pJhkTC1Pfzw98NfQ9rrfklnw9/N1iJPHwMxHS2+vN6N3Afnp9KZJscfA+mBI8WzlZ3S3p6l5zFf+BgIESl7kTIhZSebcxCk7EXK2VjKdUr7K59Jue23gPKWvjRZYTEe+rZHsNsaToY+PzrEeVvlbzuadZypnjb+89Ntl8Opzo9Ofnny8PHw7sm8p/BpeVp4IRxmSfGRlH/cdzm5+iNv2Be1PPfAh1d/tK3L/rn1vDRCYWdeHzvz00i2o9de8nTH99GMP30mbocfiSL7R+ISny/+LVBGINcCxQmBfAsUEMi3QBGBfAuUEMi3QIJAvgWaEci3QAsC+RZoRSDfApEkOBeIJMG3QIkkwblAJAnOBSJJcC4QSYJzgQSBfAtEkuBcIJIE5wKRJDgXiCTBuUAkCb4FEpIE5wKRJDgXiCTBuUAkCc4FEgTyLRBJgnOBSBKcC0SS4FwgkgTnApEk+BZoJklwLhBJgnOBSBL0BVqj3M8ZWuMzk0/mhAP2zAXm5syx8O9gvs9yTeErc1y5PXOMtj1zvLM9c+ywOfMFh2vetyyYVnvm+FB75vhQ+89zgbk5c3yoPXN8qD1zfKg9c3yoPXN8qDnzFR9q3p+v+FB75vhQe+b4UHvmAnNz5vhQ+74FH2rPHB9qzxwfas8cH2rOfMOH2jPHh9ozx4faM8eH2jMXmFv70A0fas8cH2rPHB9qzxwfas8cH2ret2R8qD1zfKg9c3yoPXN8qD1zgbk5c3yoPXN8qD1zfKg9c3youQ/N+FBr5vOED7Vnjg+1Z44PtWeOD7XuW+ZJYG7OHB9qzxwfas8cH2rPHB9qzxwfas484EPtmeND7ZnjQ819aMCH2jMXmJszx4faM8eH2jPHh9r3LfhQe+b4UHPmER9qzxwfas8cH2rPHB9qz1xgbs4cH2rPHB9q7kMjPtSeOT7Unjk+1Jx5wofaM8eHmvctCR9qzxwfas9cYG7OHB9qzxwfas8cH2rPHB9qzxwfas5c8KHmPlTwofbM8aH2zPGh9swF5ubM8aH2fQs+1J45PtSeOT7Unjk+1Jz5jA+1Z44PtWeOD7Vnjg+1Zy4wt/ahMz7Unjk+1J45PtSeOT7Unjk+1LxvWfCh9szxofbM8aH2zPGh9swF5ubM8aH2zPGh9szxofbM8aHmPnTBh5ozX/Gh9szxofbM8aH2zPGh5n3LKjA3Z44PtWeOD7Vnjg+1Z44PtWeODzVnvuFD7ZnjQ+2Z40PNfeiGD7VnLjA3Z44PtWeOD7Vnjg+171vwofbM8aHmzDM+1J45PtSeOT7Unjk+1J65wNycOT7Unjk+1NyHZnyoPXN8qD1zfKg182XCh9ozx4da9y3LhA+1Z44PtWcuMDdnjg+1Z44PtWeOD7Vnjg+1Z44PNWce8KHmPjTgQ+2Z40PtmeND7ZkLzM2Z40Pt+xZ8qD1zfKg9c3yoPXN8qDnziA+1Z44PtWeOD7Vnjg+1Zy4wt/ahER9qzxwfas8cH2rPHB9qzxwfat63JHyoPXN8qD1zfKg9c3yoPXOBuTlzfKg9c3yoPXN8qD1zfKi5D034UHPmgg+1Z44PtWeOD7Vnjg8171tEYG7OHB9qzxwfas8cH2rPHB9qzxwfas58xofaM8eH2jPHh5r70Bkfas9cYG7OHB9qzxwfas8cH2rft+BD7ZnjQ82ZL/hQe+b4UHvm+FB75vhQe+YCc3Pm+FB75vhQcx+64EPtmeND7ZnjQ82Zr/hQe+b4UPO+ZcWH2jPHh9ozF5ibM8eH2jPHh9ozx4faM8eH2jPHh5oz3/Ch5j50w4faM8eH2jPHh9ozF5ibM8eH2vct+FB75vhQe+b4UHvm+FBz5hkfas8cH2rPHB9qzxwfas9cYG7tQzM+1J45PtSeOT7Unjk+1J45PtS6b1knfKg9c3yoPXN8qD1zfKg9c4G5OXN8qD1zfKg9c3yoPXN8qLUPXSd8qDnzgA+1Z44PtWeOD7Vnjg8171uCwNycOT7Unjk+1J45PtSeOT7Unjk+1Jx5xIfaM8eH2jPHh5r70IgPtWcuMDdnjg+1Z44PtWeOD7XvW/Ch9szxoebMEz7Unjk+1J45PtSeOT7UnrnA3Jw5PtSeOT7U3IcmfKg9c3yoPXN8qDlzwYfaM8eHmvctgg+1Z44PtWcuMDdnjg+1Z44PtWeOD7Vnjg+1Z44PNWc+40PNfeiMD7Vnjg+1Z44PtWcuMDdnjg+171vwofbM8aH2zPGh9szxoebMF3yoPXN8qD1zfKg9c3yoPXOBubUPXfCh9szxofbM8aH2zPGh9szxoeZ9y4oPtWeOD7Vnjg+1Z44PtWcuMDdnjg+1Z44PtWeOD7Vnjg8196ErPtSc+YYPtWeOD7Vnjg+1Z44PNe9bNoG5OXN8qD1zfKg9c3yoPXN8qD1zfKg584wPtWeOD7Vnjg8196EZH2rPXGBuzhwfas8cH2rPHB9q37fgQ+2Z40OtmW8TPtSeOT7Unjk+1J45PtSeucDcnDk+1J45PtTah24TPtSeOT7Unjk+1Jx5wIfaM8eHmvctAR9qzxwfas9cYG7OHB9qzxwfas8cH2rPHB9qzxwfas484kPNfWjEh9ozx4faM8eH2jMXmJszx4fa9y34UHvm+FB75vhQe+b4UHPmCR9qzxwfas8cH2rPHB9qz1xgbu1DEz7Unjk+1J45PtSeOT7Unjk+1LxvEXyoPXN8qD1zfKg9c3yoPXOBuTlzfKg9c3yoPXN8qD1zfKi5DxV8qDnzGR9qzxwfas8cH2rPHB9q3rfMAnPzOseH2jPHh9ozx4faM8eH2jPHh5r3LQs+1LzOF3yoPXN8qD1zfKg9c4G5OXN8qH3fgg+1Z44PtWeOD7Vnjg99A3OJ93F//HP9R+YrPlSf+ZKnO74lhz+Yf714iyJ31nGJXwTCtDoXCIfrXCDssHOBBIF8C4TRdi4Qrty5QFh45wLh950LRDjgW6CNJMG5QCQJzgUiSXAuEEmCc4EEgXwLRJLgXCCSBOcCkSQ4F4gkwblAJAm+BcokCc4FIklwLhBJgnOBSBKcCyQI5FsgkgTnApEkOBeIJMG5QCQJzgUiSXAtUJ5IEpwLRJLgXCCSBOcCkSQ4F0gQyPhkgDwRDtgzx+/bM8fCW/9KPU+4cnvmGG1z5gHvbM8cO2zPHIdr3rcETKs9c4G5OXN8qP3nOT7Unjk+1J45PtSeOT7UnHnEh9ozx4faM8eHmvfnER9qz1xgbs4cH2rPHB9qzxwfat+34EPtmeNDzZknfKg9c3yoPXN8qD1zfKg9c4G5OXN8qD1zfKi5D034UHvm+FB75vhQc+aCD7Vnjg8171sEH2rPHB9qz1xgbs4cH2rPHB9qzxwfas8cH2rPHB9qznzGh5r70Bkfas8cH2rPHB9qz1xgbs4cH2rft+BD7ZnjQ+2Z40PtmeNDzZkv+FB75vhQe+b4UHvm+FB75gJzax+64EPtmeND7ZnjQ+2Z40PtmeNDzfuWFR9qzxwfas8cH2rPHB9qz1xgbs4cH2rPHB9qzxwfas8cH2ruQ1d8qDnzDR9qzxwfas8cH2rPHB9q3rdsAnNz5vhQe+b4UHvm+FB75vhQe+b4UHPmGR9qzxwfas8cH2ruQzM+1J65wNycOT7Unjk+1J45PtS+b8GH2jPHh1ozD9OEEa0AHSdaATpWtAJ0vGgF6AJ0e+i40QrQsaPWdvQDOn60AnQMaQXoOFJ76AFHWgE6jtS+ewk40grQcaQVoAvQ7aHjSCtAx5FWgI4jrQAdR1oBOo7UHnrEkdo70ogjrQAdR1oBOo60AnQBuj10HGmF7gVHWgE6jrQCdBxpBeg4UnvoCUdaATqOtAJ0HGkF6DjSCtAF6OaONOFIK0DHkVaAjiOtAB1HWgE6jtS+exEcaQXoONIK0HGkFaDjSCtAF6DbQ8eRVoCOI60AHUdaATqO1N6RCo7UHvqMI60AHUdaATqOtAJ0HKl99zIL0O2h40grQMeRVoCOI60AHUdaATqO1B76giOtAB1HWgE6jtTekS440grQBej20HGkFaDjSCtAx5FW6F5wpBWg40jtoa840grQcaQVoONIK0DHkVaALkC3h44jrQAdR2rvSFccaQXoONIK0HGk9tA3HGkF6DhS++5lw5FWgI4jrQBdgG4PHUdaATqOtAJ0HGkF6DjSCtBxpPbQM47U3pFmHGkF6DjSCtBxpBWgC9DtoeNIK3QvONIK0HGkFaDjSCtAx5GaQw8TjrQCdBxpBeg40grQcaQVoAvQrR1pmHCkFaDjSCtAx5FWgI4jrQAdR2rfvQQcaQXoONIK0HGkFaDjSCtAF6DbQ8eRVoCOI60AHUdaATqO1N6RBhypPfSII60AHUdaATqOtAJ0HKl99xIF6PbQcaQVoONIK0DHkVaAjiOtAB1Hag894UgrQMeRVoCOI7V3pAlHWgG6AN0eOo60AnQcaQXoONIK3QuOtAJ0HKk9dMGRVoCOI60AHUdaATqOtAJ0Abo9dBxpBeg4UntHKjjSCtBxpBWg40jtoc840grQcaT23cuMI60AHUdaAboA3R46jrQCdBxpBeg40grQcaQVoONI7aEvOFJ7R7rgSCtAx5FWgI4jrQBdgG4PHUdaoXvBkVaAjiOtAB1HWgE6jtQe+oojrQAdR1oBOo60AnQcaQXoAnRzR7riSCtAx5FWgI4jrQAdR1oBOo7UvnvZcKQVoONIK0DHkVaAjiOtAF2Abg8dR1oBOo60AnQcaQXoOFJ7R7rhSO2hZxxpBeg40grQcaQVoONI7buXLEC3h44jrQAdR1oBOo60AnQcaQXoOFJz6HHCkVaAjiOtAB1Hau5I44QjrQBdgG4PHUdaATqOtAJ0HGmF7gVHWgE6jtQeesCRVoCOI60AHUdaATqOtAJ0Abo9dBxpBeg4UntHGnCkFaDjSCtAx5HaQ4840grQcaT23UvEkVaAjiOtAF2Abg8dR1oBOo60AnQcaQXoONIK0HGk9tATjtTekSYcaQXoONIK0HGkFaAL0O2h40grdC840grQcaQVoONIK0DHkdpDFxxpBeg40grQcaQVoONIK0AXoJs7UsGRVoCOI60AHUdaATqOtAJ0HKl99zLjSCtAx5FWgI4jrQAdR1oBugDdHjqOtAJ0HGkF6DjSCtBxpPaOdMaR2kNfcKQVoONIK0DHkVaAjiO1714WAbo9dBxpBeg40grQcaQVoONIK0DHkdpDX3GkFaDjSCtAx5HaO9IVR1oBugDdHjqOtAJ0HGkF6DjSCt0LjrQCdBypPfQNR1oBOo60AnQcaQXoONIK0AXo9tBxpBWg40jtHemGI60AHUdaATqO1B56xpFWgI4jte9eMo60AnQcaQXoAnR76DjSCtBxpBWg40grQMeRVoCOIzWHniYcqbkjTROOtAJ0HGkF6DjSCtAF6PbQcaQVuhccaYVKx5FWgI4jrQAdR2oPPeBIK0DHkdp3LwFHWqHScaQVoAvQ7aHjSCtAx5FWgI4jrdC94EgrQMeR2kOPONIK0HGkb4Au8T7uj3+uX6HjSPWhL3m641ty+AP614u3KHJnHZf4VSHsq3eFBIWcK4Qx9q4QLtq7Qlhu7wrhz70rhJl3rlDC+XtXiJjAu0JkCt4VIlPwrpCgkHOFyBS8K0Sm4F0hMgXvCpEpeFeITMG5QkKm4F0hMgXvCpEpeFeITMG7QoJCzhUiU/CuEJmCd4XIFLwrRKbgXSEyBecKzWQK3hUiU/CuEJmCd4XIFLwrJCjkXCEyBe8KkSnYnyAwExNUgI7zrwAdM2//Y/YFf14BOpa7AnRcdAXoGOMK0AXo5t3Lgn2tAB1HWgE6jrTCZzqOtAJ0HKk99BVHWgE6jrQCdBxpBeg40grQBejmffqKI60AHUdaATqOtAJ0HGkF6DhS++5lw5FWgI4jrQAdR1oBOo60AnQBuj10HGkF6DjSCtBxpBWg40jtHemGI7WHnnGkFaDjSCtAx5FWgI4jte9esgDdHjqOtAJ0HGkF6DjSCtBxpBWg40jNocuEI60AHUdaATqO1NyRyoQjrQBdgG4PHUdaATqOtAJ0HGmF7gVHWgE6jtQeesCRVoCOI60AHUdaATqOtAJ0Abo9dBxpBeg4UntHGnCkFaDjSCtAx5HaQ4840grQcaT23UvEkVaAjiOtAF2Abg8dR1oBOo60AnQcaQXoONIK0HGk9tATjtTekSYcaQXoONIK0HGkFaAL0O2h40grdC840grQcaQVoONIK0DHkdpDFxxpBeg40grQcaQVoONIK0AXoJs7UsGRVoCOI60AHUdaATqOtAJ0HKl99zLjSCtAx5FWgI4jrQAdR1oBugDdHjqOtAJ0HGkF6DjSCtBxpPaOdMaR2kNfcKQVoONIK0DHkVaAjiO1714WAbo9dBxpBeg40grQcaQVoONIK0DHkdpDX3GkFaDjSCtAx5HaO9IVR1oBugDdHjqOtAJ0HGkF6DjSCt0LjrQCdBypPfQNR1oBOo60AnQcaQXoONIK0AXo9tBxpBWg40jtHemGI60AHUdaATqO1B56xpFWgI4jte9eMo60AnQcaQXoAnR76DjSCtBxpBWg40grQMeRVoCOIzWHPk84UnNHOk840grQcaQVoONIK0AXoNtDx5FW6F5wpBWg40grQMeRVoCOI7WHHnCkFaDjSCtAx5FWgI4jrQBdgG7uSAOOtAJ0HGkF6DjSCtBxpBWg40jtu5eII60AHUdaATqOtAJ0HGkF6AJ0e+g40grQcaQVoONIK0DHkdo70ogjtYeecKQVoONIK0DHkVaAjiO1716SAN0eOo60AnQcaQXoONIK0HGkFaDjSO2hC460AnQcaQXoOFJ7Ryo40grQBej20HGkFaDjSCtAx5FW6F5wpBWg40jtoc840grQcaQVoONIK0DHkVaALkC3h44jrQAdR2rvSGccaQXoONIK0HGk9tAXHGkF6DhS++5lwZFWgI4jrQBdgG4PHUdaATqOtAJ0HGkF6DjSCtBxpPbQVxypvSNdcaQVoONIK0DHkVaALkC3h44jrdC94EgrQMeRVoCOI60AHUdqD33DkVaAjiOtAB1HWgE6jrQCdAG6uSPdcKQVoONIK0DHkVaAjiOtAB1Hat+9ZBxpBeg40grQcaQVoONIK0AXoNtDx5FWgI4jrQAdR1oBOo7U3pFmHKk59GXCkVaAjiOtAB1HWgE6jtS8e1kmAbo9dBxpBeg40grQcaQVoONIK0DHkdpDDzjSCtBxpBWg40jtHWnAkVaALkC3h44jrQAdR1oBOo60QveCI60AHUdqDz3iSCtAx5FWgI4jrQAdR1oBugDdHjqOtAJ0HKm9I4040grQcaQVoONI7aEnHGkF6DhS++4l4UgrQMeRVoAuQLeHjiOtAB1HWgE6jrQCdBxpBeg4UnvogiO1d6SCI60AHUdaATqOtAJ0Abo9dBxphe4FR1oBOo60AnQcaQXoOFJ76DOOtAJ0HGkF6DjSCtBxpBWgC9DNHemMI60AHUdaATqOtAJ0HGkF6DhS++5lwZFWgI4jrQAdR1oBOo60AnQBuj10HGkF6DjSCtBxpBWg40jtHemCI7WHvuJIK0DHkVaAjiOtAB1Hat+9rAJ0e+g40grQcaQVoONIK0DHkVaAjiO1h77hSCtAx5FWgI4jtXekG460AnQBuj10HGkF6DjSCtBxpBW6FxxpBeg4UnvoGUdaATqOtAJ0HGkF6DjSCtAF6PbQcaQVoONI7R1pxpFWgI4jrQAdR2oOfZ1wpBWg40jNu5d1wpFWgI4jrQBdgG4PHUdaATqOtAJ0HGkF6DjSCtBxpPbQA47U3pEGHGkF6DjSCtBxpBWgC9DtoeNIK3QvONIK0HGkFaDjSCtAx5HaQ4840grQcaQVoONIK0DHkVaALkA3d6QRR1oBOo60AnQcaQXoONIK0HGk9t1LwpFWgI4jrQAdR1oBOo60AnQBuj10HGkF6DjSCtBxpBWg40jtHWnCkdpDFxxpBeg40grQcaQVoONI7bsXEaDbQ8eRVoCOI60AHUdaATqOtAJ0HKk99BlHWgE6jrQCdBypvSOdcaQVoAvQ7aHjSCtAx5FWgI4jrdC94EgrVDqO1B76giOtAB1HWgE6jrQCdBypffeyCNDtKx1HWgE6jrQCdBxpBeg40grQcaT23cuKI60AHUdaATqOtAJ0HOkboEu8j/vjn+tX6DIq9JTjHbrEcAJ9lTvzjxuc+7Xb/AlxWIf5I4h5L9y8Tc8QD6YYpvu1Hx8VD+JhOZphTnfQIcvTDNdPeYb1oi7kidO0j3mK6VmeA9DrDjrnr59WwxpcJ0rKsiu55L9ScljX7EPJMN/9dQybfP3IHNZf+5AnbnceMcXt9UL7YJB2HM8T/NRyG9a2d6jlsGlAg1rO4X5xmJ9t3c93y23YPGJs2YdNRFqUfdlN6PxnR/Vj2QXZR5SdFOlbsu/DDtOTOoe6S853mzNPc36tu8xZ7sNYZHq++KbPsDHSB5ldn+caP86n87LtaVx+intyOFzE2x16lumPfPoASdpXZkp5fb3Y0hT3NT+l9LWVHjZL6lPOYQOlPuUcNoBqU85HnpjCmr/ImYfNoPqUc9gYqlE59zY4xXByBy4u8a5iXNLZxXr39vKwGRc19baaGjZAo6b+oabU7lxnoaaoKeWaGjb6G6Gm5nWvqbMyOfsqWyaDpFC0mySCUGpKu6ZIY6kp7ZoiEqamdBvvbSKXpqa0a4pwnJr6ffHrL9lvE4k3hfKtQiHGplC+VShCoVAo/6H7o5NtIp2mqvSriiibqvp5Van9umabyL0pwKoFSEhOAVYtQBJ1CvBCAWr95G0LxO8UYNUCJKvvtwDXdMcX1+Uv3Wogq6dQvlUoZPUUinKfHoSaoqaUa4pQn5rSrikifWpK26GR0lNT2jVF8N5UTcVV9prazpKkn/yE7+TnVlsgIKdQfl+s9jOGLZJ5U1PaNUWMTU1p1xSJNzV1qym1n8ZEwnFqSrumhJqipv7j/McRkcSbQvlWoRBjUyjfKhSyaQrl98WaP4yJpNNUlX5VEWVTVT+vKr0vByRybwqwagESklOAVQuQRJ0CvFCAat97ScTvFGDVAhQKsN8CrHIs6JaI9akp7ZriDgA1dasptfvUiZsF1JR2TXGroN+a0vxVciL9p1C+UyhCSk+hKOeeQvBOTWnXFFk6NaVdU8Tj1NT/0E28Ragpakq5poZNvJfpHrPIsoazmkr5/tpB4mPcv+AfDCTJPhB5FGBcjq7+9eyW+0tvT8qnef6UaNgA+Y0SzY+QbV7jiUQxLvuw4zr9IdHBQNbtnsn9ehL9gaDDpreNCnq6QoeNTntdocNGnJ0KOg8bRfYq6LA5YK+CDhvC9SrosAlYr4IKgnZlW2ayn85WKElRZyuUpKizFUpS1JmgJEV9CbqQFPW1hy4kRZ2tUJKizgQlKepMUEHQvgQlKeqsKSIp6myFkhR1JihJUWeCkhT1tYeuJEV9rdCVpKizFUpS1NkKJSnqbIUKgva1QkmKOhOUpKgzQUmKOttDSYo6W6EkRX2t0I2kqK8VupEUdbZCSYo6W6EkRZ0JKgjal6AkRZ3toSRFna1QkqLOBCUp6uwjl6SorxWaSYr6WqGZpKizFUpS1NkKJSnqbIUKgvYlKElRZ4KSFHUmKElRZ4KSFHXW5ZIUdbVC80RS1JmgJEWdCUpS1NUemieSos5WqCBoXyuUpKizFUpS1JmgJEWdCUpS1JmgJEV9NUWBpKivFRpIijpboSRFna1QkqLOBBUE7esjl6SosxVKUtSZoCRFnQlKUtSZoCRFfQkaSYo6E5SkqDNBSYo6E5SkqK9gIQqC9rVCSYo6E5SkqLOPXJKizlYoSVFngpIU9SVoIinqaw9NJEWdrVCSos5WKElRZytUELQvQUmKOvvIJSnqbIWSFHW2QkmKOluhJEV9rVAhKeprhQpJUWeCkhR1JihJUWeCCoL2JShJUWddLklRZyuUpKgzQUmKOvvIJSnqa4XOJEWdCUpS1JmgJEWdCUpS1JmggqB9CUpS1JdtmUmKOluhJEWdCUpS1JmgJEV9CbqQFPXVFC0kRZ2tUJKizgQlKersI1cQtK8VSlLU2QolKepshZIUdSYoSVFnH7kkRX2t0JWkqK8VupIUdbZCSYo6E5SkqLOPXEHQvlYoSVFnK5SkqLMVSlLUmaAkRZ195JIU9bVCN5KizgQlKepMUJKizgQlKepMUEHQvgQlKepMUJKivnzoRlLU2QolKepshZIU9bVCM0lRZ4KSFHUmKElRZ4KSFHUmqCBoX4KSFHUmKElRXz40kxR1tkJJijoTlKSop4/cOE0kRT2t0A9BSYo6E5SkqLOPXJKizlaoIGhfK5SkqLMVSlLUmaAkRZ0JSlLUmaAkRX0JGkiK+upyA0lRZyuUpKgzQUmKOvvIFQTta4WSFHW2QkmKOluhJEWdrVCSos5WKElRX4JGkqK+PnIjSVFnK5SkqDNBSYo6E1QQtK89lKSosxVKUtSZoCRFnX3kkhR1tkJJivoSNJEUdSYoSVFngpIUdSYoSVFnggqCdmVbEklRZyuUpKizFUpS1NkKJSnqTFCSor4EFZKivvZQISnqbIWSFHW2QkmKOluhgqB9rVCSos5WKElRZyuUpKizFUpS1NkKJSnqa4XOJEWdCUpS1NdH7kxS1NkKJSnqTFBB0L4EJSnqTFCSos4EJSnqrMslKepshZIU9SXoQlLUmaAkRX3toQtJUWcrlKSoM0EFQfsSlKSoM0FJijoTlKSosy6XpKizFUpS1NcKXUmK+lqhK0lRZyuUpKizFUpS1NkKFQTta4WSFHUmKElRZ4KSFHW2h5IUdbZCSYr6WqEbSVFfK3QjKepMUJKizj5ySYo6W6GCoH2tUJKizlYoSVFnK5SkqLMVSlLUmaAkRX0JmkmK+tpDM0lRZyuUpKgzQUmKOvvIFQTta4WSFHW2QkmKOluhJEWdrVCSos5WKElRV4KGiaSoM0FJijoTlKSoM0FJirrqcsMkCNrXCiUp6kxQkqLOBCUp6mwPJSnqbIWSFPUlaCAp6kxQkqLOBCUp6qspCiRFna1QQdC+BCUp6uwjl6SosxVKUtSZoCRFnQlKUtSXoJGkqDNBSYr66nIjSVFnK5SkqLMVKgja1wolKepshZIUdbZCSYo6W6EkRZ2tUJKivlZoIinqa4UmkqLOBCUp6kxQkqLOBBUE7UtQkqLOulySos5WKElRZyuUpKizFUpS1NcKFZKivlaokBR1tkJJijpboSRFna1QQdC+VihJUWeCkhR19pFLUtTZCiUp6kxQkqK+PnJnkqK+VuhMUtTZCiUp6myFkhR1JqggaF+CkhR1toeSFHW2QkmKOhOUpKgzQUmK+tpDF5KivlboQlLU2QolKepshZIUdbZCBUH7WqEkRZ2tUJKizlYoSVFnK5SkqLqg27YLmtOBRGQ/riRav0q0kubUlkjisg87HexcK/mMe4lIXNxLRIbiXiJBIu8SkXO4l4jkwr1EZBHuJSJdcC8R6YJ3iTbSBfcSkS64l4h0wb1EpAvuJRIk8i4R6YJ7iUgX3EtEuuBeItIF9xKRLniXKJMuuJeIdMG9RKQL7iUiXXAvkSCRd4lIF9xLRLpQXaIl7MNeDr4wnEkX3EtEuuBeItIF5xLFiXShukQ7vyibHEhEuuBeItIF5013nEgX3EskSORdItIF9xKRLriXiHTBvUSkC+4lIl3wLlEgXXAvEemCe4lIF9xLRLrgXiJBIu8SkS64l4h0wb1EpAvuJSJdcC8R6YJ3iSLpgnuJSBfcS0S64F4i0gX3EgkSeZeIdMG9RKQL7iUiXfD+ne5IuuBeItIF7xIl0gX3EpEueP9lRCJdcC8R6YL3pjsJEnmXiHTBvUSkC+4lIl1wLxHpgnuJSBe8SySkC+4lIl1wLxHpgnuJSBfcSyRI5F0i0gX3EpEuuJeIdMG9RKQL7iUiXfAu0Uy64F4i0gX3EpEuuJeIdMG9RIJE3iUiXXAvEemCe4lIF7x/YXgmXXAvEemCd4kW0gX3EpEueP/a/UK64F4i0gXvTfciSORdItIF9xKRLriXiHTBvUSkC+4lIl3wLtFKuuBeItIF9xKRLriXiHTBvUSCRN4lIl1wLxHpgnuJSBfcS0S64F4i0gXvEm2kC+4lIl1wLxHpgnuJSBfcSyRI5F0i0gX3EpEueP826ka64F4i0gX3EpEueJcoky54/053Jl1wLxHpgvemO5MuuJdIkMi7RKQL7iUiXXAvEemCe4lIF9xLRLrgXKI0kS64l4h0wb1EpAvuJSJdcC+RIJF3iUgX3EtEuuBeItIF9xKRLriXiHTBu0SBdMG9RKQL7iUiXXAvEemCe4kEiXx/1TEF0gX3EpEuuJeIdMG9RKQLzr8wnALpgneJIumC96Y7ki64l4h0wb1EpAvuJRIk8i4R6YJ7iUgX3EtEuuBeItIF9xKRLniXKJEuuJeIdMG9RKQL7iUiXXAvkSCRd4lIF9xLRLrgXiLSBfcSkS64l4h0wbtEQrrgXiLSBe/foxPSBfcSkS64l0iQyLtEpAvev40qpAvuJSJdcN90ky64l4h0wbtEM+mCe4lIF9xLRLrgXiLSBfcSCRJ5l4h0wb1EpAvuJSJdcC8R6YJ7iUgXvEu0kC64l4h0wb1EpAvuJSJdcC+RIJF3iUgX3EtEuuBeItIF71/SWkgX3EtEuuBdopV0wb1EpAvev+q4ki64l4h0wXvTvQoSeZeIdMG9RKQL7iUiXXAvEemCe4lIF7xLtJEuuJeIdMG9RKQL7iUiXXAvkSCRd4lIF9xLRLrgXiLSBfcSkS64l4h0wbtEmXTBvUSkC+4lIl3w/g2gTLrgXiJBIu8SkS64l4h0wfv36DLpgnuJSBfcN92kC84lkol0wb1EpAvuJSJdcC8R6YJ7iQSJvEtEuuBeItIF9xKRLriXiHTBvUSkC94lCqQL7iUiXXAvEemCe4lIF9xLJEjkXSLSBfcSkS44/3qJBNIF9xKRLriXiHTBu0SRdMH5l7Qkki64l4h0wXvTHUkX3EskSORdItIF9xKRLriXiHTBvUSkC+4lIl3wLlEiXXAvEemCe4lIF9xLRLrgXiJBIu8SkS64l4h0wb1EpAvuJSJdcC8R6YL37y4I6YJ7iUgX3EtEuuBeItIF798AEkEi7xKRLnhvuoV0wb1EpAvuJSJdcC8R6YJ3iWbSBfcSkS64l4h0wb1EpAvuJRIk8i4R6YJ7iUgX3EtEuuBeItIF9xKRLniXaCFdcC8R6YL3G+ML6YJ7iUgX3EskSORdItIF718vWUgX3EtEuuC+6SZdcC8R6YJ3iVbSBfcSkS64l4h0wb1EpAvuJRIk8i4R6YJ7iUgX3EtEuuBeItIF9xKRLniXaCNdcC8R6YJ7iUgXvN913UgX3EskSORdItIF9xKRLnj/7sJGuuBeItIF90036YJ3iTLpgnuJSBfcS0S64F4i0gX3EgkSeZeIdMG9RKQL7iUiXXAvEemCe4lIF5xLNE+kC+4lIl1wLxHpgvNbevNEuuBeIkEi7xKRLriXiHTB+Y3xeSJdcC8R6YL7ppt0wbtEgXTBvUSkC+4lIl1wLxHpgnuJBIm8S0S64F4i0gX3EpEuuJeIdMG9RKQL3iWKpAvuJSJd8H6/KJIuuJeIdMG9RIJE3iUiXfB+1zWSLriXiHTBfdNNuuBeItIF7xIl0gX3EpEuuJeIdMG9RKQL7iUSJPIuEemCe4lIF9xLRLrgXiLSBfcSkS54vxkhpAvuJSJdcC8R6YJ7iUgXvN/SE0Ei7xKRLnhvuoV0wb1EpAvuJSJdcC8R6YJ3iWbSBfcSkS64l4h0wb1EpAvuJRIk8i4R6YJ7iUgXvCfdM+mCe4lIF9xLRLrgXaKFdMH7/aKFdMG9RKQL3pvuhXTBvUSCRN4lIl1wLxHpgnuJSBfcS0S64F4i0gXvEq2kC+4lIl1wLxHpgvcYdSVdcC+RIJF3iUgX3EtEuuD9ZsRKuuBeItIF90036YJ3iTbSBfcSkS64l4h0wb1EpAvuJRIk8i4R6YJ7iUgX3EtEuuA9o9tIF9xLRLrgXaJMuuBeItIF70l3Jl1wLxHpgvemOwsSeZeIdMG9RKQL7iUiXXAvEemCe4lIF5xLtEykC+4lIl1wHgAtE+mCe4lIF9xLJEjkXSLSBecx6jKRLriXiHTBfdNNuuBeItIF7xIF0gX3EpEuuJeIdMG9RKQL7iUSJHKeLgTSBfcSkS64l4h0wb1EpAveM7pAuuBdoki64L3pjqQL7iUiXXAvEemCe4kEibxLRLrgXiLSBe/WNZIuuJeIdMG9RKQL3iVKpAveA6BEuuBeItIF7013Il1wL5EgkXeJSBfcS0S64F4i0gX3voh0wb1EpAveJRLSBfcSkS54TxeEdMG9RKQL3ptuESTyLhHpgnuJSBfcS0S64L7pJl1wLxHpgneJZtIF9xKRLni3rjPpgnuJSBe8N92zIJF3iUgX3EtEuuC+oyNdcC8R6YJ7iUgXvEu0kC5490UL6YJ7iUgXvDfdC+mCe4kEiby3C6QL7iUiXXAvEemCe4lIF9w33aQL3iVaSRe8N90r6YL3vWglXXAvEemCe4kEibxLRLrgvqMjXXAvEemC+w860gX3EpEueJdoI11wLxHpgvd2YSNdcC8R6YK+RNu8B6PbMp1IlNMmn1dnmR4fdGE74pe2nV/KTxcfTTFN8T7FNKX0fPFNe0H7YbUnDxlXe4KWcbUnwelX+zBv94vDmr9qTzQ0rvZkTh1rn3ftY0ivL/71sM37oJd0cnHI6X5xyLJ9qapMTEZV/biq4jTtqKd4cvG87vWR8/P0bgVICEgBVi1AIk4KsGoBEuBSgBcKUPYZTkv+qwIUCpACrFmARNkU4M8L8BGYxPB0Z3S3toTkVJV+VRG/U1X6VUWwT1XpVxW3DKiqn1dV3IcRU9xeX/whXdpVfNblVoLrxP0FSrByCXKHgRJ8cwnO4X5xmCX+RRayTtyOoFrbqVbuXVCt7VSrUK1U65urdf/R24c5l7+qVu6KUK3tVCt3W6jWW7U+ft64nN0X1vsazTpxY4YCrFqA3MOhAC8UoNbXaNaJ2z0UYM0CDNzsoQB/D3pNd9ZxXf7y/k3g/g1VpV9V3Gehqn5eVXphdODWCQVYtQCFAqQAaxYgNzgowAsFqHbPInDPggKsWoDcs+i3AOMqewFuZyFcnd+er4F7FhRg1QLkngUFeKEA1e5ZRO5ZUIBVC5DbGxTgrQB/cNf25Fy/NXJ7g6r6cVUpNnaR2xsUYNUCFAqQAqxZgNzeoAAvFKCes+D2BgVYtQC5vUEB/rwAX59qtEbuWVBV+lXFjQiqSr2qEncXqKqfV5Xm8VeJ+wuUYOUS5GYEJfjmEtT7WnLizgXV2k61CtVKtTZTrdwToVrfXa1qX89P3EChWtupVu62UK2/B615TkLibgtVpV9V3G2hqn5eVXpGRLgxQwFWLUBuy1CAVQuQmzIU4IUCVPOrwn0WCrBqAQoFqF+Ae0l9/HM7KcB112fdlgfpT3m4V+BaHsJx1/KQBuvLk9M+kDzPf8hzg05YWgE6WaI99Jn87HvQ9x9TBXk6VOQQ+ib3D/9tO9FH5iz7KOQBOiyf8pAuuZZn1OxlTuH+e4lZ0nwiT5py2F3kcnZ1XLZ9JGvIZ1eH8PjlhqwnV2/5Xif5SZjwMd+bnqNGGa3qmfN+e3Katj8E/Xrxkqf7sJccTmKSLT4+JuISv4QOs1AqlMr3SmXUAIRS+XGpjBrGUCo/LpVRgyFK5celMmqcRan8uFRGDeEolZ+WyjJqdEip/LhURo0xKZUflwqRKqXyzVIhraVUvlkqQqlQKt8rFdJaSuWbpUJaS6l8s1RIaymVb5YKaS2l8s1SIa2lVL5XKitpLaXyzVIhraVUvlkqpLWUyjdLhbSWUvlmqQilQql8r1RIaymVb5YKaS2l8s1SIa2lVL5ZKqS1lMo3S4W0llL5XqlspLWUyjdLhbSWUvlmqZDWUirfLBXSWkrlm6UilAql8r1SIa2lVL5ZKqS1lMo3S4W0llL5ZqmQ1nZcKmuU+0uv8Vmcu/oEsAOrn8lUR1afmLRr9XfcawoH6pN8jqw+YebI6gvqD6w+kePI6pMijtzzEwyOrD5Z38jqk/WNu+9vE1nfyOqT9Y2sPlnfyOqT9Y2svqD+wOqT9Y2sPlnfuH5/m8j6RlafrG9k9cn6BlY/kPWNrD5Z38A9fyDrG1l9sr6R1RfUH1h9sr6R1SfrG1l9sr6R1SfrG1l9sr6B1Y9kfQNnfZGsb2T1yfpGVp+sb2T1BfUHVp+sb+Sen6xvZPXJ+kZWn6xvZPXJ+gZWP5H1jaw+Wd/I6pP1jaw+Wd/I6gvqj5v1JbK+kdUn6xtZfbK+kdUn6xtZfbK+gXt+IesbWX2yvpHVJ+sbWX2yvpHVF9QfWH2yvpHVJ+sbWX2yvpHVJ+sbOOsTsr6B1Z/J+kZWn6xvZPXJ+kZWn6xv4J5/FtQfWH2yvpHVJ+sbWX2yvpHVJ+sbWX2yvoHVX8j6RlafrG9k9cn6Bs76FrK+kdUX1B9YfbK+kdUn6xtZfbK+kXt+sr6R1SfrG1j9laxvZPXJ+kZWn6xvZPXJ+kZWX1B/YPXJ+kZWn6xv4KxvJesbWX2yvpHVJ+sbWP2NrG9k9cn6Bu75N7K+kdUn6xtZfUH9gdUn6xtZfbK+kdUn6xtZfbK+kdUn6xtY/UzWN3DWl8n6RlafrG9k9cn6RlZfUH9g9cn6Ru75yfpGVp+sb2T1yfpGVp+sb1z180TWN7L6ZH0jq0/WN7L6ZH0jqy+oP2zWlyeyvpHVJ+sbWX2yvpHVJ+sbWX2yvoF7/kDWN7L6ZH0jq0/WN7L6ZH0jqy+oP7D6ZH0jq0/WN7L6ZH0jq0/WN3DWF8j6BlY/kvWNrD5Z38jqk/WNrD5Z38A9fxTUH1h9sr6R1SfrG1l9sr6R1SfrG1l9sr6B1U9kfSOrT9Y3svpkfQNnfYmsb2T1BfUHVp+sb2T1yfpGVp+sb+Sen6xvZPXJ+gZWX8j6RlafrG9k9cn6RlafrG9k9QX1B1afrG9k9cn6Bs76hKxvZPXJ+kZWn6xvYPVnsr6R1SfrG7jnn8n6RlafrG9k9QX1B1afrG9k9cn6RlafrG9k9cn6RlafrG9g9ReyvoGzvoWsb2T1yfpGVp+sb2T1BfUHVp+sb+Sen6xvZPXJ+kZWn6xvZPXJ+gZWfyXrG1l9sr6R1SfrG1l9sr6R1RfUHzfrW8n6RlafrG9k9cn6RlafrG9k9cn6Bu75N7K+kdUn6xtZfbK+kdUn6xtZfUH9gdUn6xtZfbK+kdUn6xtZfbK+gbO+jaxvYPUzWd/I6pP1jaw+Wd/I6pP1DdzzZ0H9gdUn6xtZfbK+kdUn6xtZfbK+kdUn6xtW/TRNZH0jq0/WN7L6ZH3DZn0f6pP1jay+oP7A6pP1jaw+Wd/I6pP1jdzzk/WNrD5Z38DqB7K+kdUn6xtZfbK+kdUn6xtZfUH9gdUn6xtZfbK+gbO+QNY3svpkfSOrT9Y3sPqRrG9k9cn6Bu75I1nfyOqT9Y2svqD+wOqT9Y2sPlnfyOqT9Y2sPlnfyOqT9Q2sfiLrGzjrS2R9I6tP1jey+mR9I6svqD+w+mR9I/f8ZH0jq0/WN7L6ZH0jq0/WN7D6QtY3svpkfSOrT9Y3svpkfSOrL6g/btYnZH0jq0/WN7L6ZH0jq0/WN7L6ZH0D9/wzWd/I6pP1jaw+Wd/I6pP1jay+oP7A6pP1jaw+Wd/I6pP1jaw+Wd/AWd9M1jew+gtZ38jqk/WNrD5Z38jqk/UN3PMvgvoDq0/WN7L6ZH0jq0/WN7L6ZH0jq0/WN7D6K1nfyOqT9Y2sPlnfwFnfStY3svqC+gOrT9Y3svpkfSOrT9Y3cs9P1jey+mR9A6u/kfWNrD5Z38jqk/WNrD5Z38jqC+oPrD5Z38jqk/UNnPVtZH0jq0/WN7L6ZH0Dq5/J+kZWn6xv4J4/k/WNrD5Z38jqC+oPrD5Z38jqk/WNrD5Z38jqk/WNrD5Z37jqf7wC6g+b9YWJrG9k9cn6RlafrG9k9QX1B1afrG/knp+sb2T1yfpGVp+sb2T1yfoGVj+Q9Y2sPlnfyOqT9Y2sPlnfyOoL6o+b9QWyvpHVJ+sbWX2yvpHVJ+sbWX2yvoF7/kjWN7L6ZH0jq0/WN7L6ZH0jqy+oP7D6ZH0jq0/WN7L6ZH0jq0/WN3DWF8n6BlY/kfWNrD5Z38jqk/WNrD5Z38A9fxLUH1h9sr6R1SfrG1l9sr6R1SfrG1l9sr6B1ReyvpHVJ+sbWX2yvoGzPiHrG1l9Qf2B1SfrG1l9sr6R1SfrG7nnJ+sbWX2yvoHVn8n6RlafrG9k9cn6RlafrG9k9QX1B1afrG9k9cn6Bs76ZrK+kdUn6xtZfbK+gdVfyPpGVp+sb+CefyHrG1l9sr6R1RfUH1h9sr6R1SfrG1l9sr6R1SfrG1l9sr6B1V/J+gbO+layvpHVJ+sbWX2yvpHVF9QfWH2yvpF7frK+kdUn6xtZfbK+kdUn6xtY/Y2sb2T1yfpGVp+sb2T1yfpGVl9Qf9ysbyPrG1l9sr6R1SfrG1l9sr6R1SfrG7jnz2R9A6/9TNY3svpkfSOrT9Y3svqC+gOrT9Y3cs9P1jfy2ifrG1l9sr6R1SfrG1f9OJH1jaw+Wd+4PX+cyPpGVp+sb2T1BfUHVp+sr2f1Jd4Bfvxz/ao+WV9b6ocpTrv8Mp3I/5Hl3l/7w9ynk6tz2uTz6izTH8VygCRtu5QpP128HvKL6/3iKaXni29lSOhIGTooQ9JPytBBGRLDUoYGZRjm+zh+/aT/SxkG8mDK0EEZEkxThhZlmPcyjCG9vjgu8Q47Luns4mnaWU/x5OJ53Us15y92PRDTsxZYC7e1wE0L1kLba0GWfS0s+a/WgrAWWAushd9rgRtarAV3a2Fe97VwVt4hp7DPULavhph7dhR4ywWuaQK4cchaYC3c1gJ3L1kLrIXbWuAWKmuh7bWgZogj93FZC6yF21rgZjJroem18Pi2xEfDL1/CocgdYgq86wLnti8F3nWBCwVOgbdc4HEfRkxxe33xRxXtP2dLzyVyXw3czWU1sBruq4Fbv6yGcVbDHO4Xh1niX+U+3Cdm4bBwLiwcbiqzcFg4FxYOd6BZOAMtnGX/zur8Z6j104WTuF3NwmHhXFg43Ntm4XhbOGuad3zLX6ZfiXvbFHjXBc69bQq86QLX889JWAusBdbC77XATXDWAmvhtha4Bc5aaHst6CU+3NVmLbAWbmuBG9WsBYO1EFfZ+W1ndwJ+cgTS2bEviRvKFHjLBa74837hHjFrgbVwWwvc9mUtsBZua4E7xKyFtteC2lEXws1k1gJr4bYWhLXAWmh5LZwcGiDcIabAuy5wbvtS4F0XOPdyKfCmC1zzoAvhbi6rgdVwXw3c+mU1jLMa9L4sOnOfmIXDwrmwcLipzMJh4VxYONyBZuEMtHDUvr89c7uahcPCubBwhIXDwvG2cOo89m3mNjhrgbVwWwvcMWcttL0W1L7/N3NznbXAWritBW6tsxa8rQXNU/Rm7pZT4D0X+MJdbQq86QLXu9+2cKOatcBauK0F7j2zFlgLt7XA7WTWQttrQe0O8SKsBdYCa+H3WuAOcWNrIW1PYUj+o7pvinKfszdFuVvXsqLxQFHuOfWmKDdZOlN05a5Cb4qSjfemKAlvb4qSU1ZXND1+5ZEk/XH1TSNBI/cakev414ikxr9GZC/+NSJN8a8R+Yh7jTYSD/8akWH414hUwr9G5Az+NRI0cq8ROYN/jcgZ/GtEzuBfI3IG/xqRM7jXKJMz+NeInMG/RuQM/jUiZ/CvkaCRe43IGfxrRM7gXyNyBv8akTP414icwbtGaSJn8K8ROYN/jcgZ/GtEzuBfI0Ej9xqRM/jXiJzBv0bkDP41ImfwrxE5g3uNAjmDf43IGfxrRM7gXyNyBv8aCRq514icwb9G5Az+NSJn8K8ROYN/jcgZ3GsUyRn8a0TO4F8jcgb/GpEz+NdI0Mi9RuQM/jUiZ/CvETmDf43IGfxrRM7gXqNEzuBfI3IG/xqRM/jXiJyhukaS0j7uLZ1cvUj8vHhZ1v3atKSjV348+zIuYfvj6pv6gvoDq082MrL6pC4jq0+eM7L6JEUjq08GNbD6Qro1svrkZiOrTyI3svpkfR2rv877c4i3MJ9cnef96jxv8aBWhFqhVr5ZK+SI1MpnraR8p53l9OowTzvuj38vy0FtkVJSW++qLTJQauu7exyJKbXy3VohX6VW3rRnzaS31Na7aotsmNr65h43kyRTK9+tFXJnauWzVmK6jzrHOR/UilAr1Mo3P1fInamV79YKOTK18i7fRI5Mbb2rtsidqa3v7nHkztTKN2tlIUemVt60Zy3kyNTWu2qL3Jna+u4eR+5MrXy3VoRaoVZutXJ2j2Ihd6ZWvvu5Qu5MrXy3VsiRqZV3+SZyZGrrXbVF7kxtfXOPW8mdqZXv1go5MrXypj1rJUemtt5VW+TO1NZ39zihVqiVb9YKuTO18lkrZ/coVnJnauW7nyvkztTKd2uFHJlaeZdvIkemtt5UWxu5M7X1zT1uI3emVr5bK+TI1Mq79ixyZGrrXbUl1Ba19c09jtyZWvlurZA7UyuftXJ2j2Ijd6ZWvvu5Qu5MrXy3VsiRqZU3+aZMjkxtvau2yJ2prW/ucZncmVr5bq2QI1Mr79qzhNqitt5UW+TO1NZ39zhyZ2rlu7VC7kytfNbK2T2KTO5MrXz3c4XcmVr5Xq3IRI5MrbzHN8lEjkxtvau2yJ2pre/uceTO1Mp3a0WoFWrlTXsWOTK19a7aInemtr67x5E7UyvfrRVyZ2rls1ZO7lHIRO5MrXzzcyWQO1Mr360VcmRq5U2+KZAjU1vvqi1yZ2rru3ucUCvUyjdrhRyZWnnXnkWOTG29q7bInamt7+5x5M7UyndrhdyZWvmslbN7FJHcmVr55udKJHemVr5bK+TI1MqbfFMkR6a23lVbQm1RW9/c48idqZXv1go5MrXyrj2LHJnaeldtkTtTW9/d48idqZVv1koid6ZWPmvl7B5FInemVr5bK+TOHddKjnJ/5byms1rJ6/3qME3p7MVDSNPeDIcPmgfFRfBMcb2tuITiorjeVVxE1RTX24qLbJvieltxEW5TXG8rLtJtiuttxUUc3m9xybTcRy0hpq/qCwH3yOoTWY+sPiH0yOqTEo+svqD+wOqTs46sPkHoyOqTVI6sPlHiyOqT9Q2s/kzW17H6IS139eMUTq4O67bcxQlrTtPZ9WHa9us//u/gK40zWSLV9b7qIqukut5XXWShVJdKdcX5oLqE6qK6LlbX6fc3ZrJcqut91UVWTHW9r7rIoqmu91UXWTfV9b7qIkunuu7VlfMdSdim5exL3OFj4Ov9+ijr9LW6FrJ6qutqdc1L2qtrzkfVRVZPdb2vusjqqa73VRdZPdX1vuoSqovqelt1kdVTXe+rLrJ6qut91UVWT3W9r7rI6qmuT9pbfJxxsaVJDqqF7J1q+Xa1rGTpVMu9WiQ9qkXmg0cJrGTjHVdLDHGvFomn1bKGHfe2zuGgWsi6qZbvVwvZNdXy/WoRqoVq+Xa1kC1TLd+vFrJiquX71UL2S7V8v1rIcqmW71cLWS7V8u1q2chyqZbvVwtZLtVyr5ZNHsn/R7mcXL/k6c5kyeExll8/BfpaUXF/7S0u8fniWx2SElOHHuqQ/Jk69FCHQh1Shw7qkMycOvRQh6Tx1KGHOiTnpw491CF3EKhDD3XIvQnq0EEdZu56UIce6pD7KdShhzrkfgp16KEOuZ9CHXqoQ6EOqUMHdcj9FOrQQx1yP4U69FCH3E+hDj3UIfdTqEMPdcj9FOqwfh3OE/dTqEMPdcj9FOrQQx1yP4U69FCH3E+hDj3UoVCH1KGDOuR+CnXooQ65n0IdeqhD7qdQhx7qkPsp1KGHOuR+CnXooA4D91OoQw91yP0U6tBDHXI/hTr0UIfcT6EOPdShUIfUoYM65H4KdeihDrmfQh16qEPup1CHHuqQ+ynUoYc65H4KdeigDiP3U6hDD3XI/RTq0EMdcj+FOvRQh9xPoQ491KFQh9Shgzrkfgp16KEOuZ9CHXqoQ+6nUIce6pD7KdShhzoc9n6KLPeRzHP4U/3fZNKoCf+6xvtI1nWVAzKjZs7bMt2HvS0xHJAZNQU9JzNqLndORiBTIDNqdnFOZlQ3fU5mVH93TmZUx3FOZtQe+JSMjNoDn5OhBy6RoQcukaEHLpERyBTI0AOXyNADl8jQA5fI0AOXyNADF8jM9MAlMvTAJTL0wCUy9MAlMgKZAhl64BIZeuASmVF74BDiPpQQUjy4sz2P2gV/h82offA32CyjdsLfYTNqL/wdNqN2w99hM2o//B02Apsim1F74u+wGbUr/g4b+uIyG/riMhv64iKblb64zIa+uMyGvrjMhr64zEZgU2RDX1xmQ19cZkNfXGZDX1xmQ19cZLPRF5fZ0BeX2dAXl9nQF5fZCGyKbOiLy2zoi8ts6IvLbOiLy2zoi4tsMn1xmQ19cZkNfXGZDX1xmY3ApsiGvrjMhr64zIa+uMyGvrjMhr64xGaZ6IvLbOiLy2zoi8ts6IvLbAQ2RTb0xWU29MVlNvTFZTb0xWU29MVFNoG+uMyGvrjMhr64zIa+uMxGYFNkQ19cZkNfXGZDX1xmQ19cZkNfXGQz7DO4v8OGvrjMhr64zIa+uMxGYFNkQ19cZkNfXGZDX1xmQ19cZkNfXGQz7JPrvsOGvrjMhr64zIa+uMxGYFNkQ19cZkNfXGZDX1xmQ19cZkNfXGQz7NPsvsOGvrjMhr64zIa+uMxGYFNkQ19cZkNfXGZDX1xmQ19cZkNfXGQz7BPuvsOGvrjMhr64zIa+uMxGYFNkQ19cZkNfXGZDX1xmQ19cZkNfXGTD8+5esKEvLrOhLy6zoS8usxHYFNnQF5fZ0BeX2dAXl9nQF5fZ0BcX2fC8uxds6IvLbOiLy2zoi8tsBDZFNvTFZTb0xWU29MVlNvTFZTb0xUU2PO/uBRv64jIb+uIyG/riMhuBTZENfXGZDX1xmQ19cZkNfXGZDX1xkQ3Pu3vBhr64zIa+uMyGvrjMRmBTZENfXGZDX1xmQ19cZkNfXGZDX1xis/K8uxds6IvLbOiLy2zoi8tsBDZFNvTFZTb0xWU29MVlNvTFZTb0xUU2PO/uBRv64jIb+uIyG/riMhuBTZENfXGZDX1xmQ19cZkNfXGZDX1xkQ3Pu3vBhr64zIa+uMyGvrjMRmBTZENfXGZDX1xmQ19cZkNfXGZDX1xkw/PuXrChLy6zoS8us6EvLrMR2BTZ0BeX2dAXl9nQF5fZ0BeX2dAXF9nwvLsXbOiLy2zoi8ts6IvLbAQ2RTb0xWU29MVlNvTFZTb0xWU29MVFNjzv7gUb+uIyG/riMhv64jIbgU2RDX1xmQ19cZkNfXGZDX1xmQ19cZENz7t7wYa+uMyGvrjMhr64zEZgU2RDX1xmQ19cZkNfXGZDX1xmQ19cZMPz7l6woS8us6EvLrOhLy6zEdgU2dAXl9nQF5fZ0BeX2dAXl9nQFxfZ8Ly7F2zoi8ts6IvLbOiLy2wENkU29MVlNvTFZTb0xWU29MVlNvTFRTY87+4FG/riMhv64jIb+uIyG4FNkQ19cZkNfXGZDX1xmQ19cZkNfXGJzcbz7l6woS8us6EvLrOhLy6zEdgU2dAXl9nQF5fZ0BeX2dAXl9nQFxfZ8Ly7F2zoi8ts6IvLbOiLy2wENkU29MVlNvTFZTb0xWU29MVlNvTFRTY87+4FG/riMhv64jIb+uIyG4FNkQ19cZkNfXGZDX1xmQ19cZkNfXGRDc+7e8GGvrjMhr64zIa+uMxGYFNkQ19cZkNfXGZDX1xmQ19cZkNfXGTD8+5esKEvLrOhLy6zoS8usxHYFNnQF5fZ0BeX2dAXl9nQF5fZ0BcX2fC8uxds6IvLbOiLy2zoi8tsBDZFNvTFZTb0xWU29MVlNvTFZTb0xUU2PO/uBRv64jIb+uIyG/riMhuBTZENfXGZDX1xmQ19cZkNfXGZDX1xkQ3Pu3vBhr64zIa+uMyGvrjMRmBTZENfXGZDX1xm01FfPE/bnc18+trzeh/1Ep65bJ9cOuqJf8RlifcZLpv8weXrtR8doNxxrOv8uHqOnxSNu+dlkZ3ils8opnnbdozL9Bj/Eo8wBpmXO8cg2x+X/56t9XPuKs/2uMNdHrNdcj6ZbYj395jT8rg4y9F0g9w/+lKYH+OZD9lMed4vXh4r5NebfEUz57De0cw5PTSK2xGbsMw7yWVdH1fnw1dPy13TIE/6/7r6BjICUgdk6gjkLA+QT5cfg4yPYf9auH8NUgCpA3IGpA7I5QzkuqXXIFOKO5tnkMds1vsHk6SnLlvC53BWheGse8cnaXk9nLDEvV0Nizxt9vtuvLkbUTYe0fq0m6zLQcdSeN5azREF1REtU3g9opjvizJNTwte/vf/+fEf/u//8S//+q//8t//r3/99//nP//Hv/z7v/3PX384/fp/4fiUjZinsL/c8oARpt/mMhyfP3H6V+HSX8VLf5Uu/ZVc+qv50l8tl/5qvfRX26W/ulQbcqk25FJtyKXakEu1IZdqQy7VhlyqDblUG3KpNuRSbcyXamO+VBvzpdqYL9XGfKk25ku1MV+qjflSbcyXamO+VBvLpdpYLtXGcqk2lku1sVyqjeVSbSyXamO5VBvLpdpYLtXGeqk21ku1sV6qjfVSbayXamO9VBvrpdpYL9XGeqk21ku1sV2qje1SbWyXamO7VBvbpdrYLtXGdqk2tku1sV2qje1SbeRLtXHs3dI0PyxWXp/+Kt3+Kl76q3Tpr+TSX82X/mq59FeHtZHCflspxZj/+KujZGpZ9iAixKerj26DyJYeadrj2vlT001hPNu035zbwnYynnlZ71fPy7PXl9uAsq8BxeNnc9YcUPA2oOhtQMnbgMTbgGZvA1q8DWj1NiBnn9Rxsv+kXmW/M7Q+fa9jlsMvgYT7xhfnNby+eNu/XrKtT5tk2g5v9KR1v9EzP15YDu8KbY+W6o9LfxEMEwT/kmCA4F8SjBD8S4IJgn9JUCD4lwRnCP4lwQWCf0lwheBfEtwg+JcE8SR/STDiSf6WIJ7kbwniSf6WIJ7kbwkKBP+SIJ7kbwniSf6WIJ7kbwniSf6WIJ7kLwkmPMnfEsST/C1BPMnfEsST/C1BgeBfEsST/C1BPMnfEqzhScKD4PYaStj2b7CG/HyAzuFLB3mctzOv8fmlf891G2iueZy5yjTQXMNAc40DzTUNNFcZaK7zQHNdBprrQH2TDNQ3yUB90zxQ3zQP1DfNA/VN80B90zxQ3zQP1DfNA/VN80B90zxQ3zQP1DctA/VNy0B90zJQ37QM1DctA/VNy0B90zJQ37QM1DctA/VNy0B90zpQ37QO1DetA/VN60B90zpQ37QO1DetA/VN60B90zpQ37QO1DdtA/VN20B90zZQ37QN1DdtA/VN20B90zZQ37QN1DdtA/VN20B9Ux6ob8oD9U15oL4pD9Q35YH6pjxQ35QH6ptyT33Th3L7ww2np+eClsisj0eUPj/UfTsaybI/FX2JTz933NINY08tWUWMPXV71TCmqadGsiLGnnrUihh7an8rYuyps66IUcCogbEnP1ARY09WoyJGXIwKRlyMCkZcjAbGgItRwdiTi/nogtcdYz4bSAhr3F885Onp1X9J8F7sPbmehrD35JIawi5gr4G9JxfWEPaeXFtD2HtyeQ1h78kVNoS9JxfZDvbYk+tsCDsutQp2XGoV7LjUKtgF7DWwD+xS4zTfRxLix4xPsMcPmT4vj2F7grItR1ev0371Gh/f7Vtu2Ad2qTWxD+xSa2If2KXWxD6wS62IPQ3sUmtiH9il1sQ+sEutiX1gl1oTu4C9BnZcahXsuNQq2HGpVbDjUqtgH9mlpm3bsYucBb9x2ccSl2V+XJ3D0VhCvL94CvPT1b8E+3p1WveRp5z+uPqXTF09GLFjmUZ2wQ3JNLJrbkimkV12QzIJMrUg08guviGZRnb9Dck0ckrQkEwjpwoNyUQK0YJMXT1muGOZSCGakIkUogmZSCGakEmQqQWZSCGakIkUogmZSCGakIkUogmZSCFakGkhhWhCJlKIJmQihWhCJlKIJmQSZGpBJlKIJmQihWhCJlKIJmQihWhCJlKIFmRaSSGakIkUogmZSCGakIkUogmZBJlakIkUogmZSCGakIkUogmZSCGakIkUogWZNlKIJmQihWhCJlKIJmQihWhCJkGmFmQihWhCJlKIJmQihWhCJlKIJmQihWhBpkwK0YRMpBBNyEQK0YRMpBBNyCTI1IJMpBBNyEQK0YRMpBBNyEQK0YRMpBANyCQTKUQTMpFCNCETKUQTMpFCNCGTIFMLMpFCNCETKUQTMpFCNCETKUQTMpFCtCBTIIVoQiZSiCZkIoVoQiZSiCZkEmRqQSZSiCZkIoVoQiZSiCZkIoVoQiZSiBZkiqQQTchECtGETKQQTchECtGETIJMLchECtGETKQQTchECtGETKQQTchECtGCTIkUogmZSCGakIkUogmZSCGakEmQqQWZSCGakIkUogmZSCGakIkUogmZSCFakElIIZqQiRSiCZlIId4kU5R5R7idySR5l2mepvxVJlKIJmQSZGpBJlKIJmQihWhCJlKIJmQihWhCJlKIFmSaSSGakIkUogmZSCGakIkUogmZBJlakIkUogmZSCGakIkUogmZSCGakIkUogWZFlKIJmQihWhCJlKIJmQihWhCJkGmFmQihWhCJlKIJmQihWhCJlKIJmQihWhBppUUogmZSCGakIkUogmZSCGakEmQqQWZSCGakIkUogmZSCGakIkUogmZSCFakGkjhWhCJlKIJmQihfi3FmQihWhCJkGmFmQihWhCJlKIJmQihWhCJlKIJmQihWhBpkwK0YRMpBBNyEQK0YRMpBBNyCTI1IJMpBBNyEQK0YRMpBBNyEQK0YRMpBANyPTx3yFTCzKRQjQhEylEEzKRQjQhkyBTCzKRQjQhEylEEzKRQjQhEylEEzKRQrQgUyCFaEImUogmZCKFaEImUogmZBJkakEmUogmZCKFaEImUogmZCKFaEImUogWZIqkEE3IRArRhEykEE3IRArRhEyCTC3IRArRhEykEE3IRArRhEykEE3IRArRgkyJFKIJmUghmpCJFKIJmUghmpBJkKkFmUghmpCJFKIJmUghmpCJFKIJmUghWpBJSCGakIkUogmZSCGakIkUogmZBJlakIkUogmZSCGakIkUogmZSCGakIkUogWZZlKIJmQihWhCJlKIJmQihWhCJkGmFmQihWhCJlKIJmQihWhCJlKIJmQihWhBpoUUogmZSCGakIkUogmZSCGakEmQqQWZSCGakIkUogmZSCGakIkUogmZRk4hlinsMq3PAz+U6eMlww7lWaaCqNt0F3UN+ezqOOX71TGuf1z9S6Z15BSiIZlGTiEakmnkFKIhmUZO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fP91f6rY2fgb33/dnyp2Nv7G91/3p4qdjb/t/Vfcnyp2Nv62919xf6rY2fjb3n9lanv/lYYP/7qNv+39Vxo+Sus2/rb3X2n4YKrf4w+N77+Nn38ljZ9/JY2ffyXez79aUr6Pf/v15i9f+kcHy233Geb857U3Ls739WpcnPcL1bg470Pex+X1AY3i/YCxemCcd07VwHg/Eq0eGOe9Xj0wzpvIemCcd6fb/tKyyRmYdUmfF6/rsl8r8XOqMs5UnfemmlN13m6+mOpt/M7bwtPxO+/eTsfvvMk6G7/34+lOx++8ZTkdv+/OYg4y3y8Oy0G84/x4uvPx+97Vz8fve6s+H7/v/fd8/L733/Px+95/z8fve/89Hb/z4+nOx+97/30efwzxYPzt7L/H429n/z0ev/P9dw3rfvGWD8bvfP89Hb/z/fd0/M7339PxO99/T8fvfP89G7/z4+nOx+98/z0dv/P993T8zvff0/E3vv86P57ufPyN77/Oj6ebtzTdL87LdvLSkvfJPn+VaZs+5+p8r1adq/N9XXOuzo/I052r835Bda7OewvVuTrvQ1TnKgPN1Xl/ozpX573Qj+b6EXfdL5btYK499U1nc+2pbzqba09908lcnR9tqDvXnvqms7n21DedzbWnvulsrjLQXHvqm+Z575u2g77J+RGPunPtqm86mWtXfdPJXLvqm17P1fmRlLpz7apvOplrV33TyVy76ptO5ioDzXWgvsn50Zyv5nobf7u90G387fY3t/H77lmWaboPZElL+Dp+50dzno/fd29xPn7f/cL5+H33AOfj972vn4/f9159Pn7f++/5+H3vv+fj973/no+/7f13dn405/n4295/Z+dHc56Pv+39d57a3n9n50dzno+/7f13dn405/n4295/Z+dHc56O3/nRnOfjb3z/dX405/n4G99/nR/NeT7+xvdf50ddno+/8f3X+cmR5+NvfP91fg7j+fgb33+dn2p4Pv7G91/nJwqej7/x/df52X/n4298/3V+9t/5+Bvff52f/Xc+/sb3X+dn/52Pv/H91/nZf+fjb3z/dX723/n4G99/nZ/9dz7+xvdf52f/nY+/8f3X+dl/5+NvfP91fvbf+fgb33+dn/13Pv7G91/nZ/+dj7/x/df52X/n4298/3V+9t/5+Bvff52f/Xc+/sb3X+dn/52Pv/H91/l5fufj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SpZrVbJcq5LlWpUs16pkuVYl67UqWa9VyXqtStZrVbJeq5L1WpWs16pkvVYl67UqWa9VyXatSrZrVbJdq5LtWpVs16pku1Yl27Uq2a5VyXatSrZrVZKvVUm+ViX5WpXka1WSr1VJvlYl+VqV5GtVkq9VSb5UJXmarv1ZuPZn8dqfpWt/Jtf+bL72Z8u1P1uv/dl27c+uVUm4ViXhWpWEa1USrlVJuFYl4VqVhGtVEq5VSbhWJeFalcRrVRKvVUm8ViXxWpXEa1USr1VJvFYl8VqVxGtVEq9VSbpWJelalaRrVZKuVUm6ViXpWpWka1WSrlXJtew1X8te87XsNV/LXvO17DVfy17ztew1X8te87XsNV/LXvO17DVfy17ztew1X8te87XsNV/LXvO17DVfy17ztew1X8te87XsNV/LXvO17DVfy17ztew1X8te87XsNV/LXvO17DVfy17ztew1X8te87XsNV/LXvO17DVfy17ztew1X8te87XsNV/LXvO17DVfy17ztew1X8te87XsNV/LXvO17DVfy17ztew1X8te87XsNV/LXvO17DVfy17ztew1X8te87XsNV/LXvO17DVfy17ztew1X8pe5+lS9vrxZ+Han8Vrf5au/Zlc+7P52p8t1/5svfZn27U/u1Yl4VqVhGtVEq5VSbhWJeFalYRrVRKuVUm4ViXhWpWEa1USr1VJvFYlhew171/eCx9JzMGfFapkXfc/y/GPPzs6cVbpeRYfwxFfw5l9DWfxNZzV13A2X8PJroZTyvhrDSf4Gk70NRxfn8rJ16dy8vWpnHx9Kidfn8rJ16dy8vWpLL4+lcX6U/nlo5g+xhOdjSc5G484G8/sbDyLs/H8+LP59mfbtT/Ll/7s+A5uDNv9CI8Yw3wCLSxr2p/uu6zL42Cdo5MO4pbuh8ik6fkQnun4KNBpPwBrSo8fk+fpc/zB+fjn6S7AMqf0dfyx8fGnxscvjY9/bnz8S+PjXxsf/9b4+HPb41+8779n4298/10a33+XxvffpfH9d2l8/10a33+XxvffpfH9d2l8/10b33/XxvfftfH9d218/10b33/XxvfftfH9d218/10b33/XxvffrfH9d2t8/90a33+3xvffrfH9d2t8/90a33+3xvffrfH9d2t8/82N77+58f03N77/5sb339z4/psb339z4/tvbnz/zY3vv7nt/TdMbe+/YWp7/w1T2/tvmNrefz/+qPHxt73/hqnt/TdMbe+/YWp7/w1T4/tvaHz/DY3vv6Hx/Tc0vv+Gxvff0Pj+Gxrff0Pj+29ofP8Nje+/sfH9Nza+/8bG99/Y+P4bG99/Y+P7b2x8/42N77+x8f03Nr7/psb339T4/psa339T4/tvanz/TY3vv6nx/Tc1vv+mxvff1Pj+K43vv9L4/iuN77/S+P4rje+/0vj+K43vv9L4/iuN77/S+P7r/vyrs/E3vv82fv5VaPz8q9D4+Veh8fOvQuPnX4XGz78KjZ9/FRo//yo0fv5VaPz8q9D4+Veh8fOvQuPnX4XGz78KjZ9/FRo//yo0fv5VaPz8q9D4+Veh8fOvQuPnX4XGz78KjZ9/FRo//yo0fv5VaPz8q9D4+Veh8fOvQuPnX4XGz78KjZ9/FRo//yo0fv5VaPz8q9D4+Veh8fOvQuPnX4XGz78KjZ9/FRo//yo0fv5VaPz8q9D4+Veh8fOvQuPnX4XGz78KjZ9/FRo//yo2fv5VbPz8q9j4+Vex8fOv4tT2/hsbP/8qNn7+VWz8/KvY+PlXsfHzr2Lj51/Fxs+/io2ffxUbP/8qNn7+VWz8/KvY+PlXsfHzr2Lj51/Fxs+/io2ffxUbP/8qNn7+VWz8/KvY+PlXsfHzr2Lj51/Fxs+/io2ffxUbP/8qNn7+VWz8/KvY+PlXsfHzr2Lj51/Fxs+/io2ffxUbP/8qNn7+VWz8/KvY+PlXsfHzr2Lj51/Fxs+/io2ffxUbP/8qNn7+VWz8/KvY+PlXsfHzr2Lj51/Fxs+/iu7Pv3q89LLm8Dz+o4vvo1625fHCW/qcq/e9WnOu3vd1zbl67wE05+q9X9Ccq/feQnOuzvuQOc/bY67x9VxlzfdxyJa2/eKYl8Nhh3UfdZL96pTWTzbOe5yabLyfX1aVjffebJr2z4QpLV96M19no92G5KqFug1J/A3JVUNyG5KrvuE2JFfb+21Irnbh25BcbX6/h+TrzK7bkFx91N+G5O/T29dhWbch+fv09nWk1W1I/j69fR08dRuSv09vX8dD/R6SrxOfbkPy9+nt61ym25D8fXr7Oj3pNiR/n96+zji6Dcnfp7evk4huQ/L36e3rvKDbkPx9evs61ec2JH+f3r7O3rkNyd+nt68Tcm5D8vfp7escm9uQ3H16J1+nzdyG5O7TO/k6E+Y2JHef3mly9+mdfB3GchuSu0/v5OvIlNuQ3H16J18Hm/wekq+zSm5D8vfp7etEkduQ/H16+zr34zYkf5/evk7nuA3J36e3rzM0bkPy9+nt66SL25D8fXr7Oo/iNiR/n96+To24Dcnfp7evsx1uQ/L36e3rBIbbkPx9evs6J+E2JH+f3r5OM7gNyd+nt68zB25D8vfp7etkgNuQ/H16+/r9/m1I/j69ff3K/jYkf5/evn4LfxuSv09vX79Yvw3J36e3r9+V34bk79Pb16+/b0Py9+nt6zfatyH5+/T29Uvq25D8fXr7+l3ybUj+Pr19/cr3NiR/n96+fjN7G5K/T29fvxC9Dcnfp7e/31omf7+1TP5+a5n8/dYy+futZfL3W8vk77eWyd9vLZO/31omf7+1TP5+a5n8/dYy+futZfL3W8vk77eWyd9vLZO/31omf7+1TP5+a5n8/dYy+futZfL1W8uvVz8dq7NuIe9XHx6rMy9yPyhn3tbnlz66egtr/rz6/2/vW3Ztx5Er/6XHOeAj+PqWHhi222gUULCNaruBHuS/t85Dj5Ob2ryKS1EkY9WgcDJTazNiLVKMCFLk8sthe9pE881NV9NIZ9x0fhTdo9x0fnTdo9x0ftTdo9yMczRee27GORqvOTd9fSrdGTd13sVqP4Av6HDg5quRy53zA0bXP5L8gmkezPBglgcjHszxYJ4HCzxY5MF4vUTzeonm9RLN6yWa10s0r5doXi/RvF6ieb1E83qJ5vUSw+slhtdLDK+XGF4vMbxeYni9xPB6ieH1EsPrJYbXSyyvl1heL7G8XmJ5vcTyeonl9RLL6yWW10ssr5dYXi8hXi8hXi8hXi8hXi8hXi8hXi8hXi8hXi8hXi8hXi9xvF7ieL3E8XqJ4/USx+sljtdLHK+XOF4vcbxe4ni9xPN6ief1Es/rJZ7XSzyvl3heL/G8XuJ5vSS/aWH51yuMgjYZWMrD9A4z6s/36XZUtKb0di8WmKgzz6a4Fi1S+vnspzn5TQXPmaP7Msf0ZY7tyxzqyxzXlzm+L3NCX+bEvszp660c+3orx77eyrGvt3Js/Vb267NLxd9k7KHO7HGd2eM7syd0Zk/sy55KJ/i+XaCiSmfyFhqhFo3U2XdCem/EpUMj11ZGv0zy/ZkU+jMptjZpWUpZl52XdY7XnpT6MshVOjO3okHtd1AuJKy/vShU+u3ktp9OUR/erebbATO6A3Z0B2h0B9zoDvjRHQijOxBHdyAN7sAD5xlXdqD3mTgmuz6t7E8Hrm/ac7r3ebuyu73P8pXdJVnu9h5BVHa393ijsru9RyeV3e09lrnorl+3sUejUsbd3iOfuu6a3uOkyu5OFlWV3J0sqiq5O1lUVXKXZLk7WVRVcneyqKrk7mRRVcldWVGVmSuqWozd3HWm8HRItD4dUrKFp21YzSZL+7O5LyHNboYx1h4f/iTdzhXbDUL6XBHmIKTPFecOQvpc0fYgpBNIb0/6XJnHIKTPlf8MQvpcWdggpM+VCw5COjLS9qQTMtIHSEdG+gDpyEgfIB0Z6QOkE0hvTzoy0gdIR0b6AOnISB8gHRnpA6QjI21PukNG+gDpyEgfIB0Z6QOkIyN9gHQC6e1JR0b6AOnISB8gHXH6HaS7nXTvX0j3iF5uID3Q5mJw9Eo6opcHSCeQ3p50RC8PkI7o5QHSUU9/gHTU0x8gHXF6e9ID6ukPkI56+gOkd3Wzc4YYs53yHIIqXMGog1p/Wgd/0NPmfjpuD/+4rjH7rLFmS+yJfvs0ktD55dWTsk5g/QHWO79we1LWO7/Ke1LWO78kfFLWO79+fFLWO7/Y/Brr3my3HYTgC0xapfRmSPRteY+dX5o+Le8avD/Cu+AMNa4FB61Ukfb99KJlwT/8Nu2CU9QnaSfQ/gTtgpPUJ2kXnKU+SbvgNPVJ2gXnqU/SLjhR1WG9J8saE9ryngQnqo/yLjhRfZB3rzrv795tN1R6d9gRntS3/Z33m6L9nRcKivZ3nnEX7afB7e88Byza33kyVbS/86ykaH/n4X3R/s7j5JL9evD5Vw8+/+rB5189+Pz7wPV0de0ffP7Vg8+/evD5Vw8+/+rB518z+PxrBp9/zeDzrxl8/n3gIrO69g8+/5rO51+X3Fqc9Mfdepv9nc+/Rfs7n3+L9nc+/5bst53Pv0X7O59/i/Z3Pv8W7e98/i3a3/n8W7S/9z1Ijsz308EfFvGz63bWrs9aOhj9vVRme9/3U9HV3vfaVHS19/0tFV3tfU9JPVep920cFV3tfedERVd731Vf0VW5O9mdWrfdOVI/nv1ihsDMCTNy94OXmJG7ZbvEjNxd1SVm5G58LjEz1d7kmsy4qXYPV2Vmqv29VZmR+6no8ipZmUmx8CwZt9JIJtLhaf3NI46x+LUDFfb94zZkdoQ7HExRh0e5s2RVHr3cObUuj3Jn4Lo84vDBOjziOME6PBJ4rMIjjvyrwyMO8bvjYLON9WgORu+sI/t5gnXkSk+wjszqAdYD8rAnWEfW9gTryPGeYB0Z4ROsE1h/gHVkm0+wjtz0CdaRm97A+hA39noccy9Ye+TpYrWf68B/aH9Je9Qs5GqPyolc7VG/kas9QXux2qOWJVd7VNTkao+6nlztUdeTqz3qemK1n+t+FGh/SXvU9eRqj7qeXO1R15OrPUF7sdqjridXe9T15GqPup5c7VHXk6s96npStQ+93wML7W/UHnU9udqjridXe9T15GpP0F6s9sjvJ9be7dp7/6J97/dNQ/vf0D7Q+qwJjl61R5wvV3vE+XK1R5wvV3uC9mK1x/q9XO2xfi9Xe+T3crXH+r1c7bF+L1Z7I7eul8zqY3Ku8KxTYbtySqtjT9HfPMqtkdXlUW69qS6Pcms3dXkkuXNjXC/O0+pwKfUJkVrvRDqfIVJwUaEukYIz9LpECk536xIpOHesS6TgRKwqkVbwboW6RApe+q9LpOB19LpECl6UvkKk2U/XN8b+vG8v89OFs/iDJdD+BO3Imh6hHTnWI7QjI3uEduRvj9CObO8J2gm54SO0I5N8hHbknY/Qjiz1EdoJtN9A+xifJxJyZcHiI2MXLD7qBoLFR/VCsPioocgV36GSI1h81JMEi4+qlmDxUVsTLD5BfLnio8InWHxU+ASLjwqfYPFR4RMsPip8csX3qPAJFh8VPsHio8InWHxU+ASLTxBfrvio8AkWHxU+weKjwidYfFT4BIuPCp9c8QMqfILFR4VPsPgE8ScW//11cgHR/sTiF84cD4j2BYuPaF+u+BHRvmDxEe0LFh/r+YLFx3q+YPEJ4ssVH+v5gsXHer5g8afK872hTfxQ1DOp9WmTnC08TUqtfYUUHTvW94n3aaoJ9BKTVim9GRKLvNt9HNnwcxx9MTnVbPQok1O92h9lcqqVkEeZnGpZ4VEm5c7ddZmMaqqC96NMTlU9fpTJqUqxjzI5VV3zViYvXZ1eOOY7KgLvj/CO/OkZ3pFtPcM7crNneEcm9wzvyPse4V0jS3yGd+SUz/CODPQZ3pGvPsM7gfc7eB/iQ6eokTVLVh+5u2T1UUGQrD7qGJLVRzVFsPoGNR3J6qOyJFl91Lckq48qm2T1CeoLVh+1Psnqo9YnWX3U+iSrj1qfZPVR6xOsvkWtT7L6qPVJVh+1Psnqo9YnWX2C+oLVR61Psvqo9UlWH7U+yeqj1idZfdT6BKtPqPVJVh+1PsnqE9SfWf23d1ZFQsw/s/rvzzOOhJhfsvqI+QWr7xDzS1YfMb9k9bG+L1l9rO9LVp+gvmD1sb4vWX2s70tWX3CtT6u4GqJdKDxNIa2G0LI2dnhafzMpuG5WmUnBNai6THrB9ZzKTAqujeiwMWlMiUmn9frbTjufYVJwnaEyk4Jz9spMEpisxKTgXLIyk4LzsspMSs5x6jIpOcepy6TkHKcqk0FyjnOFyYu3r5fO+g/IiJ7hHfnTM7wj23qGdwLvj/COTO4Z3pH3PcM7ssRneEdO+QzvyEAf4T0iX32Gd+Srt/A+xheNEVmzZPWRu0tWn6C+YPVRx5CsPqopktVHTUey+qgsSVYf9S3B6idU2SSrj1qfZPVR65OsPmp9ktUnqC9YfdT6JKuPWp9k9VHrk6w+an2S1UetT676SaHWJ1l91Pokq49an2T1UeuTrD5BfcHqo9YnWX3U+iSrj1qfZPVR6xOsvka+P7X6b++mS5qg/sTqvz+tPGnE/JLVR8wvWX3E/JLVR8wvWX2s7wtW32B9X7L6yPclq4/1fcnqY31fsvqd5/suuVWiEHVBfWdU+H7YmeM59mr1tvP8trK3nedzlb3tPH+p663tPF6v7G3n8WllbzuPxyp723n8UdlbEuVt52tJlb0VFUtZUbGUFRVLWVGxFImKpUhULEWiYikSFUsRzeQtJbt66yj88DZjtlZptVqbvaxjVcw8TWYlkkjvJaAU8zWx1UMyP5794nyqiG4QzqeKKwfhfKrodhDOp4qxB+F8qkh/DM7dVPnGIJxPlfUMwvlUudcgnE+VAQ7COYHz5pwjD23POfLQX+Rcm41zKnD+2DeeDhnuTGoid55JTWTlE6npke/PpCYqCTOpiRrFTGqi+jGTmgQ1J1ITFZuZ1EQtaCY1UQuaSU3UgmZSE7WgidQMqAXNpCZqQTOpiVrQTGqiFjSTmgQ1J1ITtaCZ1EQtaCY1UQuaSU3UgmZSE7WgidSMqAXNpCZqQTOpiVrQTGqiFjSTmsg3h1Lz/W1TETHtSGoWzhNOiGlnUhMx7UxqIqadSU3EtDOpSVBzIjWxvjmTmsg3Z1IT65szqYn1zZnUnKoW5LbbpZw3qaCm3X6ZDmZE/8uP6qXDLCR6paYqwbwh8cvbqUoURW+nSuGL3k6V4ha9JVHeTpUiFb2dKoUoejtViF30dqoQtOjtVCGap+2KiRhsIUSLOqwB9/LLPy8A/eRGTxV5VeZmqjitMjdTRXUXudku1Y3mcLvvzs1UMWBlbgjcnHIzVXxZmZupotHK3EwVu1bmZqpItzI3kuPiAjdGclxc4kZyXFziBnHxOTeC4+J9f3g0zvzgpuVi1ttt6otCBIU6V0hwjjCIQoIzlUEUEpwvDaKQ4KxtEIUE545jKGQFZ7CDKCQ4jx5EIcHZ/CAKoabQu0IEhTpXCDWF3hVCTaF3hVBT6F0h1BR6Vwg1hc4VItQUelcINYXeFUJNoXeFUFPoXSGCQp0rhJpC7wqhptC7Qqgp9K4Qagq9K4SaQucKOdQUelcI+dDjCr07kHpRCLHc0wq9PSZqUQixXO8KIZbrXSHEcp0r5BHL9a4Q1od6VwjrQ70rhHyod4UICnWuENaHOldoriuyh1TImtXopSznXhVCTaF3hVBT6F0h1BQeV0jbTSHzWtue68rpKRVCTaF3hVBT6F0h1BR6V4igUOcKoabQu0KoKfSuEGoKvSuEmkLnCs11ofyUCuGy2w+rR7mCsVDDw2W3U6mJy25nUhOX3Q6lZmHenGq1RLiaeq5bd8WrOdUqjHg1p1qxEa/mVKs74tUkqDmRmqgFzaQmakEzqYla0ExqonowkZq93+QcTFx/OgRVUFN7Q6sdIezOapv7aavD2lGsMaHwtNnvRTTGhoJCY+yb1r3fVQ31b1W/8ygL6t+qfudRGdS/dd7vfEUP6t+qfucxPNS/U33T+Yoh1L9V/c5XGKH+rep3viIJ9W9Vv/MVTKh/q/oE9QWrj1qfZPVR65OsPqo9gtXv/XbtO9VXSm+GxNLTC3ub+kR6FPXf1/l7v7kb6t+qvuCoD+r3fuM41L913he8wgv1e78pHerfqr7gFV6o3/sN71D/VvUFr/BC/d5vpof6t6qPWp9k9QnqC1YftT7J6qPaI1h9N1XUF5Tb1PepoGeMKzNaqaL4M37K0/vV3hD/TvEJ4ssVf6qQD+Jfm/OnWt2F+NfEnyrch/jXxJ9qbRfiXxN/qqVdiH9JfD/Vyi7Evyb+VAu7EP+a+KjwCRYfFT7B4hPElys+ijxyxQ+CA77t4R/31cn5dicIjvfEay843BOvPUH7ebUvzPeCl3PFay840BevveDFXPHaC17LFa+94KVc6dpHwSu54rVHXU+u9qjrydUedT252qO2I1f7znM879Rak/bO2qP2X/Z3nqeU7E+dx9pF+zuPF4v2dx7zFO3vfN4u2k+D29/53Fm0v/PaftH+zuvTRfsHn3/T2POvUWPPv0aNPf8aNfb8a9TY869RY8+/Ro09/xo19vxr1Njzr1Fjz79GDT7/6sHnXz34/KsHn3/14POv7nz+dcmtlxT5Y4l0s7/z+bdof+fzb9H+zuffov2dz79F+zuff0v2937jdtH+zuffov2dz79F+zuff4v2dz7/Bkfm++ngD58aZtc+rV2ftXQw2ny72vsyb0VXe9+xXtHV3jdoV3S19/3IFV3tffttPVdt77tNK7ra++bKiq7K3Uvo1LrjxpH68ewXM3J32pWYITBzwozcHXolZuR+m1hiRu6XeyVm5H7XVmJG7ldfBWbmurewKjNyvxgqMSM4BvbrJTkuxcKzZNxKI5lIh6f1N4+4Oe7TkNr3B+mQvp+OOv08l+yLdwLvj/CO29Ke4X2qXOIa7zqsyyR2KSmXeL92omGRd8H3wz3K+1R50Di8S74U7dL3ljvrNuR4JPBYhUd8/1uHR5yTVodHnDlWh0ec31WHR5yFVYVHyTcEVeURZzTV4RHnHd1w7kkp+5F8YcyDrBNYf4B1ZFZ3sL6916M5GL2zjjzsCdaRtT3BOnK8J1hHRvgA6wH54xOsI9t8gnXkpk+wjtz0CdYJrD/AOnLTJ1hHbjrvWcu7GcYcznr5PmvZ4C4lwdojT5erPaoFYrXHXUqCtUflRK72qN/I1R5VJLnaE7QXqz0qanK1R11Prvao68nVHnU9udqjridW+97vbYT2N2qPup5c7VHXk6s96npytSdoL1Z71PXkao+6nlztUdeTqz3qenK1R11Pqva29/vgof2N2qOuJ1d71PXkao+6nlztkd9PrL3btff+VXvE+fNqH2h91gRHL9prxPlytUecL1d7xPlytUecL1d7gvZitcf6vVztkd/L1R7r93K1x/q9XO3l1vWSWX1MzhWedSpsl/RqdewpX/fuWiO3RlaXR7n1pro8yq3d1OVRcB0krleNa6VKl4Q6rXcinc8QSSCyDpGCM/S6RApOd+sSKTh3rEuk4ESsLpGCdytUJdIKXvqvS6TgdfS6RApelL5CpNlP1zfG/rxvL/PThdv5rEUe9AjtBNqfoB051i20v7/ww1pkZI/QjvztEdqR7T1CO3LDJ2gnZJKP0I688xHakaU+Qjuy1EdoJ9D+BO3IUh+hHVnqHbSP8Q00IVcWLD4ydsHio24gV3yH6oVg8VFDESw+KjmCxUc9SbD4BPHlio/ammDxUeETLD4qfILFR4VPsPio8MkV36PCJ1h8VPgEi48Kn2DxUeETLD5BfLnio8InWHxU+ASLjwqfYPFR4RMsPip8csUPqPAJFh8VPsHio8InWHxU+ASLjzx/ZvHf31kZEO1PLH7hYoOIaF+w+Ij2BYuPaF+w+Ij2BYtPEF+u+FjPFyw+8nzB4mM9X7D4WM+XK36aKs/3hjbxQ1HPpNanTXK28DQptfYVUnTsWN/XaqSpJtBLTFql9GZILPJu93FkQ+bugDTVbPQok1O92h9lcqqVkAeZXN6jYLISk3Ln7tpMTlXwfpTJqarHjzJJYLISk1PVNW9l0mxMEukfTGYy3MIx36SQET3DO/KnZ3hHtvUM78jNHuFdI5N7hnfkfc/wjizxGd6RUz7DO4H3R3hHvvoM78hXb+F9iA+dSCNrlqw+cnfJ6qOCIFh9gzqGZPVRTZGsPmo6ktVHZUmy+gT1BauPKptk9VHrk6w+an2S1UetT7L6qPUJVt+i1idZfdT6JKuPWp9k9VHrk6w+QX3B6qPWJ1l91Pokq49an2T1UeuTrD5qfYLVJ9T6JKuPWp9k9VHrk6w+an2S1Ue+P7X6b++sIkLMP7P6788zJoeYX7L6iPklq4+YX7L6iPklq09QX7D6WN+XrD7yfcnqY31fsvpY35esvuBan1ZxNUS7UHiaQloNoUjq8PTX7VXkBdfNKjMpuAZVmUnB9ZzKTAqujeiwMWlMiUmn9frbTjufYZLAZCUmBefslZkUnP9WZlJwLlmZScF5WWUmJec4VZkMknOcukxKznHqMik5x7nC5MXb10tn/QdkRM/wTuD9Ed6RbT3DO3KzZ3hHJvcM78j7nuEdWeIjvEfklM/wjgz0Gd6Rrz7DO/LVW3gf44vGSFBfsPrI3SWrjwqCZPVRx5CsPqopktVHTUew+gmVJcnqo74lWX1U2SSrj1qfZPUJ6gtWH7U+yeqj1idZfdT6JKuPWp9k9VHrk6u+U6j1SVYftT7J6qPWJ1l91Pokq09QX7D6qPVJVh+1Psnqo9YnWX3U+iSrj1qfYPU1an2S1Ue+P7X6b++mcxox/8zqvz+t3GnE/JLVR8wvWX3E/ILVN4j5JauP9X3J6mN9X7L6yPclq09QX7D6WN+XrH7n+b5LbpUoRF1Q34a46RkPZttkvr3tPL+t663tPJ+r7G3n+UtlbzuP1yt723l8WtlbEuVt5/FHZW87X1ur7G3na0mVvRUVS1lRsRSJiqVIVCxFomIpEhVLEYnyVlQsRVPFUtHR5m1QP7zNmK1VWq3WZi/rWBUzT5MJa72I9F4CSjFfE1vNIPPj2S/Op4roBuF8qrhyEM6nim7H4NxNFWMPwvlUkf4gnE+VbwzC+VRZzyCcEzhvzvlUGeAgnCMPbc858tD2nCMP/UXOtdk4pwLnj33j6ZDhTqSmR+48k5rIymdSE/n+TGqikjCTmgQ1J1IT1Y+Z1ERdZSY1UbGZSU3UgmZSE7WgidQMqAXNpCZqQTOpiVrQTGqiFjSTmgQ1J1ITtaCZ1EQtaCY1UQuaSU3UgmZSE7WgidSMqAXNpCZqQTOpiVrQTGqiFjSTmgQ1J1ITtaCZ1ES+OZSa72+bSohpR1KzcJ5wQkw7k5qIaWdSk6DmRGoipp1JTaxvzqQm1jdnUhP55kxqYn1zHjW9wvrmTGrOVQtK20+noz5ZNe32y3QwI/pfflRT+CZxrhLMOYlf3s5Voih5S6K8nSvFLXk7VwpY8nauFKnk7VwpRMnbuULsgrd6rhC05O1UIVqya8BNypdCtKjDGnAvv/zzAtAvbqaKvCpzM1WcVpkbEszNdqluNIfbfXdupooBK3MzVcRYmZup4svK3EwVjVbmZqrYtS43ZqpItzI3kuPiEjeS4+ISN5Lj4hI3BG5OuREcF+/7w6Nx5gc3LRez3m9T90ZwdD6IQoJzhEEUEpypDKKQ4HxpDIWs4KxtEIUE546DKCQ4gx1EIcF59CAKERTqXCHUFHpXCDWF3hVCTaF3hVBT6F0h1BQ6V4hQU+hdIdQUelcINYXeFUJNoXeFCAp1rhBqCr0rhJpC7wqhptC7Qqgp9K4QagqdK+RQU+hdIdQUelcINYXeFUI+9LhCbw+k9g6x3NMKFY6JcojlOlfII5brXSHEcr0rhFiud4WwPtS7QgSFOlcI+VDvCmF9qHeFsD7UuULh2VjOlhTScSNdR4rb0/R92kCwg9tPg9vvBrffD25/GNz+OLj9aWz7H76G/fft14PbP/j8Gweffx++Tvn37R98/o2Dz79x8Pk3Dj7/xsHn3zT4/JsGn3/T4PNv+4twrbZrRcHqpAq/bex2XKCxIXPEePu7X2s74EZ3wI/uQBjdgTi6A2lsB0L72/pqO6BHd8D07oDZHCDSPxzIVP8Lp+QG1f28Xdfd7mf5uu52HxPUdbf7CKKuu93HG3Xd7T46qetu97FMVXd195FPXXe7j5PquisrqtJzRVVDfDgU2l8SB9KDnivCHIT0ueLcQUifK9oehPS5Yv5BSJ8r8xiDdDNX/jMI6XNlYYOQPlcuOAjpyEgfIJ1AenvSkZE+QDoy0gdIR0b6AOnISB8gHRlpe9ItMtIHSEdG+gDpyEgfIB0Z6QOkE0hvTzoy0gdIR0b6AOnISB8gHRnpA6QjI21POiEjfYB0xOl3kP72iO1AiF5uIP39GWSBEL08QDqilwdIR/TSnnSH6OUB0lFPf4B01NMfIB1x+gOkE0hvTzrq6Q+Q3j4jXcoRK+mf7r39baf1ekCV027PqLXV3w6E0R2IozuQBneg/aVNtR3QoztgRnfAju4Aje6A69sBsx8usOBCKXooHUXgO5+3a7vb+Sxf293OY4La7nYeQVR2N3Qeb9R2t/PopLa7nccytd3tPPKp7S7JcldWVBXmiqrG2IkS5ortBiF9rghzENLninPHID3OFW0PQvpcMf8gpM+VeQxC+lz5zyCkE0hvT/pcueAgpCMjfYB0ZKQPkI6M9AHSkZG2Jz0hI32AdGSkD5COjPQB0pGRPkA6gfT2pCMjfYB0ZKQPkI6M9AHSkZE+QDoy0uakR4WM9AHSkZE+QDoy0gdIR0b6AOmI0+8g/e0BT1EhermB9PffMEeN6OUB0hG9PEA6opcHSEf08gDpBNLbk456+gOkI05/gHTU0x8gHfX0B0h/ICNN68PWHs7J+vjtT5Pa3xRLyq6/TcqV+sG7p78csKM7QH074KNbT3vxMejDL3+Z78Y2349tfujc/KTWV61PJryYH8c2Pw1tfvvbB+uar8c2v/OZt2R+5/NuyfzeZ92C+b3PugXze591C+aPPevasWddO/asS2PPujT2rEtjz7o09qxLY8+6NPasS2PPujT2rEtjz7o09qzrxp51XfezLm1lquReze9+1n1vfvez7nvzu59135vf/az73vzuZ9335t88bX020vuR/WOuRloTVqOtdceHv0gnkN6edGzreYB0bOu5g3RtN9LN6/b7ya6JGIR0bOt5gHR8aNKe9Mku7hiEdHxo8gDp+NDkAdKRkT5AOoH09qQjI32AdCRH7Ul/4Ex+AZdaF2ovD5zJD9IfOJMfpD9wJr8E0gvvdA/S25MeQHp70iNIb096AunNSX/gTH6Q/sCZ/CA9ISN9gHRkpA+QTiC9PelIjpqTntofJWyiXV21StvCb7vk4kpM1PvF6ynnrE123RxKyu/M2DRuoSa1P3cYCl1UyEKhzhUiKNT5POSgUOcKeSjUuUIBCnWuUIRCnSuUoFDfCrU/sx8KXVQINYXeFUJNoXeFUFPoXSFkrJ0rZKaKFPajdW0MqqCQ1iqtVmtz0FPFzNOkzco5HThPsacanpkqqhCv5lQRiHg1p4pW5lezMG8S1JxIzaniVPFqTrUKI17NqVZsxKs51eqOeDWnWgmSrqZFLWgmNVELmklN1IJmUpOg5kRqdh4FBRPXnw5BFdTU3qxq6hB2Z7XN/bTVYe0o1hwOuc8/PeNRtIk6j5qg/q3qdx5lQf1b1e88KoP6d8771PmKHtS/VX2C+oLV73zFEOrfqn7nK4xQ/1b1O1+RhPq3qt/5CibUv1V91PoEq+9Q65OsPmp9ktVHtUey+oKjPqX0ZkgsPT3jQfDJCY76oL4XHPVBfS846pOg/vt53wte4YX6XnDMD/U9QX3B6gte4YX6XvAKL9T3gld4ob5HrU+y+qj1CVY/oNYnWX1UeySrP1XUF5Tb1PepoGeMKzNaqaL4M37KE6YK+iD+NfGnivkg/iXx41QhH8S/NOfHqVZ3If418acK9yH+NfGnWtuF+NfEJ4gvV/ypVnYh/jXxp1rYhfjXxEeFT7D4qPAJFh8VPrniJxR5BIsvOODbHo7BlrSf8dudJDjeE6+94HBPvPaCo735tX833welBC/nitdecKAvXnvBi7nitRe8litee4L2YrUXvJIrXnvU9eRqj7qeXO1R1xOrvUZtR6727WM9p1brjaNU+u2YNvuVnaKQvpDuQXp70gNIb096BOnt3+kJpDcn3SiQ3p50DdLbk25AenvSLUhvTzqB9PakIyN9gHRkpA+Qjoz0AdKRHLUn3WZJJ7XWDsjspmsbc7TYtF6WpEnvtNjl6c8mSN3fhL6/CXN/E/b+Juj+Jtz9Tfj7mwjXmvgCRQ4oMUD5ixnJbu+FEDMgzQDlr4SgsL5l6Xh2YkzfIOKAHAeU7QpOr3OGM/YHKLfitX8EFqM+PP3dQri9hXh7C+nuFvLnyFZtQd/egrm9BXt7C3R7C+72Fm4f0+H2MR1uH9P585wcrWfgOgqvr8v8aSAurCBPKgOKnJbyrxy3TrvO0yso5d8i0aygZDMgzQEZDshyQMQBOQ7Ic0D5oRDVBsrpFDmgdB2klXoP8spmQPkeEdIGihlQtkd4vbLnbcqAbKGlzHhassvrg1Dnt/6WQIzhrvObjrRxq1Pa+AwVWvNghgezPBjxYI4H8zxY4MEiD5ZYMHPSS2LYYMlkYLoM8xmY4cEsD0Y8WL6XWLW+QpY/My+efIW3DAs8WOTBEgtmFQ+meTDDg53o5je5bcjMMjbP5B7jaUeZEUAnlKRtvJFyGZguwzLDlAwPZnkw4sECC5Yvgiwub9tMyeoMTPNgeSbJqw3mMy8F505gu28hMwn7E9/c1pUpZvqk1zyY4cHyvYTSdg/HUmDPwIgHczyY58HCyejedHMmM0x95MESy8igeDDNgxkezLLek/lKRhnmeDDPgyXWmyvy3lyR9+aKhgMz+dzGp+3eHJ/0MfHPLoJtRYJo/JG/7ybo/ibc/U34+5sI9zcR728i3d5EPnmt24S+2MQXyrBQloPKL+p6v630LH8e1ryWVfJPWD4yLcM0D2Z4MMuDEQ/meDDPgwUeLPJgvF7ieL3E8XqJ4/USx+sljtdLHK+XuHwvCbSuePpwSA12WFa3oPT61grK+ldYPqMowzQPZniwk/fdFk+dwGK+NQobLGQE8IkFC4oH0zxY3jerNiaP+3p2WGLB8pFpGaZ5sHwvsds3qMG6kIFZHox4MMeD+SLsEFzssBPd4g5L8RWWFA+meTDDg1keLC8Abdd9BrI2A4scmM0vHoXo1pArRJ+D5TsX+bi1diij7zDHg3keLBtgBL9tVQzehAws8mCJBcuH8GWY5sEMD2Z5MOLB8rq5uHVll17fJTa/RhPCto81xExcYvNrNGWY4cEsD0Y8mGON7vwaTRkWeLDIgyUWLL9GU4bx3pP5NZoyzPJgvjjecr3EBh4s8mCJBaOT96TfRoAPMQPLj4CwlRTCsiCTgXkeLPBgkQdLLJhTPJjmwU5mnBR2mMvALA9GPNiJbm7rXMHlfIvFt7L+OUwze7Mpun1zdsz14ZMUOGr/9uXvefOh582Hnjcfet586HnzoXcs2Mkqy7K+vq2GLov4GeVO1ll+ARi4wMgFJibwZHXnF4CaCzRcoOUCs91tWaO128qXd5n81uaz6V8Bei4wcIHxBBj0DowZYD6rXlait3h9WV5WmTg/n1cvD5vd1CWzywAtF0hcoOMCPRcYuMDIBaYTYDx8Y5ipWFB+1+qvADUXeNJz4j6QfdQ6A7RcIHGBZz3nMKyiNqUowQTanjdLsFx63rm478FwKWUM870aFno1LPZqWOrUMK16NUz3apjp1TD7lGHbC9Z5pTKGUSXDrD0Ylspp25b4Ln9rkzEsPWRYIZ8ko3o1TPdqmOnVsLPowh3PhcgBPRcYuMDIBSYm0CouUHOBhgs8i0tt2DtYZt2VLHGBjgv0XGDgAk86QNqnEp/8a32OTj4++AXgiRxp/0hiKSlmZsl83Vh/fEC0AoPO7Omgk48CfgEYucDEBJ58iPALQM0FGi7QcoF0AtyWnPXHvuYM0J0Bww5MpaJwzR2c5Hx/JoX+TIr9mZS6M8mr/kzS/Zlk+jPp5L1kti2KH3+/Lo3RySc+H5tOd2DuTXjykU8ZePKZzy8ANRd48rY3dn/bG7IZoOMCT97Jxh9MzQUYJwtDvwCMXGBiAk8Whj62c21AazKJ88nC0C8ADRd4EidYOgBdZnScLAz9AtBxgZ4LDFxg5AITE5jOeo49AjNhW9JcoOECz3rOXrZa/s6MjkRcoOMCPRcYuMDIBSYe0KmznhMOwKQyQM0FGi7wpOfQYUYmYzNA4gIdF+i5wMAFRi4wMYEnSxUfK38HIGWAmgs0XOBJzzFxn5HJuj9L1cX9sNTl78y06DRVasgevr11xZp/sezptKtkmKPdMJ/rFf4GBrINhVYNxVYNpUYNGVWpoe3szeXvZH6/lxpdybC0M0Aq80I4WZ74LQbyDdlWDVGrhlyrhiq9SUiHvSFrK/TSSm8esgcGyGUaijcwkG0oNWrIqlYN6VYNMd4kX0DLBRIX6HjVHmc9Fxi4wMgFMmtojhQXqLlAwwVaLtDzFunc2VqbOtzYqpTPACMXmJhAd7aCmdQBmAndT9bafgFouEDLBRIX6LhAzwUGLjAygfki6lIjXwfHUvU+wBx9wzQPlr/2IZoNFm0OZnkw4sEcD5a/RiHuVw9EozKwwINFHiyxYPmCaRmmeTDDg1kejHgwx4Oxeok/Obh5O+ximTo20PdlNP7k3Ob3GMPAWAaGGBjHwHgGJjAwkYFJ1zGa0Q/0yYnu2+H5h49uNoxhYCwDk+0H+7e6/pCBbhjHwHgGJjAwkYFJ1zH5mlQBoxkYw8BYBobRDwyjHxhGP8innmapo3+DzPHj3Q11EnXuH60F9ToeTndNvkd5FiqwUCc5yvYFtI7av6ISB3WWZRZQmoUyLJRloYiFciyUZ6ECC8XqG8TqG47VNxyrbzhW33CsvnGSraZ9Z3+iDMqxUFm97H4zo010uEVEqezdb/Fw+LY9bD7/ONX/q5nUpJn83sH6zeg2zZg2zdg2zVCbZlybZnybZsLVZr5gkQdLLFhQPJjmwQwPZnmwk15LZoMdvjDcYY4H8zxY4MEiD5ZYsKh4MM2DGR7M8mC8XpIvM9q03XZF+nCoRf4lsgQQ+7XIh6Px8xcdl8qzPl/CfNak0J9JsT+TUncm5UvGz5qk+zPJ9GeS7c8k6s+k/t7eqb+3d+rv7Z36e3un7t7eQXX39g7qgffStjFy+dNnTGo/4goLhUHdPOK+GoktGkkNGtE1+rnReyPOFBQMibaDaNPhG8380/tXHmR/rDFkbrjezTDmdRkjaC3HVSPHVSvHVZLjqpPjqpfjapDjapTjahLjqpETLRk50ZKREy0ZOdGSkRMtGTnRkpETLRk50ZKREy0ZOdGSlRMtWTnRkpUTLVk50ZKVEy1ZOdGSlRMtWTnREs00r7rdVe9fXZ3oDfz+e5lAE72BS65O9AYuuTrRG7jk6kRv4JKrE+WrJVcnylcLrrqJ5tWSqxPlqyVXJ8pXS67SPK5as+7zWkJg9+rqRCFEydWJQoiSqxOFEPvhr4vXr5mNmyiEKLk6UQhRcNVPFEKUXJ0ohCi5OlEIUXJ1ooJLyVWS4+pM0VLB1ZmipYKrcqKl8MDnOIVvX0L7jynjdsfC8mfKmNT+Y8rCoZAh2P5Mov5Mcv2Z5PszKfRnUvuPKUsfwIXUnUlR9WeS7s8k059Jtj+TqD+TXH8m5Y9W9ds12S6ovfymrc7FZCltB7goFX88/dlI/giA2o34Fo2EFo3EFo00ED6eHMZcuRHdohHTohHbohFq0Yhr0Yhv0Uho0Uhs0UiLEa9bjHjdYsTrFiNetxjxusWI1y1GvG4x4nWLEa9bjHjdYsSbFiPetBjxpsWINy1GvGkx4k2LEW9ajHjTYsSbFiPetBjxtsWIty1GvG0x4m2LEW9bjHjbYsTbFiPethjxtsWIty1GPLUY8dRixFOLEU8tRjy1GPHUYsRTixFPLUY8tRjx1GLEuxYj3rUY8a7FiHctRrxrMeJdixHvWox412LEuxYj3rUY8b7FiPctRrxvMeJ9ixHvW4x432LE+xYj3rcY8b7FiPctRnxoMeJDixEfWoz40GLEhxYjPrQY8aHFiA8tRnxoMeJDixEfW4z42GLExxYjPrYY8bHFiI8tRnxsMeJjixEfW4z4FluvYmox4lOLEZ9ajPjUYsSnFiO+xZ672GLPXWyx5y622HMXW+y5Sy323KUWe+5Siz13qcWeu6SoRSOuRSO+RSOhRSOxRSMtRnyLPXepxZ671GLPXWqx5y612HOXWuy5Sy323KUWe+5Siz13qcWeu9Riz11qsecutdhzl1rsuUst9tylFnvuUos9d6nFnrvUYs9darHnLrXYc5da7LlLLfbcpRZ77lKLPXepxZ671GLPXWqx5y612HOXWuy5Sy323KUWe+5Siz13qcWeu9Riz11qsecutdhzl1rsuUst9tylFnvuUos9d6nFnrtUY8+dVWn9LN4aXXo6rAaF/QN6st/W2K6soa6scV1Z47uyJnRlTezKmtSTNTX2Lla0RndlTVfvYt/Vu9h39S72Xb2LfVfvYt/Vu9h39S72Xb2LQ1fv4tDVuzi/yU9bux7SpG3UGyr6zM+T3Y92PJhC8auF/A6/qi3o21swt7dgb2+Bbm/B/XYLbh8FPteCv72F8PstbGfHupAyLcTbW/j9Me3SqrRX9rWFpG5vQddsQetMC+b2FuztLfz+mPZBry1ElWnB3d7C749pH9cDCH2iTAvh9hZ+f0wHtc7oQcdMC+neFqJSqmYLh4Ow9xb07S2Y21v4/TG9n84dFWVaoNtb+P0xHTeWYrYv+dtb+P0xHe16QHIkk2kh3t5CqtmCU68taHV7C/r2Fn5/TCe9PptyY1rb21v4/TGd7DqLLkukmRbc7S38/phOW+ydfI6lcHsLsWYLIfNu1enuFoy6vYXfH9NauTVF0cpnRrUxDdrIj2sy6+yoKfj3bVgd1zasPlylYTxlyzJhDdetivusZT9WJF+fDtvFITYc3nwfT3/ZT4Pb7wa33w9ufxjc/ji4/Wls+/M7PAeyXw9uvxnc/sHnXzv4/GsHn3/t4POvHXz+tYPPv3bw+ZcGn39p8PmXBp9/afD5lwaff2nw+ZcGn39p8PmXBp9/afD51w0+/7rB51/Xfv7dlkCsdqFg/9VLmdV2H2vQL/exLt5aUd6SKG+dKG+9KG+DKG+jKG+TJG+9EuWtFuWtqFjKi4qlvKhYyouKpbyoWMqLiqW8qFjKi4qlwlzz7bahfPnTZ7yd6p28+LN6uzye8Xbcd/KX/eO+Zb/sH/e9+WV/529Co3f7nSmMlo/Tob6f/vjirfC03b5cJLvvPP4YZC+Pmt0MY6w9PvzJYuw8Wx2Exc6z4EFY7Hy2H4TFzrP2QVgksFiBxc4j2kFY7DxSHoTFzuP1QVjsPGsYhEXkLhVYTMhdarCI3KUGi8hdarCI3KUGiwQWK7CI3KUGi8hdarCI3KUGi8hdarCI3OX3WdQKuUsNFpG71GARuUsNFpG71GCRwGIFFpG71GARuUsNFpG7VGBRI178JRbdzuLh6MqNRczRv8JioPVZExy9sog5ugaLmKNrsIg5ugaLmKNrsIj6Yg0WUV+swKJBvFiDRdQXa7CI+mINFivkLlZtLFpDP1j8aoMatOEatOEbtBEatBEbtJHub6PGGdjFNnSDNiq8yYwJWxuH073yb7Kow36BTwo/3jZfFtnuLKLuLHLdWeS7syh0Z1HszqLUm0U1zja+aNH7r3J1jdOKK1tkurPIdmcRdWeR684i351FoTuLYncWpd4sct29s13zd/YYa67OgJcsLxa8ZHkh8JLlxYGXLC8evGR5CeAly0sEL1leEnjJ8eIVeMnygng3zwvi3TwviHfzvBB4yfKCeDfPC+LdPC+Id/O8IN7N84J4N8tLQLyb5wXxbp4XxLt5XhDv5nkh8JLlBfFunhfEu3leEO/meUG8m+Ulio1f3n/NWuOM6iF5KeyUj1LnoxIvUuejEi9S56MSL1LnoxIvUusvBV6S1PpLiRep8UuJF6n1lxIvUusvJV7o93khu/FCURd4sXq7w85qctvTOvfTS3lo/eh0yfwPD4fMw57o+1nv7PHRL0edFEf9PI7G9Vl/GG+bo2EiR9dBGlRG0QoxI+m0O2oKjjql/ffTTlE4OvplUOrLIFPj5Ne6BuneDDK9GWR7M4h6M8j1ZpDvzaDQm0GdvamN6u1NrXt7U+ve3tS6tze17u1NrXt7U+ve3tS6tze17u1NrXt7U+vWb2pKKW4GufTn22yGXFpzTvKkXqw3amjr9dDWm6Gtt0NbT0Nb74a23g9tfRja+ji09QPNtfbFejvQXJuxfqC5NmP9QHNtxvqB5tqM9QPNtRnra79zfMF6TdtqhSYb31vvFa0/7VVS7x/WyxPr08vfzr84S0qSs1qSs0aSs1aSsyTJWTets+nVWS/J2SDJ2SjJ2XkjqFdn3bwR1KuzZx/rq3ji7BcqslCJgxL7+YPdjF6yR3d8+IsXqZ8/lHiR+vlDiRepnz9YbTdejH/lRernDwVexH7+UOJF6ucPJV6kfv5Q4kXq5w8lXgi8ZHkRG+8WeBEb7xZ4ERvvFnhBXJfjxSpcX/j72ZRVuHq9BosEFiuwiKvXa7wXcfV6DRZx9XoNFnH1eg0WcfV6BRY1rl6vwSKuXq/BInKXGiwid6nBIoHFCiwid6nBYufx4psrO1+fppDWp5c/d0uso29vO4/rrnkb9bZ5Per06q3pPP666K2xm7fWZLztPE6q7G3n8UxlbzuPOyp7S6K87Xwer+xt57XCi95u208Xx1XG285repW9nSqWKno7VyxV8NbOFUuVvJ0rlip5O1csVfJ2rliq5G1+BlLbAbtaxfSSFdvIQuXfiNqtaZrWwbygTj67LaE0C2VYqHyP0XE9G0n/EGpFnUU62wmrZDJtBRYqslCJgzr9yOc9SrNQhoXK6+W2E4iXUahfUcRCORbKs1CBhYosVOKgTi4ad2lNCrTX9hWlWSjDQlkWilgox0J5FiqwUHmVlzlyRVn3Or5OrtcsoTQLZVgoy0IRC+VYKM9CBRYqslCsvhFZfePkYi/rt+8bbXx920TDQlkWilgox0J5FiqwUKzIIbIih8SKHBIrcsh/C2CiXtkw0R/C5ZQLrj/i4DUUt4fTL/NPL/T67YthWmjfbUr+2yjfo1GhR6Nij0al/oyi/C0CTxulezTK9GiU7dEouteor0Zci0Z8i0ZCi0Zii0ZSg0a0atFIlTfQVhP8SMsyjZgWjdgWjVCLRlyLRnyLRkKLRmKLRmqM+KU2vTZCujT/RB3W6efjOqw/jwXuT5OM6s8k3Z9Jpj+TbH8mUX8muf5M8u1NuravUW27SoJ+3VVCJozuQBzdgTS4A1aN7oAe3QEzugN2dAdodAfc6A6MPhPb0WdiO/pMbEefiWn0mZhGn4mp+3ng/XdORL2/hQrb9oi6egt9mdTVe+XTJNfVm+LLpPZjv5MPLXczjLEvW43IGRCTJ8aCmDwxBGLyxDgQkyfGg5g8MQHE5ImJICZPTAIxWWK8AjF5YhD5nhCDyPeEGES+J8QQiMkTg8j3hBhEvifEIPI9IQaR7wkxiHzzxAREvifEIPI9IQaR7wkxiHxPiCEQkycGke8JMYh8T4hB5HtCDCLfPDFRbhzjdmK8fyVG7KwUthOfTHD0SozYWalEjNhZqUSM2FmpRIzYWalEjNh6TIGYJLYeUyJGbBxTIkZsPaZEjNh6TIkYyhFjlVo/KLWKYsFV/XH03Pfjy9+mRI1Z/renKfuljXZJWb6Mcncb9dWMb9NMaNNMbNNMatGMy596VL8Z3aYZ06YZ26aZKu8M58zezOHgurN9+e8/cXfK9WiU79Go8IRR7z+rcCr2aFTq0CitejRK92iU6dEo26NR1KNRrkejfI9G9fhG10+80YdYh3E6gZoTaowCNWfUaFBzRo0BNWfUWFBzRg2BmjNqHKg5o8aDmjNqAqg5owbR8Ck1iIbPqLGIhk+pQTR8Sg2i4VNqEA2fUkOg5owaRMOn1CAaPqUG0fApNYiGT6lBNHxGDSEaPqUG0fApNYiGT6lBNHxKDYGaM2oQDZ9SIzmuefuJnXOCZ6j3e7CdEzxDlagRPEOVqBE8Q5WoETxDlagRXK8pUSO4XlOiRnBcU6JGcL2mQI0XXK8pUSN4hrJmvRplSaHcKzWCZ6gSNYJnqBI1gmcou32wt7D0mnl7wTNUgZogeIYqUSO4XlOiRnC9pkSN4HpNiRoCNWfUSI6GC9RIjoYL1EiOhgvUIOQ7oyaKPSKpkEFFsUcklYghEJMnRuzhoKV3jNjDQUvEiD0ctESM2MNBS8SIPRy0QIzcw0FLxIg9HLREjNzIt0CM3Mi3QAyBmDwxiHxPiGkfx7w5h+r1aQppfXr5c7ffLmv0Xw6kzh2ImlYHok4vDnilenfA2M0BazIO6NEdMKM7YEd3gEZ3wI3ugO/dARU2B4zKOBBGd6D3mbjoQPczccEB3f1MXHKg+5m45ED3M3HJge5n4oID+Q/9g18TjuBf9sb6/LfMya8zTgr+FWMYGMvAEAOTncy12nYIaxXTK8qzUIGFiixU4qCcYqE0C2VYKMtCEQvF6huO1Tccq284Vt9wrL7h9fW3hc+PfLO+xRJlMIyRn9+WXmgnMDCRgUnXMfmtr+85CIw3c2C8mfO7CFNc+8GPktaKIQbGMTC+4E8OExgcRAYmXcdERj+IjH4QGf0gMsZpZMzQ+Y0MBYxnYBj9IL9qQ0FtCXjQmQQ8v6ZRhlEe5s0GCzoDczxYlsNicSF/oVYZFvOwQgibrwiXYCFfhy3DNA9meDDLgxEP5ngwz4MFHux6L1n+SX88mw/0ndXfSHcY3pr0R3v5KP89JFyHxOuQdBGy/JP5eDJ/twWF9U3gzR6LaJs+gfYTSFdyXb2sgX1A6ZP4fKFCK79C9WFW/oQuSHMZtPyTOzeVwr4yEw5A+wn0n8CsdlFtCfphSe0jVX95dElAVx6dPT66OJS/cKXWj6ff/fG4dh0f419+PH/px6Uf31IE9dPy5R/CJ/PZgRbTOmXElH7J42TX7pFceG+U1iqsEfjydzp4HT8Ni+eGFbHp4+F83LKkNysby5+Hadd/Xa/pOaDAAUUOKDFA+c1QJZDmgAwHZDkg4oA4PSJxekTi9IjE6RGJ0yO0UiyUZqEMC5XvFYHWN8ySN6pXVFasJW6k/Q3oX1GBhYosVOKg8qslS/Sd3qJcvi0KGyq8Mq89CxVYqMhB5e9fCVZtHB5332woz0IFFiqyUPm+Ye22XckeptUVlb8GoYjSLJRhoWwR5c0r6kSvuKMOM/+GCixUZKESB0WKhcozT2brUXQ4cnFDJQ4qvzIQoluD1LCsXb2i8qOSfNza8ukV5VmowEKdrLdtmwfDjxudV1TioPLH+xRRmoUyLJRloYiFcixUXi8Xt97r0ut7I1+HD2HLZkLMxBv5SnwRZVkoYqEcC+U5Yzlfky+iIguVOKh8Zb6I0iwU632Yr88XUcRCheL4yvSNGFmoxEElxUKdvA+3RYGwLAW9ovJ9fgmyV1TQ9IoKLFRkoRIDZfJZWxGlWSjDQp3MKSnsKPeKIhbKsVAnermtRx1PpNtQqfju1T9HZabiRdGt4cny92u/Nfrknab9mze80Zz5zmjDQlkWilgox0L5y6g/P9Lyj4fzq/56ybC2jRlL3vSiWz7gKMMMD2Z5MOLBHA/mebDAg0UeLL8NZynvr1WV5e/XxDQfeZRhmgczPJg9gQW9w+IrjHiwEyb9Fqlrv1Ry/vylwvTyqNl9WxK5P3+pNF2GGR7M8mDEgzkezPNg4QQW/Q57LUbkY54yLLFgJ8XqJTvch/eyfvar5epfwBkm7qynHAZP1KYUJphA2/NmCZBLzzsXN5GdS69lD0Wd2uU6tct3alfo1K7YqV2pT7u06tQu/ZRd23vVefW6qKdNJbusPdiVyunalusuf+vXQqO2ndoVH7LrfXqrderTLqM6tUt3apfp1K6zeMId4kufwXkmLjBxkYlLPJxVTJxm4gwTd/I+jTbs/Sq3vExMnGPiPBMXmLgT3dM+z/rkX4vMpJi4Ex2S3+1M4TV+OPkoLywv2BUXdGabyslneWVcZOISD3fycV4Zp5k4w8RZJo6YOHeC21bjl7/ja1znzvrL3s/CcZdxfl7waQuHfDp8wftR73t5OJptF280h6rZx77R020Fj1oUu7Mo9WaRV91ZpLuzyHRnke3OopP3kdn2Zn78/bKkqP3JiDDbmuLyd+b9d7LcVMZpJs4wcSfvd2P397uhzMYOz8SdvIWNP9iZiT9OloHKuMTDRcXEnehnt49rlr/Na15/shRUxlkm7iQesHTAudfxEB0T55m4wMRFJi7xcCfLXWXcWX+xR9xrXJYME2eZuLP+stf3lr9fx0NyTJxn4gITF5m4xMKdbPf5BdxZfwkHXFKvOMPEWSbupL/QYb4lY19xjonzTFxg4iITl3i4k3WFMu6kv5A64l43RZ3U5cs4y8Sd9BcT9/mWrPuzVEfcT2ld/n6d9042HjHa2b5vWP52xXWQ8vYwX8kuR7tdPtMfwg3+59qJjdpJbdoxqlE7ulI7we/tJPPb/dOYSnal3f/lnfDajq3vf7YdatSOa9SOb9ROpfcH6bC3Y+3v989K7xuyB//pdYuxSTf4n2nHqkbt6EbtmEbtMN4fnzhi4hwT51n1GmMDExeZOF79y5Bi4jQTZ5g4y8QRExdY62/mbD1MqW0+Xf72r7jEw52thxVxJ+vKKakD7jUuP1kPK+MsE0dMnGPiPBMXmLjIxCUG7s+PDUAfj59FidvetMOIWEpYX2+Y6xC6DnHXIf46JFyHxOuQdBlyFk28g+jrkOvq2+vq2+vq2+vq2+vq2+vq2+vq2+vq5+dis1VkzOE9vkL0dYi5DrHXIVn1l/BthRxirRXirkP8dUi4DonXIekyJD+Tv4fo6xBzHWKvQ66r766r766r766r766r766r76+rnz+ZwWwJ+BIj/BWSX7Umt92u5eILxF5vJa9+2O7lOny8tkLyN6Xr1bDjl4M65e/NOj3b8OzjxMPP25eX8ckF5e8g+bXo9xB9HWKuQ+x1CF2HuOsQfx0SrkOuq59fXrbbdfP2ePzkFyS/QvweYq5D7HUIXYe46xB/HRKuQ/Jn327nyC+10BdIugw5+dqxgMm/W/fL8Ix5xRgGxjIwxMA4BsYzMIGBiQxMuo7Jr+a+nS9PvuB6j8lnZDX31eUTuKot0O0tuNtb8Le3EG5vId7eQrq7BVIXW/gEaQ7o6sj7LKIZFNFQREMR7SIERTQU0VBEQxHtFyEooqGIhiIaimgooqGIhiIaimgooqGIhiLaPEW0zzv1zMlhxtsxjyEcPXNvamI/QIF+gDKhblqDb3ewzcTv7XV3N+DvbiDc3UC8u4F0cwNW3d2AvrsBc3cD9u4G7h7J9u6RbGuMZLNG686kHw28PhsSbbc1/LjJO+Z+ef/8l+yPG9ZfHzVmuwbCGPvXK8JtkOFmlOFmEuEmKRluahluGhluWhlukgw3nQw3ZURBJCMKIhlREMmIgpyMKMjJiIKcjCjIyYiCnIwoyMmIgpyMKMjJiIKcjCjIyYiCvIwoyMuIgryMKMjLiIK8jCjIzzNvut1N7//iZpjmTRtofdYcL6T+dnOaN+17N6d50753c5o37Xs3p3nTvndzmnzzvZvT5Jvv3Zxm3nzv5jT55ns3p8k337oZp3nTWrMeebmEtO6vbk7zpn3v5jRv2vduTvOm3e8XWDz+a4YSp3nTvndzmjftWzfTNPnmezenyTffuzlNvvnezWnyzfdukgw354mC3ro5TxT01k0Z4cHJB6CO1gDRUXyBpMuQ/Oef7yH6OsRch9jrELoOcdch/jokXIdcVz9/iZOL62d+7nAmxTckfx/Te4i+Dsl/gLgtxviXtRid//DwPYSuQ9x1iL8OCdch8TokXYbkP7F7D9HXIdfVt9fVt9fVPzlY6m3d6ORjWu3jfjGfehkAJ9ejFEDEATkO6OyAse0ylahfpicKHFDkgBIDdHbzynuQ5oAMB2Q5IOKAHAfE6RGO0yMcp0c4To/wnB7hOT3i5Cb5ZLdLjRK9giwHlNdJba+wJYpML6DAAeV10vtFmTq8vFhOrn1/Dzq5870A0hxQXicdt8vrjHoh4uSqdzJrAKSPp6ysIM8BBQ4ockCJATq5270A0hxQXie3na+xvHr0C8hyQMQBOQ7Ic0CBA4ocUL5HuLS9jbx+CahObm8vgDQHZDggywERB+Q4IM8B5cW1+6xh3ct4Orlt/S3o7Kr1AkhzQIYDshwQcUCOA/IcUOCAIgfE6REnl6lbv90xa6N+AWkOyHBAlgMiDshxQJ4DYoQEZ5eIF0CMkODseu8CKF+29ls519MLJGtc8mtvTeGvkfLJTcDvIfo6xFyH2OvR+Nk9uwWQ44A8BxQ4oMgBJQbo5FbdAkhzQIYD4vQI4vQI4vQI4vQI4vSIky/A370Z8mWftJ1qmugVcn2Y5wsx71tx1yH+OiRch8Tr7l9//frrr9986SXFVf0fa3HfEHMdYq9DqOBLBuKuu++vQ8J1yHX1/XX1w3X1w/VRGa5PvvnvCt5D6Drkovp/fhS9P57MB5YxmbV3xpQOpzR/HL/5gXUfD+ff7c5u63SHRpelkA9D82/295BwHRKvQ9JFyAcL/uPRkxU+u15REtXhzgEbvjr4dUi4DonXIeky5GSF7y0kO/Ci2SCHhecVYq5D7HUIXYe46xB/HRKuQ+J1SLoMyce57yF59bflw+WF8wOS2QDj12DDHrbhWPf18+ben7f3/jzd+/Pu3p/39/58uPfn470/nyr+fLR//fl8WlLv5/W9P58PrMy6TJZs+Ot7JL++/R5C1yHuOsRfh4TrkHgdki5DTsLqtxB9HXJd/XBd/XBd/XBd/fw6rNk2eC4p1F87f34V9j0kXofkr9MK29dA6WVU5tdf30P0dYi5DrHXIXQR8ufyj//3n//xt3/+l7//2/9ZIB//9b///V//62//8e/f//hf/+8/1//yL//429///rf//U//+Y//+Nd/+1///Y9/+6e//8e/fvy3/6G+/+9/hqUe/0dYCpeLMR8kRb/8c/SWPiKvj/++LKP+EZblto///gEgb+iP5f/Sx7/4QAQX1B/L/5nP5OPjdz9w1vxBZsU4/YfzH//584LSz3+1VMbN57+y279aGjb641/R+iMm/mH3hpdm08d/dq8Iv/+u+8Oqj38V9n8V/rCfxsUdmP4w9PGv0srDwsAfS0no2+tlLSJsDZuPpw2t/prFKvPVht5oNEvdxCr9DXfqD682uDeLq2GDL7+91AU+4XqFa4p/aJ++4VrTH/qrwc//uPikrVp/QC/DSVPYL3z9nR+wuwNmccBuEKX/0MqvEKto+a/+kKB/PrRQZvbE+1x2veuz5P4+rj+b1B9p+YE/l279/wE=",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "notify_created_nullifier_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "random",
        "decompose_hint",
        "lte_hint",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBGJwAABAMnAgEEACcCAgQAHxgAAgABgEYlAAAAPyUAAABVKAIAAQSARicCAgQAOw0AAQACKACAQwQAAygAgEQEAAAoAIBFBAABJiUAAAQvHgIAAgA2OAACAAMABAAcDAQFAAQ4BQMGJwIDAQEkAgAEAAAAiCcCBQQAPAkBBTY4AAIABAAFAhwMBQIABDgCBAckAgAFAAAArCcCAgQAPAkBAi0IAQInAgQEAgAQAQQBJwMCBAEAKAICBB8kgESARQAEASgAAoBFAAUtDQUEHAwEBQQcDAUCAC0IAQQAAAECAScDBAQBACgEAgUfJIBFgEQABScCBQAAJwIIAA0tCAEJJwIKBAQAEAEKAScDCQQBACgJAgotDAoLLQ4ICwAoCwILLQ4CCwAoCwILLQ4FCy0NCQIAKAICAi0OAgktCAECJwIIBAQAEAEIAScDAgQBACgCAggtDAgKLQ4FCgAoCgIKLQ4FCgAoCgIKLQ4FCi0NAggAKAgCCC0OCAIrAgAIAAAAAAAAAAADAAAAAAAAAAAtCAEKJwILBAUAEAELAScDCgQBACgKAgstDAsMLQ4FDAAoDAIMLQ4FDAAoDAIMLQ4FDAAoDAIMLQ4IDC0NAggAKAgCCC0OCAItDQoIACgIAggtDggKLQgBCAAAAQIBLQ4CCC0IAQIAAAECAS0OCgItCAEKAAABAgEuCoBEAAotCAELAAABAgEnAgwBAC0ODAsuCIBEAAEjAAACNQ0oAAGAQwAEJAIABAAAAvAjAAACSi0NCwEKOAEMBCQCAAQAAAJkJwIJBAA8CQEJJwIBBAwtCAAMLQwIDS0MAg4tDAoPLQwLEAAQAAEAJQAABFgtBAAALQ0IAS0NAgQtDQoJLQ4BCC0OBAItDgkKLQ4DCwEoAASARQACLQ0CAQo4BwECJAIAAgAAAsUlAAAFawo4BgUBHgIAAgEKOAYCBBI4AQQCJAIAAgAAAuYlAAAFfR4CAAEANAIAASYAKAkCDQA4DQEOLQ0OBC0NCg0tDQsOCjgODA8kAgAPAAADHCcCEAQAPAkBEAsoAA2AQwAOJAIADgAAA6sjAAADMS0NCA0tDQIOLQ0KDy0NCxANKAAPgEMAESQCABEAAANWJQAABY8uBAANgAMoAIAEBAAEJQAABaEuCIAFABEAKBECEgA4Eg8TLQ4EEwEoAA+ARQAEDjgPBA0kAgANAAADliUAAAYvLQ4RCC0ODgItDgQKLQ4QCyMAAAQeJwINBA4tCAAOLQwIDy0MAhAtDAoRLQwLEgAQAA0AJQAABFgtBAAALQ0IDS0NAg4tDQsPLgQADYADKACABAQABCUAAAWhLgiABQAQACgQAhEBKAARgEQAEi0OBBItDhAILQ4OAi4KgEUACi0ODwsjAAAEHgEoAAGARQAELQwEASMAAAI1KACABAR4AA0AAACABIADJACAAwAABFcqAQABBfeh86+lrdTKPAEBAiYlAAAELy4IgEQABSMAAARoDSgABYBDAAYkAgAGAAAE2CMAAAR9LQ0BBS0NAgYtDQMHLQ0ECCcCCQQELQgBCicCCwQFABABCwEnAwoEAQAoBgILJwIMBAQAKAoCDT8PAAsADS0NCgYAKAYCBi0OBgotDgUBLQ4KAi0OBwMtDggEJi0NAwYMOAUGBwEoAAWARQAGJAIABwAABPYjAAAFYi0NAQctDQIILQ0DCS0NBAoAKAgCDAA4DAUNLQ0NCwAoBwINADgNBQ4tDQ4MADgLDA0uBAAIgAMoAIAEBAAFJQAABaEuCIAFAAsAKAsCDAA4DAUOLQ4NDi0OBwEtDgsCLQ4JAy0OCgQjAAAFYi0MBgUjAAAEaCoBAAEF9IABplnTJ0I8AQECJioBAAEFHwBQEkAkIu48AQECJioBAAEFxWvEWg4QAAI8AQECJi4BgAOABgsAgAYAAoAHJACABwAABbwjAAAFxy4AgAOABSMAAAYuLgAAAYAFAQAAAYAEAAEBAIADgASACS4AgAOACi4AgAWACwsAgAqACYAMJACADAAABhouAYAKgAguAoAIgAsBAIAKAAKACgEAgAsAAoALIwAABekoAYAFBAABAwCABgACgAYjAAAGLiYqAQABBUWnynEZQeQVPAEBAiY=",
      "debug_symbols": "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",
      "brillig_names": [
        "constructor"
      ]
    },
    {
      "name": "commit_private_user",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "src_receiver",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 48
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6652550611004701521": {
            "error_kind": "string",
            "string": "Funds Not Sent"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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k0ZFvfym0Vr41sgc9u9gzUm+vMXtZcu1l63XXrZde1nh83f/xtjHy+YTfCHHbaedY/7WsRe+taD8JsHiTaLFmySLNxGLN5kt3mSxeJP89k+yWaNPeflbunUO73+L+P63SO9/C3n/W8zvf4vl/W+h0ae8/KHYOm/vf4v89rdYprf3KUt4/1vE979Fev9bvL9nXOb3v8Xy/rdY3/8W29vfonD3dlr3l/3z7/yvW37hluy05r2lnrawfHuZXHvZfO1ly7WXHQs7bSk9XvZ06vr9Zdu1l+VLLzt+Cs35ywq65cf581NewreXFUjm7X4OfQjT9I3ktl572XbpZXm6NLfju3XnLyssnJzT0yDnby9L114m1142X3vZsdwfl+bHy+KzAP/hglyrxZtsFm+S//5NXt/X244PDNR9i/D+t4i/fYvby9K1l8m1l81XPn22abn2svXay7ZrL8uXXhamay8L114Wr70sXXuZXHtZ4fv/8/7Buq7PP/k8as3iOu3f1vm4h/HtLfLb36Jw+0f1LcL73yK+/y3S+99C3v8W8/vfYnn/W6zvf4v3r+74/tWd3r+60/tXd3r/6k7vX93p/as7vX91p/ev7vT+1Z1+vbpvL8uXXibTtZeFay+L116Wrr1Mrr1svvay5drL1msvu1Ylcq1K5mtVMl+rkvlalczXqmS+ViXztSqZr1XJfK1K5mtVMl+rkuValSzXqmS5ViXLtSpZrlXJcq1KlmtVslyrkuValSzXqmS9ViXrtSpZr1XJeq1K1mtVsl6rkvValazXqmS9ViXrtSrZrlXJdq1KtmtVsl2rku1alWzXqmS7ViXbtSrZrlXJdq1K8rUqydeqJF+rknytSvK1KsnXqiRfq5J8rUrytSrJl6okT9O1l4VrL4vXXpauvUyuvWy+9rLl2svWay/brr3sWpWEa1USrlVJuFYl4VqVhGtVEq5VSbhWJeFalYRrVRKuVUm8ViXxWpXEa1USr1VJvFYl8VqVxGtVEq9VSbxWJfFalaRrVZKuVUm6ViXpWpWka1WSrlVJulYl6VqVXMte87XsNV/LXvO17DVfy17ztew1X8te87XsNV/LXvO17DVfy17ztew1X8te87XsNV/LXvO17DVfy17ztew1X8te87XsNV/LXvO17DVfy17ztew1X8te87XsNV/LXvO17DVfy17ztew1X8te87Xs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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "notify_created_nullifier_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "random",
        "decompose_hint",
        "lte_hint",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "redeem_private_solver",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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n0qoTyXUpxLqUwn1qYT6VEJ9KqE+lVCfSqhPJdSnktinktinktinktinktinktinktinktinktinktinktSnktSnktSnktSnktSnktSnktSnktSnktSnktSnktynktynktynktynktynktynktynktynktynktynktKnktKnktKnktKnktKnktKnktKnktKnktKnktKnktqnktqnktqnktqnktqnktqnktqnktqnktqnktqlEr8sfae5vtN832mh7zTqOy32nZb6Tst9p5W+0/pU0td79X29V9/Xe/V9vVff13v1fb1X39d79X29V9/Xe/V9vVff13v1fb1X39d79X29V9/Xe/V9vVff13v1fb1X39d79X29V9/Xe/V9vVff13v1fb1X39d79X29V9/Xe/V9vVff13v1fb1X39d79X29V9/Xe/V9vVff13v1fb1X39d79X29V9/Xe/V9vVff13v1fb1X39d79X29V9/Xe/V9vVff13v1fb1X39d79X29V9/Xe/V9vVff13v1fb1X39d79X29V9/Xe/V9vVff13v1fb1X39d79X29V9/Xe/V9vVff13v1fb1X39d79X29V9/Xe/V9vVff13v1fb1X39d79X29V9/Xe/UHvde6fbx3a9e5ndMOVJLzdlr1307bW3GWaT+LWzhZVjhFVjhVVDhHve2rwnGywvGywgmywiFZ4URZ4ch6KldZT+Uq66lcRT2VwyLqqRwWUU/lsIh6KodF1FM5LKOfym+3YrrFE4XFk4TFk4XFU4TFU2XF4378bL6f5vpO832n7T6Tbm8x1yU8bu8KYwOaSzlsu/umnB4L6+ytdHCzyusiMrf5IjT+dlqWbQGsJTx+TF6Xr/hJePxxWROQYgiv8Ufl8Sfl8Wfl8Rfl8Vfd8e9/gKEofqc8fq88funzbyt+5fOvVz7/euXzr1c+/3rl869XPv8G5fNvUD7/BuXzb1A+/wbl829QPv8G5fNvUD7/BuXzb1A+/5Ly+ZeUz7+kfP4l5fMvKZ9/Sfn8S8rnX1I+/5Ly+ZeUz79R+fwblc+/Ufn8G5XPv1H5/BuVz79R+fwblc+/Ufn8G5XPv0n5/JuUz79J+fyblM+/Sfn8m5TPv0n5/JuUz79J+fyblM+/Wfn8m5XPv1n5/JuVz79Z+fyblc+/Wfn8m5XPv1n5/JuVz79F+fxblM+/Rfn8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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "is_contract_initialized",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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f93k86+bfP51k8+/bvL5108+//rJ518/+fzrJ59//eTzr598/vWTz79+8vnXTz7/+snnX5p8/qXJ51+afP6lyedfmnz+pcnnX5p8/qXJ51+afP6lyeffMPn8Gyaff8Pk82+YfP4Nk8+/YfL5N0w+/4bJ598w+fwbJp9/4+Tzb5x8/o2Tz79x8vk3Tj7/xsnn3zj5/Bsnn3/j5PNvnHz+TZPPv2ny+TdNPv+myeffNPn8myaff9Pk82+afP5Nk8+/afL5N08+/+bJ5988+fybJ59/8+Tzb558/s2Tz7958vk3Tz7/5snn3zL5/Fsmn3/L5PNvmXz+LZPPv2Xy+bdMPv+WyeffMvn8W+aef4uZe/4tZu75t5i5599i5p5/i5l7/i1m7vm3mLnn32Lmnn+LmXv+LWby+ddOPv+K3/+q1f/J59/J978qk+9/VSbf/6pMvv9VmXz/qzL5/ldl8v2vyuT7X5XJ978qk+9/VSbf/6pMvv9VmXz/qzL5/ldl8v2vyuT7X5XJ978qk+9/VSbf/6pMvv9VmXz/qzL5/ldl8v2vyuT7X5XJ978qk+9/VSbf/6pMvv9VmXz/qzL5/ldl8v2vyuT7X5XJ978qk+9/VSbf/6pMvv9VmXz/qzL5/ldl8v2vyuT7X5XJ978qk+9/VSbf/6pMvv9VmXz/qzL5/ldl8v2vyuT7X5XJ978qk+9/VSbf/6pMvv9VmXz/qzL5/ldl8v2vyuT7X5XJ978qk+9/VSbf/6pMvv9VmXz/qzL5/ldl8v2vyuT7X5XJ978qk+9/VSbf/6pMvv9VmXz/qzL5/ldl8v2vyuT7X5XJ978qk+9/VSbf/6pMvv9VmXz/qzL5/ldl8v2vyuT7X5XJ978qk+9/VSbf/6pMvv9VmXz/qzL5/ldl7v2vopl7/6tH/6eefx/9n3r+ffR/6vn30f+p599H/6eefx/9n3r+ffR/6vn30f+p599H/yeff+fe/+rR/8nn37n3v3r0X/r8+/rpmIo99r928NbrmOPrh7P/Gqv0uXrkWKXP6yPHKj0HGDlW6fnCyLFKzy1GjlV4HvLrSfvXWN3nsTrzqAtv/X78nffDXYnP8UrfN2z4eIXnOcPHKzwvGj5e4XnU8PGSsvEKz6eGj1d6TvWo3G7jNT6++RpZ+6o9uyQqnXl2SVTW8UeXZG1o9uySqLn72SVR0+uzS6JmwGeXRE1Szy6JmkeeXRJ1q392Sd7dW9ZGW88uybt7y9oO69kleXdvWZtWPbsk7+4ta2upZ5fk3b1lbQD17JK8u7esbZqeXZJ395a1mdKzS/Lu3rK2PHp2Sd7dW9bGRM8uybt7y9o+6NkleXdvWZv8PLsk7+4tayueZ5fk3b1lbZjz7JK8u7esbW2eXZJ395a1+cyzS/Lu3rK2iHl2Sd7dW9ZGLs8uybt7y9pu5dkleXdvWZuiPLsk7+4ta+uSZ5fk3b1lbTDy7JK8u7esbUCeXZJ395a1WcezS/Lu3rK21Hh2Sd7dW9bGF88uybt7y9qe4tkleXdvWZtIPLsk7+4ta6uHZ5fk3b1lbcjw7JK8u7esbROeXZJ395a1ucGzS+Lu3lbWFgTPLom7e1tZGwU8uyTu7v34//K6JO7ubWW9dP/skri7t5X1avyzS/Lu3rJeYH92Sd7dW9Zr5s8uybt7y3rB+9kleXdvWa9LP7sk7+4t6+XjZ5fk3b1lvcb77JK8u7esl2GfXZJ395b1SumzS/Lu3rJezHx2Sd7dW967llbeu5ZW3ruWVt67llbeu5ZW3ruWVt67llbeu5ZW3ruWVt67llbeu5ZW3ruWVt67llbeu5ZW3ruWVt67llbeu5ZW3ruWVt67llbeu5ZW1ruW70cftspJ2Zb96OpWOSHStn9myOn407Wjs03l6+jHL6f9aJfdF5t5tnm7nY2st0+FsZln+7j72cyz1dz9bObZlu5+NgQ2p2zm2e7ufjZj5vB9X+7H3zYd2Pxxkp+/pvps5vuaUV+z0Ncs9jVLfc1yX7PS1eznr/E9m9m+Zn1RkvqiJPVFSeqLktQXJakvSlJflKS+KMl9UZL7oiT3RUnui5LcFyW5L0pyX5TkvijJfVGS+6Kk9EVJ6YuS0hclpS9KSl+UlL4oKX1RUvqipPRFSemKEmdMXzPb18z1NfN9zaivWehrFvuapb5mua9ZX5TYviixfVFi+6LE9kWJ7YsS2xclti9KbF+U2L4osX1R4vqixPVFieuLEtcXJa4vSlxflLi+KHF9UeL6osT1RYnvi5L6ox0U92aUrKs0c/Vm9tXMmb9/ttvZ0Gbp/atY4LKtHFvyVrQo5fuxz+54Wd0hWd0JsroTZXUnyepOltWdIqo79ccr+LpjZXVH1l2ZZN2VSdZdmWTdlenuu3Lcjn1U/F2lP0lYf7Kw/hRZ/QlGWH+ssP6MWbz7uEDlBu1c3DhJuuMkY55XIvs6SSiHk/xsZfTZpSKuS4N2Fx7aJXt3l+hR292uafceSYP2Fh7YIS+tQ3T7cwXBmO23A5XWb5ew/3TJ9nBvdV8DCLMPIM4+gDT7APLsAyiTD4Bhr+XBA7CzD8DNPgA/+wCkz8S5+O1o478P4OcP7bkkfd4ePFzps/zg4UrPCQYPV3oGMXi40vONscPN0rOTwcOVnsv8cLhxe4w9O1Mqw5We+QwervQ8afBwSddwF8uqWsNdLKtqDXexrKo13MWyqtZwF8uqGsMti2VVreHqyqrKWlnVo7P7cINrHJ0KbUenUnzjaJ+2bpOn17G1NyHdqxvOeX88+Al9rdxuEugE6PdDXyvPnQT6Wtn2JNDXyvkngb6W85gE+lr+Zwro3qzlwiaBvpYXnAQ6HCkDdDhSBugE6PdDhyNlgA5HygAdjpQBOhwpA3Q40vuhWzhSBuhwpAzQ4UgZoMORMkAnQL8fOhwpA3Q4UgbocKQM0OFIGaDDkd4P3SFPvwJ6eEGP8R06spcLoCfah5gCvUNH9sIAHdkLA3RkLwzQkb3cD92jns4AHfV0BujI0xmgo57OAJ0A/X7owj/BmNy+y3NKpvEJRpvM9tM2xYOevvbTeT/42+caq8e6h3XfgBD91d1IvBf1iW811EV9xVwNdeEfal+UuvBPwK9JnYR/XH5R6sI/W78odbcS9ej2rx2kFBskvTF270iON3P34M7CncCdhbtih5q3goM1pon9tXvRY8E//WXsii0qJ3bFHpUTu2KTyoldsUtlxB4U21RO7Ip9Kid2xUbVpu07Wd65dDN3xUaVlTuBOwf3KDzeY9i/UBnD4Ynw8rUUHIXHTbP/wgsFzf4Ld9zN/gu3rs3+C/eAzf4LN1Ot/ifhrqTZf+HpfbP/wvPkZv8nn38ZvpU3tv+Tz79p8vk3TT7/psnn3zT5/Jsnn3/z5PNvnnz+zZPPvwxfVRvb/8nn3zz5/Jsnn3/z5PNvFj7/hhK24mQ8Pq239b8In3+b/Rc+/zb7L3z+bfZf+Pzb7L/w+bfZf+Hzb7P/wuffZv+Fz7/N/kt/BimQ+zo6xcMifnXdzvvtWE+HTn8tlRXpz/0MGyoZ6c/aDByq9OdbBg5V+jMlA4cq/TGOgUMlPUOV/lT9wKHqfZI9mO2xu0Dm27FPMnofNm+R0fs8eIuM3ke2G2Ss3qeqW2T0PvjcIrPUs8lDySz19PBQMgQyJ2T0vioa4vaYdCi5cSy5sGEkl+lwtH1ydNjG4vc2VHg9P+7T+xPh5LAxxRiOemfJsRz1zqljOeqdgcdyxOaDYzhiO8ExHLFB4BiO2PJvDEds4nfFxmY79ewOnd6pe7gfDurwShzU4aw4qMOHcVAnUGegDo/HQR2OkIM6/CMHdbhNDurwpgzUscH8FdSn+GIvYZt7xdrDp+vVHtUCvdoTtFerPSonerVH/Uav9qgi6dUetSy92qOiplZ7zV/kUK896np6tUddT6/2qOvp1Z6gvVrtUdfTqz3qenq1R11Pr/ao6+nVHnU9tdpH1PX0ao+6nl7tUdfTqz3qenq1J2ivVnvU9fRqj7qeXu1R11OrvfRvVkP7v6J9eGkf47v2yPPX1T7RdqxLgd61J2ivVnvk+Xq1R56vV3vk+Xq1x/q9Xu2xfq9W+wx/r1d7rN/r1R7r93q111vXK24bYwmhcWwwaf/klDXHSPn6ilQmcBzCUW+9aSxHvbWbsRwV10Hy9uE8aw4fpT4Bae0LZIgVkIqLCmNBKnboQ0EWxXZ3LEjF3nEsSMVGbCxIxU8rjAVJADkGpOJ19LEgFS9K/wSke+2u75z//r29yk+39uIv8EEs2OGaWLDDYzFgDwaOjAU7/BsLdrg9FuzwhizYCdg5sMN3smCHS2XBDpd6BfYpXk8MBl5Zsfhw7HrFt6gbKBYf1QvF4qOGolh8VHIUi08QX6/4qGopFh+1NcXio8KnWHxU+BSLjwqfXvEdKnyKxUeFT7H4qPApFh8VPsXiE8TXKz4qfIrFR4VPsfio8CkWHxU+xeKjwqdXfI8Kn2LxUeFTLD4qfIrFR4VPsfgE8fWKD5+/svgfPycXCNn+wuJ/3nM8ELJ9xeIj21csPrJ9xeITxNcrPtbzFYuP9XzF4sPnKxYf6/mKxcd6vl7xw1I+PzraxU9NPYvZjnYl+MbRZMwWK2ToGFj2i+RSE+iPSHpj7N6R3OTuX9eRT9+voyfJpWYjVpJL3do5ScalVkJYSS61rMBKUu/cPZrkUgVvVpIEkoNILlWKZSW5VF3zUpI/+nR6a5vvCEfEwx3+iYc73BYL9wRvxsMdTo6HO3wfD3e4RB7uBO4s3OFAebjDr/Jwh1+9hPscLzoluGbN6sO7K1Y/o4KgWX3UMTSrj2qKZvVR09GsPkF9xeqjvqVZfVTZNKuPWp9m9VHr06w+an2K1S+o9WlWH7U+zeqj1qdZfdT6NKtPUF+x+qj1aVYftT7N6qPWp1l91Po0q49an171o0GtT7P6qPVpVh+1Ps3qo9anWX2C+orVh99fWv2P36yKFjn/yup/3s84WuT8mtVHzq9ZfeT8mtUnqK9Yfazva1Yf6/ua1Yff16w+1vc1q4/1fcXqO8W1Pmvy1hEbUuNoSmXrCGUyh6PtF0nFdbPBJBXXoAaTVFzPGUySFJNMO0nnWiSDtdtvBxtihaTiOsNgkoo9+2CSiv3vYJKKveRgkop92ViSXrPHGUtSs8cZS1KzxxlLUrPH+QnJH359vbHXf/QE7izc4Z94uMNt8XCHN+PhDifHwx2+j4U7wSXycIen5OEOB8rDHX6VhzuB+xXc53ijkeCaNasP765ZfVQQNKuPOoZm9VFNUax+QE1Hs/qoLGlWH/UtzeqjyqZZfYL6itVHrU+z+qj1aVYftT7N6qPWp1l91PoUqx9R69OsPmp9mtVHrU+z+qj1aVafoL5i9VHr06w+an2a1UetT7P6qPVpVh+1PsXqJ9T6NKuPWp9m9Qnqr6z+52/TJeT8K6vf2K08IefXrD5yfsXqZ+T8mtVHzq9Zfazva1Yf6/ua1Seor1h9rO9rVh/r+5rVF+73QwmbRCnbhvrBmfR1cHDHfezN12iLcH87eLTC/dzg0Qr3L4NHKzxfHzxaUjVa4fnY4NEKzz8Gj1b42trg0QpfSxo8Wk25VDKacqlkNOVSyWjKpZLRlEslQ6pGqymXSkZTLpXMUrkUFb+NNlD6NtpKt60pW6+te5V1vMlfbJbKvAazWSpPG8vGLpXVDWazVA44mM1SGeNgNkvll4PZENicslkqdx3MZqlMN+zrkCG60mDj91+mQzdy/O1D7QP/E+JSCfQHiM/RLpUSN0e7VJLbGq1bKm1tjnapRLQ52qVSy+Zol0oWm6MlVaNdKqFrjnapFC3SXozMyTdStGzTlr4+fvn7o2JPNktlXoPZLJWnDWazVFb3QzafPz6b/FI54GA2S2WMg9kslV8OZrNUNjqYDYHNKZulMt3BbDTnxS02mvPiFhvNeXGLDfLiUzakOC+eYrutRIqz80kUUuwRJlFIsVOZRCGCQsIVUuzaJlFIsXecRCHFDnYShRT76EkUUuzm51AooKYgXSHUFKQrhJqCdIVQU5CuEEEh4QqhpiBdIdQUpCuEmoJ0hVBTkK4QagrCFYqoKUhXCDUF6QqhpiBdIdQUpCtEUEi4QqgpSFcINQXpCqGmIFwh6R/g1qDQxw/lpoRcjluhz583SdI/ZA2FEnI56Qohl5OuEHI56QphfUi6QlgfEq6Q9I+TQyHpHxCHQtI/8g2F1vqw35QKebd1+lGWC+8KERQSrhBqCtIVQk2BXSHrd4Xce217rQ9VLqkQagrSFUJNQbZCea2PmC6pEGoK0hVCTUG6QqgpSFeIoJBwhVBTkK4QHKtwhaR/JDS5vP10SqahkI2Otn6kdPg8ta/9tLf713K8c6lxtHvt6eucTw2F5qj5ZemfQYX6l6pPUF+x+sKzJ6h/6bwvfLUH6l+qvvC8HOpfqr7wVSqof6n6wlfAoP6V6kv/KjfUv1R94St3UP9S9VHr06w+an2a1Seor1h9VHsUqy/9S+NXqm+M3TuSW0c/6O3qE9lZ1P9c55f+LXWof6n6irM+qO8J6q+sfmPeV7zCC/W94pwf6nvFK7xQ3yte4YX6XvEKL9QnxSu8UJ9Q69OsPmp9mtVHrU+z+qj2KFZf+tfff6Z+MmFXP5aGnjlvZKwxTfFXfJVH+oflIf6V4i+V80H8n4m/VMoH8X825xPE1yv+Uuk+xP+Z+Eut7UL8n4m/1NIuxP+Z+Eut7EL8n4m/1MIuxP+R+BEVPsXio8KnWHxU+BSLTxBfr/iKE7794G97rep5d0f6t+ah/YXaK0731GuvONtbX/vP831SvJyrXnuC9mq1V7yYq157xWu56rVXvJSrXnvFK7nqtUddT632GXU9vdqjrqdXe9R29Gov3OPFYLaadAzeH7V/9l+4T2n2X3iu3ey/8Hyx1f8iPOdp9l/4vN3sv/A1pWb/hc+dzf7T5P0XXp9u9n/y+bdMPv+WyeffMvf8W8zc828xc8+/xcw9/xYz9/xbzNzzbzFzz7/FzD3/FjP3/FvM3PNvMZPPv3by+ddOPv9a4fNvKGH7SFFMxf39Y+3VmVLc1u/H33k/3JX4NV7h8/Xw8Qqf34ePV3g+8KPxUipbPyj72miFZw+DRys81xg8WuGZyeDRCs9jxo5W+remB49WeI40eLQTZVTHRectI5T+Ndxm/2ny/k+UwVT7P1FOUu3/RFlGtf8T5Q3V/k+UCdT67yea26v9n2i2rvZf+luigTYPm+Jh84ZqtuH9dqynQ6fd11ClPzg3cKjCZ/WRQ5X+ytvAoUp/w2vgUKW/0DRwqNLf3xk4VOmvq4wb6lpfT/vRU9rBbM8wBzLfjn2S0fvuQouM3h07WmT0vvPQIkMgc0JG714ILTJ6dwpokdH7Hn2LjN63zFtk9L6D3SCj+FtyIW6fHQyH5y7qx5ILG0ZymQ5H2y+O+BbvHx0Z/UVGm8rX0dmW7zu9PrnjK7g83PH9WR7upJe7TdsyiXcutbj/bI/oJnfFX9xl5b6UD5qHu+aPUPxoB4sXdZ9qHLHD7xiO2FFlDEcCxyEcsYvrGI7YEXUMR+wuOoYjduocwxG7Xg7hiC/D/CbHoVUWfJOFhTq8Egd1OKsrqO/39ewOnX5RJ1BnoA7XxkEdHo+DOhwhB3X4Rw7qcJsM1PF1Axbq8KYc1OFNOajDm3JQJ1Bf9usVr244d9g97+vrFSXDIevVHj5dr/aoFujVHjULvdqjcqJWe+lfaoL2F2qPKpJe7VHL0qs9Kmp6tSdor1Z71PX0ao+6nl7tUdfTqz3qenq1R11PqfbJSP8CLLS/UHvU9fRqj7qeXu1R19OrPUF7tdqjrqdXe9T19GqPup5e7VHX06s96npqtbeo6+nVHnU9vdoTtF9X+/DSPsZ37ZHnr6t9ou1YlwK9a488X6/2yPPVau+Q5+vVHnm+Xu2xfq9Xe6zf69WeoL1a7bF+r1d7rN/r1V5vXa+4bYwlhMaxwaT9I73WHCPFfnHUWyMby1FvvWkoR6+3djOWo+I6SN4+NW6NaX0kNFj7AhliBaTiosJYkIod+liQBJBjQCr2jmNBKjZiY0EqflphLEjFS/9jQSpeRx8KkhQvSv8EpHvtru+c//69vcpPf/463wM7fBALdrgmFuzwWJdg//jBjwd2AnYO7PBvLNjh9liwwxuyYIeTZMEO38mBPcClsmCHS2XBDpfKgh0ulQU7AfsF2Od4BzrAKysWH45dsfioGygWH9ULxeKjhqJX/IhKjmLxUU9SLD6qWorFR21NsfgE8fWKjwqfYvFR4VMsPip8isVHhU+x+Kjw6RU/ocKnWHxU+BSLjwqfYvFR4VMsPkF8veKjwqdYfFT4FIuPCp9i8VHhUyw+Knx6xc+o8CkWHxU+xeITxF9Y/M/frMzI9hcWv/Fhg4xsX7H4yPb1il+Q7SsWH9m+YvGxnq9YfKznKxafIL5e8bGer1h8rOcrFn8pnx8d7eKnpp7FbEe7EnzjaDJmixUydAys52c1Ht1XS9IbY/eO5CZ3/7qOfHr/doA1S81GrCSXurWzklxqJYSV5FLLCqwk9c7dg0napQrerCSXqh6zklyqFMtKcqm65qUk3U6SyH4jWXG4jW2+rSVwZ+EO/8TDHW6Lhzu8GQ93ODke7vB9LNwdXCIPd3hKHu5woDzc4Vd5uBO4X8F9ihedrINr1qw+vLtm9VFB0Kw+6hia1Uc1RbH6HjUdzeqjsqRZfdS3NKuPKptm9QnqK1YftT7N6qPWp1l91Po0q49an2b1UetTrD6h1qdZfdT6NKuPWp9m9VHr06w+QX3F6qPWp1l91Po0q49an2b1UevTrD5qfYrVD6j1aVYftT7N6hPUX1n9j9+ssgE5/8rqf97P2Abk/JrVR86vWP2InF+z+sj5NauP9X3N6mN9X7P6BPUVq4/1fc3qY31fs/qKa33W5K0jj5pn42hKZesIZTKHo7++XhUV180Gk1RcgxpLMimu5wwmqbg2YtNO0rkWyWDt9tvBhlghqbjOMJikYs8+mCSB5CCSir3kYJKKfdlgkpo9zliSmj3OWJKaPc5Qklmzx/kJyR9+fb2113+GI+LhDv/Ewx1ui4c7gTsLdzg5Hu7wfTzc4RJ5uMNT8nCHA2XhXuBXebjDr17CfY43Ggtcs2b14d01q09QX7H6qGNoVh/VFM3qo6ajWX1UljSrj/qWXvWdQZVNs/qo9WlWH7U+zeqj1qdZfYL6itVHrU+z+qj1aVYftT7N6qPWp1l91PoUq29R69OsPmp9mtVHrU+z+qj1aVafoL5i9VHr06w+an2a1UetT7P6qPUpVt/B7y+t/sdv0zlHUH9h9T/vVv4IDqivWH3k/JrVR86vWX3k/JrVx/q+YvU91vc1qw+/r1l9rO9rVh/r+5rVF+73QwmbRCnbhvo+5V3PfOi2L+5rtML97eDRCvdzg0cr3L+MHS0Jz9cHj1Z4fjp4tMLzscGjFZ5/DB4tqRqt8LWkwaNVlUuRqlyKVOVSpCqXCqpyqaAqlwqqcqmgKpcKtNJoc6B9tMl8G22l29aUrdfWvco63uQvNktlXoPZLJWnDWazVFY3mM1SOeBgNktljGPZxKXyy8FslspGB7NZKncdzGapTDeX/afLcbRVNn7/ZTp0I8ffPtRS+oJISiA+R7tWStwa7VpJbmu0a6WtrdGulYi2RrtWatkYbVorWWyNdq30rzXatRK61miXStGK39JXMrGVomWbtvT18cvfHxV7siGwOWWzVJ42mM1SWd0P2Xz++KxLS+WAg9kslTEOZrNUfjmWTV4qGx3MZqncdTCbpTLdwWw058UtNgQ2p2w058UtNsiLz9kozovn2G4rK87OJ1FIsUeYQ6Gi2KlMopBivzSJQopd2yQKKfaOkyhEUEi4Qop99CQKKXbzkyiEmoJ0hVBTkK4QagqyFfIGNQXpCqGmIF0h1BSkK4SagnSFCAoJVwg1BekKoaYgXSHUFKQrhJqCdIVQUxCukEVNQbpCqClIVwg1BekKoaYgXSGCQsIVgh9iV+jjh3K9Qy7HrdDnz5t46R+yhkIOuZx0hZDLSVeIoJBwhbA+JF0hrA9JVwh+SLpCWB+SrhDWh4Qr5IlVId9SyOYdus2U96PJffU/TN7/OHn/0+T9z5P3v8zdf+YPi/71/tvJ++8m77+fvP+Tz780+fxLk8+/NPn8S5PPvzT5/Bsmn3/D5PNvmHz+DZPPv8wfdfzr/b99/vXWbxUFb4tp/Lbz+3aBzqf3Lcb9/V9HHD2ANPsA8uwDKJMP4P4v9o0egJ19AG72AfjZB0DSB+D2ARDZbwOoVP8bu+T6KH7eHjtc8bP82OGKzwnGDld8BjF2uOLzjaHDTeKzk7HDFZ/LjB2u+Mxn7HDF50ljh0u6hrtWVjXHi0NprdxuEuhrZZiTQF8rz50E+lrZ9hzQ81o5/yTQ13Iek0Bfy/9MAn0tFzYJdAL0+6HDkTJAhyNlgA5HygAdjpQBOhzp/dALHCkDdDhSBuhwpAzQ4UgZoBOg3w8djpQBOhwpA3Q4UgbocKQM0OFIb4dOBo6UATocKQN0OFIG6MjTr4D+cYttMsheLoD+eQ8yMshe7odukb0wQEf2wgAd2QsDdNTTGaAToN8PHXk6A3TU0xmgo57OAP1+R/ooR2zQ/xjex98O1m4bVAUbXo7aevs1gDL5AO7/7NboAdjZB+BmH4CffQA0+wDC7AOIsw8gyR6Ae20u8GiXWtlDYysCcsLn7dHDFT7LDx6uF54TjB6u8Axi9HCF5xujhys8Oxk9XNI1XOGZz+jhCs+TRg9XV1bl18qq5ngSxa+V280BndbKMCeBvlaeOwn0tbLtSaCvlfNPAp0A/X7oa/mfSaCv5cImgb6WF5wEOhwpA3Q40vuhBzhSBuhwpAzQ4UgZoMORMkAnQL8fOhwpA3Q4UgbocKQM0OFIGaDDkd4PPcKRMkCHI2WADkfKAB2OlAE6Afr90OFIGaAjT78C+ucNnhKylwugN95hTsheGKAje2GAToB+P3RkLwzQUU9ngI56OgN05OkM0FFPvx96Rj2dATqDIy3bwd4f9sn69dvPLtHdXSLjt98mE1px8Ono5wDC7AOIsgcQc9h2e4k52cMvP7uf5u5+nrv7RXj3i9lutbG49Ofu3/+lx7Hdt3N3383dfT9394XPvK3uC593W92XPus2ui991m10X/qs2+j+1LNuMFPPusFMPesGM/WsG8zUs24wU8+6wUw96wYz9awbzNSzbjBTz7rBzD3r2rlnXTv3rGvnnnWt+FmX9jJVCe/dFz/rfu6++Fn3c/fFz7qfuy9+1v3cffGz7sfuX/1JjOdJ8FjPr6MHr0Z6l7ZOex+OBz+h47EeBuh4rIcBOh7ruQK69Tt0F9+h47Ge+6Ev9rGKSaDjRRMG6HjRhAE6XjRhgE6Afj90OFIG6HCkDNDhSBmgwxzdD51hT34FH7Vu1F4Y9uQHdIY9+QGdYU9+DdAb9/QM6PdDL4B+O3SGPfkBnWFPfkBn2JMf0Bn25Ad0hj35AT3AkTJAhyNlgA5zdD/0+7cSdtlvQ/XG+sZvhxLyBibb14fXS22wvvjt4VAy8UXGl4kLNffvOwyFfqhQgELCFYpQSPg8lKCQcIUyFBKuUIFCshVKBgoJV8hCIeEKOSgkXCHUFKQrRFBIuEKoKUhXCI5VuEJZeKaQXN5+OiXTUMhGtylkU3oN1nqqrmykTXzvDhu01I9e8jXqLDwLgfqXqk9QX7H6wrMnqH/pvC98tQfqX6q+8Lwc6l+qvvBVKqh/qfrCV8Cg/pXqF+Gra1D/UvWFr9xB/UvVR61Ps/qo9WlWn6C+YvVR7dGrfjSKsz5j7N6R3Dp6xU1MolGc9UF9ozjrg/qGoP7K6jfmfcUrvFDfKM75ob5RvMIL9Y3iFV6obxSv8EJ9q3iFF+pb1Po0q49an2b1UevTrD6qPYrVd0tlfWn/dLpNsTT0zHkjY41pir/gqzzRLZX0Qfyfib9Uzgfxfyb+UikfxP/ZnE8QX6/4S6X7EP9n4i+1tgvxfyb+Uku7EP9n4i+1sgvxfyb+Ugu7EP9H4ntU+BSLjwqfYvFR4VMsPkF8veIrTvj2g3PyLe1XfHeHFOd76rVXnO6p115xtre+9p/ne1K8nKtee4L2arVXvJirXnvFa7nqtVe8lKtee8Urueq1R11PrfYBdT292qOup1d71Hb0an9/rhfM1nsXqLR+O5e9/8YvUkgPBdBvhx4NoN8P3QL67ff06AD9fuge0O+HToB+P/QA6PdDj4B+P/QE6PdDhyNlgA5Hej/0BEfKAB3m6H7ouQqdzFY7IPfquvW5hsWX7WNJluwLi38c/TyFv/4UdP0pwvWniNefIl1/inz9Kcrlp6h/8/b8FM9GtqeR62lUv6b8fl9IudKIft4o1T8JQWm7y9Jx78Rcvhqlnka5p1E1FILd5ozg/LdGtRWv10tgOdvD0c8z1PfGHnoGe/kZ3OVn8JefgS4/Q7j8DPHyM6TLz5AvP8Pl17S7/Jp2l1/T9f2cAm174AZK77fL+m4gIW2NIpn3RvWNBBpnqr+AHsI27YZIlUb1u0h2W6PiK42op1HoaRR7GqWeRrmnUeloVH9lNGSzN6roVH/XsNXI9TTynxtFUxtTPSJS2RvlSqNqRES70Yu+VBrFxplq11P9Ce7GRVh/9LfVqOdyrz90ZF3YBmVdrKAI1Ncs9DWLfc1SX7Pc16x0Nas/D9FuZvuaub5mJ1GS096suEozajerpPkx9DWLfc1SX7N6lHiz3UIef1ZuPPUKb7NZvUbZbmb7mrm+Zr6vGfU1C33NTnSLu9w+VWaZXCf5yvFsoMoVkE+QlP16IxMqzajdrHKZ5tDXLPY1S13NiulrVidJ+8OglrytNKO+ZnWSFM3eLFZuCiWfNHuNLb1PwtmcjC3soUzZV5pRX7PQ16weJVT273A8CuyVZqmvWe5rVrqa1cs+j6t71y24UGlm+5q5vk76vmbU1yz0NYs998lcr2S0m+W+ZqWrmXM9d67suu5c2VFfs9DVrF7IT/v9LsVva09/tKlXwEvc1qBKiu9tXEcb39GGOtrU0Rnab/oml/dWsatV6mqVu1qVjlbFmK5WtquV62rlu1pRV6vQ1Sp2tUpdrXJXq67YqE98H+8WpT7rlf2+VKjS5udXfqnPQI3zpI42uaNN+Xmbevn6MwNnO9q4jjZ1ffaC3benG7Y21NEmdLSJjfHU2qQOBrmjTfl5G98RB74jDnxHHPiO69RTR5vQ0SZ2tOmIg3rF2z402O6k5bB04gN9NfN9zaivWehrFpvNQq40S33Ncl+z0tXs5HV7Y7fFK2d8rDSzfc1cXzPf14z6moW+ZrGvWeprlvuala5msS9KYl+UxL4oiX1REvuiJPZFSeyLktgXJbEvSmJflKS+KEl9UZL6oiT1RUnqi5LUFyXpRLdAe7No35vlE5LJ7c1SZQ7Ivu9sJ0jy/iyHKaHSLPQ1i33NUl+z3NesdDUrpq/Zidyvp8hNqQRXcX3NfF8z6orJEvqaxb5mqa9Z7mtWOpplY0xfM9vXzPU1OxHgEXWvMCmvhr9Wl58NU2/D3NuwdDa0preh7W3oehv63obU2zD0NuyNHHvyBHZ5PU3ta81yX7PS1axex2o3s33NXF8z39esN1Zcb6y43lhxvXcZ13uXcb13Gd97l/G9dxnfe5fxvXcZ3xs59VJYM1J97GvWd4fxfXcY33eHob47DPXdYag3Vqg3Vqg3Vqj3LkO9dxnqvctQ712Geu8yofcuE/riJvTNTKFvZqpXANvN+u4uoe/uEvruLqE3VkJvrMTeWIm9M1LsvcvE3rtM7L3LxN67TOy9y8S+uIl9s1Lsm5VS36yU+u4uqe/ukvruLqk3VlJvrKTeWEm9M1Lqvcuk3rtM7r3L5N67TO69y+S+uMl9s1Lum5Vy36yU++4uue/ukvvuLqU3VkpvrJQf32Eqb+ST2R8jJfd6jNT79HUSf8dJ6I6T9N7pSu+drqS/PqyUtuWZdHhM5jWofP0pytWnsGdlM7M95kHJvh4D3gq89qxs1mpWH1B2/jWgSrOTslmzme1r5vqa1S/X/NrXIh+vjb0Z9TULfc1iX7PU1yz3NStdzbzpa2b7mrm+Zn1RUq89+dcGTf742KQ11e3ofT68g+Pj+23T1mtV409TbjlNvRY2/jT2ntO4e07j7zkN3XOacM9p4k9P82yW+prlvmalq1kwfc1sXzPX1+wkasntzQ4Pr7yaUV+z0Ncs9jVLfc1yX7PS1Syavma2r5nra9YXJfVqoC/7phdkTWrcRB6/8tod8fCGXH2/w2YiXa8z8nYpyutSktelLK9LRVyX6vVi3i5ZeV1y8rrk5XVJ3t07ybt7J3l37yTv7p3k3b2TvLt3ZrgvlbB36f3540eX7r/iWiWdfPEV9zxJuuMk+Y6TjIhzIVuUv7rhnP/zG7jZFqNnqFbPUJ2eoXo9QyU9Qw16hhr1DDXpGWrWM1Q12ZIzarIlZ9RkS86oyZacUZMtOUN6hqomW3JGTbbkjJpsyRk12ZIzerIlqydbsnqyJasnW7J6siWrJ1uyerIlqydbsivNq+E11BjfhuoWugOnfeNjlwK9D3WhO3BrqAvdgVtDXegO3BrqQnfg1lAX8qutoS7kV1tDXWhebQzVL+RXW0NdyK+2hrpQCuHd9pzXY1jhfaikZ6gLpRCtoS6UQnjr96G6d2fjF0ohWkNdKIVoDXWhFKIxVFoohWgNdaEUojXUhQouraGulC01hkp6hrpSttQYqp5siRhex/n87osL979Mme22IdTjz1Lp0v0vUza273HByeuSl9clktelIK9LUV6X7n+ZsvECnAtZXpeKuC5FI69LVl6XnLwueXldInldqt4EQgzbFochmcPn4399tvs9J3ttB+mNyd+O/uMk9S0ARp8k3HGSeMdJ0h0nuUX4csNJ6lsVjz6JveMk7o6T+DtOcscVn++44vMdV3y+44rPd1zx+Y4rvtxxxZc7rvhyxxVf7rjiyx1XfLnjii93XPHljiu+3HHFlxuueG/MHSexd5zE3XESf8dJ6I6ThDtOEu84SbrjJPmOk9xxxds7rnh7xxVv77ji7R1XvL3jird3XPH2jive3nHF2zuueHvHFe/uuOLdHVe8u+OKd3dc8e6OK97dccW7O654d8cV7+644t0dV7y/44r3d1zx/o4r3t9xxfs7rnh/xxXv77ji/R1XvL/jivd3XPF0xxVPd1zxdMcVT3dc8XTHFU93XPF0xxVPd1zxdMcVT3dc8eGOKz7cccWHO674cMcVH+644sMdV3y444oPd1zx4Y4rPtxxxcc7rvh4xxUf77ji4x1XfLzjio93XPHxjis+3nHF3/HolY93XPHpjis+3XHFpzuu+HTHFX/HM3f+jmfu/B3P3Pk7nrnzdzxz5+945s7f8cydv+OZO3/HM3f+jmfu/B3P3Pk7nrnzdzxz5+945s7f8cydv+OZO3/HM3f+jmfu/B3P3Pk7nrnzdzxz5+945s7f8cydv+OZO3/HM3f+jmfu6I5n7uiOZ+7ojmfu6I5n7sjQHScJd5wk3nGSdMdJ8h0nueOKv+OZO7rjmTu645k7uuOZO7rjmTu645k7uuOZO7rjmTu645k7uuOZO7rjmTu645k7uuOZO7rjmTu645k7uuOZO7rjmTu645k7uuOZO7rjmTu645k7GvHMnTdley3eO9s6Om0dSq8X6Ml/9caJ6o0X1RsS1ZsgqjdRVG+SqN5kUb0pknoz4iHHgb0RdS8mUfdiEnUvJlH3YhJ1LyZR92ISdS8mUfdiEnUvDqLuxfWH/Kz32yZN9rHovbfKsfLzj4zt61jKh65Q/jpDufoM9cf7hp7BXn4Gd/kZ/OVnoL98hvC6CmLtDOHyM8S/foZ979iQSuUM6fIz/PVrOpRN6Wh85Qzl6jMkM/IM1lbOYC8/g7v8DH/9mo7JbmfIpnIGuvwMf/2ajnnbgDAWqpwhXn6Gv35NJ7PN6Mnmyhny5WcoI89w2Ah7P0M2l5/BXn6Gv35Nv3bnzqYSS9lffoa/fk3nnVKuxVIOl5/hr1/T2W8bJD8K3ZUzpMvPkEeeIVTurblcfYZiLj/DX7+mi92OLbVrurjLz/DXr+nit1m0UCUTKHT5Gf76NV323LvEGqV4+RnSyDOkyr215MvPUC4+QzB//Zq2JmwWxZpoKuewN5yjfl0/Vpq3Zo/U8PM5vM3bObw9fErDRaqWZdKWrnuTX7OW/7Ui+X502j8c4tPhzvfr6Gf//eT9p8n7Hybvf5y8/2ny/ufJ+1/m7n/94dGJ+m8n7//k86+dfP61k8+/dvL5104+/9rJ5187+fxrJ59/3eTzr5t8/nWTz79u8vnXTT7/usnnXzf5/Osmn3/d5POvm3z+9ZPPv/7++XdfAvE2pEb/f/pRZrN/jzXZ9++xBu9UjdarGi2pGm1QNdqoarRJ1WizqtEWTaMlo2q0qnIpUpVLkapcilTlUqQqlyJVuRSpyqVIVS4V1ppv9wfKH3/GymiXuidnsz2ESI/DK6Od95787P+8d9ln/+e9bz77L/xO6Oyr/8E1rpZUaDs6leIbR/v9zUXyryePf11kb4e6Vzec8/548JOicLc6B8Uo3AVPQlH4bD8JReGufRKKwqsBk1AkUBxAUXimPAlF4fn6JBSFu4ZJKMK7jKAI7zKAYoJ3GUER3mUERXiXERThXUZQJFAcQBHeZQRFeJcRFOFdRlCEdxlBEd5lAMUM7zKCIrzLCIrwLiMowruMoEigOIAivMsIivAuIygiX/wtiuFF8bB15UaxYI7+HYqJtmNdCvROEXP0CIqYo0dQxBw9giLm6BEUUV8cQRH1xREUkS/+dYrRoL44giLqiyMoDvAu3uwUvaNvFJ/n8Decg244R7jhHPGGc6QbzpFvOEe5/hwj9qlunmPAncy5tJ/jsLtX/U6WbXp9wKekb3ebZ4+cuB55cT0icT0K4noUxfUoietRFtejcnuPPr+VG0fsVjy4R1Zcj5y4HnlxPSJxPQriehTF9SiJ61EW1yNx92x/+z17ijXX6C24VLk4cKly8eBS5ULgUuUSwKXKJYJLlUsClyqXDC5VLgVcalwI+W6dC/LdOhfku3UuyHfrXAhcqlyQ79a5IN+tc0G+W+eCfLfOBflulUtAvlvngny3zgX5bp0L8t06FwKXKhfku3UuyHfrXJDvVrlEtfnLx7dZY9Q6HzWelB+x6/SSXLTORy0uWuejFhet81GLi9b6S4uL1vpLg0vSmr+0uGitv7S4aK2/tLgMyHfJ71wo2wYXb/dv2HlLYT/a1n7aJtpeOrUpHg5OlYMfa4Rfxz6qSsdDnwMlLQMN6ww0b8fGw/W2DzQuNNDtIk2mouiAnJFseQ3UNQYajI1fRwdD6TjQZ4eytA4VYR0asYnq2A5ZaR1y0jrkpXWIpHUoSOtQlNYhaXfqLO1OnaXdqYu0O3WRdqcu0u7URdqduki7Uxdpd+oi7U5dpN2py913aiol7x0K5e8f3QyFsnlOimTee18m7n0yZure26l776buvZ+69zR178PUvY9T9z5N3fuJ5lr/3vuJ5tr33tuJ5tpK7yeaayu9n2iurfR+orm20vvR95zY6L2lfbXCks+fex8NbT8dTTGfD7aPI7ajH3+H+D7YomiwzmgarNU0WKdpsF7TYGnZwZb3wQZNg42aBps0DXbdDKoy2HUzqPfBnr2sb/LJYJ+tUler3NNK7esPfu+08z4cD35y0fr6Q4uL1tcfWly0vv7grd+5uPjORevrDy0uWl9/aHBR+/pDi4vW1x9aXLS+/tDiovV13xYXApcqF7X5boOL2ny3wQV5XZVLxucLB7ipjE+vj6CIT6+PoEigOOC+iE+vj6CIT6+PoIhPr4+giE+vj6CIT68PoFjw6fURFOFdRlCEdxlBEd5lBEUCxQEUheeLHz7Z+X40pbId/fjz1RMf6Gu0wvO6n4022/3h9WxLZbTC868fjtb5fbTevY02G+F50uDRCs9nBo9WeN4xeLTC84PBoxU+jw8erfBa4Q9Huz9++hi4qYxWeE1v8GiXyqWao10rl2qNdq1cqjFau1Yu1RrtWrlUa7Rr5VKt0VZnINqXRYkOG4iWXB3sa7dR9+3Y5wnS1SfIV5+gXHyC+ru2I09grz6Bu/oE/uoT0NUnCFef4Oor2V19JdffhSPr9hNQ4wRcXx7K9Tfbpui6N/N23c7bdTdv1/28Xad5ux7m7Xqct+tp3q7PO5v6eWdTmnc2pXlnU5p3NqV5Z1OadzaleWdTmnc2pXlnU5p3NqV5Z9Mw72wa5p1Nw7yzaZh3Ng3zzqZh3tk0SL6vf/yqd46C7zCfP9CYo+A7TKvrgu8wra4LvsO0ui74DtPquuB8vdV1wfl6q+uC7+utrgvO1xtdT4Lz9VbXBd/XP7+lnpPg+3qr64Lv662uC76vf36pJSfB9/VW1wXf11tdF3xfb3Q9C76vt7ou2CW1ui7YJbW6Lnk2bXRd8mza6Lrk2bTR9Xln05MNCOL+sJuNh1bep69mtq+ZazY7DOjVzPc1o75m1VnaZbvtR+5yPDyMXGoKZe+3o7M/fFu0frT1D9+09Yl8PGwpV+JXp4q8TpX6W5ncnbISO+UkdspL7BRJ7FSQ2KkosVPp2k49T5LvOEm54STW3HESe8dJ3B0n8XecZMgdaH/jKvvD8tfrJOGOk8Q7TpLuOEm+4yTlhpM4c8dJ7B0nGXHFPwzOdhKyrfkn27RNP9mW9M0lPbvk5XWJ5HUpyOtSlNelJK9LWV6Xyv1d+tmuUWbfsyPZ9z07ijezD8DOPgA3+wD87AOg2QcQZh9AnH0AafYB5NkHMPtMTLPPxDT7TEyzz8Q0+0xMs8/EJH4e+LyLbAnS70KNTZFKEHUXenZJ1H3l2SVRd4pnl+6/9oVsY/35NZcSAsDUwUSAqYNJAFMHkwGmDqYATBVMNABTB2MBpg7GAUwdjAeYOhgCmDoYZL4nYJD5noBB5nsCBpnvCRhkvnUwCZnvCRhkvidgkPmegEHmewKGAKYOBpnvCRhkvidgkPmegEHmewIGmW8dTEbmewIGme8JGFIL5uM+hyWrnZU+b1lVstpZqQVG7azUAFPUzkotMGpnpRYYtfWYFhi19ZgWGAKYOhi19ZgWGLX1mBaYaubrjdleKPWGcmOo1sZ9+6rH366Fxj3+72VTXtte+odleXYqX92p52nKDacppr7/0vjT2HtO4+45jb/nNHTPacI9p4n3nGbIPSME9zpNtq3b6edX3B+dyhI7VQR2yhqOTn18reLRKSuxU05ip7zETpHETgWJnYoSO5UkdipL7FQR2Ckn8Y7uOO7oM6zDPNA4oDlD44HmDA0BzRmaADRnaCLQnKFJQHOGJgPNGZoCNCdovAGaMzTIhk/RIBs+RYNs+BQNAc0ZGmTDp2iQDZ+iQTZ8igbZ8CkaZMNnaAjZ8CkaZMOnaJANn6JBNnyKhoDmDA2y4VM0yIZP0SAbPkWDbPgMTdCc13x6xe6BRvEM9fEZ7AcaxTNUC43iGaqFRvEM1UKjeIZqoVFcr2mgiYrrNS00ivOaFhrF9ZoWGsX1mhYaxTOUd9unUR4WKryjUTxDNdAkxTNUC43iGcrvL+w9KL0776R4hmqhUTxDtdAQ0JyhUVyvaaFRXK9poVFcr2mh0ZwNN9BozoY/o8mas+EGGqR8p2jUbpHUcFBZ7RZJLTBqNwdtgVG7OWjrHqN2c9AGGL2bg7bAqN0ctAVG7eagLTBqNwdtgSGAqYPRm/k2wOjNfBtg9Ga+DTDIfKtgrLk/j/mwD9X70ZTKdvTjz1f//WON/jkAJ3wA2dI2gGxLZQBe+gCc3wfgXWUANPsAwuwDiLMPIM0+gDz7AIr0AZi0D8CZ9wFYM/sApM/EzQGIn4lbAxA/E7cGIH4mbg1A/EzcGoD4mbgxgPrb7JTMPn0kW5k+6m96t5tRvVl0e7NkK81CX7OqOM2psf5mabtZrjdrCVC6mgXT18z2NXN9zXxfM+prFvqaxb5mqa/Zz6Pk749//H//8T/+5R//27/+8/96NPr1X//3v/33//yXf/+3r3/8z//vf27/5b/9x7/867/+y//4r//zP/79v//zP/3v//jn//qv//7ff/23v5mv//m/Un7UHlKO8dGhX+HwuIuVfyjWp8c/+z/+u7eP/07213//1SAYV/4hGE+//oX944jHHevxP/To26N//z8=",
      "brillig_names": [
        "is_contract_initialized"
      ]
    },
    {
      "name": "refund_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "is_solver",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/+xdB5gcxbGe016WjjvljE4SEoi4s3uRZGFyzjleJAkESCAJBVYggSQQCiiBRM4Zmww2YGxwhGcbg8E2xjbBAYMxwSQbXrc0vVtXVzM7e1t1mkbX31e3c9M9f1dXV1XH6SlwNoSCcsf5R4l3rSjm/fZSVI3umV94XUSk603cqyDuVRL3+hL3BimaiO6NItJVE/dGE/fGEPe2JO5N8H5hMP9P9H6T8bqamrb6RJubdJviicbmhtp4TW1zXYPb4NY21LYmGpLJtoaahvrG5sb6eKNbk2xz22sbk+3xDeHrXhmseF4h0SLJpxZKF/mswTc0b/0UFQJetRy+8q63cjLXE8C15uEr+Jz6v5eimKLCWOa+CTEkg3h+wd2aEasgxlc3RTE2vsi6KYpl6qAXuI6B60JUN8Xq/xJFpYrKiLrpxVw3WzLqenmMsZ6djD/RuNXCcihn1KveQnLo7cmhEMkAhgJmuRTwYcUJdrmwGylsdmfeh61iE82SfFYw8NnYVFPX3FjTTjm2PsCBVcToBgg3Opup/ysVVSnq2w2NzgRGrM0YnUM/4UanH6iPSnBdBa77orrpr/4foGigokFe3RQ6mU6dX5jIU45kUD755mH02AEyYuTd3crhd5DcPE5wZJw4N5/9Y7KNDXuvoTejYxgs1GsYDHoNvZzOjleiIqV6DbYoHDefvS3hM+YIGzB3T2kIo9FJ8jm0mxQgXz6HdZ3PBL5B9W6G+PQ2h4L7w1DvZrj6f4SikYo2B72b3k7naSpKJvH8gjucucdnwqiYIMOjQH9sIpNyaKHHHPuEXgT4rPbkMtr7HeP9jvV+t8CTvjqiFBW2F7NgGZtbd4zw+ARacDW4Hh3zHzuOU/+PV7Sloq26YezIqDzuOMYu4gThupkA6mA8uN4Sel1UN1ur/7dRtK2i7TaCdx3LIN+29vWhDfK7fUyQYQ3O5QQM89szKu0OjEorJUPNI1f3xchwB0u6WXE+Pmsk+XS7zmcS36AcVhw4Jk3memtw30UOK6H+TyqqUVQb64jXo6N8dV/Hx2eSqvs6UMdbgOtEQN3Xq/8bFDUq2rEbVtcGM/rRnYTmh3aKdV5d49aFnfl4T1C6sHMXhoW7qP93VfQtzdtG6LjsIjQs3C0myHAanFE5tND7ON2znDnAkXGeDg+frrmAsvi2J/Pd8dBSR/wR3dudsGbu4dGA/Cs/4VW++21GD7m7UMvIPVznLPMeRJm7ign1aA9Pt3LxiJxy4SiLCXvGBBneM+bfbegq/p6MTf1ewkM5DhnuFfP39F3F34vZGXCXe3ev3FxdToPLWd97M3dRjHPRuKOdTJcLdCrSYVNdktwlZgefnI3tEMDnPp4y7Ov97uf97u/9HuD9Huj9HuT9Huz9HuL9Hur9Hub9Hu79HuH9Hun9HuX9Hu39HuP9Huv9Huf9Hu/9nuD9nuj9nuT9nox7Z7oAKXRvf+LeAcS9A4l7BxH3DvYqAd7TAihF9w4jnj2CuHckce8o4t7RxL1jCF6OJXg5zuuhwnvHxzJzOObeCUS6E4l0JxHpTo517gV7m/XZDOC4XA3A9Y86PjcsNyjyhK4bZifcE7uKRXB4Uv4OI416MmMjd0o3Odx8+WzqMp9uqLnUU8BcyT7gel9w3YTmUJrV/y2KWhW1xeQX5vZj7Bg3M+pQu5AOcctvf0b5tTDK71RL5HcAo/xaGeV3GnNHHfuGduADTgXXp4HrNuQbTlf/n6HoTEWTusE3HMhYN6cz1s1Zluj2QYzyO4NRfmdbIr+DGeV3JqP8Jgv7hrOADzgbXE8G15OQbzhH/X+uovMUTekG33AIY92cw1g3Uy3R7UMZ5Xcuo/zOt0R+hzHK7zxG+V0g7BumAh9wPri+AFxPQb5hmvp/uqIZii7sBt9wOGPdTGOsm5mW6PYRjPKbzii/WZbI70hG+c1glN9sYd8wE/iAWeB6Nri+EPmGOer/i/Tco6K53eAbjmKsmzmMdXOxJbp9NKP8LmKU3yWWyO8YRvmlGOU3T9g3XAx8wCXgeh64not8w3z1/6WKLlO0oBt8w7GMdTOfsW4WCtfNQlAHl4Lry8D1AlQ3i9T/lyu6QtFiom6458qvZJOBWw/55FqsN+C7MNb7Er4yk/ttr4zRe62XxPz32y5V/y9TtFzRVbHMgn+R0z3b/aR2hHHzuZSRz2LA5wrP6a30fld5v6u93zWxzJ5ZHa5W/1+jaK2idYquVXSdousV3aDoRkU3KbpZ0S2KblV0m6LbFd2h6E5Fdym6W9E9iu5VdJ+i+xU9oOg7ir6r6EFFDyl6WNEjih5V9JiixxU9oehJRd9T9H1FTyl6WtEzMafjIq9mvtrp3k27K5mdqwk/iAky/IMYP+6zjJ5LqtzPxjICZsKNd6eyrRJSth/GBBn+oYCy/SjiyqbL/SPLlW21kLI9FxNk+DkBZXs+4sqmy/28gLJJ8PqsZxjc/fsfx+w0sjVCRvaTmCDDPxEwsp9G3Mh0uX9qiZFpZ/BjASP7mfBEwkowcFwFrtfE/E+C+Ln6/xeKXlD0YjdM8jC2iu7PGXX+/4Tr5v9AHfwCXL8Arl9EdfNL9f+vFP1a0Usx/xer8y27tsufCej7bxjrWpe9wumeNxtWCE1yOKx8JhrksDe8FGxkayYzXlZyeUXRbxW9qug1Rb9T9HtFf1D0uqI/KnpD0Z8U/VnRXxS9qegtRW8rekfRXxX9TdHfFf1D0buK/qnoPUXvK/qXog8U/VvRh4o+UvSxok8U/UfRp4o+U/S5oi8Ufanov3gy4+VY553trxD3fkvce5W49xpx73fEvd8T9/5A3HuduPdH4t4bxL0/Eff+TNz7C3HvTeLeW8S9t4l77xD3/krc+xtx7+/EvX8Q994l7v2TuPcece994t6/iHsfEPf+Tdz7kLj3EXHvY+LeJ8S9/xD3PiXufUbc+5y49wVx70vi3n9jGSdpwgTvd6L3G88vdHCa+TYcLzNgead7tL/Ch9X6Wz6sxlf5sNzX2LDa3N+xYbW4v2fDanD/wIYVd1/nwmqLu3/kwmqJu29wYTXE3T9xYSnb/jMTVpvC+gsTVovCepMJq0FhvcWEpX3h2zxYbRrrHR6sFo31Vx6sBo31Nx6s9W3H31mw2tZj/YMFq2U91rssWA3rsf7JgrWhrX2PA6ttA9b7HFgtG7D+xYHVsAHrAw4sr2/ybwasVg/rQwasZg/rIwaseg/r4/yx0mfIfJI/lmuw/pM3VkO7wfo0f6xmg/VZ/limv+p+njdWfRrri7yxatNYX+aN5aax/huTmRTBO4CiMHYwWP/jK/P6w8y5J6r0BOFvYvwTd18x1zX3Li+9q+ZlxrrR9fyVgBy/tkCOnDr+spAc9cw3lxw1b52++RcDCySF4U47LFAXvRTFFBUWyp16qnePvSIg071LZRfh8uVvfZkL+XH3KZVpxwqZ672gkK/MRXz24zLqjWtLXVzD2KcoLpSx4SjZBeVji4BfLQ7pY0vURamiMkXlgj5W7879rYCP3TfiPlaXuUTAx+5niV2XMNpib0Yfy6g3ri11sZbRx/YplLHhKNkF5WN7A7/aJ6SPrVAXmymqVFQl6GP12w+vCvjY/SPuY3WZKwR87AGW2HUFoy32ZfSxjHrj2lIX6xh9bL9CGRuOkl1QPrYv8Kv9QvrY/upigKKBigYJ+lj9dtlrAj72wIj7WF3m/gI+9iBL7Lo/oy0OZvSxjHrj2lIX1zL62CGFMjYcJbugfOxg4FeHhPSxQ9XFMEXDFY0Q9LH67d3fCfjYgyPuY3WZhwr42EMsseuhjLY4ktHHMuqNa0tdXMfoYzcvlLHhKNkF5WNHAr+6eUgfO0pdVCsarWiMoI/VpyP8XsDHHhpxH6vLPErAxx5miV2PYrTFsYw+llFvXFvq4npGH7tFoYwNR8kuKB87FvjVLUL62HHqYryiLRVtJehjb4hl3kuCuPnK9PCI+1hd5nECPvYIS+x6HKMtTmD0sYx649pSFzcw+titC2VsOEp2QfnYCcCvbh3Sx26jLrZVtJ2i7QV9rD7d63UBH3tkxH2sLvM2Aj72KEvsehtGW9yB0ccy6o1rS13cyOhj44UyNhwlu6B87A7Ar8ZD+lh9YkNCUVJRjaCP1acn/lHAxx4dcR+ry+wK+NhjLLFrl9EWaxl9LKPeuLbUxU2MPrauUMaGo2QXlI+tBX61LqSPrVcXDYoaFe0o6GP16bRvCPjYYyPuY3WZ6wV87HGW2HU9oy3uxOhjGfXGtaUubmb0sTsXythwlOyC8rE7Ab+6c0gfu4u62FXRt7TMBH2sPv37TwI+9viI+1hd5l0EfOwJltj1Loy2uBujj2XUG9eWuriF0cd+u1DGhqNkF5SP3Q341W+H9LG7q4s9FO2paC9BH6u/rvBnAR97YsR9rC7z7gI+9iRL7Hp3Rlvcm9HHMuqNa0td3MroY/cplLHhKNkF5WP3Bn51n5A+dl91sZ+i/RUdIOhj9ddr/iLgY0+OuI/VZd5XwMeeYold78toiwcy+lhGvXFtqYvbGH3sQYUyNhwlu6B87IHArx4U0scerC4OUXSoosMEfaz+OtibAj62KeI+Vpf5YAEf22yJXR/MuceH0ccy6o1rS13czuhjjyiUseEo2QXlYw8HfvWIkD72SHVxlKKjFR0j6GP11xffEvCxLRH3sbrMRwr42FZL7PpIzrURRh/LqDeuLXVxB6OPPa5QxoajZBeUjz0W+NXjQvrY49XFCYpOVHSSoI/VX7d9W8DHtkXcx+oyHy/gY9stsevjOceUjD6WUW9cW+riTkYfe0qhjA1HyS4oH3sy8KunhPSxTeqiWVGLolZBH6u/Hv6OgI89NeI+Vpe5ScDHnmaJXTdx2iKjj2XUG9eWuriL0ce2F8rYcJTsgvKxbcCvtof0saeqi9MUna7oDEEfe3cs8x08iJuvTE+PuI/VZT5VwMeeYYldn8poi2cy+lhGvXFtqYu7GX3spEIZG46SXVA+9kzgVyeF9LFnqYuzFU1WdI6gj70nlvmuKMTN2+4i7mN1mc8S8LGTLLHrsxht8VxGH8uoN64tdXEPo489r1DGhqNkF5SPPRf41fNC+tgp6mKqovMVXSDoY++NZb7TDHHzlelZEfexusxTBHzs2ZbY9RRGW5zG6GMZ9ca1pS7uZfSx0wtlbDhKdkH52GnAr04P6WNnqIsLFc1UNEvQx94Xy3z3HuLmK9PJEfexuswzBHzsOZbY9QxGW5zN6GMZ9ca1pS7uY/SxcwplbDhKdkH52NnAr84J6WMvUhcpRXMVXSzoY+9X+b4r4GPPjbiP1WW+SMDHnmeJXV/EaIuXMPpYRr1xbamL+xl97LxCGRuOkl1QPvYS4FfnhfSx89XFpYouU7RA0Mc+oPL9p4CPnRJxH6vLPF/Ax061xK7nM9riQkYfy6g3ri118QCjj11UKGPDUbILyscuBH51UUgfe7m6uELRYkVXCvrY76h83xPwsedH3MfqMl8u4GMvsMSuL2e0xSWMPpZRb1xb6uI7jD52aaGMDUfJLigfuwT41aUhfewydbFc0VWKVgj62O+qfN8X8LHTIu5jdZmXCfjY6ZbY9TJGW1zJ6GMZ9ca1pS6+y+hjVxXK2HCU7ILysSuBX10V0seuVhdrFF2t6BpBH/ugyvdfAj52RsR9rC7zagEfe6Eldr2a0RbXMvpYRr1xbamLBxl97LpCGRuOkl1QPnYt8KvrQvrYa9XFdYquV3SDoI99SOX7gYCPnRlxH6vLfK2Aj51liV1fy2iLNzL6WEa9cW2pi4cYfexNhTI2HCW7oHzsjcCv3hTSx96sLm5RdKui2wR97MMq338L+NjZEfexusw3C/jYObacvc9oi7cz+lhGvXFtqYuHGX3sHYUyNhwlu6B87O3Ar94R0sfeqS7uUnS3onsEfewjKt8PBXzsRRH3sbrMdwr42JQt55Aw2uK9jD6WUW9cW+riEUYfe1+hjA1HyS4oH3sv8Kv3hfSx96uLBxR9R9F3BX3soyrfjwR87NyI+1hd5vsFfOzFtuzJZLTFBxl9LKPeuLbUxaOMPvahQhkbjpJdUD72QeBXHwrpYx9WF48oelTRY4I+9jGV78cCPvaSiPtYXeaHBXzsPFvGp4y2+Dijj2XUG9eWuniM0cc+UShjw1GyC8rHPg786hMhfeyT6uJ7ir6v6ClBH/u4yvcTAR87P+I+Vpf5SQEfe6kldv0koy0+zehjGfXGtaUuHmf0sc8UythwlOyC8rFPA7/6TEgf+wN18ayiHyr6kaCPfULl+x8BH3tZxH2sLvMPBHzsAkvs+geMtvgco49l1BvXlrp4gtHHPl8oY8NRsgvKxz4H/OrzIX3sj9XFTxT9VNHPBH3skyrfTwV87MKI+1hd5h8L+NhFltj1jxlt8eeMPpZRb1xb6uJJRh/7i0IZG46SXVA+9ufAr/4ipI99QV28qOj/FP1S0Md+T+X7mYCPvTziPlaX+QUBH3uFJXb9AqMt/orRxzLqjWtLXXyP0cf+ulDGhqNkF5SP/RXwq78O6WNfUhe/UfSyolcEfez3Vb6fC/jYxRH3sbrMLwn42CstseuXGG3xt4w+llFvXFvq4vuMPvbVQhkbjpJdUD72t8CvvhrSx76mLn6n6PeK/iDoY59S+X4h4GOXRNzH6jK/JuBjl1pi168x2uLrjD6WUW9cW+riKUYf+8dCGRuOkl1QPvZ14Ff/GNLHvqEu/qToz4r+Iuhjn1b5fingY5dF3MfqMr8h4GOXW2LXbzDa4puMPpZRb1xb6uJpRh/7VqGMDUfJLigf+ybwq2+F9LFvq4t3FP1V0d8EfewzKt//CvjYqyLuY3WZ3xbwsSssseu3GW3x74w+llFvXFvq4hlGH/uPQhkbjpJdUD7278Cv/iOkj31XXfxT0XuK3gc+1oRezPVc5fDJ891CGd2OMZd5KaNur2TE+hej/LTe9HYybQkM3O01J9+Q3w8KBRn+oJAf99+Mjk6q3P8GHoUJd72yFTsZ5ySpbNB443kGST5XxmSM4kOgt/ynuTD2mjRvMY9Hw7RWlBKne7wSZwVAxf7IM6CPdZkkKuBDAc/0IXPTLFXuXoLlzvvVGmEZxvMLrlbMTwSGj/9hbt6NU9C4KQ+XWxYfC8niUyFZfBogi7yPNhCSxaqNO53SkoU/MR1YXRptP6Abvk8EfCljfbucMtTtsYIje59OjjLIplMQU8J/c8kEdrA+C+oxxvML7idCDhEynSPPbrZ8NM+fCTiGNRGZ28ulI5P3/rbCaDqYNaUyevk5aKi7Wj/ZZM5ZP18ALDeZVLbRWu+2t7Yna+sbE81uXbKurr2mvb6uoaa1vbamqbW+za1pSiYa2+rj7W5DW1t9bbKlvq69sbWlrh06bbc1maxpbWxucWsTdU3N8YbWZFO8vaY+mYg3tSbrW1uTDXV1Tclka11De0NjQyLR1J5siNfW1zfG6xLJxoRU/Xzh1U93jjSXCo00v/QU67+2OHAp/r4UcNb/E2q4/ic4qtGy+K+ALL4SksVXgqMaKb24JuKjGikdWBvxUc1SoVENY327a3tGNTi4XwqNar62cVTztfCo5msBx7BuExzVOEXRdDDrhHrNurwpp2OI8qimoIhvVLOWcVQjVT8FRZlRjV+jEOXpKEk+pRqYXkUWNjCQaYkGBuIb3HyN+VqhBqaImU9OBxYriuQ6DGtjda2QM4yFaKzylWlhEV+j0GHaLEKNlVT9FBZ9c6bgijwnUlxEbPaI5xdcv00PnLt48v72COP8vkTFGxnGLJFhvlglRdGuD20wJQKdhNIiGWdVWiQ3XVssJIsyIVmUFclN10rpxQ0Rn66V0oEbLZiu1eXmnq5lrG/3xp7pWhzW+28umcCOX7nkaLpEyCGWC46mNc/lAo7hJkuma0sYR8C9i6LpYG4SGmH17obpWs766cM4XXsj4whYqn76bIQRsNTrDhXeCHgzWxy4FH8VAs66UqjhqhQc1WhZbCYgiyohWVQJjmqk9OKWiI9qpHTgVgu21kuMahjr2721Z1SDg1shNKrpa+Oopq/wqKavgGO4bRMc1fQriqaDuU2o19zPslFNf8ZRza2Moxqp+um/ETahFBXJ2L0tDcwAGxuYAcINzACBBuZ2SzahcDqwgYxYnNNmnI3V7ULOcGA3bEIZxLgJ5cbSaDZWUvUziKgf7j0CjJtO3NWM50gNZvTr3XmO1GChRnRIkSDDQ4r4cYcyOmapcg8tygiYCbdbz5Fabck5Upw726BRDCsSPEdqKOPQFXp1w/Q3YWvhcM+ARhQJnCOlK2CYgGcaJrxQw1XuXoLlzpfHkRFf7NKKOVJgiLW50HBzc8HFrhFCshglJItRgotdUnpxV8QXu6R04G4LtvCNFPCljPXt3t2z2IXDev/NJRPYwaqWnIscKeQQqwXnIjXP1QKO4R5LFrtGMnaKRhdF08HcIzQ/NbobFrs462cM42LX3Yzzh1L1M2YjbOFbLTTSHOuNNLewxYFL8TdWwFmPE2q4xgmOarQsthCQxXghWYwXHNVI6cV9ER/VSOnA/REf1awWGtUw1rd7f8+oBgd3rNCoZksbRzVbCo9qthRwDA9sgqOarYqi6WAeEOo1b2XZqGYC46jmfsZRjVT9TNgIW/iGF8nYvS0NzNY2NjBbCzcwWws0MN+xZAsfpwPbhhGLc9qMs7H6jpAz3KYbtvBty7iF7+7SaDZWUvWz7TdoCm47z4lsT232iOcXXL9ND5y7ePLFYtw4InJukZEh9x5RKRnmi7VDxOtDG8wOAp2EuFCHKS44Xbu9kCxcIVm4gtO1UnrxUMSna6V04GELpmt3EJiuZaxv9+Ge6Voc1vtvLpnAjl9CcjS9g5BDTAiOpjXPCQHH8Igl07U7MHaKkkXRdDCPCI2wkt0wXctZPzWM07UPM46ApeqnZiOMgKVed6j1RsB1tjhwKf5qBZx1vVDDVS84qtGyqBOQRYOQLBoERzVSevFYxEc1UjrwuAVb6yVGNYz17T7eM6rBwa0VGtU02jiqaRQe1TQKOIYnNsFRzY5F0XQwTwj1mne0bFSzE+Oo5nHGUY1U/ey0ETahbFckY/e2NDA729jA7CzcwOws0MA8ackmFE4HtgsjFue0GWdj9aSQM9ylGzah7Mq4CeXh0mg2VlL1s6vgDMjzKpOfxvh90LeEZ8E4fM+3iL0W8fwCZzvkfovRp02MeH2sP1NQoC3cjXmPCff+Jj0Lw8njSg/P4dVrkRmoVR6v3HX+bUZd786z574t1PHevUiQ4d2L+HH3YHR8UuXeYxM3sj2FRrPcDpZTl/aKeGOySNU1J4+6jvfqJj3Pt+zHxzbYJPdyBqf+7G1pw3SC0PmP+xQJMryPQMO0b8QbJl3ufS1pmLTB7i3QMO0X8f0Xun72E3BUezPq5v4RHy2eaIGzP8BSZ3+SkLM/sEiQ4QMFnP1BEXf2utwHWeLstcEeIODsD464s9f1c7CAozqAUTcPibgM94nZM9re1yJe97OI1/0t4vUAi3g90CJeD7KI14Mt4vUQi3g91CJeD7OI18Mt4vUIi3g90iJej7KI16Mt4vUYi3g91iJej7OIVz05t7/A+PfQiI/ddP0cKlDuPSJebj0+P0Sg3IdZUN+HbYL1fbKQL9ITv30cen8695zS7oyffzw5/0nk9PZpouhs2FCuh3v1d0SRpyBm/+XhnkLDezpRNWIq1xc8sjEpVSFdxEqYt9sOZ5x8PKKIV1EkJq4PF3BoR0Z8hW13r9zc+2M5dZpTD49i3DYD/cRRwE9IOGxOGZzs4XHv/d89xtvQcmFxyu5oRiyoP0cD/ZHYMnW4wOLU8Yw2fowFOxEkZHgiowyPZZYhc1mTJyI/Fs8vrF8Y12Xmfl+No+1qa18f2k4U8on58sXpE4/jq9OEA0Iv5nrlLPPxzFuE2SfNFH/HC/RnT2B+d8G0fyd47R81EOb2Q1oPjme0S9126R2ZXOf5Ghs9/ptr72Ysl3SIwITdYdB/otdInIQH/ScSg/6TAjpj8fzC+q27xwgY5nPRPoYoebzQANsp5y23CVyDI5uMOe8BjVBdMHXw0hNbJzKW+STGjgCjDbuMduEy1Gva4Ydp4Dnsg3twSjXw8fxCkrETkuQcWHF06DdURXurQwQmXerQwJ/sOYlTcAN/MtHAn0LM6nM7mZMZncwpRTIdBc7GNwqNB1Q69veYijKdRQY9SZe7qUim0eQePXPqc3PER8+6TpoFZvuaGGXYEvGlcl3WFgF7aS1i6yi0d+f7Vq3MMycmtBUJMtxWxI/bzmgEUuVuL8oImAlX5uVaj1duIzs14ssxptzsS1qMunlaxJdjjmdejjEzW5vKNOjpfLJLUvXLsfTEvdx2ZJHMdDxXnZwRbZtbP7Jm9K2u9jGnC/j/MxnlaOvexuMs3Ns4yeu3nIVnQSYRsyBnWba38TjGvY2TGJ3OWUW8isL+0pfi7wwBJ/GLiH/5QnfmzhQo9wsROdg/S2C1vbMZGy1GvXFfiLgOaj9ztoAOThbahzFZcB+i9t+TBPYaHxfjrS+u8p4jtFf0HMva7XM3Ed9hAvfMO6dOnhfxmXetK+cJ+MspQv5ySsC+NT99iOcX3OMiZpveZHo7UXSRQc5Ub5BzPh7kTCUGOed3g7OUqpB8BzlTGR3H+YyKkouxRGAUb4J7Lt9AzyWKLmIsF3jGMg0bywWEsUwLYSxRrZB8jeUCRmOZxqwo3K2sbmGnCrSy0y3Zy8BZ1zMi3qPSdTJDYKlsOqMML4z4XgZd1gsF7GWmpXsZZgrtZZhVJMjwLIG9DLMjvpdBl3t2UUbATLgivJ7n8cptZHMivpfBlJvbQZ/HqJsXdVPDHs8vsI7EUsy2zV1W3fll1G1X13FKwP7mMjcW/ZzMoET/X6fq/Cvveisncz0U3B/mXZvnLlY8XaJonqL5RRvud2cDerFQA3ppkSDDlwo0oJdFvAHV5b7MkgZ0giPDqzGOmNM5cJehwJFpaKJswJJ8Mp7JEh8C+Fzg6dlC73eR93u593uF97vY+73S+13i/S71fpd5v8u936u83xXe70rvd5X3u9r7XeP9Xu39XuP9rvV+13m/13q/13m/1wMfJmKATFgdFhm0kFNOx6m6y4l7VxD3FhP3riTuLfEUGt7TlVSK7i0nnl1B3FtJ3FtF3FtN3FtD8HI1wcs13nQlvLeWmNZcR6S7lkh3HZHueu8eDCUOr95ck6szCfjk+NrcsAI/Xr6u606uE+61XcUiOLyOb3o1fj1jB+QG4Z6uxjc92gXgeiG4bkI93RtV3E2KblZ0S1HmvgncmzEWMY5IbmSsm1uFGmxu+V3OKL+bGOV3myXyu4JRfjczyu92Yd9wK/ABt4Hr28H1LUUdfcMd6v87Fd2l6O5u8A2LGevmDsa6uccS3b6SUX53MsrvXkvkt4RRfncxyu8+Yd9wD/AB94Lr+8D13cg33K/+f0DRdxR9txt8w1LGurmfsW4etES3lzHK7wFG+T1kifyWM8rvO4zye1jYNzwIfMBD4PphcP1d5BseUf8/qugxRY93g2+4irFuHmGsmycs0e0VjPJ7lFF+T1oiv5WM8nuMUX7fE/YNTwAf8CS4/h64fhz5hu+r/59S9LSiZ7rBN6xirJvvM9bNDyzR7dWM8nuKUX7PWiK/NYzye5pRfj8U9g0/AD7gWXD9Q3D9DPINP1L/P6foeUU/7gbfcDVj3fyIsW5+Ilw3PwF18By4fh5c/xjVzU/V/z9T9HNFvyDqhnv3ysWM8nyBTZ5ukpLnlWAniSZz/QKQp4vm3V9Ucf+n6JeKflWU2WFS5NDvPUR54VeSzxcZbaEY8Pnrog2/L3m/v/F+X/Z+XynK7BjS4bfq/1cVvabod4p+r+gPil5X9EdFbyj6k6I/K/qLojcVvaXobUXvKPqror8p+ruifyh6V9E/Fb2n6H1F/1L0gaJ/K/pQ0UeKPlb0iaL/KPpU0WeKPlf0haIvFf1X0f+0jhVZuGitBVztdO+2qpeYHasJXxcJMvx1ET+uUxztbVXrrRKYKxNuvDuV7TdCylZQLMiwBufG7RVxZdPl7mW5sr0spGyxYkGGYwLKVhhxZdPlLhRQNgletQfuVcy/47uo2E4je0XIyIqLBRkuFjCykogbmS53iSVGpp1BkYCRlRZHu9y6fkoFyl1WzGukeLD/EhjU/wZcvwKuHTTYL1c89VbUR1FFsfzEFmNvwC1ntPXNhOtG45s66A2u+4DriuKOdVOp/q9S1FdRv+KOeJx6qcfRWje5J8omMPLYn7lhrnA6vhXC7UP0JM4EgM/Fu0MEHuxEgxx2PFEA5GwmrgaoOh2oaJCiwYqGKBqqaJii4YpGKBqpaHNFoxRVKxqtaIyisYq2UDRO0XhFWyraStEERVsr2kbRtoq2U7S9oh0U6Vk2V1FCUVJRjaJaRXWK6hU1KGpUtKOinYqdjrvpBxR33nU/kLg3iLg3mLg3hLg3lLg3jLg3nLg3grg3kri3OXFvFHGvmrg3mrg3hrg3lri3BXFvHHFvPHFvS+LeVsS9CcS9rYl72xD3tiXubUfc2564twNxL07cc4l7CeJekrhXQ9yrJe7VEffqiXsNxL1G4t6OxL2dQOeI23Fqp6md51YIN98GZABDZ8EcWDGQD6t1EB9W42A+LHcIG1abO5QNq8UdxobV4A5nw4q7I7iw2uLuSC6slri7ORdWQ9wdxYWl7LyaCatNYY1mwmpRWGOYsBoU1lgmLO0Xt+DBatNY43iwWjTWeB6sBo21JQ/W+nZkKxastg1tEgtWy3qsrVmwGtZjbcOCtaHd3ZYDq20D1nYcWC0bsLbnwGrYgLUDB5bXT4kzYLV6WC4DVrOHlWDAqvewkvljpQ8prMkfyzVYtXljNbQbrLr8sZoNVn3+WKa/6jbkjVWfxmrMG6s2jbVj3lhuGmsnxkkdjSExFhlQzD/htrNwuTkmBAdEfEJwl4jrjp687S+gO7syl5u7jvVuNEb9dnU97yogx29ZIEdGHXd3FpLjREY5at7wwomuJ7NAMrE43Blpu6l031a0u6I9iv0XTuL5hfX+bKCATPe0oH0YGPH2Ya+I27fesctYz67W+b0EdHFvC+S4F7Mc9xSQ4z7CfnJv4Bv3Cekn91Xp9lO0v6IDhP3kIAGZHmiBnxwUcT95UMTtW7/VwFjPrtb5gwR08WAL5HgQsxwPFJDjIcJ+8mDgGw8J6ScPVekOU3S4oiOE/eRgAZkeaYGfHBxxP3lUxO1bv/nFWM+u1vmjBHTxaAvkeBSzHI8UkOMxwn7yaOAbjwnpJ49V6Y5TdLyiE4T95BABmZ5ogZ8cEnE/eVLE7Vu/HctYz67W+ZMEdPFkC+R4ErMcTxSQ4ynCfvJk4BtPCeknm1S6ZkUtilqF/eRQAZm2WeAnh0bcT7ZH3L71CQKM9exqnW8X0MVTLZBjO7Mc2wTkeJqwnzwV+MbTQvrJ01W6MxSdqWiSsJ8cJiDTsyzwk8Mi7ifPjrh961NWGOvZ1Tp/toAuTrZAjmczy/EsATmeI+wnJwPfeE5IP3muSneeoimKpgr7yeECMj3fAj85POJ+8oKI27c+iYqxnl2t8xcI6OI0C+R4AbMczxeQ43RhPzkN+MbpIf3kDJXuQkUzFc0S9pMjBGQ62wI/OSLifnJOxO1bn9bHWM+u1vk5Arp4kQVynMMsx9kCckwJ+8mLgG9MhfSTc1W6ixVdomiesJ8cKSDT+Rb4yZER95OXRty+9YmmjPXsap2/VEAXL7NAjpcyy3G+gBwXCPvJy4BvXBDSTy5U6RYpulzRFcJ+cnMBmS62wE9uHnE/eWXE7Vuf+sxYz67W+SsFdHGJBXK8klmOiwXkuFTYTy4BvnFpSD+5TKVbrugqRSuE/eQoAZmutMBPjoq4n1wVcfvWJ+Mz1rOrdX6VgC6utkCOq5jluFJAjmuE/eRq4BvXhPSTV6t01yhaq2idsJ+sFpDptRb4yeqI+8nrIm7f+ushjPXsap2/TkAXr7dAjtcxy/FaATneIOwnrwe+8YaQfvJGle4mRTcrukXYT44WkOmtFvjJ0RH3k7dF3L71F5YY69nVOn+bgC7eboEcb2OW460CcrxD2E/eDnzjHSH95J0q3V2K7lZ0j7CfHCMg03st8JNjIu4n74u4feuv0DHWs6t1/j4BXbzfAjnexyzHewXk+ICwn7wf+MYHQvrJ76h031X0oKKHhP3kWAGZPmyBnxwbcT/5SMTtW3+pk7GeXa3zjwjo4qMWyPERZjk+LCDHx4T95KPANz4W0k8+rtI9oehJRd8T9pNbCMj0+xb4yS0i7iefirh9668ZM9azq3X+KQFdfNoCOT7FLMfvC8jxGWE/+TTwjc+E9JM/UOmeVfRDRT8S9pPjBGT6nAV+clzE/eTzEbdv/cV3xnp2tc4/L6CLP7ZAjs8zy/E5ATn+RNhP/hj4xp+E9JM/Vel+pujnin4h7CfHC8j0BQv85PiI+8kXI27ff1f2zVjPrtb5FwV08f8skOOLzHJ8QUCOvxT2k/8HfOMvQ/rJX6l0v1b0kqLfCPvJLQVk+rIFfnLLiPvJVyJu3/9Q9s1Yz67W+VcEdPG3FsjxFWY5viwgx1eF/eRvgW98NaSffE2l+52i3yv6g7Cf3EpApq9b4Ce3irif/GPE7ftdZd+M9exqnf+jgC6+YYEc/8gsx9cF5PgnYT/5BvCNfwrpJ/+s0v1F0ZuK3hL2kxMEZPq2BX5yQsT95DsRt+9/KvtmrGdX6/w7Arr4Vwvk+A6zHN8WkOPfhP3kX4Fv/FtIP/l3le4fit5V9E9hP7m1gEzfs8BPbh1xP/l+xO37PWXfjPXsap1/X0AX/2WBHN9nluN7AnL8QNhP/gv4xg9C+sl/q3QfKvpI0cfCfnIbAZl+YoGf3CbifvI/Ebfv95V9M9azq3X+PwK6+KkFcvwPsxw/EZDjZ8J+8lPgGz8L6Sc/V+m+UPSlov8K+8ltBWT6Pwv85LYR95NfRdy+/6Xsm7GeXa3zXwno4tcWyPErZjn+T0COTomsn/wa+EadVxg/WaDS9VIUU1RYIusntxOQaVFJ9P3kdhH3k8Ul0bbvD5R9M9azq3Vel5m7rksskGMxsxyLBORYKuwnS4BvLA3pJ8tUunJFvRX1EfaT2wv4yQoL/OT2EfeTm0Xcvv+t7Juxnl2t85sJ2HelBXLcjFmOFQJyrBL2k5XAN1aF9JN9Vbp+ivorGiDsJ3cQ8JMDLfCTO0TcTw6KuH1/qOybsZ5drfODBOx7sAVyHMQsx4ECchwi7CcHA984JKSfHKrSDVM0XNEIYT8ZF/CTIy3wk/GI+8nNI27fHyn7ZqxnV+v85gL2PcoCOW7OLMeRAnKsFvaTo4BvrA7pJ0erdGMUjVW0hbCfdAX85DgL/KQbcT85PuL2/bGyb8Z6drXOjxew7y0tkON4ZjmOE5DjVsJ+ckvgG7cK6ScnqHRbK9pG0bbCfjIh4Ce3s8BPJiLuJ7ePuH1/ouybsZ5drfPbC9j3DhbIcXtmOW4nIMe4sJ/cAfjGeEg/6ap0CUVJRTXCfjIp4CdrLfCTyYj7ybqI2/d/lH0z1rOrdb5OwL7rLZBjHbMcawXk2CDsJ+uBb2wI6ScbVbodFe2kaGdhP1kj4Cd3scBP1kTcT+4acfv+VNk3Yz27Wud3FbDvb1kgx12Z5biLgBwnCvvJbwHfODGkn9xNpfu2ot0V7SHsJ2sF/OSeFvjJ2oj7yb0ibt+fKftmrGdX6/xeAva9twVy3ItZjnsKyHEfYT+5N/CN+4T0k/uqdPsp2l/RAcJ+sk7ATx5ogZ+si7ifPCji9v25sm/Gena1zh8kYN8HWyDHg5jleKCAHA8R9pMHA994SEg/eahKd5iiwxUdIewn6wX85JEW+Mn6iPvJoyJu318o+2asZ1fr/FEC9n20BXI8ilmORwrI8RhhP3k08I3HhPSTx6p0xyk6XtEJwn6yQcBPnmiBn2yIuJ88KeL2/aWyb8Z6drXOnyRg3ydbIMeTmOV4ooAcTxH2kycD33hKSD/ZpNI1K2pR1CrsJxsF/GSbBX6yMeJ+sj3i9v1fZd+M9exqnW8XsO9TLZBjO7Mc2wTkeJqwnzwV+MbTQvrJ01W6MxSdqWiSsJ/cUcBPnmWBn9wx4n7y7Ijb9/+UfTPWs6t1/mwB+55sgRzPZpbjWQJyPEfYT04GvvGckH7yXJXuPEVTFE0V9pM7CfjJ8y3wkztF3E9eEHH7/krZN2M9u1rnLxCw72kWyPECZjmeLyDH6cJ+chrwjdND+skZKt2FimYqmgX8JHcdVSkMTtue4PHu8PIZd0CIMcvgxSK+8r/EiDWbUS+1/vR2MrYDA3fbO5vZnkyYUyLI8JwSftyLSviUQarcFwkYq1Y21QdJOytJZYPGG88zSPL5UpGMUaS03nK3iFopJjgyvXJOIcQ8HlPAeCV61FoeUe5Rz2VuKUqc7mkpOI0COpuLPad2CWUc8fyCq4WdEuricPOq+Zwr0GWeVxLtcmsFmCdQ7vklMg5M46YcGSO7REgWlwrJ4tIAWeTLs5ReLCzbqNNCLVn4E9OBRWXR9gO6gZkn0Hgz1rfLKUPdeJc6dM/byVEG2XQKYkr4by6ZwI7MZcAG2JmeJ+QQLwvo3WaBcbPlo3m+TMAxXM7sGEwozLHOcunI5FvmBSXRdDCcdQH1cgFoqLtaP9lkzlk/CwGWm0wq22itd9tb25O19Y2JZrcuWVfXXtNeX9dQ09peW9PUWt/m1jQlE41t9fF2t6Gtrb422VJf197Y2lLXDp2225pM1rQ2Nre4tYm6puZ4Q2uyKd5eU59MxJtak/WtrcmGurqmZLK1rqG9obEhkWhqTzbEa+vrG+N1iWRjQqp+Fnr1050juheFRnSLvAHX5bY4cCn+Fgk46yuEGq4rBEc1WhaXC8hisZAsFguOaqT0YnHERzVSOnBlxEc1LwqNahjr272yZ1SDg7tIaFRzpY2jmiuFRzVXCjiGJZvgqGZJSTQdzBKhXvMSy0Y1SxlHNVcyjmqk6mcpGNX4NQpRno6S5FOqgVlmYwOzTLiBWSbQwCwVamCKmPnkdGDLOad4yqLZWC0VcobLQzRW+cr0qhK+RqHDtFmEGiup+rnqGzQFt8KbglspsePIb6NCPL/gzmVuuaXK3Uuw3PnyuCri06JaMVcJNMarhTomqwWnRVcKyWKNkCzWCE6LSunFVRGfFpXSgRUWTIuuEvCljPXtruiZFsVhvf/mkgnsYF0tOWpdJeQQrxYctWqerxZwDCstmRZdxdgpuqYkmg5mpdBI5ppumBblrJ+1jNOiKxhHmlL1s3YjjDSltu+v80aa19riwKX4WyfgrK8TariuExzVaFlcKyCL64Vkcb3gqEZKL1ZHfFQjpQNrLNjCLjGqYaxvd03PqAYHd53QqOYGG0c1NwiPam4QcAxXb4KjmhtLoulgrhbqNd9o2ajmJsZRzRrGUY1U/dy0ETZ7rCiRsXtbGpibbWxgbhZuYG4WaGCusWSzB6cDu4URi3PajLOxukbIGd7SDZs9bmXc7LGiLJqNlVT93ErUT4y5fhg3d7gvM55VdRujX+/Os6puE2pEby8RZPh2gY0ydzA6Zqly31GSETATbreeVfWyJWdVvSh0VtWdEjvHtFJMEBCC1FlVdwb0VDnOqrqjJNpnVd3F3FLYvq3ybs+p3UMZRzy/4Gph3yngNSUErPm8S2CYdW/EF/q0AtwrUO77hIba9wku9N0jJIv7hWRxv+BCn5ReXBvxhT4pHbjOgu2L9wo03oz17V7Xs9CHw3r/zSUT2JF5QHIe9l4hh/iA4Dys5vkBiV0gliz03cs4RP9OSTQdzPVCc3Pf6YaFPs76+S7jQt91jHOnUvXz3Y2wffFloRHdg96A6yFbHLgUfw8KOOuHhRquhwVHNVoWDwnI4hEhWTwiOKqR0osbIz6qkdKBmyI+qnlZaFTDWN/uTT2jGhzcB4VGNY/aOKp5VHhU86iAY7h5ExzVPFYSTQdzs1Cv+THLRjWPM45qbmIc1UjVz+MbYfvi3SUydm9LA/OEjQ3ME8INzBMCDcwtlmxf5HRgTzJicU6bcTZWtwg5wye7Yfvi9xi3L15XFs3GSqp+vvcNmoL7vjcF95TEjiO/jQrx/IJ7F3PLLVXuXoLlzpfHpyM+LaoV82mBxvgZoY7JM4LTok8JyeIHQrL4geC0qJRe3B7xaVEpHbjDgmnRpwV8KWN9u3f0TIvisN5/c8kEdrCelRy1Pi3kEJ8VHLVqnp8VcAx3WjIt+jRjp+iHJdF0MHcKjWR+2A3Topz18yPGadE7GEeaUvXzo40w0pTavv+cN9J83hYHLsXfcwLO+sdCDdePBUc1WhbPC8jiJ0Ky+IngqEZKL+6O+KhGSgfusWALu8SohrG+3Xt6RjU4uM8JjWp+auOo5qfCo5qfSrzjtgmOan5WEk0Hc69Qr/lnlo1qfs44qrmHcVQjVT8/3wibPb5fImP3tjQwv7CxgfmFcAPzC4EG5j5LNntwOrAXGLE4p804G6v7hJzhC92w2eNFxs0ed5RFs7GSqp8XBWdACovVtF4xvw/6v4jvj9C+R/MYY5YnYzvk/h+jT/tlxGcl9bmFvxRoC38VcT2coDB+VRLtU4B+zSzDXswy1DNZjDyuP8X9195SAWOdiNjNbzxeufXyJcY6784zAl8SGrz8pkSQ4d8IbFB8mbHxkCr3y5u4kb1iQeP0csQbp99GvHH6qdIdRh5drTO/tcRujP5w6+WrQjNp3HW/lvHQ3tcYdUiirnWdvCZQ17+ztCOyTuhc1t+XCDL8e4GOyB8i3hHR5f6DJQ5VO5TfCRjZ6xGfHdD187pAR+R3jLr5x4h35q5VuvOqgAxfZZThG5Y6++uEnP2fSgQZ/pOAs/9zxJ29LvefLXH22mDfEHD2f4m4s9f18xcBR/UGo26+GXEZLvCcvQ16vtAiXhdZxOvlFvF6hUW8LraI1yst4nWJRbwutYjXZRbxutwiXq+yiNcVFvG60iJeV1nE62qLeF1jEa9XW8TrNRbxqifn/igw/n0r4mM3XT9vWbBqxl1uPT5/U6Dcb1tQ329vgvV9vZAv0hO/fRz6nQ7uOaXdY3z1dX3+k8jpVw6IorNhQ7m+49XfX0s8BTF7lt/xFBre04mqEVO5vhSVjUmpCukiVsK8EfoO4+TjX0t4FUVi28c7Ag7tbxF3aHrC/m8C5f57N213iecXWG3vH8LbXTi2xr0T8a1x70bcXnQdvytgL/8Uehfwn6D94q533da8W8JrPxKyfU9Itu8B2UrsmpGQxfsWtEcS5f5XRLfctrWvD23XIluK5xfWbxrQZebuqzL0LyXayySnH/og4jaiy/qBgI38W8hP/tvzk9Qgl7lNWq8HnNuOtb/Uuy25Zf0B83gIBy5sWFcfegPnj/DA+UNi4PyRYOOoK+R9AQN4PNrHXyVfE+ogPWHJ4Qsf5O/k05MbHzI2GB8xOhxGHXQZ6jXtCMI473w7Qdh5c3R2Kecdzy+4Njrvjz3n/Ql23h8TzvsTYtaziIe5NJOcxvwxo9J8UiLToETASYvOoGrj/VCgcfpPN80k5ssnpw5+KjyTGM8vuLpOPhWYSfwPoww/i/goTpf1MwF7+byErUFu7873UT5nHn2a8EWJIMNflPDjfsloBFLl/rIkI2AmXLFG6UsBI/uvsHPhWEb5UsBBc06z/U+oYY8xy/Krb+7oLh00hsSUNuPy9/op7b/z63Tyb4w6/bXwMkM8v7B+0MXou1xtw18J+Fd9wC2XHG3dW3WNhXurCko9uepfOKOgI/Asg05UjZiK8t6qaxj3VhWU8vHVq5RXUbg7YdrBfi3gJH4Q8a9V6M6SU8pf7mcjchh/lsBqezG+BsFl1Bv32YjroN6bVSCgg4Wl0S631pdCgXIXMZYbtoVFRFvI3Tm5hnHvRjFj+0XVP8deR6333DLk3OtYEnEb0nVcImBDpUI2VGpZf7Ksp03rEn9aJ8sE9LJcSC/LS/33P5nA7ac4/XMZ8/gCBy5sKNfe3kC0Dx6I9iYGon26wXFIVUi+A9HejHz1YVSUXIyFszMTzy+4NhpLhWcsm2FjqSCMZbMQxhLVCsnXWCoYjWWziM/a6Fa2t0ArW8nc6zWB2ylw1nUVoz5L1LWukyqB0VIlowz7Rny0pMvaV8Be+jHIcGPs5+jH3Js2oX+pIMP9S/lxBwhPlcTzC+vLPaA0I2AmXLFGaYCAkQ0Udi4cU0UDBBx0CaNuDmKWocSQeBBzx3KggC4OFl775h7ZTlLTymfzHSbtnqew5jJOVetlgFgpry0O5vOX3T7aG+LxPhSP9oYQo72hpXKvcRnF4Tag5yI+f2kUnLvcz5dFuxGTWpP7ccTLbRwGN+5PhPYBFPPwmZ41GcLofIcyNuCMfsJltD2XUZ/dnwi/NcSxTjsk4uu0w4RmrLg3Kg//5tuG2B6ZIQL+eYQlejOyVKYtjlr7xu1jtF/gtDmtLyMF9HDziE9u2LBXZ1TEZ5+l9vlVR3xSR3+IhbFu1h/mXy0gx9GWrHpx2swY5lUvbt3ZVzWk5zFOXB2m8CYJjOvHRtwGFzHb4FVCNrhFxOW4H7M+Hi6kj+MiLkftwxj9rav92FgBfRzPvELaz8lM7uv/v1aC/cq7ro5lrnW+5tr17pvntlRxWymaoGjr0g33NamueHrcQYWJPOVIrH8vDGFz95WqY/xtMTeP44X6C9x8binBp1a4cidz5JDjyDiJLZidxDihVXQc8sVuaKyvbWiusU8xBPjcKWYHnzE+rA6rgdt4OrstXg3cplT+jaRtGGeetmM0ZiiH7Qg5cFfutpaMDlnr3rGjzAWc9WxJmXsxlnk7S8rM6GDd7bupzPH8grsDo/yKLWlI444dfLqW8JmwhM8ko65rDIkByXDG/pDG21xgVaWGUY7DIz6TtLXyaTswvvGrsepj/HzWMtbJ1jE72q46xjIPtqTtqnfs4LPBEj4bLeFzR0v43MkSPne2hM9dLOFzV0v4/JYlfE60hM/dLOHz25bwubslfO5hCZ97WsLnXpbwubclfO5jCZ/7WsLnfpbwub8lfB5gCZ8HWsLnQZbwebAlfB5iCZ+HWsLnYZbwebglfB4hxGeU146P7KYyx/ML7lGM8iu3ZF72aMcOPo+xhM9jLeHzOEv4PN4SPk+whM8TLeHzJEv4PNkSPk+xhM8mS/hstoTPFkv4bLWEzzZL+Gy3hM9TLeHzNEv4PN0SPs+whM8zLeFzkiV8nmUJn2dbwudkS/g8xxI+z7WEz/Ms4XOKJXxOtYTP8y3h8wJL+JxmCZ/TLeFzhiV8XmgJnzMt4XOWJXzOtoTPOZbweZElfKYs4XOuJXxebAmfl1jC5zxL+JxvCZ+XWsLnZZbwucASPhdawuciS/i83BI+r7CEz8WW8HmlJXwusYTPpZbwucwSPpdbwudVlvC5whI+V1rC5ypL+FxtCZ9rLOHzakv4vMYSPtdawuc6S/i81hI+r7OEz+st4fMGS/i80RI+b7KEz5st4fMWS/i81RI+b7OEz9st4fMOS/i80xI+77KEz7st4fMeS/i81xI+77OEz/st4fMBS/j8jiV8ftcSPh+0hM+HLOHzYUv4fMQSPh+1hM/HLOHzcUv4fMISPp+0hM/vWcLn9y3h8ylL+HzaEj6fsYTPH1jC57OW8PlDS/j8kSV8PmcJn89bwuePLeHzJ5bw+VNL+PyZJXz+3BI+f2EJny9YwueLlvD5f5bw+UtL+PyVJXz+2hI+X7KEz99YwufLlvD5iiV8/tYSPl+1hM/XLOHzd5bw+XtL+PyDJXy+bgmff7SEzzcs4fNPlvD5Z0v4/IslfL5pCZ9vWcLn25bw+Y4lfP7VEj7/Zgmff7eEz39Ywue7lvD5T0v4fM8SPt+3hM9/WcLnB5bw+W9L+PzQEj4/soTPjy3h8xNL+PyPJXx+agmfn1nC5+eW8PmFJXx+aQmf/7WEz/9ZwudXlvD5tSV8akAb+CywhM9elvAZs4TPQkv4LLKEz2JL+CyxhM9SS/gss4TPckv47G0Jn30s4bPCEj43s4TPSkv4rLKEz76W8NnPEj77W8LnACE+eyE+o/Rd+oHMZeYu6wSFsUUpH94YhTWulF93Blmi44ML8pdlXV1DU31Niyup4zHGMg/pJruO5xfcoQV88tuy1A59HGZJ3QxnrJudYnaUeQRjmbexRB9HWuLHN7eEz1GW8FltCZ+jLeFzjCV8jrWEzy0s4XOcJXyOt4TPLS3hcytL+JxgCZ9bW8LnNpbwua0lfG5nCZ/bW8LnDpbwGbeET9cSPhOW8Jm0hM8aS/istYTPOkv4rLeEzwZL+Gy0hM8dLeFzJ0v43HkTXFvcZRMs866WlJlzfe1blqzhTGRcz+hvyRrOboxl7h2zw9d+25I2YXdL+NzDEj73tITPvSzhc29L+NzHEj73tYTP/Szhc39L+DzAEj4PtITPgyzh82BL+DzEEj4PtYTPwyzh83BL+DzCEj6PtITPoyzh82hL+DzGEj6PtYTP4yzh83hL+DzBEj5PtITPkyzh82RL+DzFEj6bLOGz2RI+Wyzhs9USPtss4bPdEj5PtYTP0yzh83RL+DzDEj7PtITPSZbweZYlfJ5tCZ+TLeHzHEv4PNcSPs+zhM8plvA51RI+z7eEzwss4XOaJXxOt4TPGZbweaElfM60hM9ZlvA52xI+51jC50WW8JmyhM+5lvB5sSV8XmIJn/Ms4XO+JXxeagmfl1nC5wJL+FxoCZ+LLOHzckv4vMISPhdbwueVlvC5xBI+l1rC5zJL+FxuCZ9XWcLnCkv4XGkJn6ss4XO1JXyusYTPqy3h8xpL+FxrCZ/rLOHzWkv4vM4SPq+3hM8bLOHzRkv4vMkSPm+2hM9bLOHzVkv4vM0SPm+3hM87LOHzTkv4vMsSPu+2hM97LOHzXkv4vM8SPu+3hM8HLOHzO5bw+V1L+HzQEj4fsoTPhy3h8xFL+HzUEj4fs4TPxy3h8wlL+HzSEj6/Zwmf37eEz6cs4fNpS/h8xhI+f2AJn89awucPLeHzR5bw+ZwlfD5vCZ8/toTPn1jC508t4fNnlvD5c0v4/IUlfL5gCZ8vWsLn/1nC5y8t4fNXlvD5a0v4fMkSPn9jCZ8vW8LnK5bw+VtL+HzVEj5fs4TP31nC5+8t4fMPlvD5uiV8/tESPt+whM8/WcLnny3h8y+W8PmmJXy+ZQmfb1vC5zuW8PlXS/j8myV8/t0SPv9hCZ/vWsLnPy3h8z1L+HzfEj7/ZQmfH1jC578t4fNDS/j8yBI+P7aEz08s4fM/lvD5qSV8fmYJn59bwucXlvD5pSV8/tcSPv9nCZ9fWcLn15bw6fSyg88CS/jsZQmfMUv4LLSEzyJL+Cy2hM8SS/gstYTPMkv4LLeEz96W8NnHEj4rLOFzM0v4rLSEzypL+OxrCZ/9LOGzvyV8DrCEz4GW8DnIEj4HW8LnEEv4HGoJn8Ms4XO4JXyOsITPkZbwubklfI6yhM9qS/gcbQmfYyzhc6wlfG5hCZ/jLOFzvCV8bmkJn1tZwucES/jc2hI+t7GEz20t4XM7S/jc3hI+d7CEz7glfLqW8JmwhM+kJXzWWMJnrSV81lnCZ70lfDZYwmejJXzuaAmfO1nC586W8LmLJXzuagmf37KEz4mW8LmbJXx+2xI+d7eEzz0s4XNPS/jcyxI+97aEz30s4XNfS/jczxI+97eEzwMs4fNAS/g8yBI+D7aEz0Ms4fNQS/g8zBI+D7eEzyMs4fNIS/g8yhI+j7aEz2Ms4fNYS/g8zhI+j7eEzxMs4fNES/g8yRI+T7aEz1Ms4bPJEj6bLeGzxRI+Wy3hs80SPtst4fNUS/g8zRI+T7eEzzMs4fNMS/icZAmfZ1nC59mW8DnZEj7PsYTPcy3h8zxL+JxiCZ9TLeHzfEv4vMASPqdZwud0S/icYQmfF1rC50xL+JxlCZ+zLeFzjiV8XmQJnylL+JxrCZ8XW8LnJZbwOc8SPudbwuellvB5mSV8LrCEz4WW8LnIEj4vt4TPKyzhc7ElfF5pCZ9LLOFzqSV8LrOEz+WW8HmVJXyusITPlZbwucoSPldbwucaS/i82hI+r7GEz7WW8LnOEj6vtYTP6yzh83pL+LzBEj5vtITPmyzh82ZL+LzFEj5vtYTP2yzh83ZL+LzDEj7vtITPuyzh825L+LzHEj7vtYTP+yzh835L+HzAEj6/Ywmf37WEzwct4fMhS/h82BI+H7GEz0ct4fMxS/h83BI+n7CEzyct4fN7lvD5fUv4fMoSPp+2hM9nLOHzB5bw+awlfP7QEj5/ZAmfz1nC5/OW8PljS/j8iSV8/tQSPn9mCZ8/t4TPX1jC5wuW8PmiJXz+nyV8/tISPn9lCZ+/toTPlyzh8zeW8PmyJXy+Ygmfv7WEz1ct4fM1IT57IT6T8bqamrb6RJubdJviicbmhtp4TW1zXYPb4NY21LYmGpLJtoaahvrG5sb6eKNbk2xz22sbk+0e9paMZf5dN5U5nl9wf9+LT37bldpRz4WM8vuDJbpdxFjm1y0pczFjmf9oSZlLGMv8hiVlLmUs858sKXMZY5n/bEmZyxnL/BdLytybscxvWlLmPoxlfsuSMlcwlvltS8q8GWOZ37GkzJWMZf6rJWWuYizz3ywpc1/GMv/dkjL3YyzzPywpc3/GMr9rSZkHMJb5n5aUeSBjmd+zpMyDGMv8viVlHsxY5n9ZUuYhjGX+wJIyD2Us878tKfMwxjJ/aEmZhzOW+SNLyjyCscwfW1LmkYxl/sSSMm/OWOb/WFLmUYxl/tSSMlczlvkzS8o8mrHMn1tS5jGMZf7CkjKPZSzzl5aUeQvGMv/XkjKPYyzz/ywp83jGMn/FWOaYs2GPz2+8Am+jaFtF2ynaXtEOOg9FrqKEloOiGkW1iuoU1StqUNSoaEdFOynaWdEuinZV9C2v3Lsp+rai3RXtoWhPRXsp2lvRPor2VbSfov0VHaDoQEUHKTpY0SGKDlV0mKLDFR2h6EhFRyk6WtExio5VdJyi4xWdoOhERScpOlnRKYqaFDUralHUqqhNUbuiUxWdpuh0RWcoOlPRJEVnKTpb0WRF5yg6V9F5iqYomqrofEUXKJqmaLqiGYouVDRT0SxFsxXNUXSRopSiuYouVnSJonmK5iu6VNFlihYoWqhokaLLFV2haLGiKxUtUbRU0TJFyxVdpWiFopWKVilarWiNoqsVXaNoraJ1iq5VdJ2i6xXdoOhGRTcpulnRLYpuVXSbotsV3aHoTkV3Kbpb0T2K7lV0n6L7FT2g6DuKvqvoQUUPKXpY0SOKHlX0mKLHFT2h6ElF31P0fUVPKXpa0TOKfqDoWUU/VPQjRc8pel7RjxX9RNFPFf1M0c8V/ULRC4peVPR/in6p6FeKfq3oJUW/UfSyolcU/VbRq4peU/Q7Rb9X9AdFryv6o6I3FP1J0Z8V/UXRm4reUvS2oncU/VXR3xT9XdE/FL2r6J+K3lP0vqJ/KfpA0b8VfajoI0UfK/pE0X8UfaroM0WfK/pC0ZeK/qvof4q+UvS1Im1gBYp6KYopKlRUpKhYUYmiUkVlisoV9VbUR1GFos0UVSqqUtRXUT9F/RUNUDRQ0SBFgxUNUTRU0TBFwxWNUDRS0eaKRimqVjRa0RhFYxVtoWicovGKtlS0laIJirZWtI2ibRVtp2h7RTsoiityFSUUJRXVKKpVVKeoXlGDokZFOyraSdHOinZRtKuibymaqGg3Rd9WtLuiPRTtqWgvRXsr2kfRvor2U7S/ogMUHajoIEUHKzpE0aGKDlN0uKIjFB2p6ChFRys6RtGxio5TdLyiExSdqOgkRScrOkVRk6JmRS2KWhW1KWpXdKqi0xSdrugMRWcqmqToLEVnK5qs6BxF5yo6T9EURVMVna/oAkXTFE1XNEPRhYpmKpqlaLaiOYouUpRSNFfRxYouUTRP0XxFlyq6TNECRQsVLVJ0uaIrFC1WdKWiJYqWKlqmaLmiqxStULRS0SpFqxWtUXS1omsUrVW0TtG1iq5TdL2iGxTdqOgmRTcrukXRrYpuU3S7ojsU3anoLkV3K7pH0b2K7lN0v6IHFH1H0XcVPajoIUUPK3pE0aOKHlP0uKInFD2p6HuKvq/oKUVPK3pG0Q8UPavoh4p+pOg5Rc8r+rGinyj6qaKfKfq5ol8oekHRi4r+T9EvFf1K0a8VvaToN4peVvSKot8qelXRa4p+p+j3iv6g6HVFf1T0hqI/Kfqzor8oelPRW4reVvSOor8q+puivyv6h6J3Ff1T0XuK3lf0L0UfKPq3og8VfaToY0WfKPqPok8Vfaboc0VfKPpS0X8V/U/RV4q+VqQ7EwWKeimKKSpUVKSoWFGJolJFZYrKFfVW1EdRhaLNFFUqqlLUV1E/Rf0VDVA0UNEgRYMVDVE0VNEwRcMVjVA0UtHmikYpqlY0WtEYRWMVbaFonKLxirZUtJWiCYq2VrSNom0Vbadoe0U7KIorchUlFCUV1SiqVVSnqF5Rg6JGRTsq2knRzop2UbSrom/pvoqi3RR9W9HuivZQtKeivRTtrWgfRfsq2k/R/ooOUHSgooMUHazoEEWHKjpM0eGKjlB0pKKjFB2t6BhFxyo6TtHxivS35vV33PU30vX3x09RpL+brb9Jrb/3rL+lrL9TrL8BrL+vq79dq78Lq7+5qr9nqr8Vqr/Dqb9xqb8fqb/NqL97qL8pqL/Xp7+Fp78zp7/hpr+Ppr89pr/rpb+Zpb9Hpb/1pL+jpL9RpL//k1Kkv1ujvwmjv7eiv2WivxOiv8Ghv2+hvx2hv8ugv3mgvyegz+rX5+DrM+b1+e36bHR97rg+01ufl63PotbnPOszlPX5xPrsX32urj6zVp8Hq89a1eeY6jNC9fmbNyjS50bqMxn1eYf6LEF9Tp8+A0+fL6fPbtPnoukzx/R5XvqsLH0OlT7jSZ+fpM8m0uf+6DN19Hk1+iwYfc6KPsNEnw+iz97Q51roMyP0eQz6rAN9joB+R1+///6MIv3etn4nWr9vrN/l1e/J6ndQ9fud+t1J/V6ifudPv0+n31XT74Hpd6z0+0v63SD93o1+p0W/L6L7qvo9B/0Ogd6fr/e+633lep+13sOs9+Hqfal6n6bet/gnRXpfm97npfc96X1Ael+M3iei903ofQR6XV2vM+t1V70Oqdfl9DqVXrfR6xh6Xl/Pc+t5Xz0PqucF9TyZnjfS8yh6XkGPs/W4U4/D9LhE99N7bWj+Hb3PWIdtnEzwXIMT8+L1vly9T1Xv29T7GPW+Pr3PTe/70vug9L4gvU9G7xvR+yj0vgK9zq7XnfU6rF6X1Ot0et1Kr+PodQ09z6/nvfU8sJ4X1fOEet6sWtFoRWMU6XG3HofqcZkep+i971spmqBoa6dzWA2uB3i/A9/abei5P7t9T5huUEDcqIC48d7vtf0uSG15tq7NTJjg/b458NC1c3pv9RWMqw/A3CkAU7fTOszcY5fkVa/edRGMW+DFXX/n5g8Pf6vXcTBuUUDc8oC4FQFxqwPirg6IuzEg7uaAuDsC4u4KiLsvIO6BgLjHAuKeCIj7fkDc0wFxPw6I+2lA3IsBcb8MiPtdQNwfAuLeCoh7JyDu7wFx7wbEfRQQ90lA3BcBcf8NiDMTKlRcr4C48oC4PgFxlQFxfQPihgbEDQ+Iqw6IGxMQN96Le+K5mV/e+NozZ8K47by4Jxue2+/V2ysHwbgdvbgXDlv7m6P6TauCcTsFxO0cELdLQNyuAXHfCoibGBC3W0DctwPidg+I2yMgbs+AuL0C4vYOiNsnIG7fgLj9AuL2D4g7ICDuoIC4QwLiDg2IO8aLo9rU47y43f/3h70fWH7pVjDulIDnUgFxFwdgXhrw3HVeHNW+vxLb8Eu173/24ijbfDMg7t2AuPcC4j4IiPswIO6LgLj/BsQVFPrHxQLiSgLiygLi+gbE9Q+IGxQQNyQgrjogbkxA3JYBcRMC4moC4uoC4nYNiJsYELd7QNyeAXEHBsQdHBB3REDcUQFxxwXEnRAQ1xoQ1x4Qd3pA3JkBcVMC4s4PiLswIG5WQNxcL45q3xd4cVT7vtqLo3zymoC4qwPirgmIWxsQty4g7tqAuOsC4q4PiLshIO7GgLibAuJuDoi7JSDu1oC42wLibg+IuyMg7s6AuLsD4u4NiLsvIO4xL45qU5/w4qi2+OmA594IiHszAPOdgOf6F9Fxm3m/D47e8Fvm/W86AHpIopvHid7/8fyCWwZwufEb4k1pfEeG/2QZwBTATxj8Qhn89e8063B9qiO+g/Kt8P4vALI0z5g42Em8wYsr9eLN9RzvugzhSdQ75Ilbbv0J/nuBsumwe0oi70SLwd/Dw3c6YLvJhrpkoqEukWhtize11tW3Nybr48nm2mRjS7MbT9YmGlrrm5LxeFuyraUm3lrXWNva1tRYm2xvbmqsM9h7ktjJtmYFVdtU19DstjfVtceba+obkk3t9fWtTa2NNW31tfFWt6XObUm47Q0NTbW1TS21ja7b3tZY296Qxt5LRC4bbEWHvUXwk7UGfx8Z/tO+al8R/ESzwd8v5RB1mxuv+IbB3h/wzngWSBr/ABn8tOwPlMFP6+ZBqbxl3ykY7IMB7wUCvB8ig5+W/aEAn7uN1uEwEXw3Lf/DZfivMfhHyMg/LZ8jZfhvN/hHyci/3uAf7eE7ANttSCYS9Um9h7ChNe7WtLYkGlTL2FwTb4k3tSTaGmvcxvaaRE2ypbWluaGmocltj7c3tTS2N2xAN9jHiPCeTNftsQTv8XyCm+H9uJSE3iTT7fnxufPuZkM32Cfkjp0tpNvxE/2xu6w2BvskAjvRlGyJN7bHm2obmurbGmpVFyyuLpob2trrEk3NqjOWaHVdt61G/Um0tdY0NrfWuc11bfWJ2maVXVomJ6cy9cloR+l+5SnM+HVN8ca2urq0nTYx4zc319U3KXka/GZm/GRLXVt7sj7dDrYw4zfV1rS31yabDH4rM36tG2+rTdSndbONGb+xOV5b19CQ1p92Znw1lki2Njal+6+ncsunuS3e0uo2mnHqaR6+yUMHk/fpzHl7obEA5ec4HcfhDsq/HPHKPRYpQPlBfqB8zJjXyO6MVGdeq4g46GNwXIy4Z/KhsJoYsZoZsVoYsVoZsdoYsdoZsYxdy9paTbodPUMEP9lg8M8UwY+3GfxJEvig33gWwHf4+E/jnw3wCwTwJ8vIP41/jox80uPhcz18CezzZGST7oNNkcFPjzmmyuCn+6jny+CnfcMFMviNBn+aDH66jzpdBj/dx5shg5/uo14og99q8GeK4Ltp+cwC+Hy+M5H2bbNF8JNp/Dky+Gn/dpEIfk0aPyWDn54PmiuDn/bPF8vgp/3zJTL46b7PPBH82vQYeb4Ifl1afy6VwU/PUVwmg5+eK14gg5/W/4Uy+Gn9XySDn9b/y2Xw0/2TK2Tw0/2TxTL46f7JlTL46fZxiQx+uv+wVAY/3X9YJoOf9p/LZfDT/vMqEfz6dP9hhQx+2n+ulMFP+89VMvhp/7laBj/tP9fI4Kf959Uy+Gn/do0Mftq/rZXBT/u3dTL4af9zrYfvdB07iW8Y7Ovyx67BN/Q7nXp/2eD+G/CofXmM/cS42fNWmClKh7UCfV0E7jOOAVvDrBXA/MsRrxJrBTA/ww+WD1wr0HHFBK9VRByuw2Iin2IinyoiDvcr88FawYi1iBFrOSMWZxmXMmItZsRaxoh1OSPWLEYsTtlz2tDKiGLNZ8Ti1AlO2XPq1wJGLE7b5tSJyxixOH30GkasqLaPpr8u27eK11UQeZtg4kpA3rBPhUMM/Q/51n3Vkf0zuDidCX2czHr4lBlntxw0eWrbFCfgAR32SNH3oya8AhRXGqIMjpNdsG4IweIOPOStAmHCZwsILGqjDlZmKPNCHx4ghqkr3BGe6P0fzyu4yTDlgPl31yCCchLUIMLIp0RGPokChA/5KSHkg3UY112BkzHkIoAF05eAMsL08No8D++97v1WOZ3tyLxwUEDExYh7Rr6a99+issG6wXoqUw81blg9NfmXO5J2k9FTSi+oxqzM6VzPnJuZwtQr5dvKiDiDZTYXQj2F6UtBGWF6eG2eh/fe9X6rnM46jfW0jCgPvAf19G3vusynPBO9/+N5hfp6qp3CdgDlxLk5O6wdmPzLHUm9y9gBVU+UPzGyKyd4rSLi8KRPOZFPOZFPFRGHO6L5YC1nxLqMEWshI9bKiGItZsRaxoh1OSPWLEasJYxYnHofRXkFtYO5YunAqaurGLGuYMTi1FXOMs5nxIqqba9lxJrNiGUWJnE/0+A7TqavhNv7id7/8bzChrEbzM+UA96D+ZcjXnn5yfSVKLlSfVojn94y8knz05vgpzchH1OXfYg4g2XmWuCYAabvDcoI08Nr8zy8V+tVWBXC1AGPGfoQ5YH34Jhhh4KOZYN1g/VUsh5gfoZveA/mX+5I2k08UC8o+y9zOtczo3ziYeoV8mvqsoKIM1jmgCOopzB9H1BGmB5em+fhvd2RnkKdxnpaQZQH3oN6ugvSU1g3WE9F6sFtD62nJv9yR9JuMnpK6UVvQo5lTud6ZpRPPEy9Qn5NXW5GxBmsSu9/qKcwfQUoI0wPr83z8N6hSE+hTuMXsjYjygPvQT3d38Mt8ynPRO//eF6htoaqSz78ereCKCe2MyhrPr1OhrYzk3+501kvJOysEvHjpwdGdlUEr1VEHNaRKiKfKiKfKiIOj2vywVrIiDWLEesyRqwljFjzGbEWM2ItZcTi1IkFjFjzGLFWMmFR/jkfvlYw8aXDKkYsTttey4jF6Qs57XEZIxZnPa5jxOLUCU7Zc9m2w1xGTp1YzogVVT/Bydem0GfqadM2nuw57XERIxZnGa+OKF+c/QnOMuL1ATi2LPB+y5zOtsc4zm4rQPmZcsB7MP9yxCsvP5lxNiXXSkKuRnZ9CV6riDg8zu5L5NOXyKeKiMNtRj5YCxmxZjFicZZxMSPWMkasVYxYnLJfy4jVU4+5Ya1jxOLUiQWMWMsZsTj910pGLE7Zc+oqp+yj6r84dZVTv5YyYnHWI6d+cdoQp36tYMSaz4jFWcao9uU4y8jZn4hqPUa1L3c1I1ZU+zmcfcye/sQ3w4Y4/QQnX1z6pa/xvGo+fK1m4ksHTtlz9gFMW4v3uxl8HWTn0BKh99jiOTSRPVhZ5tCovXVlTmc9ZJSPG6aeIb+mLvsRcQbLe625w54wmL4vKCNMD6/N8/Ce+ZB3FcLUAe8J60eUB94z8tV7wsyHzMt8yjPR+z+eX2jA86EmD5g3lBOj3oX6cAPMv9yR1LuMHVD1RPkXI7v+BK9VTmfdwfrQn8inP5FPD1a0sA5hwgryYSZehzLiOW5/C/Mz5YD3YP7ljqhfcIPkSvlLI58BMvJJ71EeQPAzgJCPqcuBRJzBMl/Yhu0RTD8AlBGmh9fmeXjvdNQeDQRpsQ0MJMoD78H2qKVXx7LBusF6KlMP4d/5MPmXO5J2k9FTSi8o+y9zOtczo3ziYeoV8mvqchARZ7AGe/9DPYXpB4IywvTw2jwP701Degp1GuvpIKI88B7U03O9fyodf/sMY88Ql/LbWIbwOWwPIvXttsXD2oPJv9yRtM+MPQwMKVcjn0Ei8mltD6M/kF9Tl4OJOIM1xPsf2gNMPwiUEaaH1+Z5eG8BsgdoO9geBhPlgfegPVyM/DasG6ynIvUQj7eH1VOTf7kj6SczekrpBdX+lTmd65mRn7Yw9Qr5NXU5hIgzWEO9/6GewvSDQRlhenhtnof3ViE9hTqN39UbQpQH3oN6uhSNd3F5Jnr/x/MKbS5Vl3z4TfEyQtZ8+InGMqK++PCbGwz+MBn8OoM/XAS/IV2/I0Twa9PyGSmD32rwN5fRnzT/o0Twk0mDXy2C35bmf7QIfk0af4wIfnPafseK4Dem9X8LGfmk63ecCH57rcEfLyOfNP9byvCf9v8TAD7nXITB30YEP5408tjayYQYUSaTv+mLbAXSF/j8GiwcZ/IqR1hS/T6qbJB/PO7bGvADZeCHtXWOWGVEnESdTggoN8y/IoBXXA4d8Bk4XZWJDgsYsS5hxFrBhEX1bfPhaw4jX4OZ+KL6v/lgDWXEijFh6YA/NJgPX8OY+NLXwyOKNYIRayQj1uaMWKMYsaoZsUYzYemAPwCVD19jGPm6ipGvsUx86estGLG42g59PY4Razwj1pZMWDrgudOoYJk1ZNn5rppG2fmuZJPsfFdNq+x8V21Sdr6rpl52vqumxfTVTXto8oC6Bds3vnFFTeh3QU3+5YhXXn4y47vNET9YPnj/ziiC1yoiDtvoKCKfUUQ+VUQc3subD9YaRqz5jFhLGLEWM2ItYMSaxYi1lBFrISPWyohicerq5YxYXLKn2u2o6CqnPa5ixIqqPa5mxOK0oajK/gpGLE4/wdnWcvpoTtlzyiuq+sXZN+GsR07Zbwp+Yi0Tlr7GY9h8+JrLyNdQJr44sXS4KMXH1zBGvrhkr8M8RixOncBz6flgxZiwdODSCR0uYcRKMWJx6hcnX/OYsKLsC/sw8sWpq5z1yOlXoyqveUxY+hrPrUbFtjn91zpGLM7+1yJGLM45Bc4+OedYgXPu0fTvzTz2CBBX4P3KrgHEu7wGMEKGn8A1gBGEXKn9sIz8tIapZ8ivqctqIs5gjfb+h3v7YfpRoIwwPbw2z8N7t3sVV4UwdcB7+6uJ8sB7Rr56b/+NsY5lg3WD9VSmHsJ/A9bkX+6I2o0bpBebE3Kk9MI8W0XE4T59NZFPNZEPVfd471s+WMsZsS5L8WEtZMRaGVGsxYxYyxixLmfEmsWIdRUjFqcNcdbjGkas+Sk+rFWMWJy2zalfnDbE6Vc3BdkvZcTi9NHGF1LvUTH2P+LUe06M+Ol3DkYHyALmj/fimHjq12DhOJNXOcJiLpsbVLagsdtowE81uPbDGp0jFvVunESdVjv+5Yb5y74LWJuQfRewtk72XcCadqPzY4E8C5DsxonUZUPos1RM/uWIVymbGof4wfLB46HxBK9VRBzeuzeeyGc8kU8VEYfb7Xyw1jBizWfEWsKItZgRawEj1ixGrKsYsVYwYnHKPqq6uooRayEjFqd+cfqc5YxYm4LslzJicZZxZUSxOG37ckYsLtnra7wvNyq6GtU+ACdWT7vd027b0nb0tNs97XZPu/3NlH1UdXU1IxanvDh9Dqfsr2DE4rQhznY7qj46qv0JzjJy9n0565FT9puCn1jLhFXgdN6fkw9WNSMW1zy5vh7NhKUD3nucD199GPmay8SXDvMYsS5hwtLXYxw+rG+67PU1fnciH6yhjFjDmLB0mJfi42sLJr44dVUHThuKqt5HtYzzUnxYUfSFnHzpMI8Rq6ft2Hiyv5gJS19z7nngkpe+Hs7IV4qRL662Vod5KT6+OOUVxbZDh3WMWJxjvkWMWJxrOpzzAJzzE5z7c/D7bXBvWIH3S50Xr/OZ6P0fzy+0FqD8TDngPZh/OeKVmR83SK7jCLlS590z8tNSgPAhP1sS8jF1OYGIM1jmnEz4fhtMvyUoI0wPr83z8F5h0YbfKoSpA36/jTorHd4z8i1W9FVhx7LBusF6KlMPidDvt5n8yx1Ru3GD9IKyf0ovzLNUfeF2P2x9UViLGbFWMmJdxoi1nBFrDSPWQkasFRHlawEj1ixGrLWMWLMZsdYxYnHKaxkjFqc9rmLE4tR7Tl/IWY+LGLE4fQ6nTixlxOKU/XxGLE6+rmLE4tQJzr4JZ7vNWY9R9V+c+sVpj1H10ZxYnPp1OSOWkb0Zr8DxTYH3W4aeK3BYx3o1BSg/Uw54D+Zfjnjl5Scz1qPkuiUh11y+L2Z4NdcwDubT3d/x0mE5I9ZljFgLGbFWRhRrMSPWMkasyxmxZjFicX0bSYf5jFic9riKEYtTvzjltYQRi1O/OG2I069y6gSnX42qbXPaI6cNrWHE4rTHTUG/ljJicfYBTFtb6cXB/jY8jwTGwXyC+vzweZOugniuwPstQ/wVOJx97MbQ53WY/MsJmUj0+bcOKVcju20IXquIOLx3ZRsin22IfKqIONw25YO1hhFrPiPWEkasxYxYCxixZjFiXcWItYIRi1P2UdXVVYxYCxmxOPWL0+csZ8TaFGS/lBGLs4wrI4rFaduXM2JxyV5f4/M6oqKrUe0DcGJFtd3mlD1nH4DTR3P2J6Kqqz3t9sZr03r65Llh9fTJN55+9fQLN55+RbFfqAOnvKKqq6sZsTjlxelzOGV/BSMWpw1xth1R9dFRbdM4y8jZ9+WsR07Zbwp+Yi0TVoHTeY9TPnxdxMhXNRNf+roPIxbn+hCnvIYz8jUvxYd1CROWvh7j8GFx6YQO+N3mKMie07a57ZHLhvT1aCYsHTjtcVPQL3zeUD5YQxmxhjFh6TAvxcfXFkx8cfpCHTh9dFT1PqplnJfiw4piW8vJlw7zGLF6+iYbT/YXM2Fx9id04JKXvubsk6cY+eJqa3WYl+Lji1NeUWw7dFjHiMU5p7CIEYtz3YpznmkJIxbn/kJ83lAfEFfg/Zp9vtDX6Xwmev/H8wpu6POGTP7lTue2io+fzD7fQU5nufYh5GpkN5jgtYqIw2PjwUQ+g4l8qog4vOabD9ZyRqzLGLEWMmKtjCjWYkasZYxYlzNizWLEuooRi9OGOOtxDSPWfEasVYxYnLbNqV+cfHHWIydfnH6CUyc463EpIxanv8ffPMd9gone//G8Qm2t6ZvAvozpU5U5dN+EJ2+3oQDl5zh0v87kX4545eUn06+j6g3KB/frhhC8VhFxuA6HEPkMIfKpIuKwbeaDdSUjFidfy5mw9HWJw4PFXcZZjFhLGbFWMmJdzojFKa9VjFjXMGJdxYi1kBGLU/aLGbEWMGJxlnEtI9ZsRiwzz4f7FjpM9H5Vc5hsqEsmGuoSida2eFNrXX17Y7I+nmyuTTa2NLvxZG2iobW+KRmPtyXbWmrirXWNta1tTY21yfbmpsZ62b5DbWOZQ7evPPiua/CHyuAnDP4wGfykwR8ug19j8Ktl8GsN/mgZ/DqDP0YGv0H27AM3rf/byOA3GfxtZfBbDf52MvhtBn97Gfx2g7+DCH4ibvDjMvhp/+bK4Kf9W0IGP+3fkjL4af9WI4Of9m+1Mvhp/1Yng59u3+tl8NP+s0EGP+0/G2Xw0/5zRxn8tP/cSQY/7T93lsFP+89dRPCTaf+5qwx+2n9+SwY/7T8nyuCn/eduMvhp//NtGfy0/9ldBj/tH/aQwU/7hz1l8JsN/l4y+C0Gf28Z/LR/20cGP+3f9pXBT/u3/UTwa9L+Z38Z/LT/OUAGP+1/DpTBT/ffDpLBT/ffDpbBT/vPQ2Tw0/7zUBn8dP/tMBn8tH8+XAY/7Z+PkMFP++cjZfDT/vkoGfy0fz5aBj/tn4+RwU/752NF8GvT/c/jZPDT/v94Gfy0/z9BBj/t/0+UwU/7/5Nk8NP+/2QZ/LT/P0UGP+3/m2Tw0/6/2cmEDHayrVktJdQ21TU0u+1Nde3x5pr6hmRTe319a1NrY01bfW281W2pc1sSbntDQ1NtbVNLbaPrtrc11rY3pHlvIbHzCZl5/1YJubjtab/QBvAL2PhvSOO3i+DH03Z1qojeZPg/TUT+re3625RXeJsBzBnJp4O8ipDczvD+N9/d1GFyKpPmdBAP079YvuFX57fUy68ClMcB+ehgyl0oIle3sQDl5zj0XhuTfznilZefzF6bQsQPlg/ea1NE8FqF4nTAa69FRD5FRD4U1jpGrFmMWFcxYi1kxFrGiLWAEWsxIxZnGS9nxIqqfs1nxFrBiLWKEYtTvzjltYQRi1O/OG1oOSMWp05w+lWzJ6/M6dwW8rXNdUnT1sL+tQkmDvaPC1BcG0i/ZyqTDocY+h+WqVTRbv0zuDgd5gf2m1oBvl+fQQcjx2IQz9nHMfhlMvhJI/tSp6NMcZnKfGRl4qlfg4XjTF7lTme5S/QPqbJB/rG9lAJ+oAz8sEpzxCoj4iTqtDig3DD/igBeqXLg8Q3lj6j+t0lfFsAXTF9J5G2eNTIsB3GMMkwEyRDaosm/D+Czta35/FMPmHyqg0IMycHIbQhKt08qIwesg6U+WA76fwi6FwN4MMiOGTduO2DKlGs7AGXbiuK66vd0wL4By1wHXdfvo7mFGFEmrEN+cwsxEA/Tf1SSye9D77o3yLNPQJ4ViG+YXod9Uh3TbwbKFiPS9EE8mvSfeXzp+jvUqz9KdoafMvT8N0mXTZly1WVYj5g3g2l0B9etX70UlmZ4OaJ/hmecX0VAOcz/zUR+hvcqlFYHU8d9wX3GOa7Q3wMz+ZcjXpnboXQfpi/iB8vH+BYtw97e9aTJTa27N50z5fxJbb2QKCvBNYSvQnAmDUwLQxVgyfFJh6tdh8NSnZ/DwYiy0uls1lUoL4gfI+5h11tF8GbU3Mhma0/Ntdvq611XOLQa61DmdJYtoyq0hFVNk3+5I+kOM6pZifjxk72Rj5CpNBc4nc0iRuRp+DV12ZeIM1j9vP+hi4Tpob3A9PDaPA/vjfL0qcrpbN4HpTryQJk+vGfkq/V0qIdbSZRnM1Q2qt4qCdwq4nksQ2jHZ6U6xhURZTNxxQFxpQFxZUS5TFw5eG4yeq43gal5uKA0g+cnG6hXpvtC+SY/3+qHtRfCgs/3RVj9smAdirDg8/0QVv8sWIcjLPh8f4Q1IAvWeQgLPj8AYQ3MgjUFYcHnByKsQVmwpiIs+Dw+dm1wFqzzERZ8Hn8ma0gWrAsQFnweH0s6NAvWNIQFn8dHpQ3LgjUdYcHn8bGkw7NgzUBY8Hl8VNqILFgXIiz4/AiENTIL1pkICz5vnq0gsHA/YHNwf2P0A0z+5YhXqX7A5k5nuUL54GXYUQSvVUQc9lujiHxGEflQWP0ZsQYwYg1kxBrEiDWYEWsII9ZQRqxhjFjDGbGw38rWXh+Z2vAb1F6b56DuwnQxkIZqoyGGX38Ajtng/ZEhygPvYdmM9MnPjz8oGzPeDOp/VKLnKJ6rsuQTxLNJR/WZz0l1jINT7Lh/C6eDcT8cTpX3RXFlRLlwnxnWK+4zQ7nBPnMRKs8M777sdFw8DvXPT1Z4XoL6dZxw07XUlLt0Pr26KR9cns0Y84FYe6Y65tP9U3zxtjDlgPlLT/EZWfQPkMUAkbxrQk93DkCy6C8kC6OL2cZteEmRGptRbQmcHj21bapapPv2jCOaTi0BSaFbxexUoHR90f/9fNiaiNINQP+b7h/mA2LBgPkImn6l8qfciLkuIu7rQA1r8TQsVW3UqWfUNOyggHz655lPfyIf2dNl4sKnv2RW+ampBFgmk3/QKX1h3YDJq7tO0aPKFlTP1Cl6QVhhT34zWLInBmXqNOj0QJh/rqcHwtVi6OdGeH1D3a27DS11UL5CdvdYsi6sPpr8u2unedidLlRX3TxbheJ0wF+LoHadFBP5UFjLGbFWM2ItY8RawIg1ixGLs4yc9chZxssYsTjLuJQR6ypGrCWMWAsZsVYxYi1mxOLUCU575LQhTp3glNfljFgrGbE4Zb+IEYtT9isYsTjlxekL5zNiccorqr6QU16cPmdT6DNx6gRnu80le32NTzSPit5zyv4KRixOvecsI6ef4OwDcMprLSNWmLexqXG9SU+9wULNS20qb7DUonQcb7DUonsxh36DRWO/j05HwG+/6CA7H5tMFKD8cBkdlH854pW5/tNzVtT2MGre08huGMFrFRGHv/ZMbR0bRuRTRcThdjsfrKWMWFcxYi1hxFrIiLWKEWsxIxanTixjxJrFiMWpE5zyupwRi1NeixixOOW1mhGLU1cXMGJtCvW4ghGLU16c7dB8RixOeUW1HeKUF6e/59QvTp/DaY+cOsHZZ+KSvb7GczBR0XtO2V/BiMWp95xl5PQTUe1/rWXEMnMw1KtE+BUGagw7NCAf+PzQEFjUeNikp149CprroV49MnMPQq/gJILqg3p9qStzPUZuLkqH53qgbxvug+Wg/110z2+uB+9bWuJNZBn5Cu1HI7ea4/2KcM8o3heZ66u28PnKgHz655lPfyIfWVnmfopGFYprA3H4FYd2gAVPQcEhhv6H5dV2cXQOJ2zA+mj1wSwi0hagOJP2xrIMHy0eH7L7DruvTvZKZdLhQNWJKa+WRXuedYL3v0K+qdelw7zGTb2GX0U83zcgn3F55jOOyKeCeK7A59fkg+/hfCieg+bbu5oPxDI2LDt3n7v+YzlD/cd7c9tBHD5FD56ADdeBcKBsw8hC28ZdIWxDdr2p+2SIX3mDMoS2jQMlQyOLsDKsdDrLENt2JVEOyu4hRlfsnuIhau1EfxQH63gAioN1PBDFwTrG61XwlPcCFHc6iCtGcWeAOHwS4pkgrhzFTQJxsK5xyNaevZpDewb1Jkx7Rh2hYnBlXylLJsP4fZh/OeKVl5/MOij1ijB1cqeR3UCC1yoUp0MqlUmH42LEvV4BWIsZsVYyYl3GiLWcEWsNI9ZCRqwVEeVrASPWLEastYxYsxmx1jFiccprGSMWpz2uYsTi1HtOX8hZj4sYsTjrkdN/ccrrKkas+YxYnPLitCHO/gSnvJYwYvX41Y3nV7lkr6/xOmhU9J5T9lcwYnHqPWcZOf3E5YxYUe2vzmHEMv1V8xwc48M1S+FzDNJf/hwmg58+JyFoLRfmj8f0Jp76NVg4Du/bHihTtsB920F6AOfGwxwROjRHrI15ngmUNT7PhOKVKscARpmE+QIKNbeUa90GHdkqbGPpPQUDAuQE88/n/ZEESmfWCXs5netuiA+Wg/5PoHt+ewoqnc51WubDp8kX38O6Ap8vCsinPM98ykPmU5VnPlUh8+mfZz79Q+bTUz8d89mY9WP8MDyzyKzb6jWX6eV0nvBIfXhWE94zYdLfD76GO7Pcv4wxVH7oJ8xRhLJf4Mp9nQzLso0oTwGBRa0xmTLl+qUY+I4e/lKMwfT7UkwxiIfpF5RneKkYQWMWAEz4riL+ipCx2WInU26YBvNg0l8BeDBfEcKYhT7lKvXBvAno4pJyGtMhMKlylaNyYR7KEA8m/VWgXFVgkyJMY/6HenJuqiNvvYm8HJ972Kf19okLyjfbs/oafkUIx2FdwfKCz/vJFOuKSb8uQFeKCR5geXG9Yh5wmnIfHm4geIDHVrZMPmeG91UfBwX8cbIi9D+uSlwFxQSOXzBi0M/cVE7jwHQmYPWDTXEpkUe5D4/wWS0eU72tbZPaprb5CKgXAivyyayXQwfZr33KtBvU/groe3Gg2hRTXv1c/xEZXJzOBPhOdk+/qmv9KoxF9Zd0OD2ViYfpnwR+ZMwIGrOXD+ahqY7pqTaN2ptk0lNjxqA+N9RHPE6n8oayxH53YI68ZptvKEO8UmPRsLzu1c28FuXIazmRN2x7lHM9/YK28w6aPDV9irZDsOGga9zu4DS4vSj1YbUPSleJ/sfHKmP33g/935vgjwqYZ4qXmJM9GBM1svo5MNFxPibqOLSJGrXHwy/4LBx+GZWYQqQzeU5F5YHpYZ4m/fkgH6qLMwWV26R/iejiVBE8GX7K0PO8zW59nZHhBU7nYOKmOR3LDuOmg/R7pDLpcKCaVlMmLQs3h+EarEfMm8GETQasW796eQPUC/6wJ8xvquNfDvN/jMgPy9LE62DqeDrCmOj9H88r1DYVoPwcxyGn+U3+5U5n2UpM809H/GD5UG444MOeF4BrCH8sgjNpYFoYjgUsOT7pqGofTDyHgxFlEeLZlE+7k78jtwVNH3+PGPIQI+7h3lYhwT+VT3Ge+RSHzMfm8uCd1jrgD0CeQZQV77TWAX+scRKIwx+APMvpXC4Td3YA5uQAzHMC4s4NiDuPiNM8ze6T4RE3L5Sp449Kwrrzs2s/rL0QFnx+OsKakQXrUIQFn5+BsC7MgoU/KgmfvxBhzcyChT8qCZ+fibBmZcHCH5WEz89CWLOzYE1FWPD52QhrThYs/FFJ+PwchHVRFiz8UUn4/EUIK5UFC39UEj6fQlhzs2Dhj0rC5+cirIuzYOGPSsLnL0ZYl2TBwh+VhM9fgrDmZcHCH5WEz89DWPOzYOEPvcHn5yOsS7Ng4Q+jwecvRViXBWDpa/y2E3z+MoS1IAvWUIQFnzfPVhBYBd6v6U4uBPf5um9u6LdcTP7liFdefjLdyYVOZ7lC+eC3XBYRvFYRcbAtgnEwn0VEPhTWBYxY0xmxZjBiXciINZMRaxYj1mxGrDmMWBcxYqUYseYyYl3MiHUJI9Y8Rqz5jFiXMmLhtiyoX6+vzQ6poH69eQ76MzzdFUPPwPQQw2/cEHPo8cCCEOWB97BsFvjk58cflI05ISbfcYq+rkZYXR2n6OvRCCufccpRqY5YXR2n6OsxiK+ujlP09dYIq6vjFH29DcLKZ5wyM9URK59xyskIq6vjFH29rdMRCz6PffvFWbC2Q1jw+VzGKfp6e4TV1XGKvt4BYXV1nKKv4wirq+MUfe0irHzGKQmEFTROWZgFK4mw4PMLEdaiLFg1CAs+vwhhXZ4FqxZhwecvR1hXZMGqQ1jw+SsQ1uIsWPUICz6/GGFdmQWrAWHB569EWEuyYDUiLPj8EoS1NABLh31THbHg80sR1rIsWLsjLPj8MoS13Aku445ORyz4/HKEdVUWrJ0QFnz+KoS1IgvWzggLPr8CYa3MgrULwoLPr0RYq7Jg7Yqw4POrENbqLFjfQljw+dUIa00WrIkICz6/BmFdHYClwzGpjljw+asR1jVZsPZGWPD5axDWWie4jLs5HbHg82sR1rosWN9GWPD5dQjr2gAsHc5IdcSCz1+LsK7LwtfuiC/4/HUI6/osWHsgLPj89QjrhixYeyIs+PwNCOvGLFh7ISz4/I0I66YsWHsjLPj8TQjr5ixY+yAs+PzNCOuWLFj7Iiz4/C0I69YALB3Mbq5K4vlbEdZtWfjaD/EFn78NYd2eBWt/hAWfvx1h3ZEF6wCEBZ+/A2HdmQXrQIQFn78TYd2VBesghAWfvwth3Z0F62CEBZ+/G2HdkwXrEIQFn78HYd2bBetQhAWfvxdh3ZcF6zCEBZ+/D2HdnwXrcIQFn78fYT2QBesIhAWffwBhfScL1pEICz7/HYT13SxYRyEs+Px3EdaDWbCORljw+QcR1kNZsI5BWPD5hxDWw1mwjkVY8PmHEdYjWbCOQ1jw+UcQ1qNZsI5HWPD5RxHWY1mwTkBY8PnHENbjWbBORFjwefNsBYFV4P2ada4nwH2+daUatwDlZ8oB78H8yxGvvPxk1rmecDrLFcoHr3M9SfBaRcThOccniXyeJPKhsGYwYl3IiDWTEWsWI9ZsRqw5jFgXMWKlGLHmMmJdzIh1CSPWPEas+YxYlzJiXcaItZARaxEj1uWMWFcwYi1mxLqSEWsJI9ZSRqxljFjLGbGuYsRawYi1khFrFSPWakasNYxYVzNiXcOItZYRax0j1rWMWNcxYl3PiHUDI9aNjFg3MWLdzIh1CyPWrYxYtzFi3c6IdQcj1p2MWHcxYt3NiHUPI9a9jFj3MWLdz4j1ACPWdxixvsuI9SAj1kOMWA8zYj3CiPUoIxaec8y2T+4k7zpon5x5Ds474VczY+gZmB5i+O3Dizn0/rrHQ5QH3sOyedwnPz/+oGxO9q7z3fenr09BWPns+2tCWPD5XPf9DUZY1L6/SuI5vE90WkA+OgTtE50WkM/jeebzOJEP9Z7iOamOcWc4nctKfREGv/sIvwhzAYo7iygXfk8R2gh+TxHqIH5PEeoUfk8R6gh+TxHWOXxP0byPa2SU8u6XobIZ253o/R/PM1BfV8RyhPVW4PPrOJ3XJnTA+gG/ClTQTfn06qZ8cHkuYMwHYu2R2vBL2S8+viNX+4XPT/PBMkcb6AC/9HgmiIfpl3u6rLG3QkdtUHvUzwD39gkoq3nW2Ahu3yZ6/8fzC67BnymDnwxqH2GZsE+BsstFv2Be5QiLW3ZBZYP8Yz2E7XWYfsSFOWKVEXESdTojoNxUG0LxSpXDzzZhPkGnIM8M4AumD+o/GRnCPgyjDBNBMqT6YF05BdnIbThKh7+sTPVFMZaD/h+O7sWc4FOQYZ2W+fBp8s3mx+HzuB82DfFF/Zp88D2cD8WzyQeeZwFPpX0Anc1g9A4emQPfoxoC4juk75/BfNDDpN7z8rOVApAfPAsDH7Vk8vM7aulMH/4eA+0ePtHyTKLMQwJ4NpjwvBHIszn3A/PwfdSPFGojyX6kyasS8YvrB5eFqhOsd+cTcvCTrQ6wnwL7MTD9D3Psp0D9xv0UyJN5lhrzlzvZ8wlqJ8uJfPLtH1D5UDzjsZsO0M5fQHZu9AHqPHzWnIdQhNJ/1C+D+csAO8f7h3CfBvs+bOcmPz87x3pj0r8cYOdUn/mwlD/PBhPaOeQZ27lJ/ztk50L9GtLOTV5UO4btPNd2jPLjVD6988ynN5GPdHvZG+UzgzEfiIXPYfKz178hezX1Stkrbrdh+qeAvb6L7BXqe1B94rZjBpEvthnHCTdHGfRuMvZROgS1HWkfFdB2BI0BdAga4wbNCcN0ME3QvGksIA+oT/C+6bPCNu1MlPZClHZGQFq/8Zy+bvGuZcfc9S3GFuDcrwkmbjbBs4mD72QfncqkwyGG/odl0rqyTYgTnamx4WwfTCxTHfDp76bMvQjcmQgX+gAsL3PeGrb//l5htP2XVtB4WE90OMHDkx1X1rfi+oUB1y+WDw5U/Rq+df0el0P9wjqcg+Kgz8Zn/ME20mBo2Y/0Mo2qLXXFXo7L014oeeK1CChPgwHlWYQwJgJ9H4X03aTB7YUOxn6MzRr5FRLP64D7fib9WC9PLZ/bRtD5B9mb49B+AcoBnzU626F5ocps0u6C9BHaGJ8+1rimHi9CPMO8U0J5h+mvwfwrCH4M3+VEXGEevNa69fWJuprW2vbmuoba2rYChG94xffw3OFcIn0lkd7I+mLwPJ+sk63G1GKpDP5cIFcdCkFcCsUVgTjDo7ahO0d05H+uEP9h5A/zryLS7wXKkEtdVhH54LFaPlgzuojVz+loA1RbCPs2uC2E/Rd4HuwJPn45jK8zvg37fVhO7AePRb4Otn+MOlRD9Uexr7tIKO+wvs7kX+H41205EZePr2utrXFr2htrm1vbk22t9e0FTuc2IUbcw74uRaTfjEgv7CvilK9LAbnqUAjiLkJx0NcZHilflxLiP4z8Yf5VRHrs68LWZRWRD/Z1+WDN6CKW8XWwH4T7qdDX4X7qTKI80NfhcdnJyCfJfNKBniPEPhXyqwMcQ88EcsLyxTjwHuw3w2fwnI1Jfyrot7dW0PyZMhxE8EftXYLlOr3CP91MIp2eQjL9qFPbph5+WtN5ba2Ht7Wc1zY15tDs4SLi4uPhlIPS6YC/XHYO+h9P35yBcEwTHPbLZeYXYlFVB7Fx03sWGPI8hFzYmSivid5vPM9ADR1xUyuzvJYIPaww+Zc7nVVOYlsHNbUJ5YObR5lliURcf7gJLxnoMCnVWTaYD6Mv1NIdlB+2hTDLlGcQ+VCfXyjw+TX54Hs4H4pn83+Qq/VzjYuBa5xTkUmPfU2YLVthluLhPZi+DcXBJbqCAHw83TIP+IsqNIUEu1SmHOmPk4I4TnvWfDwK+MB6C7trfnZGfS7EpA/aSqaDWdII2lpE6RbUJaMjVD0H2ZTE0j+VT0We+VQQ+UjbbgXKx2+p7mofm/RbqtsBxMP094OlunWoPv181/pypTJx3WQziVxthvJTQTaT7dUNI0NqifW4VMc4St+xXHU4LdWRhzMIHqj2tIp43qQL00+B/PHVkRu6n2Ly765+ypkh5WrkM01GPvEg3ZxGyAdvDcB1B303tH1q+EMt98F2Ag8XH/GMPWhLQZDtUEvw67f/oWGRdD8I2xZ8fSoOsA5PdeRLatsH9Je4Phh1v8aUe2ZAuXH+muAyELXdFqfHYx6Mj1+RMs/DD79TuoX18WegT/qjChrTcYL7pFgmxQ7dXuJlb5P+J0Q/kqpjuGz4M9SuQlnirUYXEnJYv5UuRHtPLePj9n4K3EqH+KL8D9Wvwn34XPtVVD4YK+wWQZP+t6Be8AeXs30WLczWeChbww8lG79tGMY2dDB+BtuOn15C2zgcld+k/yMo/6Ho66HQ/vy2A/m90hhzgvWrABGeutNUReRPLYtomuj9H88zYF9WCPKYTfCDl2/+juzNTN/GiLJScp1D5AunjKtQvnNQvroeX0B6bHjr7XS2M6pO8LZ0zGc7ijfp/wX87Huorfbb0v9JBZ13uUProZ+dQF6hHc5KdYw36T8C8vqlz9gA8kPxStko/Ah7rjZ6KOLVpP88wEaDdInq0+GtPJSNYr4L0P2wepHG2SxT7q8D+nBQLyo368gD3lKYzT/gvsNE7/94ngHXJbRTyl/iuixD5TL2GyPKStXpbCJfuAyE/cNslC/lH+ArfYaPUwGmnx4XETzrgG0uvewBeMA2dyZRZkoPqDY26JUO+Mo0lR6XxaTvD3gNmvcz/QHZOQyXnPeDtlOU6lhu6jPBVN8Ky8nxkZPpu1Q52X0y3MZFjZfMcfx4bWYr4CdGbtaxrEFzEkLLkY0FKD8jG3gP5t9dcxK51u00gn8z/0Olp2yMmvPQayd4Dhf6ZJMvfDV8JrpHzVPg+Si/sc22yDdQc2BQ78xYDuepw2kpOk+IC/Ok5jqxn8xlTi6bDCj9D6OfVD5Ba0vnM+ZDbYcNGjP66Su+FzR3A/0x9k0ScySzAJ9hxjuzQRnC9G+pV06p7cnYdgt9ZIfnSEz6ycD3fgvZVVAZdYDjUswTNXbF8wCm/1LswzMeu5r0e4A2Otvrc7AcOuD5AJN+b4CJ5wOoz+kF+V1qOw/sqxl+KJvA40Y4BsR1TmHjrXsUDj5uG5fTr69tMKita5omev/H8wwGL+XhwT7vXIKfIpT+SKTHlzgdZRokM00XE/leAtLgvvbFKF+qr53y0sCxOKx3XCd4XRrzicdcJv3xwJ6PRX0p2L7D9rRpMzpvOC5IBfB6EcErtBk8LjDpTw4YF1BznpBXqk9ubHJj9Mmh3ypKdZRP0Oc4deiq/6C2Fs5EcbDND3MESJg2ptgnPdZZk/4sYkwV9Lquxp+M+lswH7wf4HxQhqB2CtcVfFbnOWUzGhe2JVBmZ6Y6ltekbwVz5hcgG/SbD5vuY4PUERc67IXyNulHgLxnIhlSa0pBa/cFRFyY/uyZIfOZ5pOPEzIfqjyc/WZqvr4f4jnXtQz4fHftEemH8rmQyEe43xx6TG3yL3c6273EmDroWEgoV5Oemi+ZEZCeOt6ROnoKjqmhD3ecjvnCMfVsdI+yczyPmOsYK2ifF7X+mc3PrcnRz52fysTD9B/0zWCuRX4uavvK+ueZT38iH2mf0R+VZ1pAeXLVKfh8dx2d0R/l47dP7l6f9Ydcj6D5FdDPB7qon0HHXXTXMSkSczSbQnm+yTbyPJONPA1s5KfIRqj9aEHHnXRVzmHz+SbU54WM+VBz89n05lWfNb2wemPS3w705vch9IaSjd9RmTDf7tK3IKygviW1TyloXjJoDRWmp47nMLog+3py+P3AJv9yxCsvP5lxAjWHM4uQXR8nMzfV1DbFTTTs0dZy3oxzpuLKMIBVTkchz0aAJr2D/sfPaaYKUZppRB46wPPkoCJVoefxQATjh+EpW9ps8ZQRzvIpp+OEM0L4vJ8R+p3nhc8xSQ9IwCRXmPO8oPLkcp6XnwOJEWUo93kOy546w2yfgDKb9J8GlPnCLGXeC5XZ77xc+D9OR22eKXXoCfaghcgBTkfec9Un+Hx3Ne4DUD5+jW6sMvMMlIPfiz+ngXiYfgVodIs9zFzP6MPn8OUqZyofaTnjs1gvDChPrueMU+d6B9XTaSCN3+asQgJTB/xitEk/0KtL4bO5yXf8TV7U++7wxc3BTDp8KdDhYUiHqYmu7ppQy8VWCpyu20p3lScIi7KHAsQzTG91h9Zti4fxQTB/6zu0bxR0FHLYDi1+LqhDi9NiZ2gUKd8OLcWTX9pcO7RwJgl3aHOdIYbPw1VwaBC8ipTo9GYiXH2FxoRn9qaDMlAdNb9Z+QIffOwo4eEulOzwTiiTvt5rEHQH8iWvM0vV1UAf/hwnXF3B57trNn8gykdit58O+C3PbLqxA+LLrxO7O+oAUB+AoFaW8ccN6kAHYC/UAaBmiYNWjcKcVkHt2KUaKKrj6bfLIZteYxkVEpg6+H0Aohl1CGVOqKmNb7zV6NrQjTI+uIl666aciMvr0M36djdeV1efbE80NbTV1uG2y/CK74VZqR5JpJed0ashD92EHX8dCkHcTBRXBOLgijc+iE6mw1TTGkb+MP8qIr3f28QUlg69BLDM4XFBb3zhHU86QL+C3xA06dtA2xnmQyjTiPIEfaAjhv7Hvgz7Kh0mer/Zarg9S3CQ3EoIXvAbcibtJCCXV0Z0LAt1SJ3xHbGAPBziXoHjLzucR4zA2y/VMe7CELxRE3YQ43wfPjUGNegegcqS62TKCIIfyZUvmGe2/stM1H/JtvJ1YSoTD9NvAfovc1D/hdqNg/thBQ7dd8A+Bb6JR00IYz9g0l8C9D3bB6xgOTGPEDPsB6xM+gWo/yK0o42c0DJ5ddfJcBir0MnsWof+cf9UR1mZ9Id6g1Jdz1dW5oZ5gA/mk5UZzGU5Yh7og3kPwFwRoPeDnI755bqjFD6PT12ROQEp87HQs2Tw0x+WnETIApbJ5J/vDlqYV3e9GUmVLaie4UegsS1RWJNyxCoj4iTqNOiUKph/RQCvVDlwv4LKZxAhE5P+7AC+YHpjw1D3zbNGhpNBHKMME0H1DT/2bfLvysdCjdwGo3T4Y6FQ9mf5YDno/8HoXsyhPxaqfeZznp+n2qU+PjwbHrK1S/B5rP8yPrO+kXqT1wTqTV7IIw4x9D/kW9f3yP4ZXJwOYmA9xh8TDPK5fhjU3Gc2u9cBTt6bheIpUyef13bIeadf0DS1bc8L2s6eSuhvKSof1rtz0P9nobRwPhOmw4uzk9D/56L/zyP4wQHLBIYKIp1fyGYfW4LrrtgHfD5oXnFUnvmMIvIJwtqSwAry36OI9JuK/x6L0pmxXT7+eyy65+e/MS9w/GQ20UAbw33n19F4SKZP0piscDr7NFMWk/fZQnkXoPwch+6XmvwrCH4M3+VEXD7zuYmGpOs2qKXgtnhNvKk1HmRj8B62yclE+glEeiPrcx0RWZMfFpkM5KpDIYg7G8UVgTjDIzWfK+M3GkPJH+ZfRaTH8yVh65LC2quLWGY+F/peY9uytp57/wu/nRl0oiVct4BzzzhQ/TZTXq1PR4fotwWdQiU7Lu8+GUJdxYGSoSlvrjKEuoZlKGPL3SdDaKM4UDI05dUybM9BhlDX8Bw29E3pU+WcaMm3AMXBdag9U5l0OGST4W45yJCaB485neV0BoGFxyHNBD+mnOc5HfmH9acDXteCz5+HsM7PgoU3S8Pnw7w5B7EORVhB+xdmZME6HGEFvSlzYRas8xBW0GmIM7NgTUFYQSczzcqCNRVh+Z18q2l2FqzzERZ8Hp+2MScL1gUICz7vd0KLH9Y0hBV0Ok4qC9Z0hEV9rI2a64B9nArinrF12Q/PuTl/kJUaL0jMcacQP1g+eLPrXILXKiIOttswDuYzl8iHwjqTEWs6I9ZkRqzzGLHOZ8Saxog1gxHrQkasmYxYsxixZjNizWHEuogR6yxGLDOPTM2Dno3yyXUeFD4fZh6U8qF9nMyawfp5892bzply/qQ2BwXYbzV5wP/P9cm/injeCcCCzwSVJegLFsbP+33BAu/pMOn38TKGp3eVEc8zjjvqqZe6TDBxuH2AcbDfumeqYxz1Jb8CIh9qTGLKq2XRH50O7RBY1NoC1InNURnORfnje1jX4fMmHZXPqDzzGUXkE4S1OYFl0lNjiqC1BWofmfCXcNJrC9QYjxqXdGVtwchtOEqH1xaosR7GctD/w9G9bGsLhhe/F4Dx2oJJP8XT7TKCV776aEgGvbcgu0+9IfTagsm/guAHnxSO90NO7CKv7Q2JeEuyvS1em2xubom3BtlYridJjCXSy+6payDXFuA8mA6FIG4GiisCcfDEcby2IOM3GuJh5A/zryLS43Y7bF1yYpm1Beh7jW3L2np01xbgnoRc5sVhe4kPIYAyHAeuYZzhB9/D9T6O4LWCeK7A59fkg+/hfCieqffX4P7neVWZZ6Bewf3P8NkZqUw8TN8P7H++LGDPBh6jY12FuqEDthN4KmyY9tCkvwL0lfH+Z+rdihkpf55NHmHf3zLpl6E2WaZdpPc/m7yCTrrD8nCcTJ0EvRtHvYMnW8b6JuxvYKD8Dd5DC+cY8N4DOGcwGcXBOQA8r4fH9DAuBeLORXFzQdx0FHcxiMPvpF4C4qCO4kD5THgoy6s5+EzqSz14TAjlS+1DGg+uYZzhFd/D+gafP8vnOexHhPc8ucI2nd5XTL2zBcuE+7rUPH2Y9gXm1V3z6FTZgvZqwHkGPI9MYU3PEauMiJOo08kB5aZ8AsUrVQ48L0jZ2XhCJib9jAC+YHrqsKHung+gZMg1H2Dktg1Kh/eKQx2c7oPloP+3Qff85gMoP3qmD58m32x+NOw7JrC/+IMqOs+w7/ub9J+D95t+BK7xnBzEOt3pGHc6iLvAuxbeX1VLzXc4SHYXgLzxGGgaUZ6wbTbcQ+V2cQ8V5A1iwvqbCtL4zT3/GvSnK0bQmAUOPYbAfXqjE2HfaTTpXwno05s0hT7lmuSD+U+gi6/56LpDYFLlOhuVC/NwFuLBpH+dmNd3nM7+F+qQDuemOvI2mcjL8bmH25zJPnFB+WZ7Vl9PAdc4DusKlpcmsz7lJ1OsKyb9OwG6Qr3LEbSnFPOA05ztw8M/CB50e9Tbi2+ZfM4Mn+WsQnCN3TNVlbgKziRw/IIRgy7eP6toHPN/kPpR21/hs2f78AifhWdctbZNapvqt97XC4Gd4ZNZL4cOsu9F1bVSe/BNwH11qt2Atnw6ijsHxEHfiwPVpsD3qcKum11RsuG6u/okYfoaOpyeysTD9F8Du8NfkDsL8EFhmj15Jj3Vz6TmRkz6bOM1k7+RJdXvD8qb2tdo0s/IkVdqrQH2oScjXoMOyczG617dzOtZOfJK7WOAvlo5o9MvaDvvoMlT26B5YDYcdF2G7uE0eJvr2T6s9kHp8DQyPmIEtw/4Nb9zCP6ogHmmeIk52QM+r7jSmz7WJjrOx0QdJ3g7BR66wGfh0IWaAsVTvJQ6hjmWA7omiIGPDTHpB4NyY9cU9qO/Jj21XRZOgeIpYGgG+NgnuMwHp3R1KARxjEP5VurjfVAGRanw5aXkQ20Bpo5nrELpoayopRY8DQqbMHhW7jykf9SRZUFlC9pCBM8BjxEYZ6Yy8TD9hAD9k/o4IrUt2jxL6R98pUKHQhDHqH9tlP5BGWD9CyovJZ8UkR4uGeAPuqdA3GwUB/XF5En5PyNzeNQRtYxb4PNreMX3gpa2D0p1zEfq4yZmmQ37S6orp6938K5NVx9/kHei9388z4DtB05BXETw0+kjyn07lmsukA/l13dwOqZPEfnOBWnOQPmmUL7wI7l4ylkHOB24F+J1DsDG0+5BZW4Gy8f7etdB3Ux8NOYBgPfXRvg/j9tA2FfDRwAEfdiUOiYM6ib2tyb9YYDPP6DhFvR5cPpch0IQx6ir7bm2uVSbENTmZmsTcLsK7QMPf6ihFJS53/DH76O48KhamP5EUEf4o7iwbccf9D0/R97D9mGng3Lg43aD6oPi4yKARaWH9gvTtxMywZjQFmAdz/bBPB1gbpUj5mk+mJMC+jMpJxOoPhLW3blE+hRIY/ihXqeai+Ig77jdTYH8cZ0em+qYP/X6l0Pk6wTwi9vsbPxin2viLgE+e5p3TX2AXmLJNOVkgpHNVkR5wtbl9IDyYyzzHPwIPax7bEMpQl5z+tKYRTliziXaPaqvdE4qk/clPm22DrjN1gH7pukEX7AvQI1v8DKg4W0hYa8bbQzgtsWp9hDKEbeH1Dgt6Dsa2cageAwA05+d6hgX9K0QanosbHsDjxgdHOJbLCbPoPkKfT0EpTflhj4e6kwriIfprw7w8ZR8qW0fQboPx6X42FBYV3Dctf75VCYOHrOgQyGIk9bXoP4bJZ+ZecgH6ys13qf0Fb8uyKWvMaSvlA+i6hLbT1g7xXIq9kmP+0Am/b0h+lWQh6BXBVJEemp+gWrjUg6dN7RNKBP8AVCT/sEo+fO461L2AeWK7SMF4mJE+lz7iHjeZi6Iw/0xaB8XoThqrjaM39UhyHbMs/AjsNTY2O8I6Gx5Yh6p8TLl6036HwX4eqrtDfL12WwavwIAfYd5duON1WldhjII4+uDxjv5+Ho8Fqa2Amfz3c8H6B9eVg77fbEgXZlJlC3XtZGNWffduTbi1y/FsoIygViUbwiaU8m3v6kD/pZutv4mnps06d/Msb8ZpIdW9ze7oIdR629SPgjOE94b4INwn4/Sv6D+WTYfhD9fRfmgGMEXbIup10B1mOj9xvMMQWs6wt8prS1A+Rl5wHsw/3JCjoz8uEH1Ss0ByH7OKV6j3RS1Hjcp1Vk2fn4H+3CzlqbD4QDH6Cre1qwDXB9y+nXEpfqB8FmTB+4HFvfLYMYQJnWsGvTBuP9LHaumcdcg24cywf0Pqs6D+suzQT5Uetg2wfS9vbJS40PKVwbNPWVbi8HjY2p9HudN7Teg2lKTvi8oz8YfHybcjb3mj9usFIjDY0eog/goIqotol6jpV5DgGNAx8e24Jo6tC18zCD1+rcfjzqYdVJsl9gmqDKZI/twf20MoWPYDh2A2Rfcy7U/EjSnhOuIyjvoVWdqTgnWm9+c0oQQPsNvXgfL1KTfNkCmlE0EyTRFpL+IKFeYeapsMsXbTKn1zyCZmvTJAJlmmyvDMjXp6wJkmnI6lytIpnOJ9CmiXEFrlWFlirdEm3zCytSk3yVApnC9KIxMTfqJG1GmsMxz0XPQZ+D+MfZ35T7PVQVgzvHBDPqWOMbwq0vKp+G63C+gLqlyzQlZrouYynVRjuUy6Q8RKtc0n3JNy7Fc2dYd8LqrSX9UiHJR8yQ64Ll/k/7YkH27jTlX0Z3zpXhOlOprU58QxPP7XOOb6Wh8A9Phvhq1nx3ygXXApD8tpA50z55yWgeC1vOpfnTQmCrbnA6uZ+qYI0oH8JwqdSRL2P49PDJnymYd00F+Cnx+TZ74Xq8QZcO2BccRUK5mHBGFvbmQH+w356Dx0VwgH6qfcjiSQ4rIdy4oK95rlUL5Untz/eZeUohXqu8/LUSZrwJzL5d411SfB++f9evz+LUxUB/82pgFIf2L4StqbUxQv0UHzv2zuK9AtSPU/llqvgGv4VHrMlo/XqjIzr9fPwjqe7ET3B/E9rE6oD+TAs9Q4824D+Y6oPfX9OtYfliPZl+WTndLP568rw8Yx8wFeYdZc7qYSA99juGnEvEAn8XlxnV1C/IL1BwXlgnsN8P0uN9M7YMscLKPB1JEGbEMi33S4/GASX83oWdVRDnx3E+2d6mC2m/Yx0+F8L8mz6BPv+uA9SSo76Ov8Ro5nL+G62vrn09l4rrHFycSG7uvh9cmoT7gY/spXxx2jRx/fog6bkfrytVeZeA++jNAh/G+e6rfT62pY8wfBvgrSm5Behh2LwI15zw74DlqnRTmNdH7jcfb8womP2O3JQQvfnO3PwdyfGUEzWtBJ37zC0FjgTKH9rs8eSfiBSg/x+k81oD5lxOylFjTDdtPkx2vuO1wTRfqL1zT9fskENyzhv0dHCe8jPoslA+Afm57EA/T/x70l171wXScYH+XbY/Y3/p0xJWas6F8C37fJ2gdiHrfx/CQ7d0mvBfSpH8T+IagdwcNX7J7z9s3+t5avH92LogL8z4E1AW/9+mLneBxF16vfz+gfxi0v3dGjrzPJHjHdo5t52XUd4R5Tg+RZz77e4eAeJj+s27sN/Ts7+2cvqv7e6G+hN3f+4Lnu6n3ssN83pCa8w5qs6B+DwXxMH25dwxblM9fMXIS1r/Ext5jbOo3zPkrQXs7qc/SaP17wNM/STnWN8TTfVpTh/BYeRgKQTxMP8LTyXJQDvOb1ydJ6pvc9mRTe1NtU2trTUsTPiZeB1Nn+pgrrQ+D+2dkZuTELTMdDH6RDH76veFCUNYYUSaTv9EleFxggc+v49BjFpNXOcJiLpsbVDbIP16vKUT8mGs/rMIcscp84ibylDtdp7GAcuP8/dJTNmDuFwfgw/TGr0MdLkayKJGRRSKo3opBnib/rhyDbf4fgdLhz2JBeRf5YDno/xHoXsyhj8HGfqnC6Vxu84ywT0mE9QMm/3JH1B7SfqAI8eNnu/A4w0mTm1q9k1Wxy8NVB8UJ4XCxcdWlm0V0D6sDPqHVdPWoJhTzWUBgUCLAXwAvIPKnXEnMJ1/Hyagrdh/ZsMx1LIAXP4wChFERgNFjOj2mQ4Qe0wlnOty98URDQ11jojleU9/a0t5ak8zWG+fOv6W5rrmmrbmlzq2pS9bEW3MZDeDeBhx1xwj5FaH0x4NRN16B6hWAqQM+SdWkPylgJE/1iqhyhnEDkJ9Kp7Ne4RFEd+lTfVNDc2NLY01TTV28JV5f15X6pMoNZT891TG96VkWO8GjqSKU/kxQV3i3RjF4xmBdmOqMiXmG9QN77PhjbCb9ZMDDG2jWA8oBN4mwN83YBLUUoPwch24STf7ljmgT7eL6MPxg+eCVMKERTnMBwof8lBDyMXVZSsQZLDMTBH0NTF8CygjTw2vzPLw329OtKoSpgzkdtYCIixH3jHzXn7KGum6wbgp8fg0uvodH8FA22IdB/wlXDi/28R9QnvBZ4z+wLa7on8Gc711T/Qtcf9gnB/UTYH5+/gq3Vyb9IuAr8MdDcHsFy4l5hPkVEvnqgP2VSb8EzcQJ2T358UiTF9XeFTi0PBwn3CwU1T5WEPkYefV2gmdagvxE0IyXsblin/QGrwilvzqgLSsFz8QIvnBfxqRfF9CXKSPKRdm1uV9OpC8jylXpdPZ/5llqVcLIXviE2hZqVQLKsCiVXT4lecjH6EAVSg9lRfnQEpRPtqElXsWlZtGgz4X9t0oif1xOyh6KiXIG2QNVPqy7D+TYt4Mf2i3x4SFs386kfwjw8JeAvh1syx7pH8wr9jdw7APTfx+0ZY+j+qFmQSk/GENxsC6NjKAfLCZwKXvGOkHZCkyP+9pG94t90sP+FEz/wwCdKAfPUP1L3Gcw6Z8P8JG9nc7lguMYLIc+RPreTmc5VDqdfUAfh84blgfKGX9A26T/BVEeyu/CFQUdCkEco98lv8YB5Yr9bpAMdcAyryDSQ1ma8lWh9FD+lO30RnEw31LEQ7axDfbJVH8D+g5qehXKwPBZRpSXr+5a3AKUnykfvAfzL3c667zEWDKsjhj5VMjIJx6kgxWEfAw/m4nwE08aXaki8ja8mjfVoV+B6SuADGF6eG2eh/feQ/paCZ4z+FUoTgc8joVxMeJer42EVUVgQbmZOtV2/BckC/xlK+rX4OJ7mEdYn0bng3xEV/OBWKZ/Q9mTpone//G8QjJhyrEZUQ6TN9QrPtuprQ/r60z+5Y6oLbtBOgzlg8e6VQSvVU5nHb4olUmXTb9hPhTWqohiLWTEWsqIdRUjFqe8FjNiLWPEupwRaxYjFmcZlzNicfJ1GSMWpz1y1uMCRixOG1rJiMVZj5y6uoYRi1O/VjBiXcOIxan3UfU5nGVcy4g1mxFrHSMWp7w4+yac+hXVfiGn3ke1LzefEWsJI9am0JeLqt5z9k162rTcsKLal4uqL1zBiMXpCznrkVNeUe1/zWHEimr/axEjFqdtc9oQp7w42yFOG4qq7Dn9F+e8XFTnhjj1i7PvG9U+ZhTbDn2N16w42g5qrRfuUSwj+OBc7zX4/YTwjaz6BsgK5o/Xfk089WuwcJzJqxxhMZfNDSpb0BoxXA+HMvDD6psjVhkRJ1GnVQHlhvlXBPBKlaOCUSZFjFh4bxu1Z4NaVzXp+xHpKT2pJPI2z5q67Q/iGOs2EVS30EeY/Lvy9raR21EonfmaQy+ns2309cFy0P9HoXsxgAdDpdNZ10p9+DT54ntYV+DzFYgP87/Z8wL3wJp9Ihtv70JdMqxv/absXZibyqTLty2/mhGLc+6csz8c1XkGzjJyruFGdT1lPiMWp05cyYi1KehEz1rDxpM9p7w45+o4y8g5zxDVtVLOuSdOvb+CESuq8/CcOtHT//pm+GjOtnYeI9am4AujupZ1KSPWakasqM53c7ZpPesDuWHNZ8S6jBGLU/acNsQpL04fPY8Rq6ft2Hi23bMPYuPpRM+cwsYrI+e7AlEdD3HKnnOfc1TnCzn7OT1+YuP1J3r8xMaTfVT9RJj+FzzHD5+bS52zYLD6ZsHaC2HB5/sirH5ZsA5FWNT+hwoCq8D77Y69ETA/Uw54D+Zfjnhl5ie9Rt7f6SxXKB+8Rj6A4LWKiIN1D/+n9jCcm+qYR3/0rA5lRB588kg2h60fk3+5I6ov6foZgPjB8sH1M5DgtQrF6XBxKpMOx8WIe70CsOYzYi1mxFrCiLWQEWsBI9YsRqxVjFjLGbE4y3gZIxZnGZcyYl3FiLWaEYtTvzjtkVO/OH0hJ1/LGLE49X5T0IkrGLE49WslIxZnGTllv4gRi1PvVzBi9fiJb4af4CzjNYxYnP2JqMp+LSNWjw3lhjWPEavHhjae7DnH7pxjZDPHieeQdJjo/cbzCsnaCiLfAqdjvoPA/Y0xt2jyL0e8MvOTnrsahPjxqzMju8EEr1VE3AAkV/76jCfKiDIwYaffmx3Mj11jZAm/BwG/DzBqUEaOmqhvn8Fz4XuBeJj+okEZzDHedQXAdQAGrKte4D6fziXiYW3A5F+OeJWygV6IHywfbAMxgtcqFKdDKpVJh+NixL0grMWMWCsZsS5jxFrOiLWGEWshI9aKiPK1gBFrFiPWfEYsTr5WMWJx6j0nX5yyX8KIxVmPnLJfxIjFWca1jFizGbHWMWJxymsZI1ZUbZuz7TD9CeqbfeZbFNR3qXqj/Khv5ukg/D1U1+CXyuCnz1PJ9l00k3/Qt2Hxr8HCcSav7vp2K1U26tutVSg9loEfVkmOWMLfiE3XadB3nWD+FQG8UuXA38jL9bvSpQF8wfSVRN7mWSND+I1CRhkmgmRIfeutK2fRGLmNQunMHrleTmcdLPHBctD/o9C9GMCDIej73NT3R02+8Lt7Q0A8PsdmCMgrRtzD9gKfH+KDRc016HB6KhMP08/35heob+QNJfgL0t1hRPqhII3hh5LNsBDP6VBB5GV4Mno/HNzn9h0wP8MvvAfzL0e8Svnw4YgfLB+ssyMIXquIOGxHI4h8RhD5UFhDEQ9Qt7qp/hJdrb+hMvwE1t9QQq651h+eyx0hUg631fA10ukcTNzmIG+sC6NAHLQVHGLof1gm7b/eRt/EdAgskyfUMcNbpdO5vmE6P59I1VUV8bxJV+Z0lgljfbRjuTpE+avBvWtTGT5woGRu+NYy/zwHmUO5VqM4WO+jURzU2zEobiSIG+tdVzr+OleA4kwZ8T1cj/D5zQPyGZZnPsOIfCqI5wp8fk0++B7OJ8gehzLmA+U2DOUzjDEfKLcRKJ8RjPlAXRyJ8oF9fbgu9CxaFzLPwb4afPbQVCYepv9ieAbzOQ/T+JJqwBefL0m4pmyjnc7BxI0BeWOdHQvisJ5tAeKwbowDcVDmOFD+qdq71v5p2MgMLk6HywHbIexngvorQv270P0Vk3939VeC+vk6BPVXzLOUPZk120pCrth/UzxQfd6u+iHZPlP4ujX5d9dYYkRIuVL9uhFI5jDOrPVXOv46EcRD0DiD8v3Gdxq7/9QbbGrf+fagjmnM+1PvgnX3v6J1d5j/WSmHlIEO+MzYaiJO468YkuEZ+ptCUGb4Tfi9Uh15NumLPKMx+gr9LZ9+1NVjn23ygHmPE8o7rK2Y/Kk2xPBdTsQV5sFre0tDPBmvq2ttq6tprq1pL0D4hld8D8+djCfSU+fpGllv6YjIOmHsJZbK4I8HctWhEMSNQ3FFIM7wqNvhO0d05H+8EP9h5A/zryLSHwrKkEtdUlh7MWFBf8CBVdJFrH5OR3uCPkfWByVqKB9kAmXzlSgO6lwVioP2BOeUcaD6m6a8Ws+TOfQ3Yb/Z8C3rSxN1WBYOwdeW4B5u67YCfMH+Mg6UnEyZtJweyUFOUJ+2RHFQDw1vsj4mUU/JCfMM5YT1cAKIw3q4NYjLVQ9NeXPVQ6hrkG+IWQjujQUYR6Q2/Bah9OO8fokuw9jBHfMbDfIweet0d6J0WxJ8lxF8bow5fpN/uSPZHmf65VshfrB8cL98AsFrFRGHv8MxgchnApEPhYV9mEwdJRorCL4cVH5oR3jeYRsQB+sNB8rGTJlynW+GNmZ4qyR4gOlwHQfVO9XGm3SmPmC5GeujxZRxW6dzMHHbgXu5zjcbvnOdb4Zy3Q7FQd3cHsVBnd4BxUG9invXlU6wXsE4U0Z8D9cjfH6bgHy2yjOfrYh8KojnCnx+TT74Hs6Hkk2Qn+9qPlBuW6F8tmLMB8ptAspnAmM+UBe3RvnAPhycbz56cOYZ+Bycb4bP4vlmk/4tMGdyHJpngHawsXwJpbPbgzisZzuAOKwbcRAHZY4D5Z+MLHKdb4b9U1gmyHvYfpdJfxqqJ6F+UrwfKhcl057+m3z/DY5/sO/Jtf9m9DFq/Tc8X78x+m/QVoP6bzAdruMw/Tf4fE//LRPX03+j8+npv3Utnyj03+D8Kuy/XROi/0bNV+P+269A/+1a1C8Qmhuzsv8G582GdXHeDPun0SCOmuMqQHn79fMOTm34xfNr94H5tXsG+/M1GuSdGNIxXU//zK75NVOXPfNrnfmB9hbUP4PpcB2H6Z/B53v6Z5m4nv4ZnU9P/6xr+UR5fu1PTPNrT4H+2Zs982vrQ1Tm13C/y6T/d4Tm18YS5ZfdHxS+/2byL0e8MvPj4vo0/GD54P7bVgSvlO/B82tUP3ErIh8KC8+vRWV/Ap5fg/YJ6w2HbGOpXPpv1D6OSoIHXB9jET9+9V5FPI/3LcFyM9ZHE+7bOET5YV8g1/6b4TvX/huUK/bzUDe3RXG59vsqnWC9gnGmjPgerkf4/ISAfMbnmc94Ih/pfshYlM9Yxnyg3MajfMYz5kPNY3d3f3Q0eA7238aivdfmOdh/g8/i/ptJfzfov433ro0vgX5mY/kSSme3BXFYz2AfCesG1e8L65+MLHLtv40Gcdg/ZZvjMvUA+5189ZBMvxflOp2DiUuAvOG3fHCgZGb41jKbu3kGF6fDeUL7TqA4qJNJFAfttQbFwfquRXHQ39ehOOjT6lEcHN80oDiov40oDurvjigO6u9OKA7q784oDo5bdvGujf64II5RfxJYR2AwcUmQN7bVGhC3BYqrBXGwXnGg9M6UV+vdX0dlcHE6zCu0M8O3PvfDvNN1atvU/dtmHNU06fTWpqmnTz77sLZzz2+bMrUQweKmDr9uMt6HXYjjBLCrQy8UF0fx5jWdXg4dKojnTB5GbaDpb4zhl8m/3JF0g5nhVwLxg+WDh19JgtcqIg5vh0wS+SSJfCgsoyuVBPZAlE+ur1YMJHiOmgsZiOKgC4H6gUM2N9HVbbCGt0qCB1zvccSPn35R22BNOlMfsNyM9VGL3a9DlL8O3Mt1mGf4znWYB+WKm2iom7iJhj4MN9FQr0wTXekE6xWMM2XE93A9wudrAvJx88zHJfKpIJ4r8Pk1+eB7OB9KNkHtSVfzgXJzUT4uYz5Qbri7mWDMB+oi7rqOBs/BYd4laJhn+hZhh3km/RowzLsUDS9kpjVz8yWUztaDOKxnDSAO60YjiIMyx4HyT0YW+QzzsH+Cr12fk+oYB18vH4OeqwZxBh++dm3SweP68LEh1BFBJg4eO1MN8B/z5lKxDl0DdOgOpJewjxvU1zDpqVeFtyDKS02f4ilomWmKaOmvidsRxOU6rQ2nMNzqDC5OZwJVz9RU9WhwzxxtSNnFWIBr/BqejroX6NiTKO+tibyh3mEdo5a54ZAd6xi1zC28lNlMTZ2bQE0X4Kmw7UAcHl7D6QI8FQanC/DUJmx3oUxwyLbMGVbHnvSZyjR55KJjWwHcsUjHDG/PAB17EeW9bZa8sY5tR6SH9WXkXul01iPzbBnxHKOOtVYQvJpA6QqepsxVV6h+OdZb2C5DmeBA6ZiRUy469mIIXwLbJKxj1NZ5uI0C69hLQMf+HELHYN656phpZ3t0rGNcd+vYn0PoGOwTYR2jXq+FW6mxjr0DdOzjEDoW1B/r8WOZuCjr2MdCfgy/bmnGCn5HOeFxpknf19tHK3ukX+Yop9FOZ1mZvMcI5V2A8nMcev4aj+cgP4bvciJO4iinMYhXfA/7A6qfH3SUk8wYjD7KCfZzdSgEcWNQXBGIg+MffJSTzBxI5iinIPnD/KuI9Pgop7B1KYkF/QEHVkkXscxRTqPB89XeNXW0bT+UT65H28LnTbqoHV+Kt106qIwwQL61XZxZncHF6XCe1NxVmdO5PhhlkcDlpWQBbRkfWwT9VBWKg/0vPFcG281icI0DJV8jCy3fKdUZXJwOl6MaxOFtfjL+KrfjyXTAR2tBOeV6tBace32ki3Ov+PhEaBfdM2+YqKXkhHmGcsI6CreqYB2F8zFYR+FWlVx1FLaNuegoNS+LfSvcnj4aYJjjHyqdzvWBj8ql5pepuT/qqFyTjspnWJ75DCPywX3i3T1mdJ3s5l3jtQEoS53uBZSu+48sDb9Pw+Rf7kjaVWafBrWvgaojytbMs9QWT/yaI7VGQc3TUFimLqn1C6zbVF87aPv3UCKfKB25CHmk/BbUDxwo3wSPXHy7i1vDDW+UD4DpuuID4PMmXZReb9Uh130a8BXWz7v4CoTfUQH6Ot+t+tSaTb6vuQS9vgHzGZdnPtRRlRXEcwU+vyYffC/otR28vXILxnyg3PyOr+bIhzr6mPJL+eYTtO0fjg3hPo3pQzPPwOfgPg34LJ4/M+n/Cj6PMRPNpcm8Dpf7q/JYZ+FWZ6xn1DoFnsfFMseB8k/wWO5hXTyGF5YJ8p6tv1qE0i9E9STUHyNfp8Qy7eknyvcT4ZgS+x7OfiIem+TaTxxG5BO1fiJ+bbOnn9jTT+zpJ3Z+vqefGD6fKPcTn2LqJ/4G9BN/gPofQnPDVvYT4ZxyLv1EuLaB/ROcszPp4Jwdbq/9+pP4eA6T/tdgvvCXQ/35GgHyPmpYx3Q9/UC75gtNXfbM43XmB9pbUP8MpsN1HKZ/Bp/v6Z9l4nr6Z3Q+Pf2zruUThf4ZHDfD/lnhsMwz8DnYP4PP+vXPfgD6ZyUeZs88XscAZdGd83i432XSD0T1tDHn8UYT5ZfdtxC+/4Y/Qzlahh8X16fhB8sH99/GEbxSvgfP4+XzKcIo7s/R13h+DdonrDccso2lcum/QTnjdxUgD7g+RiN+/Oqd2k9o0kXpmDodcu2/waPoPu/iUcJ+Ry7CtqKr/b5KJ1ivYJwpI76H6xE+Pz4gn7F55kPtXZLuh4xG+YxmzAfKbSzKZyxjPtQ8dnf3R+E71bD/tjfqv5nnYP8NPov7byb9faD/th/qF8i8V5D7kZdYZ6lj1ql+H9YNqt8X1j8ZWeTaf4Njbeyfss1xmXqA/U7GemgzfGzvdA4mDr5LlOuxaIbvXI9Fg/aNjxyHOhlHcdBe8bvmsL7xu+bUOTdUP8K2o9aM/sB3xRj1px3rCAwmDr5vhm0Vvm+G3yGC75vBesWB0jtT3lyPRYN2ZvjuwrFoo9H/Y9D/Y33YzedYtO1QfNhj0bYj8jBqA01/Ywy/TP7ljqQbzAy/dkD8YPng4Vec4JU60ge6eRgH8wk6Hgti4VN6ITY+Fi3XV34GEjxHzYXgY9GgC4H6gUM2N5HLMA/KHH/1AvKA6307xI+fflURz5t0UTqmTodch3nwKLpchnlQrriJhrqJm2jow3ATTR21VukE6xWMM2XE93A9wufdgHy2zzOf7Yl8KojnCnx+TT74Hs6Hkk1Qe9LVfKDc8FdptmfMB8oNdzd3YMwH6iLuuvoN825Hw7zRXpqwwzyTfi0Y5t2FhhfQz2wsX0LpLDx+D+sZPDUX6wY8qgrKHAfKPxlZ5DPMw/4J9uvwsWjw2LJq9Bw8tgwOD/GxZQb/he6p1/TxFNVOZ5nIvhabbA1jezB/akhZ7V1T0/r5HEmQaGtuqWtqak+2tMdbmtrbsM0aXvG9XiB/TWOI9P2J9MLHGjYZvYdHEsBhmg6FIG40iisCcXBKHR9JIDPNlGwKI3+YfxWRfh9QhlzqkpqqxK/+h8Uyr/5Xg+fxK7F4DKqDrB8IP44z+ZcjXpn5SY/jqHFPISHXigC5VhFxeBtUNZFPNZEPhWX8ftSOVMDboKBvgfWGA9WWVnvX+YyvDG+VBA94fFWI+PGrd2p8ZdIJT30nsVwdovxwaSHX8RWcps5lfAXlipc64Gu4eHmiGsThafrRIA5vZ4PyhXnDOFNGfA/XI3x+TEA+Q/PMZyiRTwXxXIHPr8kH3wta3i1E+RQy5gPlhu1+KGM+UG7VKJ9qxnyqQZrRKB+/8dXXTOOrBWB81cu7Fj4iJidfQuksXPbAegaXPbBuwGWPanCNA+WfjCzy2aaO/VNQ3wfq3sbo+5j8u6vvMxTx49cGUv7bPEvZEzziBtttrn0fPLcs0z9NxCkf46DyQ9vEW4j82igcss0j5NL3gfpqeKP6Prgty7XvA5/HfR8hf5XTkVY65Nr3gb6lq30fvGWAOvaG8klh+kXUVjDc9xntdCwjvhfUho8OyGdYnvkMI/KhxhYFPr8mH3wvaLzcXX0fbPfDGPOBcsNj9s0Z84G6WI3y8ev77Do88wx8Lmzfx6Q/H/R9dkN9HzgvurF8CaWzsF+E9SzstlIocxwo/2RkkWvfhzoGCfNeRKQdguJM2oNAfZ3nXVNtTB+nY9wQENcbXMN8oe4McTLh9BTN5+Fe/lomfxhBY/bywTT6SM1TwjZNh0IQx6eHLa7m+1HQ1mD/UZTqWCZoTzEiPZ4LpuayoE3hPhvUSdxno/oIsL8Ij1BenyaVed7wuDHkCXkMI0+YPld5GhlR8hyOsIYRWFDGQfI0PG4MeUIesTyHZykTliclfygnIyPq1cORCIsau0B7x3PxBruYSI99Ekw/GficqhEd+esDnse60JvAhj40yM7KiXJUoDj4rMYdNagj/9Ve3DTgv+ejvKk5rSB7GEukh+MeU1+ViAf4bJTmTKm2Puw8B27r4TwH7rvB7Z3V4BqHbHO0YY/Dn+/TVzN5YFvEOjaC4Bf2AfF81iKgY2tQ3pTOUPvKTHrqtSbYN8M6NhrE4deTZdY6c3/dCM+lQT3COhb2NfNqFEdtcw+rY3C9NayO4XoejfLIRcdGA9yv0X4FE3ct0LG7Q/ixIB3L1Y9BeXaPH4vWfhgTBz/dlquOdcWP3S2kY7cjHTO2+gDQsadQ3lsSeVPrPyY99do8tG2sY9Rr88KvRjdUELyaQPkVvGZHfTbOxMHXD/A8GXz9AM+TbQfioExwoHQMvjYdVsdwPVOvu4bVsXEAd2+kY4a3HwId+xXKe0KWvLGOUZ+5gfVl5F7pdNYj82wZ8RyjjjVVELyaQOkKfu0pV13Bez4pvaU+eRRWx4ycctGxX4XwJbBNwjo2luAXHsuAdewVoGNvhdAxmHeuOmba2R4d6xjX3Tr2Vggdg30irGObE/zCo9mwjv0d6NinPTq2SejYp0I6Nh3pmJnr+S/QsXI03zuKyBvOR2EdqybSwzlPMw6rRDzAZ8uI5zbmGjSeZwi7Nw/PXVDHhVHjWCgTHCgdM3LKRcdwPY9EecC60gHrWCHBr8Z91psfK0f5mmcmev/HcwyJ1tY2t8atb2xoq6lpbaylPjNldLG3QP41tU31LU31rttY47bVuFnz13UxuD8tT6PPJlQQ9wyusYUi9OzELpYDi7UA5ec49J4Zk3854pWZn/SemSLED5YP3jNTTPBaRcRh/0PVSYHTWf/D7N+IEfkEYVHl6eNk5runTJ18XtvuTedMOX9Sm4MC1pUC9H8vn/wLiOedACz4jIRdtdTWNbco44q3uev1sbvtura1uSFen2hqbG2pa03WtnR3/m3NNY31zY0ttfHWeKPbmMzFr0juwdDh3NSGX+ODoB1x+iCDX4L4Y8JP77cvIuRk8i4VKVt7e1j/avIvd0T9fdq/liJ+sHzw+0xlMvJp6+tkdA/6rGJCNpiPEsRjuRCP1Fqx4cnEFYI4w4dOc+jojjz2EuJR1kbbW6k+Cty3NBH1J03dwL0nUO97gXiYfs8RGczdvetKp2O7BP1UbxBfQsSb/0199SLS4nfASpAMKbnC9EYni33KWozKatLv75VvvZ70pzGh/CBfvXwwDwKYY1CdwPXuIJs36XsT6aGNGX4qnc622Rs9B3mHn/LG96j6KUBpcRts2in4nN//ZQSOHw+lBA61VxF/ihjmSfX18FgqRuQDbQq2+WVE/oztQy3VVppA9bULUBws+4mpTDocqHGsKZMu7zY57BWmbI2zb2TuF4H7OF/cHy9GafF7ipDHIgYeq4h8ihFuSQD/BQinkHiuwqHtkfoNy28BwW/QeLir+UCsk1Id84H1DNu0qch/Qj8eI56dmcrEw/QzQJs2LWSbhn0JLMPJqcw97LNxPxbbJN6vhdsunAa24zD9HKLtwv4BYul7qRB9BKrfh/sINwB5XoLkSfUBKp3OssE6XIbygv1j075gGVwO+Fgwwj8vI9eKgDLqe4tH0OkgDzAdxqDaToNB2bV5rpLgC9se9h3FAXlQ7RmVRxGKy7d+qHYb9jWoPgwVD9tzmA++14tIn63/Ue6DTeEWEziUny9FcQVEHPZhsLzQh+G+CTUmg76Rsju/ugvqe1O8h+lXFQfwTskP+iHuuZx4Q9yNt9TXtre7rXVNzTXZ5nLM/ZJUx3Kt/wX3ikC5dCiF6VFcGYgrTHXMv9z7vxDkA7EMH0Uo/YOgrnUoBs+Y56uI/ItR/h34Ju5BXcNYMeKeSa/r9B6PR4k5ukRtY0NTY3PcTbQnEsmGumz1SskJzh3oYGQN66KYKFsRSv8kaHO+j/rIRUR+Ot0vAtIV+PyuxyDuFaY63qPqCOquSW/yLk915tHE9QZxRSifPt7/UF4Qy/BRhNL/FOku1DfzfBWRfynKvwPfxD2su72J9L2J9OvXzJA/gmXnnvtbnyfCh/cwb78QtKu6mjq3oaGpoaWupb2xpqW5u+feWxrr2huTyWY32dja1ujWdfvcf02yud1tV/P/yfZ4ssHt9rWPpnhCrWU2N9e6bU2Nje3dXn7Xddvrapob6loSaoqx29deatrrm+ra6+O1idaatkRrU3fn31Tf1lhTl0y0JNsbmxriDd2df3NrXUu8Mem2NjXVx+vrGnJZeyoA+ZsQczr3/0yfzPQTc10j7RWAVRCAVZQFay+EBZ83z1LzA+l2z+ncD2f01TVh2mOYf7nTub/eXevyUD5dXZfHc1HUOKWYyIfCKmDEwu+NQOxs67JBeiO0fyK03qT7ME736E0M8ZNNb6h9GdQatTlTPciHBO3ZkMai/B6es6NkEwvIB9eVDmH2EEmtGYTVOZN/d+0hCrvnBs/Dw2fxfIsOWE8on0itq9mCBf0ctY5yVqpjHOUTqfmjIF018+7Yl1Y6/nWD/TvVhkN+8bx8tbdxkdp/wqiP5Cf38N4FoX5EHTWXbEIFUW5c73D+ENct3hMC46j3pwsIHmLofygLnXfr6AwuTmcCpSMFKK6YKAc1d4nbmgKCr6D9KkFz4FQ7Yc6eLkCYjhM8x0n1gbP1R4L2Pwnt7Qp9JpvJv7v2P1F9Qso3UjaC65qynwIUB/MpIfKhsDAPUIa4/oT6b6H3B5v8ywk5SNQfZScFhFypcUhQfz89z+x0tuON6ZfxmJRaKysgsCj/mp57V7RudAYXp8P8QB3D63qULhQ4neslqK6qfJ6HPATZgFBdhe7f4jGVtA3EQsqV6t/idg76PrifCsfl2ieNOpbkXhNKf2HbD/eaNI3s+Ix5Du6NgM/ic99M+ltGZjBbvWtjo1RfvLvGp8J97AbsF2HA/VUdrktl+MCB8pmG71zPsYRyLUNxsF9cjuKgrfZGcbC9wufBUX3ZrvZFgvZxUPtsuppP0F4zvH+C+jX54HtBfasw8yYc9t9d52Xi/oH0nkKqPYb+7FLkz6i9c/DZw1OZeJh+BfBnC9F4XajPm5MvoXQWv4cA4+B5ZVg34DlnUOY4UP7JyCLXcyyhTpgywf2H1Hsi1LxtgdPZx8YQBsyPGpebZ2XfyYk3Uu0Blgu1z52qQ1y/1Fl1Jq4CxGF73QzEQZngQNW9kVPY93+xTRpcbJN4P1UBwSO0dWosgNsgqs9GvWcc1JYE6R+lr0F7Qv3eM4LPQZ8F+cc+y6S/x5MHfAeDeofIyEn2vMl4LXXeJJRrEeIpSIY65GrzeN4M+s4w82ZUf8lgwr4znPPC6UwdQd0x8+W4D33B5hnsJ0Z2TGPwngbt0vdGduQT2tARqY5x1DyEvjfFy5Nq2zRN9P6P5xXqm6j5Zj78RGtQv03Wr9e0FKD8HIcep+N3LYXGJG6u9kT1LfDeXmhrl6Qy6fzssIzIh8Jazoi1ihFrISPWLEasKxix5jNirWTE4pQXZxm5+KL8bFR0dQUjFqdtc+rEMkasHv/V478ky8gp+8sYsTj1fjUjFqdtR9UeOX10VNtaznpcwIi1KbRDm0IZOfni9KtRbLf1NR63R0W/OOV1NSPWYkYszr5JVNu0HnvceGWMaru9KYzTOHXiUkasqOr9VYxYUZ3rWMOIJemjTVpqj74OZo8xXgM5B605yOy5rWml1tMLnI55lwnlXYDycxx6TcDkHzQHX07E5fX+pduebIs3N9ckmltr6+rqctUNk546141aXzCy7i0j62ZqjRPua9KhEMSVobgiEGd41LK/c0RH/mXOeaxpDiN/mD9lm5NBGXKpy35OR12D9kitK56d6hgH1/LNuiZcV6T2oxUgfLi+Ctf352ye4RU+B3mE5aPe+SwA+VP34XUBug/zhfkdnOr4HN7zhHnB5Y0RfFKy6EXIgtoTgfeCQDuFZ3tR72bEEO86lBG8MK5PtoX1jVF9b0/vtTFn85/aNvWQ85snnd6yf9uMKbud3XpI03lTT2+atFtr63ltU6ZgDYM7c3BpoTSoNDgdTk9pI1UK/CYPtbsBa7Ef1l4Ii9qxZ7CynU55KMKiTlGidnngXUvU7htqJZzCx/VRloXnwxHPficG+7WWEOs8hEV5foPVOwvWFIQFn8cnpPbxyQemgS13HyJvCh/LsiILz1NTHXmGfFUgrM2yYJ2PsODzmyGsyixYFyAs+Hwleq7KJx+YphLcryLypvCxLPtm4XlaqiPPkK++CKtfFqzpCAs+3w9h9c+CNQNhwef7o+cG+OQD0/QH9wcQeVP4WJYDs/B8Yaojz5Av82yY1nQguM/YeoUeaZj8u6s1zSZXvPtoEMFrFRGHd/0PIvIZRORDYRUxYpUwYpUyYpUxYvVmxOrDiFXBiFXJiFXFiNWXEcv4QuObYN9sovcbzyska/CudZM3zBfKemOMMEz+5U5n/ZbwiVRfA8oHz5j0l+GnNai97k/Ix9TlQCIO6yPctQ7T9wdlxPoI9bYI3fudN9SqIjCxz6XaHHgPjqh/g0bUUm984bfoeoHn4JtLb2zesSzmOb9Tv01fqgilf3lUBvMvHib1tmXQm3V4tobjDT5GX9OKbxjsQagMXcRHwa03dTfY6RxM3BCizAVE+hj6H/Kd61ue0F8NQXHQPvHXAqGN468FQvsyX1ykdAT3BXLVEfh8kC5W5plPJZFPd9t8b8Z8oNywf65kzAfKrT/Kpz9jPlAX8XjKz1cWjco8A5/z85VmDFeE0j8HfGWpdy07XnPr8HgHBuxnKJ2Ffgbr2VAQh3VjGIjDY2EYKP9kZJHrW56w/gejuKA3dYT6YaFPBTL5d9ebOtR8XtCbOpUEr5Td4nac6n9WEvlQWGbeowxhO3zyaN+IY4bQJw5FdcxAte3mWcrXxrpFrm6SajMcxDOcU8M+za+/jwPlt9Knryt6u4unZxjeurufPADlM9H7P55XcGuxXB2i/LBtujaV4QMHSuaG71z7slCug1ActDHcjkC9xX1gqO+mbaTmcfE4kppLhveC+n4DAvLpnWc+vYl8KojnCnx+TT74Hs6Hkk1Pnzl7PkF9Zr++7AGoL2ue8+vL4hOYTPrvgr7swagvG5VxMdZZ2F/Fegb7q1g3hoM4vEYGQ7axdi59WdgODQH4WL9gOr+vaPYm8sO+gWr3zP+VPvnrcHxqw28ZETfR+0UVmWhpd5O1bfW18bqmmtrWumSiNVEfb62pbXfdBjfRWNOQTLa31DS0NiSS7Yn6REuQzxFe7wp90jhe75JpT4PXuyhfnst6lw749LkorN/oYHZ6humzC+lCsqu6IN1np3QhqM8edu2Tc40Rt4NB43GhMVdoW8ZjLunxODXmomy5O/Tbr56D1o0Gy/CTMPwMIfihxjl6zbLY6axDUF5QJyHfsI019/zqhvrSaKXj+Pb9DNaALFh4fxs1HxJk8xAL72+j9pEUobjrQJ9u3qiOacyeq1UgzaXeNdUvwzYN+2Ubw6ZN/uWOqM66QToL5QN1tsQJ1h1Yd357/sqJsobRZchTvroMsXLR5WyyCtJlPAYPGuNR68lUm2jwtY5fM6p78eFuajxGgfWJ1y7g3MMggH9TAH5pAH5ZAH45gY95xqeNwbzxSXK3ehianwdG+/OET+UsJniiTjasQnGQJ7+TSyn5QNurQHFQrn6nlFJyhTa8GYqD9tcXxUE97IPi4F4nsyext9N5DP8Q8OXP+qxx6RC0ny6ozwDtwaSvdPz1NWprYXj+gFpzp+YWsF+AcwvYL8C5hXzWycKciEnVM7UnB87/BH0puT/AxfNKlD4E6c9gIj30mVh/oI6YZ6O6L0NCR0zcCBAHZYJDtrmpXE5UpXxDWJ0xz8J1daq/gceelSHz3Jj+C+cN5+Mg/377A14H7WDQiapGTqbtKARxnPsaqRNVoVyLUh3LHSRDHXK1ebyeCH1zfxQH9cVvXwfEhHvg4Jtqhg/qKxIQE94zNmL8j9BXhkKPdfBXhmIy/AR+ZYiyNarv0t1fGeLAMrpRRsQxyjfnrz3kunba1a89wHrB/VkoZ4mvPeSrE/D5oH2A+epL0DhOak2zAOVTwJgPfA7bcy/GfMKMozjyCfrag9/Xa/pVZ56Bz4X9eo1JP7o6gznQuxZ+C5r1aw9Yz2C/DetGPl97MLLIZx8g9k9QX0y6bF+CCOo3Uu/slhJl+KZ8CQLXPaxfXPcVIC6qX4KgvspAzQXBkyKMH6C+4Ep9ZS/M14RMmaivBOlg1j+LUPqG6g2/sifM0F93xe/6lYAyxJzOMsf+0KQ/rHrDr067U3VHmVEnWwS119S78bge8Mk2EN/YAfTppQFlMOm/Xb3hN9vYzZRHeOxWQ43d4JkARamO5ab2BMP02O9R7+VDP4FP9PdrB+D/EAvKHI/toS1SPhd/DcOkP7B6w69OWzWiI39Qr/HJN1RfjtpTib8AAnWrDPB8RvWGa+HxYj3V3zSBmtPGvh3aCfbtuX79qYDggfLtRha5fhWZw0/g81KiYrew3cZ2S53zEXSKVjY7N/1dai8j1m+qLcjFZnTYB+VHrb9Am8EnCxUQmDGnI38wn6CvROL+Hk5HfdXNL28sd4hB9UVNer+Tk2A7ap4Tnn8Ivd/J5F/uiPozF/czoLyhfLCvKiV4rXL8/V+B07kNotqlXgFYmAcoQ1x/vWTk9Y35qjXlv6n5j0IkV6GxdM7tKp5fwP1mx+lYfigbGGCZ8vmqNV7XDtJNIRmG1k18Kpu0blKnsgXpZjHBa5XT2SfhLzFTX0gV7g+G/sI3Xj8Q0oHA9QMon66sH+iA9zJ3dc7fBqygfkKYeqfyoXSbmouFc6S3Vmeegc/5fV0Sj6dN+m+NzmDe4WFSZwgaHqkzAfHYPtcvqVNnFQrPszRRY3UT8PhKh1y/8G34znXNJ9e1G8pW8Z4p2Eaa+UBqjibfr0FQ+6+ofIr/v72r+5Eruep1+07Ppycz2fHaXu8SbOUBSFaie6Z7PnhhpZ2x17BZnP2IIRCgp6e9a7DGSnYchQdQI5544R+JhIiEeIqExBuR+AeQgBckRB6iSFHe47Lv6f7Nb363+ra7qqfHOyW1+t576p46darq1KlTp86dsBxl21VruEnHpeLNtPdIUsmZae2VsQ5Udl7uJ7eG7+B7Zefl+Gu5lv+3bw9x/keBM7HdfyxZovqsstkp2z73DbTtj3uGGm374+z5oKzmmKMz6MtReW39qvhy8Fwcw/9irQQ3Xit9fi5QTiZoTvvlgMa2kqmWFJ8zgqm9jqrjzeo0bswCtU+15sp5mBHM6OFnIR2Mx+al343e877Ifjf5hOXkopxXxe+G91nyiOWofaxp65RlOtjq7eE7+F7VmAWW/63bQ5zrxfWr4nfDfeM8/G7Qxhjyu8G9Dm6jr0AbvU3truzxai7PiAbMr2z0XwTfHO4fs+Kbo9pZ6aBVzxegbwDLDbVXGuo/ob1S1X+wj6CPPr8Xsf8cKpuQJdUPeFyO2w8MFopziXGokSecVP8xPo3r26VkQ9U+g/vMtt4P2RqtTKWb1EWZIXmENHL/C+3tY1mq//G8Ye+pGDE+sd3C8t+9/eJ/lF8TrpV8mgNYzD2M8/SPQJ4p/wj2eQrZA+sCJ9rPB/5C/WG+FPtvxq/cDcfjXPEMy7c2XwSY5RvMlWlobRitywV+68NYJtalRvn5uk7PujBPYB2tHvgM8Vv+FYANfEngmdE4OHsEsJX+eLgWCdfCBLiMrnWRf+El6VK45gnXksCFz4y/fjx8UrRNmV9M2T7UpyU6RdV9KMv/N7eHOP+iuFZ7TVY3pUuynqDWu6P80VhuDXjpkuoXlfeMrXz19cgUdkol15UPUOIYvy2jR/nDqnnGn+P/kjvbZuqbV6ib8re/1NzCfX0Ub9R+EttwsY3Z/0+t90J2mJCP34oL+9CzzqXGMb9bxgulo7FP+t/dfvH/PEYHjXtl+1Hjl8c9jwmEYV9gm6fqW8oPzfKvivzKHqDOXa9WwLUQKFt9K201UDbShe9y2WVjROmixpvz0EVRf6z3T/Mm5DPvUxVeqnZcp/zIu5D9VY1jju+N44/HOPZTjAlj40Xpurg+tzla+fOO8sNif16ks4rfB+K6Q7hC36hUuGoBupT8VPZOns8T7TVVPkM+0JHd2T6SYj4fxdeQ3x2Pg9D8Me7cqHygYuDKqD7Ie7SP8jcyjY53ivvGmGlns9vubLX3Gt1ee6ezvcPnuhyVv1dcLxEsdj9YEvWMhX+30dpj+2pk+rcS7yO0E8uFhs0J+/0hfiUHc8rH73i42gezPCl93p+1c2o+bU3jzEWZbFE2o5A/cVVZP6v+vkpuVvlmdFUZPKU4HltV6s1t+jxPfwirEWwOYPMEQ70T/TtuQT4eg2xrQNu86TQex9cB39vFtfEvpexOqIM0Nlz5HGzP0M6m7F/Gc2UnzQmGtq65/ulyzCZpZ6gZl9HBNsyvFffKxsi2OSyfbXOn6BbPmC/j2PK+WlyvuKE9bwvwlY0RpQcqGxye0Uw4njdDaxTly+rXbBaT6vOTJ9/r3Ts++EGv+/Tk0ZPjdzvdz3qOEjt2ZFD5sokZK6pw5PC+Sr5BUi6Yd3aHhnwbEHWi01H5dcq/W9zHVoof7nSaD7c6DzvtztFRq9sZpRRbQL4LrhTvTkspTrWYTeykK5ViJXCsD5shAa+NJstzF/LchTw+hRRnZTQ4IBiOpTsEQ2Fl5XoBbIFl/bX1+8QT+u55Tug28ZhA9sL5VnF9/OTk0cO/Ojj+7tPe097R/aeHjx917zw97r4Q1I8fO0qsdGd0zwYelslzAg8nfC+DOsy6rLaApuctq39SAC62rG73piWrU/KH+3IKWf2H/SF+rotPSsbaOywPfwPe8emPAHdGsG+Lcg32x31Nh09/AjAOQPIdgPFiNcWc96yf7SVWntsbrlxRtj7+bj9J2ZuGfz8N/oEMsHnZxcPdMNyoV2QJeHM3Df4Bb95Lw/stw38vDf6W4f+9NPwZ0P/7Sehv7hj+9wG/c/H75zfS8GeA/4Mk/Bni/4M0/Bn0//tJ+LM5oP+bSfBvD+j/MA3+wfj6KA3+tuH/OA3+wQbTJ2nwD/S/b6XB/9DwP0iCf6dl667/LfCFNsH536dcPBs4erq0umvmzq7fqhgnkWakrQxXLnCtu9G6LK8r1b9z1XiYSD8PBthR9VbOGMzDcQ/3qg2PEC7Vtpa/Pmb++THzq8MFeSD/qAMQnD/GYYRQ/pUx81+pmJ8PrhgO54ZrI3SEiqhD7VYZU1j+MtGaakyFnO6Qd57H1k8+7Z188OSk9znSjbiui3phvTEPf9Sa87FOyPYuNabw+XzJ84WS54slz5dKni+XPF8peX7F6bTfP33/Ad3fpXvT9dfc2ZTRj5+nundTLCsGrSgX+Tqj5/YM5YoaL/v9F//Kia9G74XKYzmG+R3R5EryZoH3kOZ3ieZx9YXUQRMzKs85LTs54N+s6CPKmZUD/qH8wnU2w3LxjHUVhB30X/y/yri+kYCuSZ2jVDk8PpBmu8e9ErRX8FhjefFOcd+YLKV2gtuuU33NgcHP0/9APFF6L8qtkCN3lQO3iOse4VI2ZntvsaQclNsqYBjiUPhZbi8GaMY+sBYo0/ItjcAVOhC8VIKr7GMN1m9roq5IR+IDVl0+xI5JHWIPBSNT49tSTvdYJ8/HnwJezsf0IK9XCYb7ofzB19C8nOojAVXn5VkPRLYiaOVD2j6hfZdhuXhWK8HFY3VSXIsRcVVZi1fFtRQRF39YQ82lOIcoXXZcu81+/zSuPIBrlI2Gdexxg0MgLp73yuaSsjkEcfG8N+4cwv0FcVWZQ8pw8XyUCVxLJTS8U9w3JkqtbaULxcO/3V0q4U0k/Ds8bzh3dm5IM/c2Kx/+tvKXidZUc0PVjxWpADh8wFF9wCwjGJZzRZSzLmC8DzcJro8j4VLjYBK6PopEl08fRsR1PyKuBxFxfSsirlh1VLJrVvpETN7H7BMxx3ZMuj6JiCtmX43Zjhyoyuaj/y7+0/oxNrdV4Bmej5cSlV11Pi4LPo90q0Atk/jl7u31eu3Nh51mo721vdVrhXTElw3AhfmN11fS8LqlDuFh8Fyf5gC2RLA6wIxGr0v/a3aa/kS6WyX+K30I87PtsmpbvubO6hqsk2G/5cOsKrCSOijPhxZVYJlQkMiL4Ef//8X9efvRo++O5eMPbeKa9KB/GmZ4/7m48G3wM3rf8P3CDfP8vLhWftvmi6mCQtQAx49ozCVaa/YSrzV3lW92PPw7WyrYbUT8nbRr5Z1NFQwtIv+3lMyOSH9bzWnx8G8eGf7VNPTvKv+biPwftO9aGvobhn89Df6B7mhnTKwMn6xslMPx9IFWN6PynNO6o5W/TLTGpWdoy3mN6GH+sN6wIWhdFzCW8RuinA1RzrqA8VpoElwPIuL6KCKu+5FwqflvErq+GZGuhYh0xeJXzDrGpEvpAbPQV5X+MCtjO2af+CQirkv5dSm/UtYxJu+XI9IVq9/765WIdMUc27M4HmPL6Fmda2O244cRcX0R5qEvQh1j0RVbrs7qvM12k1npXzHlKttuJqHr44h0xVxbzaqOeTkez6+OszpvfxHWaTH7BNuGX8V+z/bpWdGjY66H1iPSlVJGW170E7azWT6ZPzjvYf5j9uI/7Vma1lHo47RqPy5m2RmV55zeE+C9dKTH6F4WsEn2pw+f7U73GoeHrc3Do/b29nZG+I1WfsZ2f+WzoPYX1N5hRF4fKn8S9hmZA9giweoAw48ksj9JGt+j1mEV/mP56yI/+5NUbUvzJ1EfgVd+AXaWkP0CfDooYOgXoHxSMsKvfP39/4+zIa34HtKI9QsFM89LnuN1Rs+xXCzvTv/0e+yvxrRwfXNBp+JFTfBC+erkhAPHqeFbgXcW+m6Q7N1ZCrj97wWCWQ64/W/FS56vfw9ygvHG3NddInpj4t9tbG+rGA4R6U/9IY/UMZEHcTAxjlzoQx4mK/HaaFKy1fCq+E3vEyx3Z3FjXE1/3XDDd3xS56UNhmf3agS7T7QjDNeOHGMT7a51gqFeyh9ZQNsJf7gBdVCex1EH5/kf12zLBMO4puyHinFJ+cNoGJd0lWAYl/RLBMO4pGsEw7ik6wT7U4B9mWB/BrDXCPbnANsgWAdgVwl2CLDXCdYF2DWCHQHsOsF6ALtRPLNx+4YbwuLJtaHv4M0E+H3sog1B/02om0+XcVfPJhV3NfZ84NPdNPhbHHc1Am+adsExVyPgHpSg4q1G5Mue+TT/sMBnurc6k+zTkngWh5bmVpUzJWnO/zcrfxCQz/8n0l+C5/9V/Bc/39l86D+u0vm092Gvc8TLJkO3IaqGVcc844b35/y5wBNKaY8uNbbVctgSm6FYHUJVxqf9/jAfp5zusU4ex48AL+djerCdjDYVFoDbs0b08DM2IWaC1sTt0Um81IjW3swDTqq9rU7jtjeKnlB7s6lm3PbG97m9E4Vr7HFIGifqz1sHzlXn+cAU8uz3S8DL+bhM5OsawbBvrhMMp6QvEwz71WsEw361QTA0H1wlGJpmXycYumddIxi6BZiqv0R4Ik+rg7FntGBaJVq4P3JSbW10j9vWmeCFCqN0g2C4bfcGwbDP3iQYbhO9STA8WvAWwfAYxK8RDOfwrxDsKsB+Ha6RZz4plWK//+JfhYp5nd7jfoPXyoyrykYc9RJ816gOyizL7+XubN8z9T8XeKvQf03Qf60C/dcnoP96gP7Q2FH0Xxf0Xy+hH2m6MQH9NwB+j+h/w2n6c/E+5i/DcaME380A/TdG0H8T4Mz/myXluRL6bwr6b5bQjzS9OQH9bwKc+f9WCf25eB/zI468hM4yHNxGGT2vlbyXB8qtl+CsC5z4Hstw7EsZwd4U5a2K8kPbxCsEw/maQ+ThPMT6CM41rHPgfMJ6Bc4ZrDugHOZ5D9uM9QqUfzyXomzheS8DWI1galtM6WJ8ZB71rWWCod7E7Y59gkMnqpCPSk+7QjDUtzjEIeoRrE+irsA6I+oDrBfinG8y5SIc7f+n4n4Wjvb/EPJgX3tOrzvdN33izyBZ3eZFfsTHR/3/pfj3NBwWBKbdImue+R533WmdwWhW63QXjZ4X/QjHcFlYQeah5f8x8LBXEMcyA+lOHFK0k1F5zlUzKc7Kd+eVTOWQouiuddAf5mNYLp7VLnFd4noJXMqel5X8Wzn8jMtR8iWxXbKhwpi4ePibSrexuvj6/ic8Z7nKurJPNtfVKf//AM7/Kq5VqFMMN1QldKxyi1P2Ssu/BHSo/IvuNP2W38L54NzLOJEnqM/XS3D+H+D8jHCqTwipvmnPQ6HAkJ41ogHfVW6X2M99mgNYzHnQ0/eXNB9j29b7o/mzOAF/rA+oUMzsVj7qMxj7/dO4sM/yum/UuFP6Zi7Kz0T5VfYC5kbg4jDOit4q+lOiLdDNKrIcy5+W/qTcWUP6k3J1Vf0nnw5fx94PY33fUf0xId2+f/8tjHvOx2WqPa8QzxGHuaWoeYXdiOdH4LpLuPD9MtuAc2fHRaJPR1ceF3wkIdE6ZzAulG6H/OFxoY5PrLvyOTYxX3fV3OSIZpwvkJ+c1LgwuscdF9j/OFx8ojZtZ4IXPFaw/FDI/SpjJc3Rnupjxcqf1lgJfUbHJx4rS4LWdQFbmA5f95guTMreOu5YMbrHHSvK/pt4rAyOZKkjVqGxoo4LVRkraY42VR8rVv60xoria2isLAta1wVscTp87TBdmNQ+0Lhjxeged6yofalpfGaJeVFlrGDb8L5OaKwk+gRH5bFi5U9rrCi+hsZK6LNEap2cmK+HTBcmta827ljBI6PjjBW1z5d4rOxmghdVxgq2zQq9p9rbX6vP35WVXTavzwFtIZp9MlviWqBMRTPbCBU/VNnqiKddj7sfnROsit3EX4d8BkL72KE959BedcgPwdpwxcXfd221Ozvdzk6zuddq9lrN9qh91+j7vq3NXq+92zo8fHbVPGpOu/xue/uw+4wJjd7zEyKbo8pXR2fRTuvTQnGPx3Mxv+GrU/4nBQLfL75L8q4uyvP5+oF8Wcn/cxzi2Vz/9LOl/tn8eJzZ8lvZy/2zNBpsBWB1KudKcY/8QlxGR53y/3WBwNoEjyDb++ui/EUq/xTd4hn7ka+I/Csiv2+f7xcvWb/FusfWKZ6XSfjxGdNmfafMnyKGfXvUXlDd6XlBlV12dsLjCM0Lvn6/U1xf7KPkO1vTOkqep8G/mXqf1ubi/f5p/I7KzSmfeof7FOZhXcOngwLmx5L5dPlr9KXz6Q6UkxHsLsBqBHuP6EPYPYDxcXH0e2L7elU7cEob1W6jdZh2Xb+5q/ZU+Qj8HMBCoWxwDf9bxJ8U9u5d+CRoGhvh5tGGoN/KsvmhBTxBuOVHPiRqx70qugyWv5yUb2G7l9oH9+tR8/38tHdy/+nh40fd/c5J58Gjk+Pe55+zfSSne97bZX9+fp/35ozO3yz+1b5iWTJ6WCYivhrlz+i+VpIP66nm8tA6bpy1WlVf5SprtYsU+meruJ/l0D9vF9cXwQ96r7g/bz9o842/2Hpta+dSrw2nqnrtJDqrnXPw1xw+R+msKc+ao86TqM2aGyX0+2Q6D4bpRPi8K19vhuaviyDb7PzQecs2Owt7KduCaSvlOGwU/Ek4DqVsC9nwlWxj+cUhvg4AN6+574hyU9b5WZ9oJ54vNjdc+RzBobNc9XKbowo2uWl6ibL/4ThD+59qcyeeZa5c9nIZucBn9V4N0Pay+0wXQb5b/IHzlu+3i+tL+R5Ml7qru9RdKVXSXTGWAPKZP2+NePi8kJ0X9/ruRgm+KrpwXvIerl8Zh4vIr5CsRzouuu5+q7g/b9lu9pELLtt3L3jo5ta0Qjfv94f4Q6GbLR+/M2q/LbG8bqc+H5X4PMSZ+ADGc64T28PVWTH+N1wMm9Wz8Oq8VpVzRfNj4jrPNi2Lq/I8T38I4z3kOYBxePB6/2wdvR5xC/LxGGTdDecq28v2OL4O+MzOr+b82LI7lczwacOV6z32bNb3hb5W3M/yvtBXi+sVN9RttwBf2RjBtYJdh84JTuMsIMsslj1Yvt8rtjhPPkxw797xwQ963acnj54cv9vpftZzlHizOIPKl03MWFGFI4f3VboISvFucX/eSvF3iusLrhR3p6UUpzowmXigD5Tig/4Qvxrg1ofNQIHXRpPlwVj475XkuQd50CHMJ6VcG33KuHKHYGpiV0rkewRDOWM0eQGOwWAxgJ1PHKgLYfiNmCkZ6zuzZKxPsTDxaT8N/qZN2L8L7cgTduZOt2NKhRrLc04vbGb1ML5XCMwI1+08fnz/e4++3znp3Xl63PU6AVYB0dZEFXk6R/ufK8nHIoLFAosCHP6It+x9fmZlh+ITZe4snbl4FlrPhURkVvJv5bgR5Sialbh92XJS782uE61YVmKx2FZTiCMehtoRxQiPASf46yAPfgvgAPByPqYH22Ee8GM9VHupdb2Ko6KmCHs+a7FouD0m+TYD2iPGaY9Q/Fkca+xjoGwcF2Gps1/cz0J8VpvyVcwqlu3q85yWD+cQZfcz1UgtG5yLN11zHNj3i39f1wdEs7JH5IJXVVQArK+yXyxUKBv5td/XZc87LYcw5izm/6j49/X/dnGt5r2cYDWBW41Jq+MsnPs873O3eKbfpzTfABmaDq6mwd/Afu6oLlgum0hcRBoMn/VLpV+wPjywaRJ9WXz6mo6S0v8s2XLgKjzDpTXSmiq+huFfSYNf9hmMncHxJ6zt1DfMspL7Gv2H8mYBvKsCZjitrZBeq4d9BwBjmBremLzEuKsJ8A/kR6olvOoL+IzHK7YVz0ksUyPTOogpznM7lsk0Yh7Vf2t0P0fP8wp5Vf812GCvJ/Aen3XjZ7yv6ER+w4VxfhWuBYBj/gXKm6oNNwRNRvuvAFJNR4QEuQwA",
      "debug_symbols": "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40PPZ44PPZ85PvR85h7mpzPHh57PHB96PnN86PnM8aHnM8eHns7c40PPZ44PPZ85PvR85vjQ85l7mJ/OHB96PnN86PnM8aHnM8eHns8cH3o6897fHTwkc3zo+czxoeczx4eez9zD/HTm0/rQ7Q3qfzax+Z75t9v2m6Fey30RwmldohhCVS+bzd8fnOJ6bErx60w1ieV3M9Vk5H830yvss3nMtDL47z767/gveb2p5PiN8vFb5eN3ysfvlY8/KB9/VD7+pHz8Wfn4la+/Wfn6m/tef/3iVp/il1IqH+18XFMH5/PTsMPyMdu+V2vp2fa9tkvP1k812777BunZ9t1lSM+2755EerZ9dzDSs+273xGebem7O5Ke7VS9VNHbS93Hr7c7uo/fKx+/3g7mPn69Pcl9/Hq7jPv4O+8bzHZDwzvjKx+dF/9xcHaPud5uvO0cW/L6waV8PvbOpfMO4yIudum8F7mMS+ddy2VcOu9vLuPSed90GRcPl10unfd5l3HpvH+8jEvnfellXOh397nQ7+5yMfS7+1zod/e5+M65bE+Ue2O/5gHW9N5n1Mbfez9QG3/v63Zt/L2vr7Xx974OVsZve1+vauPvfV2pjb/3vKM2/t5zidr4la+/Vvn6a5Wvv1b5+muVr79W+frrlK+/Tvn665Svv075+nvJptiS41e+/jrl669Tvv465euvU77+euXrr1e+/nrl669Xvv5eshmo5PiVr79e+frrla+/Xvn665Wvv0H5+huUr79B+foblK+/l2yCJjl+5etvUL7+BuXrb1C+/gbl629Uvv5G5etvVL7+RuXrb1S+/kbl629Uvv5G5etvVL7+dr6TYHX8ne8kWB+/8vW3850E6+NXvv52vpNgffzK19/OdxKsj1/5+tv5ToL18StffzvfSbA+fuXrb+97A1bHr3z97X3/vur4la+/ve+xVx2/8vW3933wquNXvv72vldddfzK19/e95Orjl/5+tv7fnLV8Stff3vfT646fuXrb/f7ydXGr3v9dd3vz1Ybv+7113W/31lt/LrXX7foXn9d9/t81cave/113e+bVRu/7vXXdb8PVWX83e8XVRu/8vXXKF9/jfL1V/n+V075/ldO+f5XTvn+V075/ldO+f5XTvn+V075/ldO+f5XTvn+V075/leu+/2vDttXNK7HmmWxnw6+g5l2o+samGl3uq6BmXar6xqYafe6roDpfvOyy8DofYvJffx63zZyH79XPn69Xc19/Hqbj/v49fYI9/HrXcrv49e74v4df/e7itXGr/dtDffxK19/u99VrDZ+5etv97uK1cavfP3tflex2viVr7/d7ypWGX/3u4rVxq98/e1+V7Ha+JWvv93vKlYbv/L1t/tdxWrjV77+dr+rWG38ytff7ncVq41f+frb/a5itfErX3+731WsNn7l62/3u4rVxq98/e1+V7Ha+JWvv93vKlYbv/L1t/tdxWrjV77+dr+rWG38ytff7ncVq41f+frb/a5itfErX3+731WsNn7l62/3u4rVxq98/e1+V7Ha+JWvv93vKlYbv/L1t/tdxWrjV77+dr+rWG38ytff7ncVq41f+frb/a5itfErX3+731WsNn7l62/3u4rVxq97/fXd7ypWG7/u9dd3v6tYbfy611+/6F5/ffe7itXGr3v99d3vKlYbv+7113e/q1hl/N3vKlYbv/L1t/tdxWrjV77+dr+rWG38ytff7ncVq41f+frb/a5itfErX3+731WsNn7l62/3u4rVxq98/e1+V7Ha+JWvv4o3/7qPX/n6q3grrfv4la+/ijemuo9f+fqrfP8rr3z/K698/yvf+/5X0ZV1/PnPl3/70T/aWC6vMyzl87F3Lp2v65dx6bxfuIxL533IcVy+36DR977B2GVget+57Downbdk14HpvNe7DkznTeR1YHzfYPL20T77GpgU3cfBKcXtWG8/ptp5Iys51c57U8mpdt5ufjPV+/g7bwur4++8e6uNv/ft6arj77wXqo6/85alOv6+O4tgfFgPNnEn3ul8e7r6+Pte1evj73upro+/7/W3Pv6+19/6+Ptef6vj73x7uvr4+15/6+Pve/19Hr81dmf8etbf/fHrWX/3x9/5+ptM2g7OZWf8na+/1fF3vv5Wx9/5+lsdf+frb238nW9PVx9/5+tvdfydr7/V8Xe+/lbH3/n6Wx2/8vW38+3p6uNXvv52vj1dyG5ZDy4xVz7al22yz48y5eVjrp2v1ZJz7XzbO9m5dt4DiM61835BdK6d9xaic/UTzbXznkV0rp33N6Jz7bwX+tFcb3HXerDPO3MdqW+qzXWkvqky1863K5Sd60h9U22uI/VNtbmO1DfV5uonmutIfVNtriP1TSFsfVPe6Zs63+JRdq5D9U2VuQ7VN30719D5NpOycx2qb6rMdai+qTLXofqmylz9RHMdqm+qzHWevil0vjXnd3O9j19vL3Qfv97+5u/4O9+aMy7LOpDootkZf999SH38ffcW9fH33S/Ux++Vj7/vdb0+/r7X6vr4+15/6+Pve/2tj7/v9bc6/s635qyPX/n62/nWnPXxK19/O9+asz5+5etv51tz1sevfP3tfGvO+viVr7+db81ZH7/y9bfzrTnr41e+/na+NWd9/MrX38630KyPX/n62/mWlPXxK19/O9/gsT5+5etv59sl1sevfP3tfPPB+viVr7+dbxNYH7/y9bfzvf/q41e+/na+9199/MrX3873/quPX/n62/nef/XxK19/O9/7rz5+5etv53v/1cevfP3tfO+/+viVr7+d7/1XH7/y9bfzvf/q41e+/na+9199/MrX3873/quPX/n62/nef/XxK19/O9/7rz5+5etv53v/1cevfP3tfO+/+viVr7+d7/1XH7/y9bfzPfrq41e+/na+l159/MrX3873vKuPX/n62/nedPXxK19/O99Drj5+5etv53u91cevfP3tfE+2+viVr7+d751WH7/y9bfzPc7q41e+/na+F1l9/LrX39j5nmH18etef2Pne3vVx697/Y2L7vU3dr6vVn38utff2Pn+V/Xx615/Y+f7X1XHr3z/q6h8/6uofP+rqHz/q6h8/6uofP+rqHz/q6h8/6uofP+rqHz/q6h8/6uofP+rqHz/q6h8/6uofP+rqHz/q6h8/6uofP+rqHz/q6h8/6uofP+r2Pv+Vz6vB8dg7M74O19/Xdr4306sfHRe/MfB2T3es2yz2Tm25PWDS/l87J1L5+v6ZVw8XHa5dN6HXMal8/7mMi6d902Xcem8H7uMS+d93lVcet+/7TIunfell3Gh393nQr+7z8XDZZcL/e4+F/rdfS70u/tcpu1343qsWRa7A2bahrcCpvcdE68DM23LWwMzbc9bAzNt01sD49WCuY9fb3d6H7/eLvI+fr3d3n38eruy+/j1Nk9/x9/7rpTV8ettRe7j19sx3Mevd2G/j1/5+tv7rpTV8Stff3vflbI6fuXrb++7UtbG3/uulNXxK19/e9+Vsjp+5etv77tSVsevfP3tfVfK6viVr7+974oYclnHH00tGDOhLG6Nu0Ixbjs+fsy286vVN7O9j7/zq1V1/H1frVJK68EpPd3D2/9om2L4ONqm5J4/+j7Zvi9twpPt+zooPNm+TYvwZPt2OLKT7XyTQuHJ9u2dhCfbt9ESnmzffc5PJ1vsOtn81FVsk/UzTXasDqoy2ZE6KGeXtTl21qavkx2pg6pOdqQOqjrZkTqoymRT59tM/niyy7eTHWmddd6sRztvl6+THWmdrU52pHW2Otmh1tnaZIdaZ13J22TN8v1Hh5LWS3coZedqNtSi/BMycdmu83H52oimzveePEczu2Q639Xyp5cOt/U2Ppjf/TV1vl/mOWT2NTNSFOP8dofN+ZK/TnasFrEyWT/TZMdqESuTHatFfEw2PP0qYpvsUC1ibbJDdX21yQ7VyFUm2/mOpz/tWh8DCSZ9/9Em5rWfN8k/bYbm8geaoVqQtG395lJxv2tbO9/m9EAyNRPY+Qaq52hmn8xQndDjo90/bkrtXGiWsj1wZtyyc6EZqm/K1m9odprEzreIFZ7sUH1TbbJD9U2VyXa+U63wZIeKqWqTHartq012qE6uNtnOfwch+hx76n2vVeHZdv4bC+HZdv6LSOHZdv77SdnZ9r6HqfBsO/9tpvBsO/8lp/Bs9f6SqmW2fqzZOv+YbbBPs90/2j4dHb+wGazzEmUzWJ8mymawru4HbLzZnsDx9ulexkpmsA5QkMxg3aIcmd73Cr2QzGBdqCCZwTpWQTKDdbeCZDxkXpCZtw+ukZm3C66RoQd+RYYe+BWZ0XrgVy5x57Pz9ljX7b7lUvvsktdJ3jA+vdEzLHeSve89q4jkaD22DMk7m9G6bEk2o/XZ3yZeL/aaNdt2/s7aUpmtycu684fJ5plN2p3t8pjtEp9nex9ROn9E9jGinV9Uv9gP9soRld5G9GLP1itHZLobkT1/RD4+riyV50at3y5x1vuvT9S+2FZVzfC97uEH3cOPuoefdA8/6x5+UT38vHQ+fJsfw//akGWje/i9r7qV4Xe+6oaw9jw2xF/+mil3vkT/ZK613yflztfzYNw211TZXCEv6wdn/zTm9fdGufO1X3KqnfcJklPtvKeQnGrn/YfgVEvnvYrkVHtfWX8y1bAOI6f4aao7H2zcIzl/2jfnz2/Svx78+Enu8unQO8LeF2wFCEfqAy5COFJ/cRHCkfqWixCO1A9dhHCkPusShHkZqX+7CGHneZcGhJ1nbhoQ4k5+jdCD8JcIzayt9fJ4C4h5ekhlF2HO6yCKsZUPNiWb7YGcku3jeFviB/NZe/Ermc/avF/JfNZu/0LmdlZ7cCXzWf3ElcxnNSBXMp/VsVzJ3MP8dOaz3rG5kjk+9Hzm+NDzmeNDz2eODz2ducOHns8cH3o+c3zo+czxoecz9zA/nTk+9Hzm+NDzmeNDz2eODz2fOT70dOYeH3o+c3zo+czxoeczx4eez9zD/HTm+NDzmeNDz2eODz2fOT70fOb40NOZB3zo+czxoeczx4eezxwfej5zD/PTmeNDz2eODz2fOT70fOb40POZ40NPZx7xoeczx4eezxwfej5zfOj5zD3MT2eODz2fOT70fOb40POZ40PPZ44PPZ15woeezxwfej5zfOj5zPGh5zP3MD+dOT70fOb40POZ40PPZ44PPZ85PvR05r2/unVI5vjQ85njQ89njg89n7mH+enM8aHnM8eHns8cH3o+c3zo+czxoaczH+q13FqY40PPZ44PPZ85PvR85h7mpzPHh57PHB96PnN86PnM8aHnM8eHns28LPjQ85njQ89njg89nzk+9HzmHuanM8eHns8cH3o+c3zo+czxoeczx4eeztzgQ89njg89nzk+9Hzm+NDzmXuYn84cH3o+c3zo+czxoeczx4eezxwfejpziw89nzk+9Hzm+NDzmeNDz2fuYX46c3zo+czxoeczx4eezxwfej5zfOjpzB0+9Hzm+NDzmeNDz2eODz2fuYf56czxoeczx4eezxwfej5zfOj5zPGhpzP3+NDzmeNDz2eODz2fOT70fOYe5qczx4eezxwfej5zfOj5zPGh5zPHh57OPOBDz2eODz2fOT70fOb40POZe5ifzhwfej5zfOj5zPGh5zPHh57PHB96OvOIDz2fOT70fOb40POZ40PPZ+5hfjpzfOj5zPGh5zPHh57PHB96PnN86OnMEz70fOb40POZ40PPZ44PPZ+5h/npzPGh5zPHh57PHB96PnN86PnM8aGnM8/40POZ40PPZ44PPZ85PvR85h7mpzPHh57PHB96PnN86PnM8aHnM8eHns684EPPZ44PPZ85PvR85vjQ85l7mJ/OHB96PnN86PnM8aHnM8eHns8cH3oyc7cs+NDzmeNDz2eODz2fOT70fOYe5qczx4eezxwfej5zfOj5zPGh5zPHh57O3OBDz2eODz2fOT70fOb40POZe5ifzhwfej5zfOj5zPGh5zPHh57PHB96OnOLDz2fOT70fOb40POZ40PPZ+5hfjpzfOj5zPGh5zPHh57PHB96PnN86OnMHT70fOb40POZ40PPZ44PPZ+5h/npzPGh5zPHh57PHB96PnN86PnM8aGnM/f40POZ40PPZ44PPZ85PvR85h7mpzPHh57PHB96PnN86PnM8aHnM8eHns484EPPZ44PPZ85PvR85vjQ85l7mJ/OHB96PnN86PnM8aHnM8eHns8cH3o684gPPZ85PvR85vjQ85njQ89n7mF+OnN86PnM8aHnM8eHns8cH3o+c3zo6cwTPvR85vjQ85njQ89njg89n7mH+enM8aHnM8eHns8cH3o+c3zo+czxoaczz/jQ85njQ89njg89nzk+9HzmHuanM8eHns8cH3o+c3zo+czxoeczx4eezrzgQ89njg89nzk+9Hzm+NDzmXuYn84cH3o+c3zo+czxoeczx4eezxwfejZzs+BDz2eODz2fOT70fOb40POZe5ifzhwfej5zfOj5zPGh5zPHh57PHB96OnODDz2fOT70fOb40POZ40PPZ+5hfjpzfOj5zPGh5zPHh57PHB96PnN86OnMLT70fOb40POZ40PPZ44PPZ+5h/npzPGh5zPHh57PHB96PnN86PnM8aGnM3f40POZ40PPZ44PPZ85PvR85h7mpzPHh57PHB96PnN86PnM8aHnM8eHns7c40PPZ44PPZ85PvR85vjQ85l7mJ/OHB96PnN86PnM8aHnM8eHns8cH3o684APPZ85PvR85vjQ85njQ89n7mF+OnN86PnM8aHnM8eHns8cH3o+c3zo6cwjPvR85vjQ85njQ89njg89n7mH+enM8aHnM8eHns8cH3o+c3zo+czxoaczT/jQ85njQ89njg89nzk+9HzmHuanM8eHns8cH3o+c3zo+czxoeczx4eezjxP60NTeTBP3zO32aw0FvN86B3htLZSDuG0LlEO4bSmTw6hB+FvEU5rycQQFk3dfv7+4BTXY1OKX2eqqcf+3Uw1dba/mam95H305jHTyuC/++j7+I3y8Vvl43fKx++Vjz8oH39UPv6kfPxZ+fiL7vEb5euvUb7+mt7X3xC3QNC6ykcbX1ZXY0Kyzx99n2zvi7XoZHtf2UUn23sb8JPJ2pw2e5NLqRztbMnrJJ15OKf4Qab3BuM6Mr23LteR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tuzVtmWvti17tW3Zq23LXm1b9mrbslfblr3atuzVtmWvti17tW3Zq23LXm1b9mrbslf7Inst28N7t7jO7Jz2QiUpbacV++m0vR1nhd5ncRtO6ms4ua/hlK6G8yrbvmo4pq/h2L6G4/oaju9rOKGv4fR1VS59XZVLX1fl0tVV2S1dXZXd0tVV2S1dXZXd0tVV2S1nX5W/fRXTbTyhs/HEzsaTOhtP7mw8pa/xmB9fm++nmbbTbNtpu9ek213MdQuP273CUIFmYnLb231jio+NdfZ2OrhZ5XUTmdt64SqfHZdl2wBrcY8fk5flY/y+8/GHZS1ADM59HX9QPv6ofPxJ+fiz8vEX3ePffwBD0fiN8vFb5ePvff2tjV/5+muVr79W+fprla+/Vvn6a5Wvv075+uuUr79O+frrlK+/Tvn665Svv075+uuUr79O+frrlK+/Xvn665Wvv175+uuVr79e+frrla+/Xvn665Wvv175+uuVr79B+foblK+/Qfn6G5Svv0H5+huUr79B+foblK+/Qfn6G5Svv1H5+huVr79R+fobla+/Ufn6G5Wvv1H5+huVr79R+fobla+/Sfn6m5Svv0n5+puUr79J+fqblK+/Sfn6m5Svv0n5+puUr79Z+fqbla+/Wfn6m5Wvv1n5+puVr79Z+fqbla+/Wfn6m5Wvv0X5+luUr79F+fpblK+/Rfn6W5Svv0X5+luUr79F+fpbdK+/ftG9/vpF9/rrF93rr190r79+0b3++kX3+usX3euvX3Svv37Rvf76Rfn6a5Svv0b5+muUr7/d739VG7/y9Vf5/lde+f5XXvn+V175/lde+f5XXvn+V175/lde+f5XXvn+V175/lde+f5XXvn+V175/lde+f5XXvn+V175/lde+f5XXvn+V175/lde+f5XXvn+V175/lde+f5XXvn+V175/lde+f5XXvn+V175/lde+f5XXvn+V175/lde+f5XXvn+V175/lde+f5XXvn+V175/lde+f5XXvn+V175/lde+f5XXvn+V175/lde+f5XXvn+V175/lde+f5XXvn+V175/lde+f5XXvn+V175/lde+f5XXvn+V175/lde+f5XXvn+V175/lde+f5XXvn+V175/lde+f5XXvn+V175/lde+f5XXvn+V175/lde+f5XXvn+V175/lde+f5XXvn+V175/lde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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "get_note_internal",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000001"
            },
            {
              "kind": "string",
              "value": "HTLC_Private"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Train"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "contracts_private",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "contracts_public_user",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "contracts_public_solver",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "secret",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "ownership_key",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::redeem_private_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::redeem_private_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::add_lock_public_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::add_lock_public_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "src_receiver",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 48
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::lock_public_solver_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::lock_public_solver_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "Train::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "is_solver",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::refund_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::refund_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "secret",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::redeem_private_solver_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::redeem_private_solver_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "secret",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "is_solver",
                    "type": {
                      "kind": "boolean"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::redeem_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::redeem_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::add_lock_private_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::add_lock_private_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "src_receiver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 48
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::commit_private_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::commit_private_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 48
                    }
                  },
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "src_receiver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::commit_public_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::commit_public_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "key",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "is_solver",
                    "type": {
                      "kind": "boolean"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::get_htlc_public_solver_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "src_receiver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "hashlock_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "hashlock_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "secret_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "secret_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "claimed",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::HTLC_Public"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::get_htlc_public_solver_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "is_solver",
                    "type": {
                      "kind": "boolean"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::refund_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::refund_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "src_receiver",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 48
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::lock_private_solver_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::lock_private_solver_abi"
        }
      ]
    }
  },
  "file_map": {
    "100": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, &[], true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "101": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\nuse super::utils::is_note;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract. Only a single struct in the entire contract\n/// should have this macro (or `storage_no_init`) applied to it.\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot }, false);\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n/// Only a single struct in the entire contract should have this macro (or `storage`) applied to it.\npub comptime fn storage_no_init(_s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(\n    typ: Type,\n    slot: Quoted,\n    parent_is_map: bool,\n) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot }, true);\n        (quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }, 1)\n    } else {\n        let storage_size = if parent_is_map {\n            // Variables inside a map do not require contiguous slots since the map slot derivation is assumed to result\n            // in slots very far away from one another.\n            1\n        } else {\n            let (_, container_struct_generics) = typ.as_data_type().unwrap();\n            let stored_struct = container_struct_generics[0];\n\n            if is_note(stored_struct) {\n                // Private notes always occupy a single slot, since the slot is only used as a state variable\n                // identifier.\n                1\n            } else {\n                get_storage_size(typ)\n            }\n        };\n\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        (quote { $struct_name::new(context, $slot)}, storage_size)\n    }\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "103": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "104": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash =\n            compute_unique_note_hash(nonce, compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash));\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.nonce, note_and_data.nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == first_note_and_data.nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == second_note_and_data.nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "105": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    pending_partial_notes.for_each(|i, pending_partial_note: DeliveredPendingPartialNote| {\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log sans the extra\n            // fields) to get the complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                // temporary node connectivity issue - is simply throwing good enough here?\n                assert(\n                    deliver_note(\n                        contract_address,\n                        pending_partial_note.storage_slot,\n                        discovered_note.nonce,\n                        complete_packed_note,\n                        discovered_note.note_hash,\n                        discovered_note.inner_nullifier,\n                        log.tx_hash,\n                        pending_partial_note.recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "107": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/messages/discovery/private_logs.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{\n            ComputeNoteHashAndNullifier,\n            partial_notes::process_partial_note_private_msg,\n            pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n            private_notes::process_private_note_msg,\n        },\n        encoding::decode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        msg_type::{\n            PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n        },\n    },\n    oracle::{logs::store_private_event_log, message_discovery::sync_notes},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `syncNotes` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    sync_notes(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get the logs from the capsule array and process them one by one\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    logs.for_each(|i, log: PendingTaggedLog| {\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n        logs.remove(i);\n    });\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(log_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            pending_tagged_log.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        // In the case of events, the msg metadata is the event selector.\n        let event_selector = EventSelector::from_field(msg_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            msg_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n            pending_tagged_log.tx_index_in_block,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "108": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n        // issue, and we should perhaps not have marked the tag index as taken.\n        assert(\n            oracle::message_discovery::deliver_note(\n                contract_address,\n                storage_slot,\n                discovered_note.nonce,\n                packed_note,\n                discovered_note.note_hash,\n                discovered_note.inner_nullifier,\n                tx_hash,\n                recipient,\n            ),\n            \"Failed to deliver note\",\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "109": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\nglobal MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "110": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "117": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/messages/logs/note.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    messages::{\n        encoding::encode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        logs::utils::prefix_with_tag,\n        msg_type::{PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID},\n    },\n    note::{note_emission::NoteEmission, note_interface::NoteType},\n};\nuse protocol_types::{\n    abis::note_hash::NoteHash, address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS,\n    traits::Packable,\n};\n\n// TODO: it feels like this existence check is in the wrong place. In fact, why is it needed at all? Under what circumstances have we found a non-existent note being emitted accidentally?\nfn assert_note_exists<let N: u32>(context: PrivateContext, note_hash_counter: u32) {\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists =\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n}\n\npub fn compute_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PRIVATE_NOTE_MSG_TYPE_ID,\n    )\n}\n\npub fn compute_partial_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID,\n    )\n}\n\nfn compute_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    msg_type: u64,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let packed_note = note.pack();\n\n    // A note message's content is the storage slot followed by the packed note representation\n    let mut msg_content: [Field; N + 1] = std::mem::zeroed();\n    msg_content[0] = storage_slot;\n    for i in 0..packed_note.len() {\n        msg_content[1 + i] = packed_note[i];\n    }\n\n    // Notes use the note type id for metadata\n    let plaintext = encode_message(msg_type, Note::get_id() as u64, msg_content);\n\n    let ciphertext = AES128::encrypt_log(plaintext, recipient);\n\n    let log = prefix_with_tag(ciphertext, sender, recipient);\n\n    log\n}\n\npub unconstrained fn compute_note_log_unconstrained<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_note_log(note, storage_slot, recipient, sender)\n}\n\n/// Sends an encrypted message to `recipient` with the content of the note, which they will discover when processing\n/// private logs.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n        assert_note_exists(*context, note_hash_counter);\n\n        let encrypted_log = compute_note_log(note, storage_slot, recipient, sender);\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n\n/// Same as `encode_and_encrypt_note`, except encryption is unconstrained. This means that the sender is free to make\n/// the log contents be whatever they wish, potentially resulting in scenarios in which the recipient is unable to\n/// decrypt and process the payload, **leading to the note being lost**.\n///\n/// Only use this function in scenarios where the recipient not receiving the note is an acceptable outcome.\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n\n        assert_note_exists(*context, note_hash_counter);\n\n        // Safety: this function does not constrain the encryption of the log, as explained on its description.\n        let encrypted_log =\n            unsafe { compute_note_log_unconstrained(note, storage_slot, recipient, sender) };\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n"
    },
    "118": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/messages/logs/utils.nr",
      "source": "use crate::{\n    oracle::notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n    prelude::AztecAddress,\n};\n\npub(crate) fn prefix_with_tag<let L: u32>(\n    log_without_tag: [Field; L],\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> [Field; L + 1] {\n    // Safety: we assume that the sender wants for the recipient to find the tagged note, and therefore that they will\n    // cooperate and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the\n    // note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    let mut log_with_tag = [0; L + 1];\n\n    log_with_tag[0] = tag;\n    for i in 0..log_without_tag.len() {\n        log_with_tag[i + 1] = log_without_tag[i];\n    }\n\n    log_with_tag\n}\n\nmod test {\n    use super::prefix_with_tag;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn prefixing_with_tag() {\n        let sender = AztecAddress::from_field(1);\n        let recipient = AztecAddress::from_field(2);\n\n        let app_tagging_secret = 42;\n        let index = 5;\n\n        // I am using the deserialize trait instead of directly instantiating the IndexedTaggingSecret struct because\n        // direct instantiation functionality is not exposed.\n        let indexed_tagging_secret = IndexedTaggingSecret::deserialize([app_tagging_secret, index]);\n\n        // Mock the tagging oracles\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(indexed_tagging_secret);\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        let log_without_tag = [1, 2, 3];\n        let log_with_tag = prefix_with_tag(log_without_tag, sender, recipient);\n\n        let expected_result = [indexed_tagging_secret.compute_tag(recipient), 1, 2, 3];\n\n        // Check tag was prefixed correctly\n        assert_eq(log_with_tag, expected_result, \"Tag was not prefixed correctly\");\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "123": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_interface::{NoteHash, NoteType},\n    retrieved_note::RetrievedNote,\n    utils::{compute_note_hash_for_nullify_from_read_request, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::notify_created_note;\nuse protocol_types::traits::Packable;\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    let note_hash_counter = context.side_effect_counter;\n\n    let note_hash = note.compute_note_hash(storage_slot);\n\n    let packed_note = Note::pack(note);\n    notify_created_note(\n        storage_slot,\n        Note::get_id(),\n        packed_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(note, storage_slot, note_hash_counter)\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n\n    destroy_note_unsafe(context, retrieved_note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_from_read_request(retrieved_note, note_hash_for_read_request);\n    let nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash = if retrieved_note.metadata.is_settled() {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifying so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, note_hash)\n}\n"
    },
    "125": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub note: Note,\n    pub storage_slot: Field,\n    pub note_hash_counter: u32, // a note_hash_counter of 0 means settled\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note, storage_slot: Field, note_hash_counter: u32) -> Self {\n        Self { note, storage_slot, note_hash_counter }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "128": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/note/note_getter.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n    retrieved_note::RetrievedNote,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::oracle;\nuse crate::utils::{array, comparison::compare};\nuse dep::protocol_types::{\n    constants::{GET_NOTES_ORACLE_RETURN_LENGTH, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL},\n    traits::{Packable, ToField},\n};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    packed_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the packed note.\n    // This allows easier packing and custom (un)packing schemas. A note property is located\n    // inside the packed note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = packed_note[selector.index as u32].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[(31 + offset - i) as u32] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_packed_note<let N: u32>(packed_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(packed_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (RetrievedNote<Note>, Field)\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    // Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do\n    // is check that the metadata is correct, and that the note exists.\n    let retrieved_note = unsafe { get_note_internal::<Note, N>(storage_slot) };\n\n    // For settled notes, the contract address is implicitly checked since the hash returned from\n    // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n    // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the contract\n    // address returned from the oracle matches. Since branching in circuits is expensive, we perform this check on all\n    // note types.\n    assert(\n        retrieved_note.contract_address.eq(context.this_address()),\n        \"Note contract address mismatch.\",\n    );\n\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (retrieved_note, note_hash_for_read_request)\n}\n\n/// Returns a BoundedVec of notes that have been proven to have been created by this contract, either in the current or\n/// past transactions (i.e. pending or settled notes). A second BoundedVec contains the note hashes used for the read\n/// requests, which can save constraints when computing the note's nullifiers.\n///\n/// WARNING: recall that notes are never destroyed! Note existence therefore does not imply that the note is _current_\n/// or _valid_ - this typically requires also emitting the note's nullifier to prove that it had not been emitted\n/// before. Because of this, calling this function directly from end-user applications should be discouraged, and safe\n/// abstractions such as aztec-nr's state variables should be used instead.\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // Safety: The notes are constrained below.\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the notes (as opposed to simply removing some), the private\n    // kernel will later validate that these note actually exist, so transformations would cause for that check\n    // to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = array::collapse(filtered_notes);\n    let mut note_hashes = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_packed_note = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let retrieved_note = notes.get_unchecked(i);\n\n            // For settled notes, the contract address is implicitly checked since the hash returned from\n            // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n            // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the\n            // contract address returned from the oracle matches. Since branching in circuits is expensive, we perform\n            // this check on all note types.\n            assert(\n                retrieved_note.contract_address.eq(context.this_address()),\n                \"Note contract address mismatch.\",\n            );\n\n            let packed_note = retrieved_note.note.pack();\n            check_packed_note(packed_note, options.selects);\n            if i != 0 {\n                check_notes_order(prev_packed_note, packed_note, options.sorts);\n            }\n            prev_packed_note = packed_note;\n\n            let note_hash_for_read_request =\n                compute_note_hash_for_read_request(retrieved_note, storage_slot);\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> RetrievedNote<Note>\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let opt_notes: [_; 1] = oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_fields,\n    );\n\n    opt_notes[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_fields,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\n/// Unconstrained variant of `get_notes`, meant to be used in unconstrained execution contexts. Notably only the note\n/// content is returned, and not any of the information used when proving its existence (e.g. nonce, note hash, etc.).\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteType + Packable<N> + Eq,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n\n    // We fetch the notes from the same oracle we use in the constrained case, except we don't bother inspecting the\n    // metadata in order to prove existence.\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_fields,\n    );\n\n    // Even though we don't expect for the opt_notes array to be sparse, collapse is still useful in this case to\n    // convert it into a BoundedVec.\n    array::collapse(opt_notes).map(\n        // view_notes just returns the actual note, so we drop the metadata\n        |retrieved_note| retrieved_note.note,\n    )\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects as u32] = select.unwrap_unchecked().value;\n            select_comparators[num_selects as u32] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
    },
    "131": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "134": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "137": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "138": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "139": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "140": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "141": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "142": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "146": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "147": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "148": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "149": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use crate::messages::encoding::MAX_MESSAGE_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        msg_content,\n        tx_hash,\n        log_index_in_tx,\n        tx_index_in_block,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {}\n"
    },
    "150": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr",
      "source": "use crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn sync_notes(pending_tagged_log_array_base_slot: Field) {\n    sync_notes_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "152": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::{\n    note::{note_interface::NoteType, note_metadata::NoteMetadata, retrieved_note::RetrievedNote},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::IndexedTaggingSecret,\n    traits::{FromField, Packable},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {\n    // This wrapper exists to extract the ORACLE_RETURN_FIELD_LENGTH generic numeric param into a value and pass it to\n    // the oracle, so that it knows how big the return array must be.\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        ORACLE_RETURN_FIELD_LENGTH,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let MAX_NOTES: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    _placeholder_fields: [Field; ORACLE_RETURN_FIELD_LENGTH], // TODO: Compute this value automatically from MAX_NOTES\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let fields: [_; ORACLE_RETURN_FIELD_LENGTH] = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n\n    let mut opt_notes = [Option::none(); MAX_NOTES];\n    for i in 0..opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let maybe_nonce = fields[read_offset];\n            let maybe_note_hash_counter = fields[read_offset + 1] as u32;\n            let packed_note = array::subarray(fields, read_offset + 2);\n\n            let note = Note::unpack(packed_note);\n            let retrieved_note = RetrievedNote {\n                note,\n                contract_address,\n                metadata: NoteMetadata::from_raw_data(maybe_note_hash_counter != 0, maybe_nonce),\n            };\n\n            opt_notes[i] = Option::some(retrieved_note);\n        };\n    }\n    opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "153": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "154": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "155": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "157": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "159": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/state_vars/private_immutable.nr",
      "source": "use dep::protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\nuse crate::context::{PrivateContext, UtilityContext};\nuse crate::note::{\n    lifecycle::create_note,\n    note_emission::NoteEmission,\n    note_getter::{get_note, view_notes},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateImmutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context, let N: u32> Storage<N> for PrivateImmutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateImmutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateImmutable>` type (for example), because the storage slot often also identifies an actor.\n    // e.g. the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<Note> PrivateImmutable<Note, &mut PrivateContext> {\n    // docs:start:initialize\n    pub fn initialize<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: NoteType + NoteHash + Packable<N>,\n    {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:get_note\n    pub fn get_note<let N: u32>(self) -> Note\n    where\n        Note: NoteType + NoteHash + Packable<N>,\n    {\n        let storage_slot = self.storage_slot;\n        let retrieved_note = get_note(self.context, storage_slot).0;\n\n        // Because the notes obtained from PrivateImmutable are not meant to be nullified and get_note(...) function\n        // has already constrained the note (by pushing a read request to the context), we can return just the note\n        // and skip the additional data in RetrievedNote.\n        retrieved_note.note\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateImmutable<Note, UtilityContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    // docs:start:is_initialized\n    pub unconstrained fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // view_note does not actually use the context, but it calls oracles that are only available in private\n    // docs:start:view_note\n    pub unconstrained fn view_note<let N: u32>(self) -> Note\n    where\n        Note: Packable<N>,\n    {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: x_coordinates_match,\n        };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "168": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable.nr",
      "source": "use dep::protocol_types::{\n    shared_mutable::{\n        ScheduledDelayChange,\n        ScheduledValueChange,\n        shared_mutable_values::{unpack_delay_change, unpack_value_change},\n        SharedMutableValues,\n    },\n    traits::Packable,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\n\nmod test;\n\npub struct SharedMutable<T, let INITIAL_DELAY: u32, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// This will make the Aztec macros require that T implements the Packable and Eq traits, and allocate `M` storage\n// slots to this state variable.\nimpl<T, let INITIAL_DELAY: u32, Context, let M: u32> Storage<M> for SharedMutable<T, INITIAL_DELAY, Context>\nwhere\n    WithHash<SharedMutableValues<T, INITIAL_DELAY>, _>: Packable<M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in blocks. Reads in private are only valid as long as they are included in a block not too far into the\n// future, so that they can guarantee the value will not have possibly changed by then (because of the delay).\n// The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, let INITIAL_DELAY: u32, Context> SharedMutable<T, INITIAL_DELAY, Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PublicContext>\nwhere\n    T: Eq,\n{\n\n    pub fn schedule_value_change<let N: u32>(self, new_value: T)\n    where\n        T: Packable<N>,\n    {\n        let _value_change = self.schedule_and_return_value_change(new_value);\n    }\n\n    pub fn schedule_and_return_value_change<let N: u32>(\n        self,\n        new_value: T,\n    ) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n        let current_delay = delay_change.get_current(block_number);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let block_of_change = block_number + current_delay;\n        value_change.schedule_change(new_value, block_number, current_delay, block_of_change);\n\n        self.write(value_change, delay_change);\n\n        value_change\n    }\n\n    pub fn schedule_delay_change<let N: u32>(self, new_delay: u32)\n    where\n        T: Packable<N>,\n    {\n        let mut delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n\n        delay_change.schedule_change(new_delay, block_number);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    pub fn get_current_delay<let N: u32>(self) -> u32\n    where\n        T: Packable<N>,\n    {\n        let block_number = self.context.block_number() as u32;\n        self.read_delay_change().get_current(block_number)\n    }\n\n    pub fn get_scheduled_value<let N: u32>(self) -> (T, u32)\n    where\n        T: Packable<N>,\n    {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay<let N: u32>(self) -> (u32, u32)\n    where\n        T: Packable<N>,\n    {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change<let N: u32>(self) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        // We don't read ScheduledValueChange directly by having it implement Packable because ScheduledValueChange\n        // and ScheduledDelayChange are packed together (sdc and svc.block_of_change are stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_value_change::<T, N>(packed)\n    }\n\n    fn read_delay_change<let N: u32>(self) -> ScheduledDelayChange<INITIAL_DELAY>\n    where\n        T: Packable<N>,\n    {\n        // Since all ScheduledDelayChange member are packed into a single field, we can read a single storage slot\n        // here and skip the ones that correspond to ScheduledValueChange members. We are abusing the fact that\n        // the field containing the ScheduledDelayChange data is the first one in the storage layout - otherwise we'd\n        // need to offset the storage slot to get the position where it'd land.\n        // We don't read ScheduledDelayChange directly by having it implement Packable because\n        // ScheduledValueChange and ScheduledDelayChange are packed together (sdc and svc.block_of_change are\n        // stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_delay_change::<INITIAL_DELAY>(packed)\n    }\n\n    fn write<let N: u32>(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>,\n    )\n    where\n        T: Packable<N>,\n    {\n        // Whenever we write to public storage, we write both the value change and delay change to storage at once.\n        // We do so by wrapping them in a single struct (`SharedMutableValues`). Then we wrap the resulting struct in\n        // `WithHash`.\n        // Wrapping in `WithHash` makes for more costly writes but it also makes private proofs much simpler because\n        // they only need to produce a historical proof for the hash, which results in a single inclusion proof (as\n        // opposed to 4 in the best case scenario in which T is a single field). Private shared mutable reads are\n        // assumed to be much more frequent than public writes, so this tradeoff makes sense.\n        let values = WithHash::new(SharedMutableValues::new(value_change, delay_change));\n\n        self.context.storage_write(self.storage_slot, values);\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext>\nwhere\n    T: Eq,\n{\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction block number as this proof\n        // will only be valid for however many blocks we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n        let (value_change, delay_change, historical_block_number) =\n            self.historical_read_from_public_storage();\n\n        // We use the effective minimum delay as opposed to the current delay at the historical block as this one also\n        // takes into consideration any scheduled delay changes.\n        // For example, consider a scenario in which at block 200 the current delay was 50. We may naively think that\n        // the earliest we could change the value would be at block 251 by scheduling immediately after the historical\n        // block, i.e. at block 201. But if there was a delay change scheduled for block 210 to reduce the delay to 20\n        // blocks, then if a value change was scheduled at block 210 it would go into effect at block 230, which is\n        // earlier than what we'd expect if we only considered the current delay.\n        let effective_minimum_delay =\n            delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon =\n            value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any block after the block horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_tx_max_block_number(block_horizon);\n        value_change.get_current_at(historical_block_number)\n    }\n\n    fn historical_read_from_public_storage<let N: u32>(\n        self,\n    ) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u32)\n    where\n        T: Packable<N>,\n    {\n        let header = self.context.get_block_header();\n        let address = self.context.this_address();\n\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        let values: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::historical_public_storage_read(header, address, self.storage_slot);\n\n        (values.svc, values.sdc, historical_block_number)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, UtilityContext>\nwhere\n    T: Eq,\n{\n    pub unconstrained fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let smv: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::utility_public_storage_read(self.context, self.storage_slot);\n\n        let block_number = self.context.block_number() as u32;\n        smv.svc.get_current_at(block_number)\n    }\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "180": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "183": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "184": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "186": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "187": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "189": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "191": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "192": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/utils/random.nr",
      "source": "use crate::oracle::random::random;\n\n/// Returns as many random bytes as specified through N.\npub unconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n"
    },
    "195": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "20": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "219": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "221": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "233": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/abis/max_block_number.nr",
      "source": "use crate::{constants::MAX_BLOCK_NUMBER_LENGTH, traits::{Deserialize, Empty, Serialize}};\n\npub struct MaxBlockNumber {\n    _opt: Option<u32>,\n}\n\nimpl Empty for MaxBlockNumber {\n    fn empty() -> Self {\n        Self { _opt: Option::none() }\n    }\n}\n\nimpl Eq for MaxBlockNumber {\n    fn eq(self, other: Self) -> bool {\n        self._opt == other._opt\n    }\n}\n\nimpl Serialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn serialize(self) -> [Field; MAX_BLOCK_NUMBER_LENGTH] {\n        [self._opt.is_some() as Field, self._opt.unwrap_unchecked() as Field]\n    }\n}\n\nimpl Deserialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn deserialize(serialized: [Field; MAX_BLOCK_NUMBER_LENGTH]) -> MaxBlockNumber {\n        MaxBlockNumber {\n            _opt: if serialized[0] as bool {\n                Option::some(serialized[1] as u32)\n            } else {\n                Option::none()\n            },\n        }\n    }\n}\n\nimpl MaxBlockNumber {\n    pub fn new(max_block_number: u32) -> Self {\n        Self { _opt: Option::some(max_block_number) }\n    }\n\n    pub fn is_none(self) -> bool {\n        self._opt.is_none()\n    }\n\n    pub fn is_some(self) -> bool {\n        self._opt.is_some()\n    }\n\n    pub fn unwrap(self) -> u32 {\n        self._opt.unwrap()\n    }\n\n    pub fn unwrap_unchecked(self) -> u32 {\n        self._opt.unwrap_unchecked()\n    }\n\n    pub fn min(lhs: MaxBlockNumber, rhs: MaxBlockNumber) -> MaxBlockNumber {\n        if rhs.is_none() {\n            lhs // lhs might also be none, but in that case both would be\n        } else {\n            MaxBlockNumber::min_with_u32(lhs, rhs.unwrap_unchecked())\n        }\n    }\n\n    pub fn min_with_u32(lhs: MaxBlockNumber, rhs: u32) -> MaxBlockNumber {\n        if lhs._opt.is_none() {\n            MaxBlockNumber::new(rhs)\n        } else {\n            let lhs_value = lhs._opt.unwrap_unchecked();\n\n            MaxBlockNumber::new(if lhs_value < rhs { lhs_value } else { rhs })\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = MaxBlockNumber::empty();\n    let serialized = item.serialize();\n    let deserialized = MaxBlockNumber::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn zeroed_is_none() {\n    // Large parts of the kernel rely on zeroed to initialize structs. This conveniently matches what `default` does,\n    // and though we should eventually move everything to use `default`, it's good to check for now that both are\n    // equivalent.\n    let a = MaxBlockNumber::empty();\n    assert(a.is_none());\n}\n\n#[test]\nfn serde_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert(b.is_none());\n}\n\n#[test]\nfn serde_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert_eq(b.unwrap(), 13);\n}\n\n#[test(should_fail)]\nfn default_unwrap_panics() {\n    let a = MaxBlockNumber::empty();\n    let _ = a.unwrap();\n}\n\n#[test]\nfn min_default_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::empty();\n\n    assert(MaxBlockNumber::min(a, b).is_none());\n}\n\n#[test]\nfn min_default_some() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::new(13);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_some_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::new(42);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_with_u32_default() {\n    let a = MaxBlockNumber::empty();\n    let b = 42;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 42);\n}\n\n#[test]\nfn min_with_u32_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = 42;\n    let c = 8;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min_with_u32(a, c).unwrap(), 8);\n}\n"
    },
    "264": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "279": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "281": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "282": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "283": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr",
      "source": "use crate::traits::{Deserialize, Serialize, ToField};\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\nuse std::meta::derive;\n\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\n\n#[derive(Serialize, Deserialize)]\npub struct IndexedTaggingSecret {\n    app_tagging_secret: Field,\n    index: u32,\n}\n\nimpl IndexedTaggingSecret {\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\n        poseidon2_hash(\n            [self.app_tagging_secret, recipient.to_field(), self.index as Field],\n        )\n    }\n}\n"
    },
    "292": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "296": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `omit`: A list of field names (as `Quoted`) to be excluded from the serialized output.\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, &[], false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, &[], false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], &[], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, &[], false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with Omitted Field and packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// Serializing while omitting `value2`:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, MyStruct, &[quote { self.value2 }], true)\n/// // Returns:\n/// // ([`value_packed[0]`], [`let value_packed = self.value.pack()`])\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    omit: [Quoted],\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // Proceed if none of the omit rules omits this name\n    if !omit.any(|to_omit| to_omit == name) {\n        // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n        let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n        let packable_constraint =\n            quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n        if (should_pack & typ.implements(packable_constraint)) {\n            // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n            // method, add the resulting field array to `aux_vars` and each field to `fields`.\n            let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n            // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n            let name_at_one_token = collapse_to_one_token(name);\n            let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n            // We add the individual fields to the fields array\n            let pack_method = get_trait_impl_method(\n                typ,\n                quote { crate::traits::Packable<$packed_len> },\n                quote { pack },\n            );\n            let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n            for i in 0..packed_len {\n                fields = fields.push_back(quote { $packed_struct_name[$i] });\n            }\n\n            // We add the new auxiliary variable to the aux_vars array\n            aux_vars = aux_vars.push_back(packed_struct);\n        } else if typ.is_field() {\n            // For field we just add the value to fields\n            fields = fields.push_back(name);\n        } else if typ.as_integer().is_some() | typ.is_bool() {\n            // For integer and bool we just cast to Field and add the value to fields\n            fields = fields.push_back(quote { $name as Field });\n        } else if typ.as_data_type().is_some() {\n            // For struct we pref\n            let nested_struct = typ.as_data_type().unwrap();\n            let params = nested_struct.0.fields(nested_struct.1);\n            let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n                let maybe_prefixed_name = if name == quote {} {\n                    // Triggered when the param name is of a value available in the current scope (e.g. a function\n                    // argument) --> then we don't prefix the name with anything.\n                    param_name\n                } else {\n                    // Triggered when we want to prefix the param name with the `name` from function input. This\n                    // can typically be `self` when implementing a method on a struct.\n                    quote { $name.$param_name }\n                };\n                generate_serialize_to_fields(\n                    quote {$maybe_prefixed_name},\n                    param_type,\n                    omit,\n                    should_pack,\n                )\n            });\n            let struct_flattened_fields = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n            );\n            let struct_flattened_aux_vars = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n            );\n            fields = fields.append(struct_flattened_fields);\n            aux_vars = aux_vars.append(struct_flattened_aux_vars);\n        } else if typ.as_array().is_some() {\n            // For array we recursively call `generate_serialize_to_fields(...)` for each element\n            let (element_type, array_len) = typ.as_array().unwrap();\n            let array_len = array_len.as_constant().unwrap();\n            for i in 0..array_len {\n                let (element_fields, element_aux_vars) = generate_serialize_to_fields(\n                    quote { $name[$i] },\n                    element_type,\n                    omit,\n                    should_pack,\n                );\n                fields = fields.append(element_fields);\n                aux_vars = aux_vars.append(element_aux_vars);\n            }\n        } else if typ.as_str().is_some() {\n            // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n            // then we add each byte to fields as a Field\n            let length_type = typ.as_str().unwrap();\n            let str_len = length_type.as_constant().unwrap();\n            let as_member = name.as_expr().unwrap().as_member_access();\n            let var_name = if as_member.is_some() {\n                as_member.unwrap().1\n            } else {\n                name\n            };\n            let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n            let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n            for i in 0..str_len {\n                fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n            }\n            aux_vars = aux_vars.push_back(as_bytes);\n        } else {\n            panic(\n                f\"Unsupported type for serialization of argument {name} and type {typ}\",\n            )\n        }\n    }\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) =\n        generate_serialize_to_fields(quote { self }, typ, &[], packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "298": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "299": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "308": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize, ToField},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "312": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_delay_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initially equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation\n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the\n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a\n// reduced delay, invalidating prior private reads.\npub struct ScheduledDelayChange<let INITIAL_DELAY: u32> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option,\n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pub(crate) pre: Option<u32>,\n    pub(crate) post: Option<u32>,\n    // Block at which `post` value is used instead of `pre`\n    pub(crate) block_of_change: u32,\n}\n\nimpl<let INITIAL_DELAY: u32> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u32>, post: Option<u32>, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current block number - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_block_number: u32) -> u32 {\n        // The post value becomes the current one at the block of change, so any transaction that is included in the\n        // block of change will use the post value.\n        if current_block_number < self.block_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the block at which it will become the current\n    /// delay. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u32, u32) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.block_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current block number. This function is only meaningful\n    /// when called in public with the current block number.\n    /// The block at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u32, current_block_number: u32) {\n        let current = self.get_current(current_block_number);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let blocks_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior constraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value block of change\n            //       block                 block of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   blocks until change               new delay            |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.block_of_change = current_block_number + blocks_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical block number. It only returns a meaningful value when called in private with historical blocks. This\n    /// function can be used alongside `ScheduledValueChange.get_block_horizon` to properly constrain the\n    /// `max_block_number` transaction property when reading mutable shared state.\n    /// This value typically equals the current delay at the block following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is\n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_block_number: u32) -> u32 {\n        if self.block_of_change <= historical_block_number {\n            // If no delay changes were scheduled, then the delay value at the historical block (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // block of change the current delay will be the scheduled one, with an overall delay from the historical\n            // block number equal to the number of blocks until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //         block                  delay                  actual earliest value\n            //           v                block of change              block of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest block in            |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |         blocks                  new delay                      |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest block in\n            //                             which to scheduled value change\n            let blocks_until_change = self.block_of_change - (historical_block_number + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                blocks_until_change + self.post.unwrap_or(INITIAL_DELAY),\n            )\n        }\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Empty for ScheduledDelayChange<INITIAL_DELAY> {\n    fn empty() -> Self {\n        Self { pre: Option::none(), post: Option::none(), block_of_change: 0 }\n    }\n}\n"
    },
    "314": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_value_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some block\n// called the `block_of_change`. The value can only be made to change by scheduling a change event at some future block\n// of change after some minimum delay measured in blocks has elapsed. This means that at any given block number we know\n// both the current value and the smallest block number at which the value might change - this is called the\n// 'block horizon'.\npub struct ScheduledValueChange<T> {\n    pub(crate) pre: T,\n    pub(crate) post: T,\n    // Block at which `post` value is used instead of `pre`\n    pub(crate) block_of_change: u32,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given block. This function can be called both in public\n    /// (where `block_number` is simply the current block number, i.e. the number of the block in which the current\n    /// transaction will be included) and in private (where `block_number` is the historical block number that is used\n    /// to construct the proof).\n    /// Reading in private is only safe if the transaction's `max_block_number` property is set to a value lower or\n    /// equal to the block horizon (see `get_block_horizon()`).\n    pub fn get_current_at(self, block_number: u32) -> T {\n        // The post value becomes the current one at the block of change. This means different things in each realm:\n        // - in public, any transaction that is included in the block of change will use the post value\n        // - in private, any transaction that includes the block of change as part of the historical state will use the\n        //   post value (barring any follow-up changes)\n        if block_number < self.block_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the block at which it will become the current\n    /// value. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u32) {\n        (self.post, self.block_of_change)\n    }\n\n    // Returns the previous value. This is the value that is current up until the block of change. Note that this value\n    // might not be the current anymore since block of change might have already passed.\n    pub fn get_previous(self) -> (T, u32) {\n        (self.pre, self.block_of_change)\n    }\n\n    /// Returns the largest block number at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_block_number`,\n    /// since due to its asynchronous nature private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum number of blocks that need to\n    /// elapse from the next block until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical block number is only safe to use\n    /// if the transaction's `max_block_number` property is set to a value lower or equal to the block horizon computed\n    /// using the same historical block number.\n    pub fn get_block_horizon(self, historical_block_number: u32, minimum_delay: u32) -> u32 {\n        // The block horizon is the very last block in which the current value is known. Any block past the horizon\n        // (i.e. with a block number larger than the block horizon) may have a different current value. Reading the\n        // current value in private typically requires constraining the maximum valid block number to be equal to the\n        // block horizon.\n        if historical_block_number >= self.block_of_change {\n            // Once the block of change has been mined, the current value (post) will not change unless a new value\n            // change is scheduled. This did not happen at the historical block number (or else it would not be\n            // greater or equal to the block of change), and therefore could only happen after the historical block\n            // number. The earliest would be the immediate next block, and so the smallest possible next block of change\n            // equals `historical_block_number + 1 + minimum_delay`. Our block horizon is simply the previous block to\n            // that one.\n            //\n            //      block of      historical\n            //       change         block            block horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n            historical_block_number + minimum_delay\n        } else {\n            // If the block of change has not yet been mined however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the block horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the block of change is in the past: the time horizon is the\n            //      block prior to the earliest one in which a new block of change might land.\n            //\n            //         historical\n            //           block                        block horizon      block of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` blocks away from the historical block number, in which case\n            //      the block of change would become the limiting factor for the time horizon, which would equal the\n            //      block right before the block of change (since by definition the value changes at the block of\n            //      change).\n            //\n            //           historical                         block horizon\n            //             block     block of change       if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the block of change to an arbitrary\n            // value, and therefore scenario a) is not currently possible. However implementing #5501 would allow for\n            // this to happen.\n            // Because historical_block_number < self.block_of_change, then block_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.block_of_change - 1,\n                historical_block_number + minimum_delay,\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current block number. This function is only meaningful when\n    /// called in public with the current block number.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_block_number: u32,\n        minimum_delay: u32,\n        block_of_change: u32,\n    ) {\n        assert(block_of_change >= current_block_number + minimum_delay);\n\n        self.pre = self.get_current_at(current_block_number);\n        self.post = new_value;\n        self.block_of_change = block_of_change;\n    }\n}\n\nimpl<T> Eq for ScheduledValueChange<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n\nimpl<T> Empty for ScheduledValueChange<T>\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        Self { pre: T::empty(), post: T::empty(), block_of_change: 0 }\n    }\n}\n"
    },
    "316": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/shared_mutable_values.nr",
      "source": "use crate::{\n    hash::poseidon2_hash,\n    shared_mutable::{\n        scheduled_delay_change::ScheduledDelayChange, scheduled_value_change::ScheduledValueChange,\n    },\n    traits::{Hash, Packable},\n    utils::arrays,\n};\nuse std::meta::derive;\n\nmod test;\n\n/// SharedMutableValues is just a wrapper around ScheduledValueChange and ScheduledDelayChange that then allows us\n/// to wrap both of these values in WithHash. WithHash allows for efficient read of values in private.\n///\n/// Note that the WithHash optimization does not work in public (due to there being no unconstrained). But we also want\n/// to be able to read the values efficiently in public and we want to be able to read each value separately. Reading\n/// the values separately is tricky because ScheduledValueChange and ScheduledDelayChange are packed together (sdc and\n/// svc.block_of_change are stored in the same slot). For that reason we expose `unpack_value_change` and\n/// `unpack_delay_change` functions that can be used to extract the values from the packed representation. This\n/// is \"hacky\" but there is no way around it.\n#[derive(Eq)]\npub struct SharedMutableValues<T, let INITIAL_DELAY: u32> {\n    pub svc: ScheduledValueChange<T>,\n    pub sdc: ScheduledDelayChange<INITIAL_DELAY>,\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutableValues<T, INITIAL_DELAY> {\n    pub fn new(svc: ScheduledValueChange<T>, sdc: ScheduledDelayChange<INITIAL_DELAY>) -> Self {\n        SharedMutableValues { svc, sdc }\n    }\n}\n\npub fn unpack_value_change<T, let N: u32>(packed: [Field; 2 * N + 1]) -> ScheduledValueChange<T>\nwhere\n    T: Packable<N>,\n{\n    let svc_pre_packed = arrays::subarray(packed, 1);\n    let svc_post_packed = arrays::subarray(packed, N + 1);\n    ScheduledValueChange::new(\n        T::unpack(svc_pre_packed),\n        T::unpack(svc_post_packed),\n        packed[0] as u32,\n    )\n}\n\npub fn unpack_delay_change<let INITIAL_DELAY: u32>(\n    packed: Field,\n) -> ScheduledDelayChange<INITIAL_DELAY> {\n    // This function expects to be called with just the first field of the packed representation, which contains sdc\n    // and svc block_of_change. We'll discard the svc component.\n    let svc_block_of_change = packed as u32;\n\n    let mut tmp = (packed - svc_block_of_change as Field) / TWO_POW_32;\n    let sdc_block_of_change = tmp as u32;\n\n    tmp = (tmp - sdc_block_of_change as Field) / TWO_POW_32;\n    let sdc_post_is_some = tmp as bool;\n\n    tmp = (tmp - sdc_post_is_some as Field) / TWO_POW_8;\n    let sdc_post_inner = tmp as u32;\n\n    tmp = (tmp - sdc_post_inner as Field) / TWO_POW_32;\n    let sdc_pre_is_some = tmp as bool;\n\n    tmp = (tmp - sdc_pre_is_some as Field) / TWO_POW_8;\n    let sdc_pre_inner = tmp as u32;\n\n    ScheduledDelayChange {\n        pre: if sdc_pre_is_some {\n            Option::some(sdc_pre_inner)\n        } else {\n            Option::none()\n        },\n        post: if sdc_post_is_some {\n            Option::some(sdc_post_inner)\n        } else {\n            Option::none()\n        },\n        block_of_change: sdc_block_of_change,\n    }\n}\n\nglobal TWO_POW_32: Field = 2.pow_32(32);\nglobal TWO_POW_8: Field = 2.pow_32(8);\n\n// We pack to `2 * N + 1` fields because ScheduledValueChange contains T twice (hence `2 * N`) and we need one extra\n// field to store ScheduledDelayChange and the block_of_change of ScheduledValueChange.\nimpl<T, let INITIAL_DELAY: u32, let N: u32> Packable<2 * N + 1> for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; 2 * N + 1] {\n        let mut result = [0; 2 * N + 1];\n\n        // We pack sdc.pre, sdc.post, sdc.block_of_change and svc.block_of_change into a single field as follows:\n        // [ sdc.pre_inner: u32 | sdc.pre_is_some: u8 | sdc.post_inner: u32 | sdc.post_is_some: u8 | sdc.block_of_change: u32 | svc.block_of_change: u32 ]\n        result[0] = self.svc.block_of_change as Field\n            + ((self.sdc.block_of_change as Field) * 2.pow_32(32))\n            + ((self.sdc.post.is_some() as Field) * 2.pow_32(64))\n            + ((self.sdc.post.unwrap_unchecked() as Field) * 2.pow_32(72))\n            + ((self.sdc.pre.is_some() as Field) * 2.pow_32(104))\n            + ((self.sdc.pre.unwrap_unchecked() as Field) * 2.pow_32(112));\n\n        // Pack the pre and post values from ScheduledValueChange\n        let svc_pre_packed = self.svc.pre.pack();\n        let svc_post_packed = self.svc.post.pack();\n        for i in 0..N {\n            result[i + 1] = svc_pre_packed[i];\n            result[i + 1 + N] = svc_post_packed[i];\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; 2 * N + 1]) -> Self {\n        let svc = unpack_value_change::<T, N>(fields);\n        let sdc = unpack_delay_change::<INITIAL_DELAY>(fields[0]);\n        Self::new(svc, sdc)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32, let N: u32> Hash for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn hash(self) -> Field {\n        poseidon2_hash(self.pack())\n    }\n}\n"
    },
    "319": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "333": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n"
    },
    "337": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "338": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "354": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "355": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "357": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "363": {
      "path": "/home/nerses/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "392": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER},\n        hash::poseidon2_hash_with_separator,\n        traits::{Deserialize, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// The returned `PartialUintNote` value must be sent to public execution via a secure channel, since it is not\n    /// possible to verify the integrity of its contents due to it hiding information. The recommended ways to do this\n    /// are to retrieve it from public storage, or to receive it in an internal public function call.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient, sender);\n        context.emit_private_log(encrypted_log);\n\n        PartialUintNote { commitment }\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nimpl PartialUintNote {\n    pub fn commitment(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, value: u128, context: &mut PublicContext) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; 2] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "50": {
      "path": "/home/nerses/contracts/chains/aztec/contracts/train/src/lib.nr",
      "source": "pub fn bytes_to_u128_limbs(bytes: [u8; 32]) -> (u128, u128) {\n    let mut high: u128 = 0;\n    let mut low: u128 = 0;\n    for i in 0..16 {\n        high = (high << 8) + (bytes[i] as u128);\n    }\n    for i in 16..32 {\n        low = (low << 8) + (bytes[i] as u128);\n    }\n    (high, low)\n}\n\npub fn u128_limbs_to_bytes(high: u128, low: u128) -> [u8; 32] {\n    let mut bytes: [u8; 32] = [0; 32];\n\n    let mut temp = high;\n    for i in 0..16 {\n        bytes[15 - i] = (temp & 0xff) as u8;\n        temp >>= 8;\n    }\n\n    temp = low;\n    for i in 0..16 {\n        bytes[31 - i] = (temp & 0xff) as u8;\n        temp >>= 8;\n    }\n\n    bytes\n}\n"
    },
    "51": {
      "path": "/home/nerses/contracts/chains/aztec/contracts/train/src/main.nr",
      "source": "mod lib;\nmod types;\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract Train {\n    use crate::lib::{bytes_to_u128_limbs, u128_limbs_to_bytes};\n    use crate::types::events::{\n        TokenCommitted, TokenLockAdded, TokenLocked, TokenRedeemed, TokenRefunded,\n    };\n    use dep::aztec::messages::logs::note::encode_and_encrypt_note;\n    use dep::aztec::protocol_types::traits::{FromField, Packable, Serialize, ToField};\n    use dep::aztec::state_vars::{private_immutable::PrivateImmutable, SharedMutable};\n    use dep::sha256;\n    use dep::token::Token;\n    use aztec::macros::{\n        functions::{initializer, internal, private, public, utility, view},\n        notes::note,\n        storage::storage,\n    };\n    use aztec::prelude::{AztecAddress, Map};\n    use std::meta::derive;\n\n    #[note]\n    #[derive(Eq)]\n    struct HTLC_Private {\n        owner: AztecAddress,\n        randomness: Field,\n    }\n    #[derive(Eq, Packable, Serialize)]\n    pub struct HTLC_Public {\n        src_receiver: AztecAddress,\n        amount: u128,\n        token: AztecAddress,\n        hashlock_high: u128,\n        hashlock_low: u128,\n        secret_high: u128,\n        secret_low: u128,\n        timelock: u64,\n        claimed: u8,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor() {}\n\n    #[storage]\n    struct Storage<Context> {\n        contracts_private: Map<Field, PrivateImmutable<HTLC_Private, Context>, Context>,\n        contracts_public_user: Map<Field, SharedMutable<HTLC_Public, 3, Context>, Context>,\n        contracts_public_solver: Map<Field, SharedMutable<HTLC_Public, 3, Context>, Context>,\n    }\n\n    #[private]\n    fn commit_private_user(\n        Id: Field,\n        src_receiver: AztecAddress,\n        timelock: u64,\n        token: AztecAddress,\n        amount: u128,\n        dst_chain: str<8>,\n        dst_asset: str<8>,\n        dst_address: str<48>,\n        randomness: Field,\n    ) {\n        assert(amount > 0, \"Funds Not Sent\");\n\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address())\n            .commit_public_user(\n                dst_chain,\n                dst_asset,\n                dst_address,\n                Id,\n                src_receiver,\n                timelock,\n                token,\n                amount,\n            )\n            .enqueue(&mut context);\n\n        let htlc_note = HTLC_Private { owner: context.msg_sender(), randomness: randomness };\n        storage.contracts_private.at(Id).initialize(htlc_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n\n        Token::at(token)\n            .transfer_to_public(context.msg_sender(), context.this_address(), amount, randomness)\n            .call(&mut context);\n    }\n\n    #[internal]\n    #[public]\n    fn commit_public_user(\n        dst_chain: str<8>,\n        dst_asset: str<8>,\n        dst_address: str<48>,\n        Id: Field,\n        src_receiver: AztecAddress,\n        timelock: u64,\n        token: AztecAddress,\n        amount: u128,\n    ) {\n        assert(context.timestamp() + 900 < timelock, \"InvalidTimelock\");\n        let htlc_public = HTLC_Public {\n            src_receiver: src_receiver,\n            amount: amount,\n            token: token,\n            hashlock_high: 0 as u128,\n            hashlock_low: 0 as u128,\n            secret_high: 0 as u128,\n            secret_low: 0 as u128,\n            timelock: timelock,\n            claimed: 1 as u8,\n        };\n        storage.contracts_public_user.at(Id).schedule_value_change(htlc_public);\n        let log_msg = TokenCommitted {\n            Id: Id,\n            amount: amount,\n            token: token,\n            timelock: timelock,\n            dst_chain: dst_chain,\n            dst_asset: dst_asset,\n            dst_address: dst_address,\n            src_receiver: src_receiver,\n        };\n        context.emit_public_log(log_msg.pack());\n    }\n\n    #[private]\n    fn add_lock_private_user(Id: Field, hashlock: [u8; 32], timelock: u64) {\n        let htlc_private = storage.contracts_private.at(Id).get_note();\n        assert(htlc_private.owner == context.msg_sender(), \"NoAllowance\");\n\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address()).add_lock_public_user(Id, hashlock, timelock).enqueue(\n            &mut context,\n        );\n    }\n\n    #[internal]\n    #[public]\n    fn add_lock_public_user(Id: Field, hashlock: [u8; 32], timelock: u64) {\n        assert(context.timestamp() + 900 < timelock, \"InvalidTimelock\");\n\n        let htlc_public = storage.contracts_public_user.at(Id).get_current_value();\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n        assert(htlc_public.hashlock_high == (0 as u128), \"HashlockAlreadySet\");\n        assert(htlc_public.hashlock_low == (0 as u128), \"HashlockAlreadySet\");\n\n        let hashlock_tuple = bytes_to_u128_limbs(hashlock);\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: hashlock_tuple.0,\n            hashlock_low: hashlock_tuple.1,\n            secret_high: htlc_public.secret_high,\n            secret_low: htlc_public.secret_low,\n            timelock: timelock,\n            claimed: htlc_public.claimed,\n        };\n        storage.contracts_public_user.at(Id).schedule_value_change(modified_htlc_public);\n        let log_msg = TokenLockAdded { Id, hashlock, timelock };\n        context.emit_public_log(log_msg.pack());\n    }\n\n    #[private]\n    fn refund_private(Id: Field, is_solver: bool, randomness: Field) {\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address()).refund_public(Id, is_solver).enqueue(&mut context);\n\n        let mut htlc_private = storage.contracts_private.at(Id).get_note();\n        let mut htlc_public = storage.contracts_public_user.at(Id).get_current_value();\n\n        if is_solver {\n            htlc_public = storage.contracts_public_solver.at(Id).get_current_value();\n        }\n\n        Token::at(htlc_public.token)\n            .transfer_to_private(htlc_private.owner, htlc_public.amount)\n            .call(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn refund_public(Id: Field, is_solver: bool) {\n        let mut htlc_public = storage.contracts_public_user.at(Id).get_current_value();\n        if is_solver {\n            htlc_public = storage.contracts_public_solver.at(Id).get_current_value();\n        }\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n        assert(htlc_public.timelock < context.timestamp(), \"NotPassedTimelock\");\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: htlc_public.hashlock_high,\n            hashlock_low: htlc_public.hashlock_low,\n            secret_high: htlc_public.secret_high,\n            secret_low: htlc_public.secret_low,\n            timelock: htlc_public.timelock,\n            claimed: 2 as u8,\n        };\n\n        if is_solver {\n            storage.contracts_public_solver.at(Id).schedule_value_change(modified_htlc_public);\n        } else {\n            storage.contracts_public_user.at(Id).schedule_value_change(modified_htlc_public);\n        }\n\n        let log_msg = TokenRefunded { Id };\n        context.emit_public_log(log_msg);\n    }\n\n    #[private]\n    fn lock_private_solver(\n        Id: Field,\n        hashlock: [u8; 32],\n        amount: u128,\n        src_receiver: Field,\n        timelock: u64,\n        token: AztecAddress,\n        randomness: Field,\n        dst_chain: str<8>,\n        dst_asset: str<8>,\n        dst_address: str<48>,\n    ) {\n        assert(amount > 0, \"FundsNotSent\");\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address())\n            .lock_public_solver(\n                Id,\n                hashlock,\n                amount,\n                src_receiver,\n                token,\n                timelock,\n                dst_chain,\n                dst_asset,\n                dst_address,\n            )\n            .enqueue(&mut context);\n\n        let htlc_note = HTLC_Private { owner: context.msg_sender(), randomness: randomness };\n        storage.contracts_private.at(Id).initialize(htlc_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n\n        Token::at(token)\n            .transfer_to_public(context.msg_sender(), context.this_address(), amount, randomness)\n            .call(&mut context);\n    }\n\n    #[internal]\n    #[public]\n    fn lock_public_solver(\n        Id: Field,\n        hashlock: [u8; 32],\n        amount: u128,\n        src_receiver: Field,\n        token: AztecAddress,\n        timelock: u64,\n        dst_chain: str<8>,\n        dst_asset: str<8>,\n        dst_address: str<48>,\n    ) {\n        assert(context.timestamp() + 2700 < timelock, \"InvalidTimelock\");\n        let hashlock_tuple = bytes_to_u128_limbs(hashlock);\n        let htlc_public = HTLC_Public {\n            src_receiver: AztecAddress::from_field(src_receiver),\n            amount: amount,\n            token: token,\n            hashlock_high: hashlock_tuple.0,\n            hashlock_low: hashlock_tuple.1,\n            secret_high: 0 as u128,\n            secret_low: 0 as u128,\n            timelock: timelock,\n            claimed: 1 as u8,\n        };\n        storage.contracts_public_solver.at(Id).schedule_value_change(htlc_public);\n\n        let log_msg = TokenLocked {\n            Id: Id,\n            hashlock: hashlock,\n            amount: amount,\n            src_receiver: src_receiver,\n            token: token,\n            timelock: timelock,\n            dst_chain: dst_chain,\n            dst_asset: dst_asset,\n            dst_address: dst_address,\n        };\n\n        context.emit_public_log(log_msg.pack());\n    }\n\n    #[private]\n    fn redeem_private_solver(Id: Field, secret: [u8; 32], randomness: Field) {\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address()).redeem_public(Id, secret, true).enqueue(&mut context);\n\n        let htlc_public = storage.contracts_public_user.at(Id).get_current_value();\n\n        Token::at(htlc_public.token)\n            .transfer_to_private(htlc_public.src_receiver, htlc_public.amount)\n            .call(&mut context);\n    }\n\n    #[private]\n    fn redeem_private_user(\n        Id: Field,\n        secret: [u8; 32],\n        ownership_key: [u8; 32],\n        randomness: Field,\n    ) {\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address()).redeem_public(Id, secret, false).enqueue(&mut context);\n\n        let htlc_public = storage.contracts_public_solver.at(Id).get_current_value();\n        let ownership_key_hashed = sha256::sha256_var(ownership_key, ownership_key.len() as u64);\n        let ownership_key_tuple = bytes_to_u128_limbs(ownership_key_hashed);\n        let owner_tuple =\n            bytes_to_u128_limbs(((htlc_public.src_receiver).to_field()).to_le_bytes());\n        assert(owner_tuple.0 == ownership_key_tuple.0, \"NotAnOwner\");\n        assert(owner_tuple.1 == ownership_key_tuple.1, \"NotAnOwner\");\n\n        Token::at(htlc_public.token)\n            .transfer_to_private(context.msg_sender(), htlc_public.amount)\n            .call(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn redeem_public(Id: Field, secret: [u8; 32], is_solver: bool) {\n        let mut htlc_public = storage.contracts_public_user.at(Id).get_current_value();\n        if is_solver {\n            htlc_public = storage.contracts_public_solver.at(Id).get_current_value();\n        }\n        assert(htlc_public.amount > 0, \"HTLCNotExists\"); // If it doesn't exist, all parameters will default to zero values.\n        let hashed_secret = sha256::sha256_var(secret, secret.len() as u64);\n        let hashed_secret_tuple = bytes_to_u128_limbs(hashed_secret);\n        assert(htlc_public.hashlock_high == hashed_secret_tuple.0, \"HashlockNotMatch\");\n        assert(htlc_public.hashlock_low == hashed_secret_tuple.1, \"HashlockNotMatch\");\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n        let secret_limbs = bytes_to_u128_limbs(secret);\n\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: htlc_public.hashlock_high,\n            hashlock_low: htlc_public.hashlock_low,\n            secret_high: secret_limbs.0,\n            secret_low: secret_limbs.1,\n            timelock: htlc_public.timelock,\n            claimed: 3 as u8,\n        };\n\n        if is_solver {\n            storage.contracts_public_solver.at(Id).schedule_value_change(modified_htlc_public);\n        } else {\n            storage.contracts_public_user.at(Id).schedule_value_change(modified_htlc_public);\n        }\n\n        let log_msg = TokenRedeemed {\n            Id: Id,\n            hashlock: u128_limbs_to_bytes(htlc_public.hashlock_high, htlc_public.hashlock_low),\n            secret: secret,\n        };\n\n        context.emit_public_log(log_msg.pack());\n    }\n\n    // This utility function should be invoked by the frontend before each function call\n    // where the existence or non-existence of an HTLC is a critical security check.\n    #[utility]\n    unconstrained fn is_contract_initialized(Id: Field) -> bool {\n        let private_context = storage.contracts_private.at(Id).is_initialized();\n        let user_public = storage.contracts_public_user.at(Id).get_current_value();\n        let solver_public = storage.contracts_public_solver.at(Id).get_current_value();\n        let mut public_initialized: bool = true;\n        if (user_public.amount > 0 as u128 | solver_public.amount > 0 as u128) {\n            public_initialized = true;\n        }\n        private_context | public_initialized\n    }\n\n    #[view]\n    #[public]\n    fn get_htlc_public_solver(key: Field, is_solver: bool) -> pub HTLC_Public {\n        let mut result: HTLC_Public = storage.contracts_public_user.at(key).get_current_value();\n        if is_solver {\n            result = storage.contracts_public_solver.at(key).get_current_value();\n        }\n        result\n    }\n\n}\n"
    },
    "52": {
      "path": "/home/nerses/contracts/chains/aztec/contracts/train/src/types/events.nr",
      "source": "use dep::aztec::prelude::AztecAddress;\nuse dep::aztec::protocol_types::traits::{Packable, Serialize};\n\n#[derive(Serialize)]\npub struct TokenCommitted {\n    pub Id: Field,\n    pub amount: u128,\n    pub token: AztecAddress,\n    pub timelock: u64,\n    pub dst_chain: str<8>,\n    pub dst_asset: str<8>,\n    pub dst_address: str<48>,\n    pub src_receiver: AztecAddress,\n}\n\nimpl Packable<9> for TokenCommitted {\n    fn pack(self) -> [Field; 9] {\n        let zero: Field = 0;\n        let mut out = [zero; 9];\n        out[0] = self.Id;\n        out[1] = self.amount as Field;\n        out[2] = self.token.inner;\n        out[3] = self.timelock as Field;\n\n        let dst_chain_byte_array = self.dst_chain.as_bytes();\n        let mut dst_chain_byte_array_filled = [0 as u8; 31];\n        for i in 0..dst_chain_byte_array.len() {\n            dst_chain_byte_array_filled[i] = dst_chain_byte_array[i];\n        }\n\n        out[4] = Field::from_be_bytes::<31>(dst_chain_byte_array_filled);\n\n        let dst_asset_byte_array = self.dst_asset.as_bytes();\n        let mut dst_asset_byte_array_filled = [0 as u8; 31];\n        for i in 0..dst_asset_byte_array.len() {\n            dst_asset_byte_array_filled[i] = dst_asset_byte_array[i];\n        }\n\n        out[5] = Field::from_be_bytes::<31>(dst_asset_byte_array_filled);\n\n        let dst_address_byte_array = self.dst_address.as_bytes();\n        let mut dst_address_byte_array_filled_1 = [0 as u8; 31];\n        let mut dst_address_byte_array_filled_2 = [0 as u8; 31];\n\n        for i in 0..31 {\n            dst_address_byte_array_filled_1[i] = dst_address_byte_array[i];\n        }\n\n        for i in 31..48 {\n            dst_address_byte_array_filled_2[i - 31] = dst_address_byte_array[i];\n        }\n\n        out[6] = Field::from_be_bytes::<31>(dst_address_byte_array_filled_1);\n        out[7] = Field::from_be_bytes::<31>(dst_address_byte_array_filled_2);\n\n        out[8] = self.src_receiver.inner;\n        out\n    }\n\n    fn unpack(fields: [Field; 9]) -> Self {\n        assert(false, \"unpack not implemented\");\n        TokenCommitted {\n            Id: fields[0] as Field,\n            amount: 0 as u128,\n            token: AztecAddress::zero(),\n            timelock: 0 as u64,\n            dst_chain: \"00000000\",\n            dst_asset: \"00000000\",\n            dst_address: \"000000000000000000000000000000000000000000000000\",\n            src_receiver: AztecAddress::zero(),\n        }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenLockAdded {\n    pub Id: Field,\n    pub hashlock: [u8; 32],\n    pub timelock: u64,\n}\n\nimpl Packable<4> for TokenLockAdded {\n    fn pack(self) -> [Field; 4] {\n        let mut out = [0 as Field; 4];\n        out[0] = self.Id;\n\n        let hb = self.hashlock;\n        let mut h1 = [0 as u8; 31];\n        for i in 0..31 {\n            h1[i] = hb[i];\n        }\n        out[1] = Field::from_be_bytes::<31>(h1);\n\n        let mut h2 = [0 as u8; 31];\n        h2[0] = hb[31];\n        out[2] = Field::from_be_bytes::<31>(h2);\n\n        out[3] = self.timelock as Field;\n        out\n    }\n\n    fn unpack(fields: [Field; 4]) -> Self {\n        let Id = fields[0];\n\n        let b1 = fields[1].to_be_bytes();\n        let b2 = fields[2].to_be_bytes();\n        let mut hash = [0 as u8; 32];\n        for i in 0..31 {\n            hash[i] = b1[i];\n        }\n        hash[31] = b2[0];\n\n        let timelock = fields[3] as u64;\n\n        TokenLockAdded { Id, hashlock: hash, timelock }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenRefunded {\n    pub Id: Field,\n}\n\n#[derive(Serialize)]\npub struct TokenRedeemed {\n    pub Id: Field,\n    pub hashlock: [u8; 32],\n    pub secret: [u8; 32],\n}\n\nimpl Packable<5> for TokenRedeemed {\n    fn pack(self) -> [Field; 5] {\n        let mut out = [0 as Field; 5];\n        out[0] = self.Id;\n\n        let hb = self.hashlock;\n        let mut h1 = [0 as u8; 31];\n        for i in 0..31 {\n            h1[i] = hb[i];\n        }\n        out[1] = Field::from_be_bytes::<31>(h1);\n        let mut h2 = [0 as u8; 31];\n        h2[0] = hb[31];\n        out[2] = Field::from_be_bytes::<31>(h2);\n\n        let sb = self.secret;\n        let mut s1 = [0 as u8; 31];\n        for i in 0..31 {\n            s1[i] = sb[i];\n        }\n        out[3] = Field::from_be_bytes::<31>(s1);\n        let mut s2 = [0 as u8; 31];\n        s2[0] = sb[31];\n        out[4] = Field::from_be_bytes::<31>(s2);\n\n        out\n    }\n\n    fn unpack(fields: [Field; 5]) -> Self {\n        let Id = fields[0];\n\n        let b1 = fields[1].to_be_bytes();\n        let b2 = fields[2].to_be_bytes();\n        let mut hashlock = [0 as u8; 32];\n        for i in 0..31 {\n            hashlock[i] = b1[i];\n        }\n        hashlock[31] = b2[0];\n\n        let b3 = fields[3].to_be_bytes();\n        let b4 = fields[4].to_be_bytes();\n        let mut secret = [0 as u8; 32];\n        for i in 0..31 {\n            secret[i] = b3[i];\n        }\n        secret[31] = b4[0];\n\n        TokenRedeemed { Id, hashlock, secret }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenLocked {\n    pub Id: Field,\n    pub hashlock: [u8; 32],\n    pub amount: u128,\n    pub src_receiver: Field,\n    pub token: AztecAddress,\n    pub timelock: u64,\n    pub dst_chain: str<8>,\n    pub dst_asset: str<8>,\n    pub dst_address: str<48>,\n}\n\nimpl Packable<11> for TokenLocked {\n    fn pack(self) -> [Field; 11] {\n        let mut out = [0 as Field; 11];\n        out[0] = self.Id;\n\n        let hb = self.hashlock;\n        let mut h1 = [0 as u8; 31];\n        for i in 0..31 {\n            h1[i] = hb[i];\n        }\n        out[1] = Field::from_be_bytes::<31>(h1);\n\n        let mut h2 = [0 as u8; 31];\n        h2[0] = hb[31];\n        out[2] = Field::from_be_bytes::<31>(h2);\n\n        out[3] = self.amount as Field;\n        out[4] = self.src_receiver as Field;\n        out[5] = self.token.inner;\n        out[6] = self.timelock as Field;\n\n        let dst_chain_byte_array = self.dst_chain.as_bytes();\n        let mut dst_chain_byte_array_filled = [0 as u8; 31];\n        for i in 0..dst_chain_byte_array.len() {\n            dst_chain_byte_array_filled[i] = dst_chain_byte_array[i];\n        }\n        out[7] = Field::from_be_bytes::<31>(dst_chain_byte_array_filled);\n\n        let dst_asset_byte_array = self.dst_asset.as_bytes();\n        let mut dst_asset_byte_array_filled = [0 as u8; 31];\n        for i in 0..dst_asset_byte_array.len() {\n            dst_asset_byte_array_filled[i] = dst_asset_byte_array[i];\n        }\n        out[8] = Field::from_be_bytes::<31>(dst_asset_byte_array_filled);\n\n        let addr = self.dst_address.as_bytes();\n        let mut dst_address_byte_array_filled_1 = [0 as u8; 31];\n        let mut dst_address_byte_array_filled_2 = [0 as u8; 31];\n        for i in 0..31 {\n            dst_address_byte_array_filled_1[i] = addr[i];\n        }\n        for i in 31..48 {\n            dst_address_byte_array_filled_2[i - 31] = addr[i];\n        }\n        out[9] = Field::from_be_bytes::<31>(dst_address_byte_array_filled_1);\n        out[10] = Field::from_be_bytes::<31>(dst_address_byte_array_filled_2);\n\n        out\n    }\n\n    fn unpack(fields: [Field; 11]) -> Self {\n        assert(false, \"unpack not implemented\");\n        TokenLocked {\n            Id: fields[0] as Field,\n            hashlock: [0 as u8; 32],\n            amount: 0 as u128,\n            src_receiver: 0 as Field,\n            token: AztecAddress::zero(),\n            timelock: 0 as u64,\n            dst_chain: \"00000000\",\n            dst_asset: \"00000000\",\n            dst_address: \"000000000000000000000000000000000000000000000000\",\n        }\n    }\n}\n"
    },
    "54": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
    },
    "55": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "62": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "63": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(gas_for_call(gas_opts), contract_address, calldata);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(gas_for_call(gas_opts), contract_address, calldata);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_opcode(gas, address, args)\n}\n\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "64": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "65": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "69": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "81": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "84": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/keys/ecdh_shared_secret.nr",
      "source": "use dep::protocol_types::{\n    address::aztec_address::AztecAddress, point::Point, scalar::Scalar, traits::FromField,\n};\nuse std::{embedded_curve_ops::multi_scalar_mul, ops::Neg};\n\n/// Computes a standard ecdh shared secret: [secret] * public_key = shared_secret.\n/// The input secret is known only to one party. The output shared secret is derivable\n/// by both parties, through this function.\n/// E.g.:\n/// Epk = esk * G // ephemeral keypair\n/// Pk = sk * G // recipient keypair\n/// Shared secret S = esk * Pk = sk * Epk // see how this function can be called with two different sets of inputs, depending on which secret the caller knows (either esk or sk)?\n// See also: https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman\npub fn derive_ecdh_shared_secret(secret: Scalar, public_key: Point) -> Point {\n    let shared_secret = multi_scalar_mul([public_key], [secret]);\n    shared_secret\n}\n\n/// Computes a standard ecdh shared secret using the address public key of the given address:\n/// [ephemeral_secret] * recipient_address_public_key = shared_secret.\n/// The intention is that the _creator_ of a shared secret would call this function,\n/// given the address of their intended recipient.\npub fn derive_ecdh_shared_secret_using_aztec_address(\n    ephemeral_secret: Scalar,\n    recipient_address: AztecAddress,\n) -> Point {\n    derive_ecdh_shared_secret(ephemeral_secret, recipient_address.to_address_point().inner)\n}\n\n#[test]\nunconstrained fn test_consistency_with_typescript() {\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let shared_secret = derive_ecdh_shared_secret(secret, point);\n\n    // This is just pasted from a test run.\n    // The original typescript code from which this could be generated seems to have been deleted by someone, and soon the typescript code for encryption and decryption won't be needed, so this will have to do.\n    let hard_coded_shared_secret = Point {\n        x: 0x15d55a5b3b2caa6a6207f313f05c5113deba5da9927d6421bcaa164822b911bc,\n        y: 0x0974c3d0825031ae933243d653ebb1a0b08b90ee7f228f94c5c74739ea3c871e,\n        is_infinite: false,\n    };\n    assert_eq(shared_secret, hard_coded_shared_secret);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let shared_secret = derive_ecdh_shared_secret(secret_a, pk_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_from_address_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let mut pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let mut pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let address_b = AztecAddress::from_field(pk_b.x);\n\n    // We were lazy in deriving the secret keys, and didn't check the resulting y-coordinates\n    // of the pk_a or pk_b to be less than half the field modulus.\n    // If needed, we negate the pk's so that they yield valid address points.\n    // (We could also have negated the secrets, but there's no negate method for\n    // EmbeddedCurvesScalar).\n    pk_a = if (AztecAddress::from_field(pk_a.x).to_address_point().inner == pk_a) {\n        pk_a\n    } else {\n        pk_a.neg()\n    };\n    pk_b = if (address_b.to_address_point().inner == pk_b) {\n        pk_b\n    } else {\n        pk_b.neg()\n    };\n\n    let shared_secret = derive_ecdh_shared_secret_using_aztec_address(secret_a, address_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n"
    },
    "85": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/keys/ephemeral.nr",
      "source": "use std::embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul};\n\nuse dep::protocol_types::{point::Point, scalar::Scalar};\n\nuse crate::oracle::random::random;\n\npub fn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n\n    // Safety: we use the randomness to preserve the privacy of both the sender and recipient via encryption, so a\n    // malicious sender could use non-random values to reveal the plaintext. But they already know it themselves anyway,\n    // and so the recipient already trusts them to not disclose this information. We can therefore assume that the\n    // sender will cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // TODO(#12757): compute the key pair without constraining eph_sk twice (once in from_field, once in the black box\n    // called by fixed_base_scalar_mul).\n    let eph_sk = EmbeddedCurveScalar::from_field(randomness);\n    let eph_pk = fixed_base_scalar_mul(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n"
    },
    "86": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "90": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_notes` utility function PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_notes = generate_sync_notes();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_notes\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_notes() -> Quoted {\n    // TODO(https://github.com/noir-lang/noir/issues/7912): Doing the following unfortunately doesn't work. Once\n    // the issue is fixed uncomment the following and remove the workaround from TS (look for the issue link in the\n    // codebase).\n    // let utility: fn(FunctionDefinition) -> () = crate::macros::functions::utility;\n    // quote {\n    //     #[$utility]\n    //     unconstrained fn sync_notes() {\n    //     }\n    // }\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[aztec::macros::functions::utility]\n        unconstrained fn sync_notes() { }\n    }\n}\n"
    },
    "91": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "94": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_slice, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_view,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_SLICE_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args =  &[];\n    // serialized_args = serialized_args.append(aztec::protocol_types::traits::Serialize::serialize(target_address));\n    // serialized_args = serialized_args.push_back(fee_juice_limit_per_tx as Field);\n    // ```\n    let serialized_args_slice_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_SLICE_NAME = &[];\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append = add_to_field_slice(SERIALIZED_ARGS_SLICE_NAME, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n"
    },
    "95": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "98": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, &[], false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    }
  }
}
