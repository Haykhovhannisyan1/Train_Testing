{
  "transpiled": true,
  "noir_version": "1.0.0-beta.4+0000000000000000000000000000000000000000",
  "name": "Train",
  "functions": [
    {
      "name": "refund_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3564161243949231814": {
            "error_kind": "string",
            "string": "Function refund_public can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "9323748002447105156": {
            "error_kind": "string",
            "string": "NotPassedTimelock"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "refund_public"
      ]
    },
    {
      "name": "lock_private_solver",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 48
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6418028854678020178": {
            "error_kind": "string",
            "string": "FundsNotSent"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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tSpZrlXJcq1KlmtVslyrkuValSzXqmS9ViXrtSpZr1XJeq1K1mtVsl6rkvValazXqmS9ViXrtSrZrlXJdq1KtmtVsl2rku1alWzXqmS7ViXbtSrZrlXJdq1K8rUqydeqJF+rknytSvK1KsnXqiRfq5J8rUrytSrJl6okT9O1PwvX/ixe+7N07c/k2p/N1/5sufZn67U/26792bUqCdeqJFyrknCtSsK1KgnXqiRcq5JwrUrCtSoJ16okXKuSeK1K4rUqideqJF6rknitSuK1KonXqiReq5J4rUritSpJ16okXauSdK1K0rUqSdeqJF2rknStStK1KrmWveZr2Wu+lr3ma9lrvpa95mvZa76WveZr2Wu+lr3ma9lrvpa95mvZa76WveZr2Wu+lr3ma9lrvpa95mvZa76WveZr2Wu+lr3ma9lrvpa95mvZa76WveZr2Wu+lr3ma9lrvpa95mvZa76WveZr2Wu+lr3ma9lrvpa95mvZa76WveZr2Wu+lr3ma9lrvpa95mvZa76WveZr2Wu+lr3ma9lrvpa95mvZa76WveZr2Wu+lr3ma9lrvpa95mvZa76WveZr2Wu+lr3ma9lrvpa95mvZa76WveZL2es8XcpeP/4sXPuzeO3P0rU/k2t/Nl/7s+Xan63X/my79mfXqiRcq5JwrUrCtSoJ16okXKuScK1KwrUqCdeqJFyrknCtSuK1KonXqqSQveb9y3vhI4k5+LNClazr/mc5fvmzoxNnlZ5n8TEc8TWc2ddwFl/DWX0NZ/M1nOxqOKWMv9Zwgq/hRF/D8fWpnHx9Kidfn8rJ16dy8vWpnHx9Kidfn8ri61NZrD+VXz6K6WM80dl4krPxiLPxzM7Gszgbz68/m29/tl37s3zpz47v4Maw3Y/wiDHMJ9DCsqb96b7LujwO1jk66SBu6X6ITJqeD+GZjo8CnfYDsD423/3qPH2OPzgf/zzdBVjmlL6PPzY+/tT4+KXx8c+Nj39pfPxr4+PfGh9/bnv8i/f992z8je+/S+P779L4/rs0vv8uje+/S+P779L4/rs0vv8uje+/a+P779r4/rs2vv+uje+/a+P779r4/rs2vv+uje+/a+P779r4/rs1vv9uje+/W+P779b4/rs1vv9uje+/W+P779b4/rs1vv9uje+/ufH9Nze+/+bG99/c+P6bG99/c+P7b258/82N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V3wUeeSKHwQHfNvDP+6rk/PtThAc74nXXnC4J157gvbzal+Y7wUv54rXXnCgL157wYu54rUXvJYrXnvBS7nStY+CV3LFa4+6nlztUdeTqz3qenK1R21Hrvad53jeqbUm7Z21R+2/7O88TynZnzqPtYv2dx4vFu3vPOYp2t/5vF20nwa3v/O5s2h/57X9ov2d16eL9g8+/6ax51+jxp5/jRp7/jVq7PnXqLHnX6PGnn+NGnv+NWrs+deosedfo8aef40afP7Vg8+/evD5Vw8+/+rB51/d+fzrklsvKfLHEulmf+fzb9H+zuffov2dz79F+zuff4v2dz7/luzv/cbtov2dz79F+zuff4v2dz7/Fu3vfP4Njsz308EfPjXMrn1auz5r6WC0+Xa192Xeiq72vmO9oqu9b9Cu6Grv+5Erutr79tt6rtred5tWdLX3zZUVXZW7l9CpdceNI/Xj2S9m5O60KzFDYOaEGbk79ErMyP02scSM3C/3SszI/a6txIzcr74KzMx1b2FVZuR+MVRiRnAM7NdLclyKhWfJuJVGMpEOT+tvHnFz3Kchte8P0iF9Px11+nku2RfvBN4f4R23pT3D+1S5xDXedViXSexSUi7xfu1EwyLvgu+He5T3qfKgcXiXfCnape8td9ZtyPFI4LEKj/j+tw6POCetDo84c6wOjzi/qw6POAurCo+SbwiqyiPOaKrDI847uuHck1L2I/nCmAdZJ7D+AOvIrO5gfXuvR3MwemcdedgTrCNre4J15HhPsI6M8AHWA/LHJ1hHtvkE68hNn2AduekTrBNYf4B15KZPsI7cdN6zlnczjDmc9fJ91rLBXUqCtUeeLld7VAvEao+7lARrj8qJXO1Rv5GrPapIcrUnaC9We1TU5GqPup5c7VHXk6s96npytUddT6z2vd/bCO1v1B51Pbnao64nV3vU9eRqT9BerPao68nVHnU9udqjridXe9T15GqPup5U7W3v98FD+xu1R11Prvao68nVHnU9udojv59Ye7dr7/2r9ojz59U+0PqsCY5etNeI8+VqjzhfrvaI8+VqjzhfrvYE7cVqj/V7udojv5erPdbv5WqP9Xu52sut6yWz+picKzzrVNgu6dXq2FO+7t21Rm6NrC6PcutNdXmUW7upy6PgOkhcrxrXSvkSkVrvRDqfIZJAZB0iBWfodYkUnO7WJVJw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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "notify_created_nullifier_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "random",
        "decompose_hint",
        "lte_hint",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "get_htlc_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "view",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "key",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "Train::HTLC_Public",
            "fields": [
              {
                "name": "src_receiver",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "amount",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "token",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "hashlock_high",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "hashlock_low",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "secret_high",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "secret_low",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "timelock",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "claimed",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 8
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "9174444391250494040": {
            "error_kind": "string",
            "string": "Function get_htlc_public can only be called statically"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_htlc_public"
      ]
    },
    {
      "name": "lock_public_solver",
      "is_unconstrained": true,
      "custom_attributes": [
        "internal",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 48
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "15001264570739363109": {
            "error_kind": "string",
            "string": "Function lock_public_solver can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "lock_public_solver"
      ]
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [
        "aztec::macros::functions::utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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39bJ3n87RPz8IdbPHyJ9/hD584conz9E/fghXjz+6XoI9/lD+M8f4vNnd/382V0/f3bXz5/d9fNnd/382V0/fna7Zfn8IdznD+E/f4jfPrvvu8Vzu63ndkvndsvndivndqundnPLud3cud38ud3OVYk7VyXuXJW4c1XizlWJO1cl7lyV+HNV4s9ViT9XJf5clfhzVeLPVYk/VyX+XJX4c1Xiz1VJOFcl4VyVhHNVEs5VSThXJeFclYRzVRLOVUk4VyXhXJXEc1USz1VJPFcl8VyVxHNVEs9VSTxXJfFclcRzVRLPVcl6rkrWc1WynquS9VyVrOeqZD1XJeu5KlnPVcl6rkrWc1WSzlVJOlcl6VyVpHNVks5VSTpXJelclaRzVZLOVUk6VyX5XJXkc1WSz1VJPlcl+VyV5HNVks9VST5XJflcleRzVVLOVUk5VyXlXJWUc1VSzlVJOVcl5VyVlHNVUs5VSTlXJfVcldRzVVLPVUk9VyX1XJXUc1VSz1VJPVcl9VyV1FNV4pfl3G7u3G7+3G7h3G7x3G7rud3Sud3yud3Kud3OVcm57NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1b/IXuv+8t4tHHQHu72okpz33ar/abejFWc7fc/iNpyqajivsmKp4Thdw/G6hhN0DSfqGs6qazhJ13CyruHouipXVVflsKi6KodF1VU5LKquymFRdVUOi6qrclhUXZXDcvVV+e2nmG7jycrGU5SNp+oaj1uUjccpG89vX5vvu4Vzu8Vzux1ek27PTLclPG5PJtcGNJdy2L/um3J6LKxztNLBzZhvi8jc7qah8bfTsuwLYC3h8WPyunyNPykf/7psAqQ1hO/jz4OPvww+/jr2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",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "commit_public_user",
      "is_unconstrained": true,
      "custom_attributes": [
        "internal",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 48
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "src_receiver",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3559210201980528457": {
            "error_kind": "string",
            "string": "Function commit_public_user can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "commit_public_user"
      ]
    },
    {
      "name": "add_lock_private_user",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17476367995570638746": {
            "error_kind": "string",
            "string": "NoAllowance"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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7J6M9C/DQtuw2DYstQ0rh/t2aH4Ms88B+Ovn4So/C+M+ielxEvvzk7x9rnc7hbv+FHT9Kfynp7gPC23DYtuw1HT3CW23yNh2i4xtt8iT54XVYa5tGLUN823DQtuw2DTs5PFP9MeNNcbnTz5LpZmN2/G2TrT25RT2+lO4609B15/CX3+KcP0p4vWnSNefIl9+ipPHP6ynuP7qztdf3fn6qztff3Xn66/ufP3Vna+/uvP1V3e+/Oo223b9KT6+uu/DbNsw1zaM2ob5tmGhbVhsG5bahuWmYWZrG9aWJaYtS0xblpi2LDFtWWLassS0ZYlpyxLTliW2LUtsW5bYtiyxbVli27LEtmWJbcsS25Ylti1LbFuWuLYscW1Z4tqyxLVliWvLEteWJa4tS1xblri2LHFtWUJtWUJtWUJtWUJtWUJtWUJtWUJtWUJtWUJtWUJtWeLbssS3ZYlvyxLfliW+LUt8W5b4tizxbVni27LEt2VJaMuS0JYloS1LQluWhLYsCW1ZEtqyJLRlSWjLktCWJbEtS2JblsS2LIltWRLbsiS2ZUlsy5LYliWxLUtiW5aktixJbVmS2rIktWVJasuS1JYlqS1LUluWpLYsSW1ZktuyJLdlSW7LktyWJbktS3JbluS2LMltWZLbsiQ3ZYndtrZhpm2YbRvm2oZR2zDfNiy0DYttw1LbsLYsaeu92rbeq23rvdq23qtt673att6rbeu92rbeq23rvdq23qtt673att6rbeu92rbeq23rvdq23qtt673att6rbeu92rbeq23rvdq23qtt673att6rbeu92rbeq23rvdq23qtt673att6rbeu92rbeq23rvdq23qtt673att6rbeu92rbeq23rvdq23qtt673att6rbeu92rbeq23rvdq23qtt673att6rbeu92rbeq23rvdq23qtt673att6rbeu92rbeq23rvdq23qtt673att6rbeu92rbeq23rvdq23qtt673att6rbeu92rbeq23rvdq23qtt673att6rbeu92rbeq23rvdqT3ms+Xt67tetMYdhJlsR4DMv227DSirNM+1nczIlzmZPmMidPZc5Zb3uUOWYuc+xc5ri5zKG5zPFzmTPXXTnPdVfOc92V81R3ZbdNdVd221R3ZbdNdVd221R3Zbf1viu/3YrpZo+fzJ4wmT1xMnvSZPbkuewxH9+b78NM2zDbNqx4T7o9xdyX8Lg9K/QVaCZEd+zuG2J4LKxTWungJpX3RWRu84Wr/HbYtmMBrM09PibP25f9NLn9ftsDELxzr/Z74fYH4fZH4fYn4fZn2faXX8AQZL8Rbr8Vbv/s82/NfuHzrxU+/1rh868VPv9a4fOvFT7/OuHzrxM+/zrh868TPv864fOvEz7/OuHzrxM+/zrh868TPv+S8PmXhM+/JHz+JeHzLwmff0n4/EvC518SPv+S8PmXhM+/Xvj864XPv174/OuFz79e+Pzrhc+/Xvj864XPv174/OuFz79B+PwbhM+/Qfj8G4TPv0H4/BuEz79B+PwbhM+/Qfj8G4TPv1H4/BuFz79R+Pwbhc+/Ufj8G4XPv1H4/BuFz79R+Pwbhc+/Sfj8m4TPv0n4/JuEz79J+PybhM+/Sfj8m4TPv0n4/JuEz79Z+Pybhc+/Wfj8m4XPv1n4/JuFz79Z+Pybhc+/Wfj8m2XPv7TJnn9pkz3/0iZ7/qVN9vxLm+z5lzbZ8y9tsudf2mTPv7TJnn9pEz7/GuHzrxE+/xrh8+/061/V7Bc+/wpf/4qEr39Fwte/IuHrX5Hw9a9I+PpXJHz9KxK+/hUJX/+KhK9/RcLXvyLh61+R8PWvSPj6VyR8/SsSvv4VCV//ioSvf0XC178i4etfkfD1r0j4+lckfP0rEr7+FQlf/4qEr39Fwte/IuHrX5Hw9a9I+PpXJHz9KxK+/hUJX/+KhK9/RcLXvyLh61+R8PWvSPj6VyR8/SsSvv4VCV//ioSvf0XC178i4etfkfD1r0j4+lckfP0rEr7+FQlf/4qEr39Fwte/IuHrX5Hw9a9I+PpXJHz9KxK+/hUJX/+KhK9/RcLXvyLh61+R8PWvSPj6VyR8/SsSvv4VCV//ioSvf0XC178i4etfkfD1r0j4+lckfP0rEr7+FQlf/4qEr39Fwte/IuHrX5Hw9a9I+PpXJHz9KxK+/hUJX/+KhK9/RcLXvyLh61+R8PWvvPD1r7zw9a+88PWvvPD1r/wme/71wte/8sLXv/LC17/ywte/8sLXv/LC17/ywte/8sLXv/LC17/ywte/8tOvf/X46RCzeba/dPBudUjh8cPJffk6+1zN6evs8zqnr7PXAJy+zl4vMPo6/dpenL5OXof47NPDV/veV4p5t+P2gDkdB9scimabeFjt6DjaufjFZvIaZyibyeunoWxo8vvHth33hM2Fl9psrrXR7iZNVULdTZqq0rmbNFVBcjdpqrrht0lzLR12N2mqWfhu0lST392kqeacu0lT3ervJs13955rsay7SfPdveda0upu0nx377kWnrqbNN/de67loe4mzXf3nmsRp7tJ892951pq6W7SfHfvuRZEups03917rmWL7ibNd/eea3Ghu0nz3b3nWgLobtJ8d++5Fuq5mzTf3Xuu5XTuJs13955r0Zu7SfPdvedamuZu0nx377kWkLmbNN/de65lXu4mzXf3nmsxlrtJ892951oy5W7SfHfvuRY2uZs03917ruVH7ibNd/eea5GQu0nz3b3nWsrjbtJ8d++5Fty4mzTf3XuuZTHuJs13955r8Yq7SfPdvedaYuJu0nx377kWgribNN/de67lGu4mzXf3nmtRhbtJ892951r64G7SfHfvuRYouJs03917rmUE7iZNd/cOc33sfzdpurt3mOuT/LtJ0929wzbd3TvM9S383aTp7t5hri/W7yZNd/cOc31X/tukuT4Vv5s03917rg+67ybNd/ee67Pru0nz3b3n+uD5btJ8d++5Ph++mzTf3Xuuj3HvJs13957rU9W7SfPdvef6MPNu0nx37/m+tQzzfWsZ5vvWMsz3rWWY71vLMN+3lmG+by3DfN9ahvm+tQzzfWsZ5vvWMsz3rWWY71vLMN+3lmG+by3DfN9ahvm+tQzzfWsZ5vvWMsz3rWWY61vL16OfltWJyeTj6OKyOjd39oVyfIrPP106OpmYv46+/XI8jrbJfrGZfGm5oWwmX4puKJvJl64byWau73EnYyNnabz+bOQsjdefjZyl8fqz4bkXb48F+KKJT2x+n+TzDzDvw1zbMGob5tuGhbZhsW1YahuWm4Z9/oHafZhpG9aWJbEtS2JblsS2LIltWRLbsiS2ZUlsy5LUliWpLUtSW5aktixJbVmS2rIktWVJasuS1JYlqS1LcluW5LYsyW1ZktuyJLdlSW7LktyWJbktS3JbluSmLInb1jbMtA2zbcNc2zBqG+bbhoW2YbFtWGob1pYlpi1LTFuWmLYsMW1ZYtqyxLRliWnLEtOWJaYtS0xblti2LLFtWWLbssS2ZYltyxLbliW2LUtsW5bYtiyxbVni2rKk/NIChWMY3e4bhWG2PMw8htntP9/L7bTR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",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert"
      ],
      "verification_key": "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"
    },
    {
      "name": "redeem_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "772057049813214347": {
            "error_kind": "string",
            "string": "HTLCNotExists"
          },
          "2570651705007895968": {
            "error_kind": "string",
            "string": "HashlockNotMatch"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17814817983036354427": {
            "error_kind": "string",
            "string": "Function redeem_public can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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GYBeABokAgAaAAAftiUAAChEACgSAhsAOBsZHC0NHBoBKAATgFsAGQ44ExkbJAIAGwAAH94lAAAoMg0oABmAXgAbJAIAGwAAH/MlAAAoRAAoEgIcADgcGR0tDR0bASgAE4BTABkOOBMZHCQCABwAACAbJQAAKDINKAAZgF4AEyQCABMAACAwJQAAKEQAKBICHAA4HBkdLQ0dExwMGBkEGSgAGYBdABgcDBoZBAA4GBkaDjgYGhwkAgAcAAAgZyUAACgyGSgAGoBdABgcDBsZBAA4GBkaDjgYGhskAgAbAAAgiyUAACgyGSgAGoBdABgcDBMZBAA4GBkTDjgYExokAgAaAAAgryUAACgyDSgAF4BOABgkAgAYAAAgxCUAAChELgQAFIADKACABAQAESUAACiMLgiABQAYACgYAhkAOBkXGi0OExotDhgIASgACYBZABMtDBMJIwAACkAtDQgRDSgACYBOABIkAgASAAAhGCUAAChELgQAEYADKACABAQAESUAACiMLgiABQASACgSAhMAOBMJFC4KgFUAFC0OEggBKAAJgFkAES0MEQkjAAAJvC0IARMAAAECAS4KgFUAEwUoABCATAAUJwIYBAALKAAYgEwAFyQCABcAACGbBygAFIBMABoKOBoQGSQCABkAACGbJQAAKGguCIBVABIjAAAhpg0oABKATAAXJAIAFwAAIhMjAAAhuy0NCRItDRMUDSgAEIBOABMkAgATAAAh2CUAAChELgQAEoADKACABAQAESUAACiMLgiABQATACgTAhcAOBcQGC0OFBgBKAAQgFkAEi0OEwktDBIQIwAABfoAOBQSGA44FBgZJAIAGQAAIiolAAAoMg0oABiAYgAZJAIAGQAAIkgjAAAiPy0MDRcjAAAidA0oABiAYgAZJAIAGQAAIl0lAAAoRAAoAgIaADgaGBstDRsZLQwZFyMAACJ0LQ0TGBkoABiAXQAZHAwXGAQAOBkYFw44GRcaJAIAGgAAIpwlAAAoMi0OFxMBKAASgFkAFy0MFxIjAAAhpigAgAQEeAANAAAAgASAAyQAgAMAACLZKgEAAQX3ofOvpa3UyjwBAQImKgEAAQW+Hj//PqT2+jwBAQImKgEAAQX3OvKRkR9vezwBAQImJQAAIrErAgALAAAAAAAAAAACAAAAAAAAAAAnAhAEES0IABEtDAsSABAA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",
      "debug_symbols": "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",
      "brillig_names": [
        "redeem_public"
      ]
    },
    {
      "name": "is_contract_initialized",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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8Km5ntO11VWN8Am0ntO11VWN8GmuntO11VWN8MmontO11VWN8CmjntO11VWN8ImdntO11VWN8OmXntO11VWN8EmSntO11VWN8KmMntO11VWN8AmHntO11VWN8GmBntO11VWNsOR9z+na6qpGWIq953RtdVUjrCnec7q2uqpiq6sqtrqqYqurKra6qmqrq6q2uqpqq6uqtrqqEb5i0XO6trqqEb440XO6trqqub4j0Z6uqa4qzPUdifZ0TXVVYa7vSLSna6qrCkuwNV1TXVWY6zsS7ema6qrCXN+RaE/XVlc12ZchmtO11VVN9vWG5nRtdVWTfWGhOV1bXdVkX0FoTtdWVzXZlwqa07XVVU32NYHmdG11VZN9TaA5XVtd1WRfE2hO11ZXNdvXBFrTtdVVzbY6f2u6trqq2Va7b03XVlc12+rxrena6qpmW429NV1bXdVsq5u3pmurq5pttfDWdG11VcFWVxVsdVW21lYPttZWD7bWVg+21lYPttZWD7bWVg+21lYPttZWD7bWVg+21lYPttZWD7Otrf6x7xylbVu3LOsvG985Bjh24cg3Cftw5KOEfTjyVcI+HPksYReOsy1B/5rjfbpmPt99n66Zz2zfp2um+bxPN9iarplW7j5dMx3XfbpmGqP7dM30L/fpmvn88c/pzrYEfWu6trqq2Zagb03XVlc12xL0rena6qpmW4K+NV1bXdVsS9C3pmurq5ptCfrWdG11VbMtQd+arq2uarYl6FvTtdVVzbYEfWu6trqq2Zagb03XVlc12xL0rena6qpmW4K+NV1bXdVsS9C3pmurq5ptCfrWdG11VbMtQd+arqmuKs62BH1ruqa6qjjbEvSt6ZrqquISbE3XVFcVZ1uCvjVdU11VnG0J+tZ0bXVVsy1B35qura5qtiXoW9O11VXNtgR9a7q2uqrZlqBvTddWVzXbEvSt6drqqmZbgr41XVtd1WxL0Lema6urmm0J+tZ0bXVVsy1B35qura5qtiXoW9O11VXNtgR9a7q2uqrZlqBvTddWVzXbEvSt6drqqmZbgr41XVtd1WxL0Lema6urmm0J+tZ0bXVVsy1B35qura5qtiXoW9O11VXNtgR9a7q2uqrZlqBvTddWVzXbEvSt6drqqmZbgr41XVtdlZ2V4u/TtdVV2Vl3/T5dW12VnVXM79O11VXZWls92lpbPdpa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",
      "brillig_names": [
        "is_contract_initialized"
      ]
    },
    {
      "name": "commit_private_user",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "src_receiver",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 48
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6652550611004701521": {
            "error_kind": "string",
            "string": "Funds Not Sent"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "notify_created_nullifier_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "random",
        "decompose_hint",
        "lte_hint",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "add_lock_public_user",
      "is_unconstrained": true,
      "custom_attributes": [
        "internal",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "2722406262643068352": {
            "error_kind": "string",
            "string": "HashlockAlreadySet"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16870384257694633552": {
            "error_kind": "string",
            "string": "Function add_lock_public_user can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "add_lock_public_user"
      ]
    },
    {
      "name": "refund_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "get_note_internal",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "call_private_function_internal",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "redeem_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "772057049813214347": {
            "error_kind": "string",
            "string": "HTLCNotExists"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2570651705007895968": {
            "error_kind": "string",
            "string": "HashlockNotMatch"
          },
          "2722406262643068352": {
            "error_kind": "string",
            "string": "HashlockAlreadySet"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3559210201980528457": {
            "error_kind": "string",
            "string": "Function commit_public_user can only be called internally"
          },
          "3564161243949231814": {
            "error_kind": "string",
            "string": "Function refund_public can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "9174444391250494040": {
            "error_kind": "string",
            "string": "Function get_htlc_public can only be called statically"
          },
          "9323748002447105156": {
            "error_kind": "string",
            "string": "NotPassedTimelock"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "15001264570739363109": {
            "error_kind": "string",
            "string": "Function lock_public_solver can only be called internally"
          },
          "16870384257694633552": {
            "error_kind": "string",
            "string": "Function add_lock_public_user can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17814817983036354427": {
            "error_kind": "string",
            "string": "Function redeem_public can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "constructor"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000001"
            },
            {
              "kind": "string",
              "value": "HTLC_Private"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Train"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "contracts_private",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "contracts_public",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 48
                    }
                  },
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "src_receiver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::commit_public_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::commit_public_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::refund_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::refund_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "secret",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::redeem_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::redeem_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::refund_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::refund_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "secret",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::redeem_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::redeem_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "key",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::get_htlc_public_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "src_receiver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "hashlock_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "hashlock_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "secret_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "secret_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "claimed",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::HTLC_Public"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::get_htlc_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 48
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::lock_private_solver_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::lock_private_solver_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 48
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::lock_public_solver_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::lock_public_solver_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "Train::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "src_receiver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 48
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::commit_private_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::commit_private_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::add_lock_public_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::add_lock_public_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::add_lock_private_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::add_lock_private_user_abi"
        }
      ]
    }
  },
  "file_map": {
    "100": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, &[], true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "101": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\nuse super::utils::is_note;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract. Only a single struct in the entire contract\n/// should have this macro (or `storage_no_init`) applied to it.\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot }, false);\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n/// Only a single struct in the entire contract should have this macro (or `storage`) applied to it.\npub comptime fn storage_no_init(_s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(\n    typ: Type,\n    slot: Quoted,\n    parent_is_map: bool,\n) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot }, true);\n        (quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }, 1)\n    } else {\n        let storage_size = if parent_is_map {\n            // Variables inside a map do not require contiguous slots since the map slot derivation is assumed to result\n            // in slots very far away from one another.\n            1\n        } else {\n            let (_, container_struct_generics) = typ.as_data_type().unwrap();\n            let stored_struct = container_struct_generics[0];\n\n            if is_note(stored_struct) {\n                // Private notes always occupy a single slot, since the slot is only used as a state variable\n                // identifier.\n                1\n            } else {\n                get_storage_size(typ)\n            }\n        };\n\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        (quote { $struct_name::new(context, $slot)}, storage_size)\n    }\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "103": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "104": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash =\n            compute_unique_note_hash(nonce, compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash));\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.nonce, note_and_data.nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == first_note_and_data.nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == second_note_and_data.nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "105": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    pending_partial_notes.for_each(|i, pending_partial_note: DeliveredPendingPartialNote| {\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log sans the extra\n            // fields) to get the complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                // temporary node connectivity issue - is simply throwing good enough here?\n                assert(\n                    deliver_note(\n                        contract_address,\n                        pending_partial_note.storage_slot,\n                        discovered_note.nonce,\n                        complete_packed_note,\n                        discovered_note.note_hash,\n                        discovered_note.inner_nullifier,\n                        log.tx_hash,\n                        pending_partial_note.recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "107": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/messages/discovery/private_logs.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{\n            ComputeNoteHashAndNullifier,\n            partial_notes::process_partial_note_private_msg,\n            pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n            private_notes::process_private_note_msg,\n        },\n        encoding::decode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        msg_type::{\n            PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n        },\n    },\n    oracle::{logs::store_private_event_log, message_discovery::sync_notes},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `syncNotes` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    sync_notes(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get the logs from the capsule array and process them one by one\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    logs.for_each(|i, log: PendingTaggedLog| {\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n        logs.remove(i);\n    });\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(log_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            pending_tagged_log.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        // In the case of events, the msg metadata is the event selector.\n        let event_selector = EventSelector::from_field(msg_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            msg_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n            pending_tagged_log.tx_index_in_block,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "108": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n        // issue, and we should perhaps not have marked the tag index as taken.\n        assert(\n            oracle::message_discovery::deliver_note(\n                contract_address,\n                storage_slot,\n                discovered_note.nonce,\n                packed_note,\n                discovered_note.note_hash,\n                discovered_note.inner_nullifier,\n                tx_hash,\n                recipient,\n            ),\n            \"Failed to deliver note\",\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "109": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\nglobal MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "110": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "117": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/messages/logs/note.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    messages::{\n        encoding::encode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        logs::utils::prefix_with_tag,\n        msg_type::{PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID},\n    },\n    note::{note_emission::NoteEmission, note_interface::NoteType},\n};\nuse protocol_types::{\n    abis::note_hash::NoteHash, address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS,\n    traits::Packable,\n};\n\n// TODO: it feels like this existence check is in the wrong place. In fact, why is it needed at all? Under what circumstances have we found a non-existent note being emitted accidentally?\nfn assert_note_exists<let N: u32>(context: PrivateContext, note_hash_counter: u32) {\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists =\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n}\n\npub fn compute_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PRIVATE_NOTE_MSG_TYPE_ID,\n    )\n}\n\npub fn compute_partial_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID,\n    )\n}\n\nfn compute_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    msg_type: u64,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let packed_note = note.pack();\n\n    // A note message's content is the storage slot followed by the packed note representation\n    let mut msg_content: [Field; N + 1] = std::mem::zeroed();\n    msg_content[0] = storage_slot;\n    for i in 0..packed_note.len() {\n        msg_content[1 + i] = packed_note[i];\n    }\n\n    // Notes use the note type id for metadata\n    let plaintext = encode_message(msg_type, Note::get_id() as u64, msg_content);\n\n    let ciphertext = AES128::encrypt_log(plaintext, recipient);\n\n    let log = prefix_with_tag(ciphertext, sender, recipient);\n\n    log\n}\n\npub unconstrained fn compute_note_log_unconstrained<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_note_log(note, storage_slot, recipient, sender)\n}\n\n/// Sends an encrypted message to `recipient` with the content of the note, which they will discover when processing\n/// private logs.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n        assert_note_exists(*context, note_hash_counter);\n\n        let encrypted_log = compute_note_log(note, storage_slot, recipient, sender);\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n\n/// Same as `encode_and_encrypt_note`, except encryption is unconstrained. This means that the sender is free to make\n/// the log contents be whatever they wish, potentially resulting in scenarios in which the recipient is unable to\n/// decrypt and process the payload, **leading to the note being lost**.\n///\n/// Only use this function in scenarios where the recipient not receiving the note is an acceptable outcome.\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n\n        assert_note_exists(*context, note_hash_counter);\n\n        // Safety: this function does not constrain the encryption of the log, as explained on its description.\n        let encrypted_log =\n            unsafe { compute_note_log_unconstrained(note, storage_slot, recipient, sender) };\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n"
    },
    "118": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/messages/logs/utils.nr",
      "source": "use crate::{\n    oracle::notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n    prelude::AztecAddress,\n};\n\npub(crate) fn prefix_with_tag<let L: u32>(\n    log_without_tag: [Field; L],\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> [Field; L + 1] {\n    // Safety: we assume that the sender wants for the recipient to find the tagged note, and therefore that they will\n    // cooperate and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the\n    // note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    let mut log_with_tag = [0; L + 1];\n\n    log_with_tag[0] = tag;\n    for i in 0..log_without_tag.len() {\n        log_with_tag[i + 1] = log_without_tag[i];\n    }\n\n    log_with_tag\n}\n\nmod test {\n    use super::prefix_with_tag;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn prefixing_with_tag() {\n        let sender = AztecAddress::from_field(1);\n        let recipient = AztecAddress::from_field(2);\n\n        let app_tagging_secret = 42;\n        let index = 5;\n\n        // I am using the deserialize trait instead of directly instantiating the IndexedTaggingSecret struct because\n        // direct instantiation functionality is not exposed.\n        let indexed_tagging_secret = IndexedTaggingSecret::deserialize([app_tagging_secret, index]);\n\n        // Mock the tagging oracles\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(indexed_tagging_secret);\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        let log_without_tag = [1, 2, 3];\n        let log_with_tag = prefix_with_tag(log_without_tag, sender, recipient);\n\n        let expected_result = [indexed_tagging_secret.compute_tag(recipient), 1, 2, 3];\n\n        // Check tag was prefixed correctly\n        assert_eq(log_with_tag, expected_result, \"Tag was not prefixed correctly\");\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "123": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_interface::{NoteHash, NoteType},\n    retrieved_note::RetrievedNote,\n    utils::{compute_note_hash_for_nullify_from_read_request, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::notify_created_note;\nuse protocol_types::traits::Packable;\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    let note_hash_counter = context.side_effect_counter;\n\n    let note_hash = note.compute_note_hash(storage_slot);\n\n    let packed_note = Note::pack(note);\n    notify_created_note(\n        storage_slot,\n        Note::get_id(),\n        packed_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(note, storage_slot, note_hash_counter)\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n\n    destroy_note_unsafe(context, retrieved_note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_from_read_request(retrieved_note, note_hash_for_read_request);\n    let nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash = if retrieved_note.metadata.is_settled() {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifying so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, note_hash)\n}\n"
    },
    "125": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub note: Note,\n    pub storage_slot: Field,\n    pub note_hash_counter: u32, // a note_hash_counter of 0 means settled\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note, storage_slot: Field, note_hash_counter: u32) -> Self {\n        Self { note, storage_slot, note_hash_counter }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "128": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/note/note_getter.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n    retrieved_note::RetrievedNote,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::oracle;\nuse crate::utils::{array, comparison::compare};\nuse dep::protocol_types::{\n    constants::{GET_NOTES_ORACLE_RETURN_LENGTH, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL},\n    traits::{Packable, ToField},\n};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    packed_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the packed note.\n    // This allows easier packing and custom (un)packing schemas. A note property is located\n    // inside the packed note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = packed_note[selector.index as u32].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[(31 + offset - i) as u32] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_packed_note<let N: u32>(packed_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(packed_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (RetrievedNote<Note>, Field)\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    // Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do\n    // is check that the metadata is correct, and that the note exists.\n    let retrieved_note = unsafe { get_note_internal::<Note, N>(storage_slot) };\n\n    // For settled notes, the contract address is implicitly checked since the hash returned from\n    // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n    // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the contract\n    // address returned from the oracle matches. Since branching in circuits is expensive, we perform this check on all\n    // note types.\n    assert(\n        retrieved_note.contract_address.eq(context.this_address()),\n        \"Note contract address mismatch.\",\n    );\n\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (retrieved_note, note_hash_for_read_request)\n}\n\n/// Returns a BoundedVec of notes that have been proven to have been created by this contract, either in the current or\n/// past transactions (i.e. pending or settled notes). A second BoundedVec contains the note hashes used for the read\n/// requests, which can save constraints when computing the note's nullifiers.\n///\n/// WARNING: recall that notes are never destroyed! Note existence therefore does not imply that the note is _current_\n/// or _valid_ - this typically requires also emitting the note's nullifier to prove that it had not been emitted\n/// before. Because of this, calling this function directly from end-user applications should be discouraged, and safe\n/// abstractions such as aztec-nr's state variables should be used instead.\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // Safety: The notes are constrained below.\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the notes (as opposed to simply removing some), the private\n    // kernel will later validate that these note actually exist, so transformations would cause for that check\n    // to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = array::collapse(filtered_notes);\n    let mut note_hashes = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_packed_note = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let retrieved_note = notes.get_unchecked(i);\n\n            // For settled notes, the contract address is implicitly checked since the hash returned from\n            // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n            // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the\n            // contract address returned from the oracle matches. Since branching in circuits is expensive, we perform\n            // this check on all note types.\n            assert(\n                retrieved_note.contract_address.eq(context.this_address()),\n                \"Note contract address mismatch.\",\n            );\n\n            let packed_note = retrieved_note.note.pack();\n            check_packed_note(packed_note, options.selects);\n            if i != 0 {\n                check_notes_order(prev_packed_note, packed_note, options.sorts);\n            }\n            prev_packed_note = packed_note;\n\n            let note_hash_for_read_request =\n                compute_note_hash_for_read_request(retrieved_note, storage_slot);\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> RetrievedNote<Note>\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let opt_notes: [_; 1] = oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_fields,\n    );\n\n    opt_notes[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_fields,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\n/// Unconstrained variant of `get_notes`, meant to be used in unconstrained execution contexts. Notably only the note\n/// content is returned, and not any of the information used when proving its existence (e.g. nonce, note hash, etc.).\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteType + Packable<N> + Eq,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n\n    // We fetch the notes from the same oracle we use in the constrained case, except we don't bother inspecting the\n    // metadata in order to prove existence.\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_fields,\n    );\n\n    // Even though we don't expect for the opt_notes array to be sparse, collapse is still useful in this case to\n    // convert it into a BoundedVec.\n    array::collapse(opt_notes).map(\n        // view_notes just returns the actual note, so we drop the metadata\n        |retrieved_note| retrieved_note.note,\n    )\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects as u32] = select.unwrap_unchecked().value;\n            select_comparators[num_selects as u32] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
    },
    "131": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "134": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "137": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "138": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "139": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "140": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "141": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "142": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "146": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "147": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "148": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "149": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use crate::messages::encoding::MAX_MESSAGE_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        msg_content,\n        tx_hash,\n        log_index_in_tx,\n        tx_index_in_block,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {}\n"
    },
    "150": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr",
      "source": "use crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn sync_notes(pending_tagged_log_array_base_slot: Field) {\n    sync_notes_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "152": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::{\n    note::{note_interface::NoteType, note_metadata::NoteMetadata, retrieved_note::RetrievedNote},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::IndexedTaggingSecret,\n    traits::{FromField, Packable},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {\n    // This wrapper exists to extract the ORACLE_RETURN_FIELD_LENGTH generic numeric param into a value and pass it to\n    // the oracle, so that it knows how big the return array must be.\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        ORACLE_RETURN_FIELD_LENGTH,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let MAX_NOTES: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    _placeholder_fields: [Field; ORACLE_RETURN_FIELD_LENGTH], // TODO: Compute this value automatically from MAX_NOTES\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let fields: [_; ORACLE_RETURN_FIELD_LENGTH] = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n\n    let mut opt_notes = [Option::none(); MAX_NOTES];\n    for i in 0..opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let maybe_nonce = fields[read_offset];\n            let maybe_note_hash_counter = fields[read_offset + 1] as u32;\n            let packed_note = array::subarray(fields, read_offset + 2);\n\n            let note = Note::unpack(packed_note);\n            let retrieved_note = RetrievedNote {\n                note,\n                contract_address,\n                metadata: NoteMetadata::from_raw_data(maybe_note_hash_counter != 0, maybe_nonce),\n            };\n\n            opt_notes[i] = Option::some(retrieved_note);\n        };\n    }\n    opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "153": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "154": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "155": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "157": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "159": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/state_vars/private_immutable.nr",
      "source": "use dep::protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\nuse crate::context::{PrivateContext, UtilityContext};\nuse crate::note::{\n    lifecycle::create_note,\n    note_emission::NoteEmission,\n    note_getter::{get_note, view_notes},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateImmutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context, let N: u32> Storage<N> for PrivateImmutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateImmutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateImmutable>` type (for example), because the storage slot often also identifies an actor.\n    // e.g. the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<Note> PrivateImmutable<Note, &mut PrivateContext> {\n    // docs:start:initialize\n    pub fn initialize<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: NoteType + NoteHash + Packable<N>,\n    {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:get_note\n    pub fn get_note<let N: u32>(self) -> Note\n    where\n        Note: NoteType + NoteHash + Packable<N>,\n    {\n        let storage_slot = self.storage_slot;\n        let retrieved_note = get_note(self.context, storage_slot).0;\n\n        // Because the notes obtained from PrivateImmutable are not meant to be nullified and get_note(...) function\n        // has already constrained the note (by pushing a read request to the context), we can return just the note\n        // and skip the additional data in RetrievedNote.\n        retrieved_note.note\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateImmutable<Note, UtilityContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    // docs:start:is_initialized\n    pub unconstrained fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // view_note does not actually use the context, but it calls oracles that are only available in private\n    // docs:start:view_note\n    pub unconstrained fn view_note<let N: u32>(self) -> Note\n    where\n        Note: Packable<N>,\n    {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: x_coordinates_match,\n        };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "168": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable.nr",
      "source": "use dep::protocol_types::{\n    shared_mutable::{\n        ScheduledDelayChange,\n        ScheduledValueChange,\n        shared_mutable_values::{unpack_delay_change, unpack_value_change},\n        SharedMutableValues,\n    },\n    traits::Packable,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\n\nmod test;\n\npub struct SharedMutable<T, let INITIAL_DELAY: u32, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// This will make the Aztec macros require that T implements the Packable and Eq traits, and allocate `M` storage\n// slots to this state variable.\nimpl<T, let INITIAL_DELAY: u32, Context, let M: u32> Storage<M> for SharedMutable<T, INITIAL_DELAY, Context>\nwhere\n    WithHash<SharedMutableValues<T, INITIAL_DELAY>, _>: Packable<M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in blocks. Reads in private are only valid as long as they are included in a block not too far into the\n// future, so that they can guarantee the value will not have possibly changed by then (because of the delay).\n// The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, let INITIAL_DELAY: u32, Context> SharedMutable<T, INITIAL_DELAY, Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PublicContext>\nwhere\n    T: Eq,\n{\n\n    pub fn schedule_value_change<let N: u32>(self, new_value: T)\n    where\n        T: Packable<N>,\n    {\n        let _value_change = self.schedule_and_return_value_change(new_value);\n    }\n\n    pub fn schedule_and_return_value_change<let N: u32>(\n        self,\n        new_value: T,\n    ) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n        let current_delay = delay_change.get_current(block_number);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let block_of_change = block_number + current_delay;\n        value_change.schedule_change(new_value, block_number, current_delay, block_of_change);\n\n        self.write(value_change, delay_change);\n\n        value_change\n    }\n\n    pub fn schedule_delay_change<let N: u32>(self, new_delay: u32)\n    where\n        T: Packable<N>,\n    {\n        let mut delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n\n        delay_change.schedule_change(new_delay, block_number);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    pub fn get_current_delay<let N: u32>(self) -> u32\n    where\n        T: Packable<N>,\n    {\n        let block_number = self.context.block_number() as u32;\n        self.read_delay_change().get_current(block_number)\n    }\n\n    pub fn get_scheduled_value<let N: u32>(self) -> (T, u32)\n    where\n        T: Packable<N>,\n    {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay<let N: u32>(self) -> (u32, u32)\n    where\n        T: Packable<N>,\n    {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change<let N: u32>(self) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        // We don't read ScheduledValueChange directly by having it implement Packable because ScheduledValueChange\n        // and ScheduledDelayChange are packed together (sdc and svc.block_of_change are stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_value_change::<T, N>(packed)\n    }\n\n    fn read_delay_change<let N: u32>(self) -> ScheduledDelayChange<INITIAL_DELAY>\n    where\n        T: Packable<N>,\n    {\n        // Since all ScheduledDelayChange member are packed into a single field, we can read a single storage slot\n        // here and skip the ones that correspond to ScheduledValueChange members. We are abusing the fact that\n        // the field containing the ScheduledDelayChange data is the first one in the storage layout - otherwise we'd\n        // need to offset the storage slot to get the position where it'd land.\n        // We don't read ScheduledDelayChange directly by having it implement Packable because\n        // ScheduledValueChange and ScheduledDelayChange are packed together (sdc and svc.block_of_change are\n        // stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_delay_change::<INITIAL_DELAY>(packed)\n    }\n\n    fn write<let N: u32>(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>,\n    )\n    where\n        T: Packable<N>,\n    {\n        // Whenever we write to public storage, we write both the value change and delay change to storage at once.\n        // We do so by wrapping them in a single struct (`SharedMutableValues`). Then we wrap the resulting struct in\n        // `WithHash`.\n        // Wrapping in `WithHash` makes for more costly writes but it also makes private proofs much simpler because\n        // they only need to produce a historical proof for the hash, which results in a single inclusion proof (as\n        // opposed to 4 in the best case scenario in which T is a single field). Private shared mutable reads are\n        // assumed to be much more frequent than public writes, so this tradeoff makes sense.\n        let values = WithHash::new(SharedMutableValues::new(value_change, delay_change));\n\n        self.context.storage_write(self.storage_slot, values);\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext>\nwhere\n    T: Eq,\n{\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction block number as this proof\n        // will only be valid for however many blocks we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n        let (value_change, delay_change, historical_block_number) =\n            self.historical_read_from_public_storage();\n\n        // We use the effective minimum delay as opposed to the current delay at the historical block as this one also\n        // takes into consideration any scheduled delay changes.\n        // For example, consider a scenario in which at block 200 the current delay was 50. We may naively think that\n        // the earliest we could change the value would be at block 251 by scheduling immediately after the historical\n        // block, i.e. at block 201. But if there was a delay change scheduled for block 210 to reduce the delay to 20\n        // blocks, then if a value change was scheduled at block 210 it would go into effect at block 230, which is\n        // earlier than what we'd expect if we only considered the current delay.\n        let effective_minimum_delay =\n            delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon =\n            value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any block after the block horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_tx_max_block_number(block_horizon);\n        value_change.get_current_at(historical_block_number)\n    }\n\n    fn historical_read_from_public_storage<let N: u32>(\n        self,\n    ) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u32)\n    where\n        T: Packable<N>,\n    {\n        let header = self.context.get_block_header();\n        let address = self.context.this_address();\n\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        let values: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::historical_public_storage_read(header, address, self.storage_slot);\n\n        (values.svc, values.sdc, historical_block_number)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, UtilityContext>\nwhere\n    T: Eq,\n{\n    pub unconstrained fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let smv: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::utility_public_storage_read(self.context, self.storage_slot);\n\n        let block_number = self.context.block_number() as u32;\n        smv.svc.get_current_at(block_number)\n    }\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "180": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "183": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "184": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "186": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "187": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "189": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "191": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "192": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/utils/random.nr",
      "source": "use crate::oracle::random::random;\n\n/// Returns as many random bytes as specified through N.\npub unconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n"
    },
    "195": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "20": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "219": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "221": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "264": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "279": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "281": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "282": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "283": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr",
      "source": "use crate::traits::{Deserialize, Serialize, ToField};\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\nuse std::meta::derive;\n\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\n\n#[derive(Serialize, Deserialize)]\npub struct IndexedTaggingSecret {\n    app_tagging_secret: Field,\n    index: u32,\n}\n\nimpl IndexedTaggingSecret {\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\n        poseidon2_hash(\n            [self.app_tagging_secret, recipient.to_field(), self.index as Field],\n        )\n    }\n}\n"
    },
    "292": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "296": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `omit`: A list of field names (as `Quoted`) to be excluded from the serialized output.\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, &[], false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, &[], false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], &[], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, &[], false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with Omitted Field and packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// Serializing while omitting `value2`:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, MyStruct, &[quote { self.value2 }], true)\n/// // Returns:\n/// // ([`value_packed[0]`], [`let value_packed = self.value.pack()`])\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    omit: [Quoted],\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // Proceed if none of the omit rules omits this name\n    if !omit.any(|to_omit| to_omit == name) {\n        // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n        let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n        let packable_constraint =\n            quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n        if (should_pack & typ.implements(packable_constraint)) {\n            // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n            // method, add the resulting field array to `aux_vars` and each field to `fields`.\n            let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n            // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n            let name_at_one_token = collapse_to_one_token(name);\n            let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n            // We add the individual fields to the fields array\n            let pack_method = get_trait_impl_method(\n                typ,\n                quote { crate::traits::Packable<$packed_len> },\n                quote { pack },\n            );\n            let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n            for i in 0..packed_len {\n                fields = fields.push_back(quote { $packed_struct_name[$i] });\n            }\n\n            // We add the new auxiliary variable to the aux_vars array\n            aux_vars = aux_vars.push_back(packed_struct);\n        } else if typ.is_field() {\n            // For field we just add the value to fields\n            fields = fields.push_back(name);\n        } else if typ.as_integer().is_some() | typ.is_bool() {\n            // For integer and bool we just cast to Field and add the value to fields\n            fields = fields.push_back(quote { $name as Field });\n        } else if typ.as_data_type().is_some() {\n            // For struct we pref\n            let nested_struct = typ.as_data_type().unwrap();\n            let params = nested_struct.0.fields(nested_struct.1);\n            let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n                let maybe_prefixed_name = if name == quote {} {\n                    // Triggered when the param name is of a value available in the current scope (e.g. a function\n                    // argument) --> then we don't prefix the name with anything.\n                    param_name\n                } else {\n                    // Triggered when we want to prefix the param name with the `name` from function input. This\n                    // can typically be `self` when implementing a method on a struct.\n                    quote { $name.$param_name }\n                };\n                generate_serialize_to_fields(\n                    quote {$maybe_prefixed_name},\n                    param_type,\n                    omit,\n                    should_pack,\n                )\n            });\n            let struct_flattened_fields = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n            );\n            let struct_flattened_aux_vars = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n            );\n            fields = fields.append(struct_flattened_fields);\n            aux_vars = aux_vars.append(struct_flattened_aux_vars);\n        } else if typ.as_array().is_some() {\n            // For array we recursively call `generate_serialize_to_fields(...)` for each element\n            let (element_type, array_len) = typ.as_array().unwrap();\n            let array_len = array_len.as_constant().unwrap();\n            for i in 0..array_len {\n                let (element_fields, element_aux_vars) = generate_serialize_to_fields(\n                    quote { $name[$i] },\n                    element_type,\n                    omit,\n                    should_pack,\n                );\n                fields = fields.append(element_fields);\n                aux_vars = aux_vars.append(element_aux_vars);\n            }\n        } else if typ.as_str().is_some() {\n            // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n            // then we add each byte to fields as a Field\n            let length_type = typ.as_str().unwrap();\n            let str_len = length_type.as_constant().unwrap();\n            let as_member = name.as_expr().unwrap().as_member_access();\n            let var_name = if as_member.is_some() {\n                as_member.unwrap().1\n            } else {\n                name\n            };\n            let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n            let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n            for i in 0..str_len {\n                fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n            }\n            aux_vars = aux_vars.push_back(as_bytes);\n        } else {\n            panic(\n                f\"Unsupported type for serialization of argument {name} and type {typ}\",\n            )\n        }\n    }\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) =\n        generate_serialize_to_fields(quote { self }, typ, &[], packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "298": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "299": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "308": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize, ToField},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "312": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_delay_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initially equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation\n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the\n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a\n// reduced delay, invalidating prior private reads.\npub struct ScheduledDelayChange<let INITIAL_DELAY: u32> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option,\n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pub(crate) pre: Option<u32>,\n    pub(crate) post: Option<u32>,\n    // Block at which `post` value is used instead of `pre`\n    pub(crate) block_of_change: u32,\n}\n\nimpl<let INITIAL_DELAY: u32> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u32>, post: Option<u32>, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current block number - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_block_number: u32) -> u32 {\n        // The post value becomes the current one at the block of change, so any transaction that is included in the\n        // block of change will use the post value.\n        if current_block_number < self.block_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the block at which it will become the current\n    /// delay. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u32, u32) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.block_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current block number. This function is only meaningful\n    /// when called in public with the current block number.\n    /// The block at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u32, current_block_number: u32) {\n        let current = self.get_current(current_block_number);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let blocks_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior constraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value block of change\n            //       block                 block of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   blocks until change               new delay            |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.block_of_change = current_block_number + blocks_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical block number. It only returns a meaningful value when called in private with historical blocks. This\n    /// function can be used alongside `ScheduledValueChange.get_block_horizon` to properly constrain the\n    /// `max_block_number` transaction property when reading mutable shared state.\n    /// This value typically equals the current delay at the block following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is\n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_block_number: u32) -> u32 {\n        if self.block_of_change <= historical_block_number {\n            // If no delay changes were scheduled, then the delay value at the historical block (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // block of change the current delay will be the scheduled one, with an overall delay from the historical\n            // block number equal to the number of blocks until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //         block                  delay                  actual earliest value\n            //           v                block of change              block of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest block in            |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |         blocks                  new delay                      |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest block in\n            //                             which to scheduled value change\n            let blocks_until_change = self.block_of_change - (historical_block_number + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                blocks_until_change + self.post.unwrap_or(INITIAL_DELAY),\n            )\n        }\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Empty for ScheduledDelayChange<INITIAL_DELAY> {\n    fn empty() -> Self {\n        Self { pre: Option::none(), post: Option::none(), block_of_change: 0 }\n    }\n}\n"
    },
    "314": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_value_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some block\n// called the `block_of_change`. The value can only be made to change by scheduling a change event at some future block\n// of change after some minimum delay measured in blocks has elapsed. This means that at any given block number we know\n// both the current value and the smallest block number at which the value might change - this is called the\n// 'block horizon'.\npub struct ScheduledValueChange<T> {\n    pub(crate) pre: T,\n    pub(crate) post: T,\n    // Block at which `post` value is used instead of `pre`\n    pub(crate) block_of_change: u32,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given block. This function can be called both in public\n    /// (where `block_number` is simply the current block number, i.e. the number of the block in which the current\n    /// transaction will be included) and in private (where `block_number` is the historical block number that is used\n    /// to construct the proof).\n    /// Reading in private is only safe if the transaction's `max_block_number` property is set to a value lower or\n    /// equal to the block horizon (see `get_block_horizon()`).\n    pub fn get_current_at(self, block_number: u32) -> T {\n        // The post value becomes the current one at the block of change. This means different things in each realm:\n        // - in public, any transaction that is included in the block of change will use the post value\n        // - in private, any transaction that includes the block of change as part of the historical state will use the\n        //   post value (barring any follow-up changes)\n        if block_number < self.block_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the block at which it will become the current\n    /// value. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u32) {\n        (self.post, self.block_of_change)\n    }\n\n    // Returns the previous value. This is the value that is current up until the block of change. Note that this value\n    // might not be the current anymore since block of change might have already passed.\n    pub fn get_previous(self) -> (T, u32) {\n        (self.pre, self.block_of_change)\n    }\n\n    /// Returns the largest block number at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_block_number`,\n    /// since due to its asynchronous nature private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum number of blocks that need to\n    /// elapse from the next block until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical block number is only safe to use\n    /// if the transaction's `max_block_number` property is set to a value lower or equal to the block horizon computed\n    /// using the same historical block number.\n    pub fn get_block_horizon(self, historical_block_number: u32, minimum_delay: u32) -> u32 {\n        // The block horizon is the very last block in which the current value is known. Any block past the horizon\n        // (i.e. with a block number larger than the block horizon) may have a different current value. Reading the\n        // current value in private typically requires constraining the maximum valid block number to be equal to the\n        // block horizon.\n        if historical_block_number >= self.block_of_change {\n            // Once the block of change has been mined, the current value (post) will not change unless a new value\n            // change is scheduled. This did not happen at the historical block number (or else it would not be\n            // greater or equal to the block of change), and therefore could only happen after the historical block\n            // number. The earliest would be the immediate next block, and so the smallest possible next block of change\n            // equals `historical_block_number + 1 + minimum_delay`. Our block horizon is simply the previous block to\n            // that one.\n            //\n            //      block of      historical\n            //       change         block            block horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n            historical_block_number + minimum_delay\n        } else {\n            // If the block of change has not yet been mined however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the block horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the block of change is in the past: the time horizon is the\n            //      block prior to the earliest one in which a new block of change might land.\n            //\n            //         historical\n            //           block                        block horizon      block of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` blocks away from the historical block number, in which case\n            //      the block of change would become the limiting factor for the time horizon, which would equal the\n            //      block right before the block of change (since by definition the value changes at the block of\n            //      change).\n            //\n            //           historical                         block horizon\n            //             block     block of change       if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the block of change to an arbitrary\n            // value, and therefore scenario a) is not currently possible. However implementing #5501 would allow for\n            // this to happen.\n            // Because historical_block_number < self.block_of_change, then block_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.block_of_change - 1,\n                historical_block_number + minimum_delay,\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current block number. This function is only meaningful when\n    /// called in public with the current block number.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_block_number: u32,\n        minimum_delay: u32,\n        block_of_change: u32,\n    ) {\n        assert(block_of_change >= current_block_number + minimum_delay);\n\n        self.pre = self.get_current_at(current_block_number);\n        self.post = new_value;\n        self.block_of_change = block_of_change;\n    }\n}\n\nimpl<T> Eq for ScheduledValueChange<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n\nimpl<T> Empty for ScheduledValueChange<T>\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        Self { pre: T::empty(), post: T::empty(), block_of_change: 0 }\n    }\n}\n"
    },
    "316": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/shared_mutable_values.nr",
      "source": "use crate::{\n    hash::poseidon2_hash,\n    shared_mutable::{\n        scheduled_delay_change::ScheduledDelayChange, scheduled_value_change::ScheduledValueChange,\n    },\n    traits::{Hash, Packable},\n    utils::arrays,\n};\nuse std::meta::derive;\n\nmod test;\n\n/// SharedMutableValues is just a wrapper around ScheduledValueChange and ScheduledDelayChange that then allows us\n/// to wrap both of these values in WithHash. WithHash allows for efficient read of values in private.\n///\n/// Note that the WithHash optimization does not work in public (due to there being no unconstrained). But we also want\n/// to be able to read the values efficiently in public and we want to be able to read each value separately. Reading\n/// the values separately is tricky because ScheduledValueChange and ScheduledDelayChange are packed together (sdc and\n/// svc.block_of_change are stored in the same slot). For that reason we expose `unpack_value_change` and\n/// `unpack_delay_change` functions that can be used to extract the values from the packed representation. This\n/// is \"hacky\" but there is no way around it.\n#[derive(Eq)]\npub struct SharedMutableValues<T, let INITIAL_DELAY: u32> {\n    pub svc: ScheduledValueChange<T>,\n    pub sdc: ScheduledDelayChange<INITIAL_DELAY>,\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutableValues<T, INITIAL_DELAY> {\n    pub fn new(svc: ScheduledValueChange<T>, sdc: ScheduledDelayChange<INITIAL_DELAY>) -> Self {\n        SharedMutableValues { svc, sdc }\n    }\n}\n\npub fn unpack_value_change<T, let N: u32>(packed: [Field; 2 * N + 1]) -> ScheduledValueChange<T>\nwhere\n    T: Packable<N>,\n{\n    let svc_pre_packed = arrays::subarray(packed, 1);\n    let svc_post_packed = arrays::subarray(packed, N + 1);\n    ScheduledValueChange::new(\n        T::unpack(svc_pre_packed),\n        T::unpack(svc_post_packed),\n        packed[0] as u32,\n    )\n}\n\npub fn unpack_delay_change<let INITIAL_DELAY: u32>(\n    packed: Field,\n) -> ScheduledDelayChange<INITIAL_DELAY> {\n    // This function expects to be called with just the first field of the packed representation, which contains sdc\n    // and svc block_of_change. We'll discard the svc component.\n    let svc_block_of_change = packed as u32;\n\n    let mut tmp = (packed - svc_block_of_change as Field) / TWO_POW_32;\n    let sdc_block_of_change = tmp as u32;\n\n    tmp = (tmp - sdc_block_of_change as Field) / TWO_POW_32;\n    let sdc_post_is_some = tmp as bool;\n\n    tmp = (tmp - sdc_post_is_some as Field) / TWO_POW_8;\n    let sdc_post_inner = tmp as u32;\n\n    tmp = (tmp - sdc_post_inner as Field) / TWO_POW_32;\n    let sdc_pre_is_some = tmp as bool;\n\n    tmp = (tmp - sdc_pre_is_some as Field) / TWO_POW_8;\n    let sdc_pre_inner = tmp as u32;\n\n    ScheduledDelayChange {\n        pre: if sdc_pre_is_some {\n            Option::some(sdc_pre_inner)\n        } else {\n            Option::none()\n        },\n        post: if sdc_post_is_some {\n            Option::some(sdc_post_inner)\n        } else {\n            Option::none()\n        },\n        block_of_change: sdc_block_of_change,\n    }\n}\n\nglobal TWO_POW_32: Field = 2.pow_32(32);\nglobal TWO_POW_8: Field = 2.pow_32(8);\n\n// We pack to `2 * N + 1` fields because ScheduledValueChange contains T twice (hence `2 * N`) and we need one extra\n// field to store ScheduledDelayChange and the block_of_change of ScheduledValueChange.\nimpl<T, let INITIAL_DELAY: u32, let N: u32> Packable<2 * N + 1> for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; 2 * N + 1] {\n        let mut result = [0; 2 * N + 1];\n\n        // We pack sdc.pre, sdc.post, sdc.block_of_change and svc.block_of_change into a single field as follows:\n        // [ sdc.pre_inner: u32 | sdc.pre_is_some: u8 | sdc.post_inner: u32 | sdc.post_is_some: u8 | sdc.block_of_change: u32 | svc.block_of_change: u32 ]\n        result[0] = self.svc.block_of_change as Field\n            + ((self.sdc.block_of_change as Field) * 2.pow_32(32))\n            + ((self.sdc.post.is_some() as Field) * 2.pow_32(64))\n            + ((self.sdc.post.unwrap_unchecked() as Field) * 2.pow_32(72))\n            + ((self.sdc.pre.is_some() as Field) * 2.pow_32(104))\n            + ((self.sdc.pre.unwrap_unchecked() as Field) * 2.pow_32(112));\n\n        // Pack the pre and post values from ScheduledValueChange\n        let svc_pre_packed = self.svc.pre.pack();\n        let svc_post_packed = self.svc.post.pack();\n        for i in 0..N {\n            result[i + 1] = svc_pre_packed[i];\n            result[i + 1 + N] = svc_post_packed[i];\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; 2 * N + 1]) -> Self {\n        let svc = unpack_value_change::<T, N>(fields);\n        let sdc = unpack_delay_change::<INITIAL_DELAY>(fields[0]);\n        Self::new(svc, sdc)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32, let N: u32> Hash for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn hash(self) -> Field {\n        poseidon2_hash(self.pack())\n    }\n}\n"
    },
    "319": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "333": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n"
    },
    "337": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "338": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "354": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "355": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "357": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "363": {
      "path": "/home/nerses/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "392": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER},\n        hash::poseidon2_hash_with_separator,\n        traits::{Deserialize, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// The returned `PartialUintNote` value must be sent to public execution via a secure channel, since it is not\n    /// possible to verify the integrity of its contents due to it hiding information. The recommended ways to do this\n    /// are to retrieve it from public storage, or to receive it in an internal public function call.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient, sender);\n        context.emit_private_log(encrypted_log);\n\n        PartialUintNote { commitment }\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nimpl PartialUintNote {\n    pub fn commitment(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, value: u128, context: &mut PublicContext) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; 2] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "50": {
      "path": "/home/nerses/contracts/chains/aztec/contracts/train/src/lib.nr",
      "source": "pub fn bytes_to_u128_limbs(bytes: [u8; 32]) -> (u128, u128) {\n    let mut high: u128 = 0;\n    let mut low: u128 = 0;\n    for i in 0..16 {\n        high = (high << 8) + (bytes[i] as u128);\n    }\n    for i in 16..32 {\n        low = (low << 8) + (bytes[i] as u128);\n    }\n    (high, low)\n}\n\npub fn u128_limbs_to_bytes(high: u128, low: u128) -> [u8; 32] {\n    let mut bytes: [u8; 32] = [0; 32];\n\n    let mut temp = high;\n    for i in 0..16 {\n        bytes[15 - i] = (temp & 0xff) as u8;\n        temp >>= 8;\n    }\n\n    temp = low;\n    for i in 0..16 {\n        bytes[31 - i] = (temp & 0xff) as u8;\n        temp >>= 8;\n    }\n\n    bytes\n}\n"
    },
    "51": {
      "path": "/home/nerses/contracts/chains/aztec/contracts/train/src/main.nr",
      "source": "mod lib;\nmod types;\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract Train {\n    use crate::lib::{bytes_to_u128_limbs, u128_limbs_to_bytes};\n    use crate::types::events::{\n        TokenCommitted, TokenLockAdded, TokenLocked, TokenRedeemed, TokenRefunded,\n    };\n    use dep::aztec::messages::logs::note::encode_and_encrypt_note;\n    use dep::aztec::protocol_types::traits::{Packable, Serialize};\n    use dep::aztec::state_vars::{private_immutable::PrivateImmutable, SharedMutable};\n    use dep::sha256;\n    use dep::token::Token;\n    use aztec::macros::{\n        functions::{initializer, internal, private, public, utility, view},\n        notes::note,\n        storage::storage,\n    };\n    use aztec::prelude::{AztecAddress, Map};\n    use std::meta::derive;\n\n    #[note]\n    #[derive(Eq)]\n    struct HTLC_Private {\n        owner: AztecAddress,\n        randomness: Field,\n    }\n    #[derive(Eq, Packable, Serialize)]\n    pub struct HTLC_Public {\n        src_receiver: AztecAddress,\n        amount: u128,\n        token: AztecAddress,\n        hashlock_high: u128,\n        hashlock_low: u128,\n        secret_high: u128,\n        secret_low: u128,\n        timelock: u64,\n        claimed: u8,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor() {}\n\n    #[storage]\n    struct Storage<Context> {\n        contracts_private: Map<Field, PrivateImmutable<HTLC_Private, Context>, Context>,\n        contracts_public: Map<Field, SharedMutable<HTLC_Public, 3, Context>, Context>,\n    }\n\n    #[private]\n    fn commit_private_user(\n        Id: Field,\n        src_receiver: AztecAddress,\n        timelock: u64,\n        token: AztecAddress,\n        amount: u128,\n        dst_chain: str<8>,\n        dst_asset: str<8>,\n        dst_address: str<48>,\n        randomness: Field,\n    ) {\n        assert(amount > 0, \"Funds Not Sent\");\n\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address())\n            .commit_public_user(\n                dst_chain,\n                dst_asset,\n                dst_address,\n                Id,\n                src_receiver,\n                timelock,\n                token,\n                amount,\n            )\n            .enqueue(&mut context);\n\n        let htlc_note = HTLC_Private { owner: context.msg_sender(), randomness: randomness };\n        storage.contracts_private.at(Id).initialize(htlc_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n\n        Token::at(token)\n            .transfer_to_public(context.msg_sender(), context.this_address(), amount, randomness)\n            .call(&mut context);\n    }\n\n    #[internal]\n    #[public]\n    fn commit_public_user(\n        dst_chain: str<8>,\n        dst_asset: str<8>,\n        dst_address: str<48>,\n        Id: Field,\n        src_receiver: AztecAddress,\n        timelock: u64,\n        token: AztecAddress,\n        amount: u128,\n    ) {\n        assert(context.timestamp() + 900 < timelock, \"InvalidTimelock\");\n        let htlc_public = HTLC_Public {\n            src_receiver: src_receiver,\n            amount: amount,\n            token: token,\n            hashlock_high: 0 as u128,\n            hashlock_low: 0 as u128,\n            secret_high: 0 as u128,\n            secret_low: 0 as u128,\n            timelock: timelock,\n            claimed: 1 as u8,\n        };\n        storage.contracts_public.at(Id).schedule_value_change(htlc_public);\n        let log_msg = TokenCommitted {\n            Id: Id,\n            amount: amount,\n            token: token,\n            timelock: timelock,\n            dst_chain: dst_chain,\n            dst_asset: dst_asset,\n            dst_address: dst_address,\n            src_receiver: src_receiver,\n        };\n        context.emit_public_log(log_msg.pack());\n    }\n\n    #[private]\n    fn add_lock_private_user(Id: Field, hashlock: [u8; 32], timelock: u64) {\n        let htlc_private = storage.contracts_private.at(Id).get_note();\n        assert(htlc_private.owner == context.msg_sender(), \"NoAllowance\");\n\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address()).add_lock_public_user(Id, hashlock, timelock).enqueue(\n            &mut context,\n        );\n    }\n\n    #[internal]\n    #[public]\n    fn add_lock_public_user(Id: Field, hashlock: [u8; 32], timelock: u64) {\n        assert(context.timestamp() + 900 < timelock, \"InvalidTimelock\");\n\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n        assert(htlc_public.hashlock_high == (0 as u128), \"HashlockAlreadySet\");\n        assert(htlc_public.hashlock_low == (0 as u128), \"HashlockAlreadySet\");\n\n        let hashlock_tuple = bytes_to_u128_limbs(hashlock);\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: hashlock_tuple.0,\n            hashlock_low: hashlock_tuple.1,\n            secret_high: htlc_public.secret_high,\n            secret_low: htlc_public.secret_low,\n            timelock: timelock,\n            claimed: htlc_public.claimed,\n        };\n        storage.contracts_public.at(Id).schedule_value_change(modified_htlc_public);\n        let log_msg = TokenLockAdded { Id, hashlock, timelock };\n        context.emit_public_log(log_msg.pack());\n    }\n\n    #[private]\n    fn refund_private(Id: Field, randomness: Field) {\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address()).refund_public(Id).enqueue(&mut context);\n\n        let htlc_private = storage.contracts_private.at(Id).get_note();\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n\n        Token::at(htlc_public.token)\n            .transfer_to_private(htlc_private.owner, htlc_public.amount)\n            .call(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn refund_public(Id: Field) {\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n        assert(htlc_public.timelock < context.timestamp(), \"NotPassedTimelock\");\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: htlc_public.hashlock_high,\n            hashlock_low: htlc_public.hashlock_low,\n            secret_high: htlc_public.secret_high,\n            secret_low: htlc_public.secret_low,\n            timelock: htlc_public.timelock,\n            claimed: 2 as u8,\n        };\n\n        storage.contracts_public.at(Id).schedule_value_change(modified_htlc_public);\n        let log_msg = TokenRefunded { Id };\n        context.emit_public_log(log_msg);\n    }\n\n    #[private]\n    fn lock_private_solver(\n        Id: Field,\n        hashlock: [u8; 32],\n        amount: u128,\n        timelock: u64,\n        token: AztecAddress,\n        randomness: Field,\n        dst_chain: str<8>,\n        dst_asset: str<8>,\n        dst_address: str<48>,\n    ) {\n        assert(amount > 0, \"FundsNotSent\");\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address())\n            .lock_public_solver(\n                Id,\n                hashlock,\n                amount,\n                token,\n                timelock,\n                dst_chain,\n                dst_asset,\n                dst_address,\n            )\n            .enqueue(&mut context);\n\n        let htlc_note = HTLC_Private { owner: context.msg_sender(), randomness: randomness };\n        storage.contracts_private.at(Id).initialize(htlc_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n\n        Token::at(token)\n            .transfer_to_public(context.msg_sender(), context.this_address(), amount, randomness)\n            .call(&mut context);\n    }\n\n    #[internal]\n    #[public]\n    fn lock_public_solver(\n        Id: Field,\n        hashlock: [u8; 32],\n        amount: u128,\n        token: AztecAddress,\n        timelock: u64,\n        dst_chain: str<8>,\n        dst_asset: str<8>,\n        dst_address: str<48>,\n    ) {\n        assert(context.timestamp() + 2700 < timelock, \"InvalidTimelock\");\n        let hashlock_tuple = bytes_to_u128_limbs(hashlock);\n        let htlc_public = HTLC_Public {\n            src_receiver: AztecAddress::zero(),\n            amount: amount,\n            token: token,\n            hashlock_high: hashlock_tuple.0,\n            hashlock_low: hashlock_tuple.1,\n            secret_high: 0 as u128,\n            secret_low: 0 as u128,\n            timelock: timelock,\n            claimed: 1 as u8,\n        };\n        storage.contracts_public.at(Id).schedule_value_change(htlc_public);\n\n        let log_msg = TokenLocked {\n            Id: Id,\n            hashlock: hashlock,\n            amount: amount,\n            token: token,\n            timelock: timelock,\n            dst_chain: dst_chain,\n            dst_asset: dst_asset,\n            dst_address: dst_address,\n        };\n\n        context.emit_public_log(log_msg.pack());\n    }\n\n    #[private]\n    fn redeem_private(Id: Field, secret: [u8; 32], randomness: Field) {\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address()).redeem_public(Id, secret).enqueue(&mut context);\n\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n\n        if htlc_public.src_receiver == AztecAddress::zero() {\n            Token::at(htlc_public.token)\n                .transfer_to_private(context.msg_sender(), htlc_public.amount)\n                .call(&mut context);\n        } else {\n            Token::at(htlc_public.token)\n                .transfer_to_private(htlc_public.src_receiver, htlc_public.amount)\n                .call(&mut context);\n        }\n    }\n\n    #[public]\n    #[internal]\n    fn redeem_public(Id: Field, secret: [u8; 32]) {\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public.amount > 0, \"HTLCNotExists\"); // If it doesn't exist, all parameters will default to zero values.\n        let hashed_secret = sha256::sha256_var(secret, secret.len() as u64);\n        let hashed_secret_tuple = bytes_to_u128_limbs(hashed_secret);\n        assert(htlc_public.hashlock_high == hashed_secret_tuple.0, \"HashlockNotMatch\");\n        assert(htlc_public.hashlock_low == hashed_secret_tuple.1, \"HashlockNotMatch\");\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n        let secret_limbs = bytes_to_u128_limbs(secret);\n\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: htlc_public.hashlock_high,\n            hashlock_low: htlc_public.hashlock_low,\n            secret_high: secret_limbs.0,\n            secret_low: secret_limbs.1,\n            timelock: htlc_public.timelock,\n            claimed: 3 as u8,\n        };\n\n        storage.contracts_public.at(Id).schedule_value_change(modified_htlc_public);\n\n        let log_msg = TokenRedeemed {\n            Id: Id,\n            hashlock: u128_limbs_to_bytes(htlc_public.hashlock_high, htlc_public.hashlock_low),\n            secret: secret,\n        };\n\n        context.emit_public_log(log_msg.pack());\n    }\n\n    // This utility function should be invoked by the frontend before each function call\n    // where the existence or non-existence of an HTLC is a critical security check.\n    #[utility]\n    unconstrained fn is_contract_initialized(Id: Field) -> bool {\n        storage.contracts_private.at(Id).is_initialized()\n    }\n\n    #[view]\n    #[public]\n    fn get_htlc_public(key: Field) -> pub HTLC_Public {\n        storage.contracts_public.at(key).get_current_value()\n    }\n\n}\n"
    },
    "52": {
      "path": "/home/nerses/contracts/chains/aztec/contracts/train/src/types/events.nr",
      "source": "use dep::aztec::prelude::AztecAddress;\nuse dep::aztec::protocol_types::traits::{Packable, Serialize};\n\n#[derive(Serialize)]\npub struct TokenCommitted {\n    pub Id: Field,\n    pub amount: u128,\n    pub token: AztecAddress,\n    pub timelock: u64,\n    pub dst_chain: str<8>,\n    pub dst_asset: str<8>,\n    pub dst_address: str<48>,\n    pub src_receiver: AztecAddress,\n}\n\nimpl Packable<9> for TokenCommitted {\n    fn pack(self) -> [Field; 9] {\n        let zero: Field = 0;\n        let mut out = [zero; 9];\n        out[0] = self.Id;\n        out[1] = self.amount as Field;\n        out[2] = self.token.inner;\n        out[3] = self.timelock as Field;\n\n        let dst_chain_byte_array = self.dst_chain.as_bytes();\n        let mut dst_chain_byte_array_filled = [0 as u8; 31];\n        for i in 0..dst_chain_byte_array.len() {\n            dst_chain_byte_array_filled[i] = dst_chain_byte_array[i];\n        }\n\n        out[4] = Field::from_be_bytes::<31>(dst_chain_byte_array_filled);\n\n        let dst_asset_byte_array = self.dst_asset.as_bytes();\n        let mut dst_asset_byte_array_filled = [0 as u8; 31];\n        for i in 0..dst_asset_byte_array.len() {\n            dst_asset_byte_array_filled[i] = dst_asset_byte_array[i];\n        }\n\n        out[5] = Field::from_be_bytes::<31>(dst_asset_byte_array_filled);\n\n        let dst_address_byte_array = self.dst_address.as_bytes();\n        let mut dst_address_byte_array_filled_1 = [0 as u8; 31];\n        let mut dst_address_byte_array_filled_2 = [0 as u8; 31];\n\n        for i in 0..31 {\n            dst_address_byte_array_filled_1[i] = dst_address_byte_array[i];\n        }\n\n        for i in 31..48 {\n            dst_address_byte_array_filled_2[i - 31] = dst_address_byte_array[i];\n        }\n\n        out[6] = Field::from_be_bytes::<31>(dst_address_byte_array_filled_1);\n        out[7] = Field::from_be_bytes::<31>(dst_address_byte_array_filled_2);\n\n        out[8] = self.src_receiver.inner;\n        out\n    }\n\n    fn unpack(fields: [Field; 9]) -> Self {\n        assert(false, \"unpack not implemented\");\n        TokenCommitted {\n            Id: fields[0] as Field,\n            amount: 0 as u128,\n            token: AztecAddress::zero(),\n            timelock: 0 as u64,\n            dst_chain: \"00000000\",\n            dst_asset: \"00000000\",\n            dst_address: \"000000000000000000000000000000000000000000000000\",\n            src_receiver: AztecAddress::zero(),\n        }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenLockAdded {\n    pub Id: Field,\n    pub hashlock: [u8; 32],\n    pub timelock: u64,\n}\n\nimpl Packable<4> for TokenLockAdded {\n    fn pack(self) -> [Field; 4] {\n        let mut out = [0 as Field; 4];\n        out[0] = self.Id;\n\n        let hb = self.hashlock;\n        let mut h1 = [0 as u8; 31];\n        for i in 0..31 {\n            h1[i] = hb[i];\n        }\n        out[1] = Field::from_be_bytes::<31>(h1);\n\n        let mut h2 = [0 as u8; 31];\n        h2[0] = hb[31];\n        out[2] = Field::from_be_bytes::<31>(h2);\n\n        out[3] = self.timelock as Field;\n        out\n    }\n\n    fn unpack(fields: [Field; 4]) -> Self {\n        let Id = fields[0];\n\n        let b1 = fields[1].to_be_bytes();\n        let b2 = fields[2].to_be_bytes();\n        let mut hash = [0 as u8; 32];\n        for i in 0..31 {\n            hash[i] = b1[i];\n        }\n        hash[31] = b2[0];\n\n        let timelock = fields[3] as u64;\n\n        TokenLockAdded { Id, hashlock: hash, timelock }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenRefunded {\n    pub Id: Field,\n}\n\n#[derive(Serialize)]\npub struct TokenRedeemed {\n    pub Id: Field,\n    pub hashlock: [u8; 32],\n    pub secret: [u8; 32],\n}\n\nimpl Packable<5> for TokenRedeemed {\n    fn pack(self) -> [Field; 5] {\n        let mut out = [0 as Field; 5];\n        out[0] = self.Id;\n\n        let hb = self.hashlock;\n        let mut h1 = [0 as u8; 31];\n        for i in 0..31 {\n            h1[i] = hb[i];\n        }\n        out[1] = Field::from_be_bytes::<31>(h1);\n        let mut h2 = [0 as u8; 31];\n        h2[0] = hb[31];\n        out[2] = Field::from_be_bytes::<31>(h2);\n\n        let sb = self.secret;\n        let mut s1 = [0 as u8; 31];\n        for i in 0..31 {\n            s1[i] = sb[i];\n        }\n        out[3] = Field::from_be_bytes::<31>(s1);\n        let mut s2 = [0 as u8; 31];\n        s2[0] = sb[31];\n        out[4] = Field::from_be_bytes::<31>(s2);\n\n        out\n    }\n\n    fn unpack(fields: [Field; 5]) -> Self {\n        let Id = fields[0];\n\n        let b1 = fields[1].to_be_bytes();\n        let b2 = fields[2].to_be_bytes();\n        let mut hashlock = [0 as u8; 32];\n        for i in 0..31 {\n            hashlock[i] = b1[i];\n        }\n        hashlock[31] = b2[0];\n\n        let b3 = fields[3].to_be_bytes();\n        let b4 = fields[4].to_be_bytes();\n        let mut secret = [0 as u8; 32];\n        for i in 0..31 {\n            secret[i] = b3[i];\n        }\n        secret[31] = b4[0];\n\n        TokenRedeemed { Id, hashlock, secret }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenLocked {\n    pub Id: Field,\n    pub hashlock: [u8; 32],\n    pub amount: u128,\n    pub token: AztecAddress,\n    pub timelock: u64,\n    pub dst_chain: str<8>,\n    pub dst_asset: str<8>,\n    pub dst_address: str<48>,\n}\n\nimpl Packable<10> for TokenLocked {\n    fn pack(self) -> [Field; 10] {\n        let mut out = [0 as Field; 10];\n        out[0] = self.Id;\n\n        let hb = self.hashlock;\n        let mut h1 = [0 as u8; 31];\n        for i in 0..31 {\n            h1[i] = hb[i];\n        }\n        out[1] = Field::from_be_bytes::<31>(h1);\n\n        let mut h2 = [0 as u8; 31];\n        h2[0] = hb[31];\n        out[2] = Field::from_be_bytes::<31>(h2);\n\n        out[3] = self.amount as Field;\n        out[4] = self.token.inner;\n        out[5] = self.timelock as Field;\n\n        let dst_chain_byte_array = self.dst_chain.as_bytes();\n        let mut dst_chain_byte_array_filled = [0 as u8; 31];\n        for i in 0..dst_chain_byte_array.len() {\n            dst_chain_byte_array_filled[i] = dst_chain_byte_array[i];\n        }\n        out[6] = Field::from_be_bytes::<31>(dst_chain_byte_array_filled);\n\n        let dst_asset_byte_array = self.dst_asset.as_bytes();\n        let mut dst_asset_byte_array_filled = [0 as u8; 31];\n        for i in 0..dst_asset_byte_array.len() {\n            dst_asset_byte_array_filled[i] = dst_asset_byte_array[i];\n        }\n        out[7] = Field::from_be_bytes::<31>(dst_asset_byte_array_filled);\n\n        let addr = self.dst_address.as_bytes();\n        let mut dst_address_byte_array_filled_1 = [0 as u8; 31];\n        let mut dst_address_byte_array_filled_2 = [0 as u8; 31];\n        for i in 0..31 {\n            dst_address_byte_array_filled_1[i] = addr[i];\n        }\n        for i in 31..48 {\n            dst_address_byte_array_filled_2[i - 31] = addr[i];\n        }\n        out[8] = Field::from_be_bytes::<31>(dst_address_byte_array_filled_1);\n        out[9] = Field::from_be_bytes::<31>(dst_address_byte_array_filled_2);\n\n        out\n    }\n\n    fn unpack(fields: [Field; 10]) -> Self {\n        assert(false, \"unpack not implemented\");\n        TokenLocked {\n            Id: fields[0] as Field,\n            hashlock: [0 as u8; 32],\n            amount: 0 as u128,\n            token: AztecAddress::zero(),\n            timelock: 0 as u64,\n            dst_chain: \"00000000\",\n            dst_asset: \"00000000\",\n            dst_address: \"000000000000000000000000000000000000000000000000\",\n        }\n    }\n}\n"
    },
    "54": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
    },
    "55": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "62": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "63": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(gas_for_call(gas_opts), contract_address, calldata);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(gas_for_call(gas_opts), contract_address, calldata);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_opcode(gas, address, args)\n}\n\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "64": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "65": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "69": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "81": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "84": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/keys/ecdh_shared_secret.nr",
      "source": "use dep::protocol_types::{\n    address::aztec_address::AztecAddress, point::Point, scalar::Scalar, traits::FromField,\n};\nuse std::{embedded_curve_ops::multi_scalar_mul, ops::Neg};\n\n/// Computes a standard ecdh shared secret: [secret] * public_key = shared_secret.\n/// The input secret is known only to one party. The output shared secret is derivable\n/// by both parties, through this function.\n/// E.g.:\n/// Epk = esk * G // ephemeral keypair\n/// Pk = sk * G // recipient keypair\n/// Shared secret S = esk * Pk = sk * Epk // see how this function can be called with two different sets of inputs, depending on which secret the caller knows (either esk or sk)?\n// See also: https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman\npub fn derive_ecdh_shared_secret(secret: Scalar, public_key: Point) -> Point {\n    let shared_secret = multi_scalar_mul([public_key], [secret]);\n    shared_secret\n}\n\n/// Computes a standard ecdh shared secret using the address public key of the given address:\n/// [ephemeral_secret] * recipient_address_public_key = shared_secret.\n/// The intention is that the _creator_ of a shared secret would call this function,\n/// given the address of their intended recipient.\npub fn derive_ecdh_shared_secret_using_aztec_address(\n    ephemeral_secret: Scalar,\n    recipient_address: AztecAddress,\n) -> Point {\n    derive_ecdh_shared_secret(ephemeral_secret, recipient_address.to_address_point().inner)\n}\n\n#[test]\nunconstrained fn test_consistency_with_typescript() {\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let shared_secret = derive_ecdh_shared_secret(secret, point);\n\n    // This is just pasted from a test run.\n    // The original typescript code from which this could be generated seems to have been deleted by someone, and soon the typescript code for encryption and decryption won't be needed, so this will have to do.\n    let hard_coded_shared_secret = Point {\n        x: 0x15d55a5b3b2caa6a6207f313f05c5113deba5da9927d6421bcaa164822b911bc,\n        y: 0x0974c3d0825031ae933243d653ebb1a0b08b90ee7f228f94c5c74739ea3c871e,\n        is_infinite: false,\n    };\n    assert_eq(shared_secret, hard_coded_shared_secret);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let shared_secret = derive_ecdh_shared_secret(secret_a, pk_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_from_address_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let mut pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let mut pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let address_b = AztecAddress::from_field(pk_b.x);\n\n    // We were lazy in deriving the secret keys, and didn't check the resulting y-coordinates\n    // of the pk_a or pk_b to be less than half the field modulus.\n    // If needed, we negate the pk's so that they yield valid address points.\n    // (We could also have negated the secrets, but there's no negate method for\n    // EmbeddedCurvesScalar).\n    pk_a = if (AztecAddress::from_field(pk_a.x).to_address_point().inner == pk_a) {\n        pk_a\n    } else {\n        pk_a.neg()\n    };\n    pk_b = if (address_b.to_address_point().inner == pk_b) {\n        pk_b\n    } else {\n        pk_b.neg()\n    };\n\n    let shared_secret = derive_ecdh_shared_secret_using_aztec_address(secret_a, address_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n"
    },
    "85": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/keys/ephemeral.nr",
      "source": "use std::embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul};\n\nuse dep::protocol_types::{point::Point, scalar::Scalar};\n\nuse crate::oracle::random::random;\n\npub fn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n\n    // Safety: we use the randomness to preserve the privacy of both the sender and recipient via encryption, so a\n    // malicious sender could use non-random values to reveal the plaintext. But they already know it themselves anyway,\n    // and so the recipient already trusts them to not disclose this information. We can therefore assume that the\n    // sender will cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // TODO(#12757): compute the key pair without constraining eph_sk twice (once in from_field, once in the black box\n    // called by fixed_base_scalar_mul).\n    let eph_sk = EmbeddedCurveScalar::from_field(randomness);\n    let eph_pk = fixed_base_scalar_mul(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n"
    },
    "86": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "90": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_notes` utility function PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_notes = generate_sync_notes();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_notes\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_notes() -> Quoted {\n    // TODO(https://github.com/noir-lang/noir/issues/7912): Doing the following unfortunately doesn't work. Once\n    // the issue is fixed uncomment the following and remove the workaround from TS (look for the issue link in the\n    // codebase).\n    // let utility: fn(FunctionDefinition) -> () = crate::macros::functions::utility;\n    // quote {\n    //     #[$utility]\n    //     unconstrained fn sync_notes() {\n    //     }\n    // }\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[aztec::macros::functions::utility]\n        unconstrained fn sync_notes() { }\n    }\n}\n"
    },
    "91": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "94": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_slice, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_view,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_SLICE_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args =  &[];\n    // serialized_args = serialized_args.append(aztec::protocol_types::traits::Serialize::serialize(target_address));\n    // serialized_args = serialized_args.push_back(fee_juice_limit_per_tx as Field);\n    // ```\n    let serialized_args_slice_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_SLICE_NAME = &[];\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append = add_to_field_slice(SERIALIZED_ARGS_SLICE_NAME, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n"
    },
    "95": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "98": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.3/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, &[], false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    }
  }
}
