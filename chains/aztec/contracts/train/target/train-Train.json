{
  "transpiled": true,
  "noir_version": "1.0.0-beta.3+0000000000000000000000000000000000000000",
  "name": "Train",
  "functions": [
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "772057049813214347": {
            "error_kind": "string",
            "string": "HTLCNotExists"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2570651705007895968": {
            "error_kind": "string",
            "string": "HashlockNotMatch"
          },
          "2722406262643068352": {
            "error_kind": "string",
            "string": "HashlockAlreadySet"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3559210201980528457": {
            "error_kind": "string",
            "string": "Function commit_public_user can only be called internally"
          },
          "3564161243949231814": {
            "error_kind": "string",
            "string": "Function refund_public can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "9174444391250494040": {
            "error_kind": "string",
            "string": "Function get_htlc_public can only be called statically"
          },
          "9323748002447105156": {
            "error_kind": "string",
            "string": "NotPassedTimelock"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "15001264570739363109": {
            "error_kind": "string",
            "string": "Function lock_public_solver can only be called internally"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16870384257694633552": {
            "error_kind": "string",
            "string": "Function add_lock_public_user can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17814817983036354427": {
            "error_kind": "string",
            "string": "Function redeem_public can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "redeem_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2588366281349374274": {
            "error_kind": "fmtstring",
            "length": 136,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "3473764466780631008": {
            "error_kind": "fmtstring",
            "length": 106,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5533887251808526417": {
            "error_kind": "fmtstring",
            "length": 120,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "commit_public_user",
      "is_unconstrained": true,
      "custom_attributes": [
        "internal",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 48
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "src_receiver",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3559210201980528457": {
            "error_kind": "string",
            "string": "Function commit_public_user can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "commit_public_user"
      ]
    },
    {
      "name": "lock_public_solver",
      "is_unconstrained": true,
      "custom_attributes": [
        "internal",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 48
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "15001264570739363109": {
            "error_kind": "string",
            "string": "Function lock_public_solver can only be called internally"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "lock_public_solver"
      ]
    },
    {
      "name": "redeem_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "772057049813214347": {
            "error_kind": "string",
            "string": "HTLCNotExists"
          },
          "2570651705007895968": {
            "error_kind": "string",
            "string": "HashlockNotMatch"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17814817983036354427": {
            "error_kind": "string",
            "string": "Function redeem_public can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "redeem_public"
      ]
    },
    {
      "name": "refund_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3564161243949231814": {
            "error_kind": "string",
            "string": "Function refund_public can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "9323748002447105156": {
            "error_kind": "string",
            "string": "NotPassedTimelock"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "refund_public"
      ]
    },
    {
      "name": "is_contract_initialized",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2588366281349374274": {
            "error_kind": "fmtstring",
            "length": 136,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "3473764466780631008": {
            "error_kind": "fmtstring",
            "length": 106,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5533887251808526417": {
            "error_kind": "fmtstring",
            "length": 120,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7b3fruy6jt77Lvu6LyyJ+pdXCQ6CTtIJNtDoDjqdAxwE/e6n5qxhV81VVslDQyVS4rcvFsbayy5TP9LiR9qW/u/f/vs//df/8z//y9//5X/86//+23/6z//3b//8r//tH//97//6L7d/+7//8Q9/+6//9vd//ue//8//8vx//2379Q9j7e8T/vf/+sd/+fXv//vf//Hf/v1v/8lsZNI//O2f/uW///47xtuP/I+///M/3f7Nbv/xDy/HxxS+jk4bHceGeHKot/7rUO+3x88S/cf/8w83c1wPc5KLuzk+vzeHXP46lEJ6NYe6mJNoNyen9+aEbacTbHg1x/cwJ1v7dXR2vmJO2r4OjduJs8KpOS5t+wWMy95UzLEp7d5ym7dPR9v7VeKQq6QhV8kjruK2IVcxQ65ih1zFDbkKDbmKH3KVIfe+G3LvuyH3vhty79OQe5+G3Ps05N6nIfc+Dbn3aci9T0PufRpy79OQe5+G3Pt+yL3vh9z7fsi974fc+37Ive+H3Pt+yL3vh9z7fsi974fc+2HIvR+G3PthyL0fhtz7Yci9H4bc+2HIvR+G3PthyL0fhtz7cci9H4fc+3HIvR+H3PtxyL0fh9z7cci9H4fc+3HIvR+H3PtpyL2fhtz7aci9n4bc+2nIvZ+G3PtpyL2fhtz7qcu977zfn9M4nx8PakK+XyQPuEjeRlzEjLiIHXERN+IiXe56Fza3XyTa9HyR14Nvc/Px8C+Fx8PX6M6edsb9h/3z40V/f56X/XDr7Wb3J8d2c39Y/9uiIM6iKM6iJM6iLMwiu23iLDLiLLLiLHLiLCJxFkmbs+3GMGfbh0XWVXKg9Wb/Zevjww4fzl7dOdJ9is/v49izHzbHa0fWPA2QwqlONYdM/ePQ3wgjEP4UYQLCnyLMQPhDhGYDwp8iNED4U4QWCH+K0AHhTxESEP4UoQfCnyJEdfJjhKhOfowQ1cmPEaI6+SlCi+rkxwhRnfwYIaqTHyNEdfJjhASEP0WI6uTHCFGd/BghqpMfI0R18mOEqE5+itChOvkxQlQnP0aI6uTHCFGd/BghMSCkw3hnau+Vmu1YRufX6jBPCH+b7+c2P8xtfpzb/DS3+Xlq82mb23wzt/l2bvPd3ObPnXVp7qxLc2ddmjvr0txZl+bOun7urOvnzrp+7qzr5866fVZL4jN/7qzr5866fu6s6+fOun7urBvmzrph7qwb5s66Ye6s22edMj7z5866Ye6sG+bOumHurBvmzrpx7qwb5866ce6sG+fOun1WCOQzf+6sG+fOunHurBvnzrpx7qyb5s66ae6sm+bOumnurNtnbU4+8+fOumnurJvmzrpp7qyb5s66ee6sm+fOunnurJvnzroMa+N+y3xH276QriPK7w82FPc9PY037mF0SidHh+OX/9jVM8U7GOH5nA+McKXAB0a4BuEDI1zd8IERrpu4wLhNuCLjAyNc6/GBEa4i+cAI16d8YAhgzsFA+RbAQPkWwED5FsCIV75x/yLbeRffH5xN3jsJ2T19Zh3TpymKl8kzUDTiNfUUFMUL8CkoilfrU1AUL+2noEig2IGi+KJhCoriK4wpKIovR6agiNqlB0XULh0oWtQuPSiidulBcanaxdsdTPYxvqdoTdyHaE16tNFMPhuhjQcQG+1jz+9wp7hU7cJGkUCxA8Wlahc2ikvVLmwUl6pd2CguVbuwUVyqduGi6JaqXdgoLlW7sFFE7dKDImqXHhQJFDtQRO3Sg+JStUsK+6YFOZtKZ8wGf+zJEIJ/oujP7DD2eJHK+OejT612cR+ic9n9cfRv6kvVOtNQX6o2mob6UrXULNSl75OwKPWlarVpqC9V201DfalacBrqBOoM1JeqNaehjtqUgzpqUw7qqE05qKM2ZaAufTehRamjNuWgjtqUgzpqUw7qBOoM1FGbclBHbcpBHbUpB3XUphzUUZsyUJe+596i1FGbclBHbcpBHbUpB3UCdQbqqE05qKM25aCO2pSDOmpTDuqoTRmoS9+ZdlHqqE05qKM25aCO2pSDOoE6A3XUphzUUZtyUEdtykEdtSkHddSmDNSl79++KHXUphzUUZtyUEdtykGdQJ2BOmpTDuqoTTmoozbloI7alIM6alMG6hm1KQd11KYc1FGbclBHbcpBnUCdgTpqUw7qqE05qKM25aCO2pSDOmrT8dRpQ23KQR21KQd11KYc1FGbclAnUGegjtqUgzpqUw7qqE05qKM25aCO2pSBukFtykEdtSkHddSmHNRRm3JQJ1BnoI7alIM6alMO6qhNOaijNuWgjtqUgbpFbcpBHbUpB3XUphzUUZtyUCdQZ6CO2pSDOmpTDuqoTTmoozbloI7alIG6Q23KQR21KQd11KYc1FGbclAnUGegjtqUgzpqUw7qqE05qKM25aCO2vQadUt+t8OmGnXKB3W/bfmFOqE25aCO2pSDOmpTDuqoTTmoE6gzUEdtykEdtSkHddSmHNRRm3JQR23KQN2jNuWgjtqUgzpqUw7qqE05qBOoM1BHbcpBHbUpB3XUphzUUZtyUEdtykA9oDbloI7alIM6alMO6qhNOagTqDNQR23KQR21KQd11KYc1FGbclBHbcpAPaI25aCO2pSDOmpTDuqoTTmoE6gzUEdtykEdtSkHddSmHNRRm3JQR23KQD2hNuWgjtqUgzpqUw7qqE05qBOoM1BHbcpBHbUpB3XUphzUUZtyUEdtykA9ozbloI7alIM6alMO6qhNOagTqDNQR23KQR21KQd11KYc1FGbclBHbTqe+u3/A3UG6qhNOaijNuWgjtqUgzqBOgN11KYc1FGbclBHbcpBHbUpB3XUpgzUDWpTDuqoTTmoozbloI7alIM6gToDddSmHNRRm3JQR23KQR21KQd11KYM1C1qUw7qqE05qKM25aCO2pSDOoE6A3XUphzUUZtyUEdtykEdtSkHddSmDNQdalMO6qhNOaijNuWgjtqUgzqBOgN11KYc1FGbclBHbcpBHbUpB3XUpgzUCbUpB3XUphzUUZtyUEdtykGdQJ2BOmpTDuqoTTmoozbloI7alIM6alMG6h61KQd11KYc1FGbclBHbcpBnUCdgTpqUw7qqE05qKM25aCO2pSDOmpTBuoBtSkHddSmHNRRm3JQR23KQZ1AnYE6alMO6ivVpmbbIu1mbyabCvct7YO01j856Qy7CXH3qIlmqxxst20/2Jr0fPBv6CuVptNAX6kynQb6SoXpLNDjSnXpNNBXKkungb5SVToN9JWK0mmgE6CPh75SSToNdFSkDNBRkTJAR0XKAB0V6XjoCRXpJ6CTPeygSO8PDrRbEcJjgM7n0+51ehpf5eBgjqOD9Vvl6NuoQnyM8FfP+v2v520HErJ5GG7OUCdLO5Bkg30++HcUokRHFPJHIXoWiEL+KEQTB1HIH4WEKEQUskch2nyIQv4oRN8TUcgfhWgEIwr5oxCdcUQhfxTiUQGikD0KM56dIAr5oxDPThCF/FGIZyeIQv4oxLMTRCF/FBKiEFHIHoV4doIo5I9CPDtBFPJHIZ6dIAr5oxDPThCF/FGIZyeIQu4oDBuenSAK+aMQz04QhfxRiGcn60ah9fGIwlT7aZOC253462/64/jfsYInHIiVq7FCiBXEysVYwdMCxMrVWEFPH7FyNVbQeUesXI0V9McRK1djBV1sxMrFWDHoNSNWrsYKOsKIlauxgr4tYuVqrKBvi1i5GiuEWEGsXIwV9G0RK1djBX3bi7ESnT9ixf1x8G+O6Gn24Yh+Xx+O6IV14WjRJ+rDET2UPhzRX+jDEbV3H44Ejl04ombrwxH1TB+OqGf6cEQ904cj6pkuHN1a9Uw6dlc3W7b+PUdjkj+6YSbFR8MvnJkdDyQ2Wvt07G+Oa9UzfBzXqmf4OC5VzxhPR0/cBLu95xi2x0ddjwnvBvROhkCmQGapmqMrmaWqiK5klqoLupJZSul3JbOUdu9JhpZS413JLKWvu5JZSjF3JQMNXCJDIFMgAw1cIgMNXCKzlAa2xh5mW/PcXjztRbqYDkPyo8Hxu4n5f7/Xs6ClFDMjx6X0NR9Hv5QaZ+S4lHZn5LiU0mfkuFRdwMiRwLELx6VqDkaOS1UojBxRz/ThiHqmD0fUM104BtQzfThqrmfIbLshRNsfHH+z0Vyj1NhorjtqbAhsimw01wc1Npo1f42NZh1fY6NZm9fYaNbbFTZRs4ausYEuLrOBLi6zgS4usyGwKbKBLi6zgS4us4EuLrOBLi6zgS4usknQxWU20MVlNtDFZTbQxWU2BDZFNtDFZTbQxWU20MVlNtDFZTbQxUU2Gbq4zAa6uMwGurjMBrq4zIbApsgGurjMBrq4zAa6uMwGurjMBrq4xCZu0MVlNtDFZTbQxWU20MVlNgQ2RTbQxWU20MVlNtDFZTbQxWU20MVFNmvtQ92ZDXRxmQ10cZkNdHGZDYFNkQ10cZkNdHGZDXRxmQ10cZkNdHGRzVr7bnZmA11cZgNdXGYDXVxmQ2BTZANdXGYDXVxmA11cZgNdXGYDXVxks9b+jZ3ZQBeX2UAXl9lAF5fZENgU2UAXl9lAF5fZQBeX2UAXl9lAFxfZrLWTYmc20MVlNtDFZTbQxWU2BDZFNtDFZTbQxWU20MVlNtDFZTbQxUU2qvc0rLGBLi6zgS4us4EuLrMhsCmyka6LYzrYJGveHxwo7GYEb/Lzwb/HKl3n9hyrdN3ac6zSdWjPsUrXlR3HKn6vuJ5jla77eo5Vuo7rOVbpuqznWEnRWBXpJvH7m/UcqyLdJH7/sZ5jVaSbxO8P1nOsinST+P27eo5VkW4Sv79Wz7Eq0k3i97/qOVZFukn8/lQ9x6pIN4nfP6rnWBXpJvH7O/UcqyLdJH7/pZ5jVaSbxO+P1HOsinST+P2Leo5VkW4Sv79Qz7Eq0k3i9//pOVZFukn8/jw9x6pIN4nfP6fnWBXpJvH72/Qcqx7dlMTvP9NzrHp0UxK/P0zPserRTWkjRWPVo5uS+P1Veo5Vj25K4vc/6TlWRbpJ/P4kPceqSDeJ3z+k51gV6Sbx+3v0HKsi3SR+/42eY1Wkm8Tvj9FzrIp0k/j9K3qOVZFuEr+/RM+xKtJN4vd/6DlWRbpJ/P4MPceqSDeJ3z+h51gV6Sbx+xv0HKsi3SR+/4GeY1Wkm8TvD9BzrIp0k/j1+3uOVZFuEr++fs+xKtJN4te/7zlWRbpJ/Pr0PceqSDeJXz++51gV6Sbx67v3HKsi3SR+/fWeY1Wkm8Svj95zrIp0k/j1y3uOVZFuEr++eM+xKtJNitYLT4rWC0+K1gtPitYLT4rWC0+K1gtPitYLT4rWC0+K1gtPitYLT4rWC0+K1gtPitYLT4rWC0+K1gtPitYLT4rWC0+K1gtPitYLT4rWC0+K1gtPitYLT4rWC0+K1gtPitYLT4rWC0+K1gtPitYLT4rWC0+K1gtPitYLT4rWC0+K1gtPitYLT4rWC0+K1gtPitYLT4rWC0+K1gtPitYLT4rWC0+K1gtPitYLT4rWC8+K1gvPitYLz4rWC8+K1gvPGykaqx7dlBWtF54VrReeFa0XnhWtF54VrReeFa0XnhWtF54VrReeFa0XnhWtF54VrReeFa0XnhWtF54VrReeFa0XnhWtF54VrReeFa0XnhWtF54VrReeFa0XnhWtF54VrReeFa0XnhWtF54VrReeFa0XnhWtF54VrReeFa0XnhWtF54VrReeFa0XnhWtF54VrReeFa0XnhWtF54VrReeFa0XnhWtF54VrReeFa0XnhWtF54VrReeFa0XnhWtF54VrReeFa0XnhWtF54VrReeFa0XnhWtF54VrReeFa0XnhWtF54VrReeFa0XnhWtF54VrReeFa0XnhWtF54VrReeFa0XnhWtF54VrReeFa0XnhWtF54VrReeFa0XnhWtF54VrReeFa0XnhWtF54VrReel1ovPFpjvg6ONvr3BxuKtA/RG/cYYUpnGLe0U7Th6dh4p7iSIuOjuJLW46O4korko0ig2IHiSsqXj+JKmpqP4kpqnY/iSnUAH8WVKgw2ikut2c9HEbVLD4qoXXpQRO3SgyIJp5icOSjG7a8tKfHbHVTMl67WK+ZLl8kV86Xr04r50oXhW/PNJn47gJr90sVQzX7pMqRmv3QBULN/6tR7s3/q3Huzf+rke7N/6ux7s3/q9Huzf/L8K35Z+Zr9k+df8cu/1+yfPP+KX6a9Zv/k+Vf8cuo1+yfPv+KXPa/ZP3n+Fb88ec3+yfOv+GXEa/ZPnn/FL/dds3/y/Ct+We6a/ZPnX/HLZ9fsnzz/il/mumb/5PlX/HLUNfsnz7/il42u2T95/hW/vHPN/snzr/hlmGv2T55/xS+XXLN/8vwrflnjmv2T51/xyw/X7J88/4pfJrhm/+T5V/xyvjX7J8+/4pfdrdk/ef4VvzxuzX7x+Tcd9ufaC9gm7m9J2+3xRrWN8eTYtO2vXyeXK8fm4yXwnP889s6QwPDHDMXrkAkYitdCEzAUr8cmYCheE07AULwulc9Q/NLKMzAUr88nYCi+RpiAIeqUnzMkMPwxQ+l1Sna7IWRTqDC0IR1Wm4cZkU5ttn63OaT8fPCdjPTqg4+M9JqCj4z0SoGPjHT9z0ZG/MLffGSka3U+MtIVOB8Z6bqajwyBTIEMNHCJDDRwiQw0cIkMNHCJDDRwgYz4Rdz5yEADl8hAA5fIQAOXyBDIFMhAA5fIQAOXyEADl8hAA5fIQAMXyIhfDJyPDDRwiQw0cIkMNHCJDIFMgQw0cIkMNHCJDDRwiQw0cIkMNPA5GSN+9XU+MtDAJTLQwCUy0MAlMgQyBTLQwCUy0MAlMtDAJTLQwCUy0MAFMuJ3QOAjAw1cIgMNXCIDDVwiQyBTIAMNXCIDDVwiAw1cIgMNXCIDDVwgI34XEj4y0MAlMtDAJTLQwCUyBDIFMtDAJTLQwCUy0MAlMtDAJTLQwAUy4ncC4iMDDVwiAw1cIgMNXCJDIFMgAw1cIgMNXCIDDVwiAw1cIgMNXCAjfjcuPjLQwCUy0MAlMtDAJTIEMgUy0MAlMtDAJTLQwCUy0MAlMtDABTLid8TjIwMNXCIDDVwiAw1cIkMgUyADDVwiAw1cIgMNXCIDDVwiAw1cICN+5zs+MtDAJTLQwCUy0MAlMgQyBTLQwCUy0MAlMtDAJTLQwCUy0MAFMtgnrkgGGrhEBhq4RAYauESGQKZABhq4RAYauEQGGrhEBhq4RAYauEAG+8QVyUADl8hAA5fIQAOXyBDIFMhAA5fIQAOXyEADl8hAA5fIQAMXyGCfuCIZaOASGWjgEhlo4BIZApkCGWjgEhlo4BIZaOASGWjgEhlo4HMyFvvEFclAA5fIQAOXyEADl8gQyBTIQAOXyEADl8hAA5fIQAOXyEADF8hgn7giGWjgEhlo4BIZaOASGQKZAhlo4BIZaOASGWjgEhlo4BIZaOACGewTVyQDDVwiAw1cIgMNXCJDIFMgAw1cIgMNXCIDDVwiAw1cIgMNXCCDfeKKZKCBS2SggUtkoIFLZAhkCmSggUtkoIFLZKCBS2SggUtkoIELZLBPXJEMNHCJDDRwiQw0cIkMgUyBDDRwiQw0cIkMNHCJDDRwiQw0cIEM9okrkoEGLpGBBi6RgQYukSGQKZCBBi6RgQYukYEGLpGBBi6RgQYukME+cUUy0MAlMtDAJTLQwCUyBDIFMtDAJTLQwCUy0MAlMtDAJTLQwAUy2CeuSAYauEQGGrhEBhq4RIZApkAGGrhEBhq4RAYauEQGGrhEBhq4QAb7xBXJQAOXyEADl8hAA5fIEMgUyEADl8hAA5fIQAOXyEADl8hAAxfIYJ+4Ihlo4BIZaOASGWjgEhkCmQIZaOASGWjgEhlo4BIZaOASGWjgczIO+8QVyUADl8hAA5fIQAOXyBDIFMhAA5fIQAOXyEADl8hAA5fIQAMXyGCfuCIZtRqYXAz7LxPl9wcbirT/sjfugSOlk6PDtpsRbHg6Nn4xV6uuGZmr1e2MzAnMhzNXW2swMldbxTAyV1sfMTJXW3kxMldb0/Ex17ujIiNz1KHjmaMOHc8cdeh45gTmw5kvVYe6o4lq/G2EbzFak3aMlkz4j792XNfaE7MrmaVquq5klqq8upJZqj7qSWatPTG7klmq1uhKZqmKoCuZpXR7VzIEMgUy0MAlMtDAJTLQwCUy0MAlMtDABTJr7YnZlQw0cIkMNHCJDDRwiQyBTIEMNHCJDDRwiQw0cIkMNHCJDDRwgcxae2J2JQMNXCIDDVwiAw1cIkMgUyADDVwiAw1cIgMNXCIDDVwiAw1cILPWnphdyUADl8hAA5fIQAOXyBDIFMhAA5fIQAOXyEADl8hAA5fIQAMXyKy1J2ZXMtDAJTLQwCUy0MAlMgQyBTLQwCUy0MAlMtDAJTLQwCUy0MAFMmvtidmVDDRwiQw0cIkMNHCJDIFMgQw0cIkMNHCJDDRwiQw0cIkMNHCBzFp7YnYlAw1cIgMNXCIDDVwiQyBTIAMNXCIDDVwiAw1cIgMNXCIDDXxOhtbaE7MrGWjgEhlo4BIZaOASGQKZAhlo4BIZaOASGWjgEhnhGpjcYQi553XI3Zf9wpVqzX7p+0tW7Reu+qr2C9dmVfuFK6iq/TS5/cLVSNV+4Zqhar/wzF61f/L8K32XsZr90nfsqto/ef6VvpNU1f7J86/0HY6q9k+ef6Xv6VO1f/L8K31/nKr9k+df6XvNVO2fPP9K37elav/k+Vf6HihV+yfPv9L3E6naP3n+lb43R9X+yfOv9H0uqvZPnn+l7xlRtX/y/Ct9/4Wq/ZPnX+l7GVTtnzz/St8XoGr/5PlX+hr7Vfsnz7/S16uv2j95/pW+9nvV/snzr/R11Kv2T55/pa9JXrV/8vwrfX3vqv2T51/pa2VX7Z88/0pfd7pq/+T5V/oazlX7J8+/0tdDrto/ef6VvrZw1f7J86/0dXqr9k+ef6WveVu1f/L8K3392Kr9k+df6WuxVu2fPP9KX9e0av/k+Vf6GqFV+8Xn37Dt9tOW3h9sYtp/eHPHoTbGk2PTtn9XmVyuHJtT+Do25z+PvTMkMPwxQ/E6ZAKG0rUQmbwz9Mm/P9hGe3z4HJN9HGzOIHq/DzEFS88H38lIV1l8ZKTrNz4y0pUhGxnp64gykpGuZvnISNfJfGSkK3A+MgQyBTLS1TIfGWjgEhlo4BIZaOASGWjgczJe+jqijGSggUtkoIFLZKCBS2QIZApkoIFLZKCBS2SggUtkoIFLZKCBC2TEr33KRwYauEQGGrhEBhq4RIZApkAGGrhEBhq4RAYauEQGGrhEBhq4QEb8+sN8ZKCBS2SggUtkoIFLZAhkCmSggUtkoIFLZKCBS2SggUtkoIELZMSvAc5HBhq4RAYauEQGGrhEhkCmQAYauEQGGrhEBhq4RAYauEQGGrhARvw6/HxkoIFLZKCBS2SggUtkCGQKZKCBS2SggUtkoIFLZKCBS2SggQtkxO+FwUcGGrhEBhq4RAYauESGQKZABhq4RAYauEQGGrhEBhq4RAYauEBG/H40fGSggUtkoIFLZKCBS2QIZApkoIFLZKCBS2SggUtkoIFLZKCBC2TE7wnFRwYauEQGGrhEBhq4RIZApkAGGrhEBhq4RAYauEQGGrhEBhq4QEb8vmx8ZKCBS2SggUtkoIFLZAhkCmSggUtkoIFLZKCBS2SggUtkoIELZLBPXJEMNHCJDDRwiQw0cIkMgUyBDDRwiQw0cIkMNHCJDDRwiQw08DmZgH3iimSggUtkoIFLZKCBS2QIZApkoIFLZKCBS2SggUtkoIFLZKCBC2SwT1yRDDRwiQw0cIkMNHCJDIFMgQw0cIkMNHCJDDRwiQw0cIkMNHCBDPaJK5KBBi6RgQYukYEGLpEhkCmQgQYukYEGLpGBBi6RgQYukYEGLpDBPnFFMtDAJTLQwCUy0MAlMgQyBTLQwCUy0MAlMtDAJTLQwCUy0MAFMtgnrkgGGrhEBhq4RAYauESGQKZABhq4RAYauEQGGrhEBhq4RAYauEAG+8QVyUADl8hAA5fIQAOXyBDIFMhAA5fIQAOXyEADl8hAA5fIQAMXyGCfuCIZaOASGWjgEhlo4BIZApkCGWjgEhlo4BIZaOASGWjgEhlo4AIZ7BNXJAMNXCIDDVwiAw1cIkMgUyADDVwiAw1cIgMNXCIDDVwiAw1cIIN94opkoIFLZKCBS2SggUtkCGQKZKCBS2SggUtkoIFLZKCBS2SggQtksE9ckQw0cIkMNHCJDDRwiQyBTIEMNHCJDDRwiQw0cIkMNHCJDDTwOZmIfeKKZKCBS2SggUtkoIFLZAhkCmSggUtkoIFLZKCBS2SggUtkoIELZLBPXJEMNHCJDDRwiQw0cIkMgUyBDDRwiQw0cIkMNHCJDDRwiQw0cIEM9okrkoEGLpGBBi6RgQYukSGQKZCBBi6RgQYukYEGLpGBBi6RgQYukME+cUUy0MAlMtDAJTLQwCUyBDIFMtDAJTLQwCUy0MAlMtDAJTLQwAUy2CeuSAYauEQGGrhEBhq4RIZApkAGGrhEBhq4RAYauEQGGrhEBhq4QAb7xBXJQAOXyEADl8hAA5fIEMgUyEADl8hAA5fIQAOXyEADl8hAAxfIYJ+4Ihlo4BIZaOASGekaOGxmJxPIPB98t58mt1+6nqzZL1311eyXrs1q9ktXUDX7peuciv3id+yq2S9dM9Tsl57Za/ZPnn/F7yRVs3/y/Ct+V6aa/ZPnX/E7HNXsnzz/it8tqGb/5PlX/M47Nfsnz7/id7Gp2T95/hW/I0zN/snzr/jdVWr2T55/xe9UUrN/8vwrftePmv2T51/xO2jU7J88/4rfjaJm/+T5V/zODjX7586/SfwuCTX7586/SfyOAzX7586/aZs7/ybxa+zX7J87/ybx69XX7J87/ybxa79X7Be/QnvN/snzr/jVzmv2T55/xa8cXrN/8vwrfhXumv2T51/xK1rX7J88/4pfHbpm/+T5V/xKyzX7J8+/4lctTmE3xJstv9ovPf/W7Jeef2v2S8+/Nful59+a/dLzb8V+8SvT1uyXnn9r9kvPvzX7peffmv2T51/x65rW7J88/4pfI7Rm/+T5V/x6mxX7xa+KWbN/8vwrfoXJmv2T51/xqzXW7J88/4pf+bBm/+T5V/wqgjX7J8+/4lfkq9k/ef4Vv7pdzf7J86/4leJq9k+ef8Wvulazf/L8K34Fs5r9k+df8auB1eyfPP+KX1mrZv/k+Vf8+lc1+yfPv+LXv6rZP3n+Fb/+Vc3+yfOv+PWvavZPnn/Fr39Vs3/y/Ct+/aua/ZPnX/HrX9Xsnzz/il//qmb/5PlX/PpXNfsnz7/i17+q2T95/hW//lXN/snzr/j1r2r2T55/xa9/VbN/8vwrfv2rmv2T51/x61/V7J88/4pf/6pm/+T5V/z6VzX7J8+/4te/qtk/d/7N4te/qtk/d/7N4te/qtk/d/7N29z5N4tf/6pm/9z5N4tf/6pm/9z5N4tf/6piv/j1r2r2T55/xa9/VbN/8vwrfv2rmv2T51/x61/V7J88/4pf/6pm/+T5V/z6VzX7J8+/4te/qtk/ef6dfP2rPPn6V3ny9a/y5Otf5cnXv8qTr3+VJ1//Kk++/lWefP2rPPn6V3ny9a/y5Otf5cnXv8qTr3+VJ1//Kk++/lWefP2rPPn6V3ny9a/y5Otf5cnXv8qTr3+VJ1//Kk++/lWefP2rPPf6V3bj6P/cLrrbvzl6NYkhpM0DqfH2xaROXYLo/G5SivG9SS4ke9ifH/ZH82WSkWeSlWeSk2cSyTPJyzMpyDMpyjMpyTMpizOJ5M3eJG/2JnmzN8mbvUne7E3yZm+SN3uTvNmb5M3eJG/29vJmby9v9vbyZm8vb/b28mZvL2/29vJmby9v9vbyZm8vb/YO8mbvIG/2DvJm7yBv9g7yZu8gb/YO8mbvIG/2DvJm7yBv9o7yZu8ob/aO8mbvKG/2jvJm7yhv9o7yZu8ob/aO8mbvKG/2TvJm7yRv9k7yZu/EMHunkI6Ds3s1ieSZ5OWZFOSZFOWZlOSZlMWZlDd5JhlWk/JGryYxzN5pOw7Oxj6b9Hpw2ujr2OQeb1/ZX9d4OTan/b2onP889j5Up2eopGeoXs9Qg56hRj1DTXqGmrUM1WybnqEaPUNVo5bMpkYtmY30DFWNWjLbSmop7MfeEos9GetKcqk21pX0Um2sKwmmyljNSoqpNtaVJFNtrAyaKTtzjNXZvza9jHHyTCJ5JgV5JjHkuUyPBmp0ryYleSZlcSbZTZ5JRp5JVp5JTp5JJM8kz2ESPUzyryYV5qWbqDxMsu7x7Nz7k4vciqj9I/CbZnmM24Qz1WCOgsw8PZR3xn9ZlKVZVPosndEiI84iK84iJ84iEmeRF2dREGdRHG+Rf6zcYf+w6PXYmGnPBjE/vUxgYzpLB8cv06/csh9LJ4dak/fMYe1TJXg7+M4lgcsplwwuZ1xoA5dTLgZcTrlYcDnl4sDllAuByykXDy6nXAK4nHKB3j3nAr17zgV695SLh9495wK9e84FevecC/TuORcCl1Mu0LvnXKB3z7lA755zgd495wK9e8olQO+ec4HePecCvXvOBXr3nAuByykX6N1zLlr1i3UPLuRfuESt+SiavFsRnXvlojUf1bhozUc1LlrzUY2L1nxU46K1/1LjorX/UuOiVb/UuGjtv1S4JK39lxqXLnrXpP3LDvMsqs+5eB/3o0N6Kk2MPds7MMf9Y7ac0tMvuy/77eT2u8ntp8ntv6LHfHxvvwvmWEozUP7jKqel+W6SdaZ2dLq1ML6OTnbLlZmB0rbvIUnpaW5wfvsab1A23qhsvEnZeLOu8eZN2XiNsvFaZeN1ysZLysYrXl9Z8xivt5Xxsj2vyeJ12yQcxevBSTiK15mTcBSvX6fgaDfxungSjuL19iQcxev4STiKrw8m4Ujg2IUj6pk+HFHP9OGIeqYPR9QzfTiinunC0aCe6cMR9Uwfjqhn+nBEPdOHI4FjF46oZ/pwRD3ThyPqmT4cUc/04Yh6pgtHi3qmD0fUM304op7pwxH68RrH998dW4t8fY3j++9ZrEW+7sLRIV/34Yh83Ycj8nUfjug/9uFI4NiFI/RjH47oP/bhiP5jH4596plw7GQaMlXIRBt36tGZp299fbjbRNAQ13zrtvAwml58S9AQfTgSOHbhCA3RhyM0RB+O0BB9OKIn2ocjeqLXONpsD6O31x69R0+0D0f0RPtwRD3ThyPqmT4cCRy7cEQ904cj6pk+HFHP9OGIeqYLxwAd3oej1rXIK/Vy0LoWeY2L1rXIa1y0rkVe46J1LfIKl6h1LfIaF61779S4aN17p6Jf1O69U+NC4HLKRaverXHRqndrXLTq3RoXtXsHVrho1bsVLmr33qlx0ap3a1yg6865FPJ02uzBJXvzGOqvC74aFN1uvkvx0SUN+ezgTPtniy7Hh0nRfJkUh5tEG+2/TVuIzyadICV3OJboUVrtrwSXtkuZxv48t/2l7Uymsd9Mbr+d3H43uf00uf1euv02PewPr/aHye0Xn38r9kvPv94fz319cM/2n/yycbtAJXN2s0hP1t8b7JbfDNZt0jO7N+4YbDTvB5uOBn16flWA7NdYpauAnmOVrhh6jlW6uug5VlI0VumqpedYpSucnmOVroZ6jlW8cuo3VrNUfvXHu4Ex/DHWkx82bt9e0ZqnAdLZD9/6yfvwtj8OvTNcKm8zMVxKDzAxJDD8McOl9AsTw6V0ERPDpfQWE8OldBwTQ/GNNfkM7VL9OiaGqFN+zhB1ys8Zok75OUMCwx8zRJ3yc4aoU37OEHXKjxk6tXG4Pd7KNFt4zzCl3Yj8tFnG+Q+bnI5P0G9/26fvxPNX49upDVxO6Gorck7oakt4RuiktubnhK62ScAJXW1XgRO62jYEJ3QC9PHQ1TY6OKGjImWAjoqUAToqUgboqEjHQ/eoSBmgoyJlgI6KlAE6KlIG6ATo46GjImWAjoqUAToqUgboqEgZoKMiHQ89oCJlgI6KlAE6KlIG6KhIGaAToI+HjoqUAToqUgboqEgZoKMiZYCOinQ89IiKlAE6KlIG6KhIGaCjImWAToA+HjoqUgboqEgZoKMiZYCOipQBOirS8dATKlIG6KhIGaCjImWAjoqUAToB+njoqEgZoKMiZYCOipQBOipSBuioSMdDF7+v6JLQUZEyQEdFygAdFSkDdAL08dBRkTJAR0XKAB0VKQN0VKQM0FGRDodOa+2HPQt0vRVpzA/o8T30twv/01obfjMx1FsvdmM41wa26T3DGPZjYwyvQ50qXH42VNIzVFGl9N0kUYXm3SRRZdjdJI4iJe8b99ziphKjjvxuiKOnGDWevgaQJx8Ay+aUXQdgZh+AnX0AbvYB0OwD8LMPIMw+gDj7AGbPxFZUJv5tkhOVW+8micqWd5NE5b+7SaIy2t0kUTnqbhJD1rEb7Sa5aN9PGek4Nrl8HGp/XePl2JzC3h3Nfx57H2rQM9SoZ6hJz1CzmqFybL3INVSjZ6hWz1CdnqGSnqHqUUukRy2RHrVEetQSx7ZNJm5HsZVeiy2OTY1qJjl5JpE8k7w8k4I8k6I8k5I8k7I4kzg2caiZJG/2DvJm7yBv9g7yZu8gb/YO8mbvIG/2DvJm7yBv9o7yZu8ob/aO8mbvKG/2jvJm7yhv9o7yZu8ob/aO8mbvKG/2TvJm7yRv9k7yZu8kb/ZO8mbvJG/2TvJm7yRv9k7yZu8kb/bO8mbvLG/2zvJm7yxv9s7yZu8sb/bO8mbvLG/2zvJm7yxu9vabuNnbb+Jmb7+Jm739Jm729pu42dtv4mZvv4mbvf0mbvb2m7jZ22/yZm8jb/Y28mZvI2/2NvJmbyNv9jbyZm8jb/Y28mZvI2/2NvJmbytv9rbyZm8rb/a28mZvK2/2tvJmbytv9rbyZm8rb/a28mZvJ2/2dvJmbydv9nbyZm8nb/Z28mZvJ2/2dvJmbydv9nbyZm+SN3uTvNmb5M3eJG/2JnmzN8mbvUne7E3yZm+SN3uTvNnby5u95X1r6eV9a+nlfWvp5X1r6eV9a+nlfWvp5X1r6eV9a+nlfWvp5X1r6eV9a+nDSivFhP1Ys232j4PvY11pqZjaWEnRWFdaLKY21pVWi6mNdaXlYmpjFbVezN0khpzujqVmyD2tNbObxPEFbs0kI88kK88kJ88kL8+kIM+kKM+kJM8keVNlkjdVJnlTZZI3VSZ5UyXH5641k+TN3kne7J3kzd5J3uyd5M3eWd7sneXN3lne7J3lzd5Z3uyd5c3eWd7sneXN3lne7J3Fzd5hEzd7h03c7B02cbN32MTN3mETN3uHTdzsHTZxs3fYxM3eYRM3e4dN3uxt5M3eRt7sbeTN3kbe7G3kzd5G3uxt5M3eRt7sbeTN3kbe7G3lzd5W3uxt5c3eVt7sbeXN3lbe7G3lzd5W3uxt5c3eVt7s7eTN3k7e7O3kzd5O3uzt5M3eTt7s7eTN3k7e7O3kzd5O3uxN8mZvkjd7k7zZm+TN3iRv9iZ5szfJm71J3uxN8mZvkjd7e3mzt5c3e3t5s7eXN3t7ebO3lzd7e3mzt5c3e3t5s7eXN3sHebN3kDd7B3mzd5A3ewd5s3eQN3sHebN3kDd7B3mzt7wPG4O8DxuDvA8bg7wPG4O8DxtDlDd7y/vWMsj71jLI+9YycHxrGU3cTUrJPJv0evC3PsE/hprzn8feh5rVDJXj21CuoZqFhvp+DYnA8TEr21idorGSorF6RWMNisbKoG3yth9M2VbGGoP7OjbGcBxK4cv6NLX1eWbrOT6FLlt/N8nIM8nKM8nJM4nkmeTlmTQ+L3lr9znAW6qsu+ZsTvsvO0OPX/4yP85tfprb/CzcfBfyYf7Tgqjh7EYxx1DJmviXoUaGz7zZhmp4h5q3v85SkeHz8apJTp5J4zOej2EPJZ/oxCQvz6Qgz6Qoz6Qkz6QsziSGz8erJhl5Jll5Jjl5JsmbvY282dvIm70ZPh/3t37e18FhM/m9NKS8twH9k4Q3ib7MT3Obn6c2n+ET9q7mm7nNt3Ob7+Y2n+Y2389tfpBtvrf7sZ7SifnCs27NfOFZt2a+8KxbMd8Jz7o184Vn3Zr5wrNuzXzhWbdmvvCsWzNfeNb1Pj6KxRPzpWfdivnSs27FfOlZt2K+9Kz73nySnnUr5kvPuhXzpWfdivnSs27FfOlZt2L+3FmXRGXdu0miMundJFHZ8W7S+IwXtiOWApmXrRIjw9IZVZOMPJOsPJOcPJNInklenklBnklRnklJnknyZu8gb/YO8mbvIG/2DvJm7yBv9g7yZu8gb/YO8mbvIG/2DvJm7yhv9o7yZu8ob/aO8mbvKG/2jvJm7yhv9o7yZu8ob/aO8mbvJG/2TvJm7yRv9k7yZu8kb/ZO8mbvJG/2TvJm7yRv9k7yZu8sb/bO8mbvLG/2zvJm7yxv9s7yZu8sb/bO8mbvLG/2zuJm77SJm73TJm72Tpu42Ttt4mbvtImbvdMmbvZOm7jZO23iZu+0iZu90yZv9jbyZm8jb/Y28mZvI2/2NvJmbyNv9jbyZm8jb/Y28mZvI2/2tvJmbytv9rbyZm8rb/a28mZvK2/2tvJmbytv9rbyZm8rb/Z28mZvJ2/2dvJmbydv9nbyZm8nb/Z28mZvJ2/2dvJmbydv9iZ5szfJm71J3uxN8mZvkjd7k7zZm+TN3iRv9iZ5s7e8by2TvG8tk7xvLZO8by2TvG8tk7xvLZO8by2TvG8tk7xvLZO8by2TvG8tk7xvLZO8by2TvG8tk7xvLZO8by2TvG8tk7xvLZO8by2TvG8tk7xvLRPHt5be7b8dfHCvJjHM3mQPSsH6Z5NeD+63l23i+IaTa6hOz1BJz1C9nqEGPUONeoaa9Aw1qxkqxzfIXEPVo5aSHrWU9Kgljm+8uYaqRy0lPWopraSWwn6s2TZ7MtaV5FJtrCvppcpY80qCqTbWlRRTbawrSabaWEVpprtJJM8kURrkbpIorXA3SVROv5skKvXeTRKVIX+ZlDdRiexukqh8czdJVFq4myRu9s6buNk7b+Jm77yJm73zJm72zpu42Ttv8mZvI2/2NvJmbyNv9jbyZm8jb/Y28mZvI2/25vi2P9D2dXD0Tz2+05qVTPo69jaQhxUp3M3n+MK9bP7dpPF3Z8wx75X9tsX3RH/taPB18K9FxI+D/Y6UJrffT25/mNz+OLn9aXL789z2MywO0Nd+I93+vBvya+WqV/vt5PaLz78V+4XnX2e3/WBnnzTZYb/w/Fu1X3j+rdovPP9W7Reef2/2b+/sJ+HzvyOz7w/r6Ne1/2q/8Pm/ar/w+b9qv/T5v2a/9Pnf5XTYb/6w/6z94PabnQy9JmuSniy+N9hjZj4frPTMQu7ILPRkR5tnpaeh7w224lnhNaOjGI7B5vRivxdeM1btF68ZKvaL1wwV+8Vrhof9/ul1rMN+mtx+6ZqhZr90GVCzX3pmd8dTLOdNfJ/sTEh7ZjeRHoM1t7/vo5We7WI6FHbM7mc6JkhPjd8b7HsdE6Tn0UjHYP/S+zuJ4y273eqbk1/jOEjPusnS8csnWTdIz7o1+6Vn3Zr90rNuzX7pWbdmv/SsW7Nfeolcs1+6DqjYz7F2S8d3d6Kod3e+b76b23ya23w/t/lhbvPj3Oanuc2f+51NjvVCvmX+cSz5P80/G2p+jPWpMbEPVXqG7jhU6dm841ClZ/6OQyU9Q5WuKDoOVbr66DhU6Uql41Clq5qOQ5WugPoNNetRS1mPWsp61FLWo5Y4ViDhGqoetZT1qKWsRy1lPWopa1FLbtu0qKXbULWopdtQtail21C1qKXbUEn4UN1hfaDKUCvvnN0GK10vdR2sdMXUdbDSNVPXwUpXTV0HK1039Ryska6cug5WunbqOljp6qnrYKXrp28MNm52f2s/Urbvf9jkuL8ib014GqCnLzIEMgUyC2mzN2TuY11ImlXHOq0y+22+7ZORw7Z/ReCiTe/Nt4Yet4p/Iuq+TDIMJgX3uHvzq0lWnklOnkkkzyQvz6Qw3iR7zGHWOno26eRgcsfB9PL5083+OLn9aXL789z2u21y+83k9tvJ7XeT20/S7bfpYX94td9Pbr/4/FuxX3r+9X7//Ng+bwbe8GH5bbDSk/X3Bvvuw/LbYKVndm8OZeujeT/YtO0/nCi/ttBIugroOVbpiqHnWKWri55jla5Eeo6VFI1VfIb9zlj93lhMMfwx1rPWhXvqzD1+mM5+2D6WVNn+OPTOUHzinoDhUnqAh6FfSmcwMVxKvzAxXEoXMTFcSm8xMSQw/DFD6R2wGRhK78LNwBB1ys8Zok75McOgtk7ZHrvsmC28Z5jSbkQ2tvLDJidzsMvJPo63+atJEdUWNpzQ1VZCnNDVlk6c0NXWWpzQCdDHQ1dbzXFCV1v+cUJXWy9yQldbYHJCR0U6HnpCRcoAHRUpA3RUpAzQUZEyQCdAHw8dFSkDdFSkDNBRkTJAR0XKAB0V6XjoGRUpA3RUpAzQUZEyQEdFygCdAH08dFSkDNBRkTJAR0XKAB0VKQN0VKTDoZsNFSkDdFSkDNBRkTJAR0XKAJ0AfTx0VKQM0FGRMkBHRcoAHRUpA3RUpOOhG1SkDNBRkTJAR0XKAB0VKQN0AvTx0FGRMkBHRcoAHRUpA3RUpAzQUZGOh25RkTJAR0XKAB0VKQN0VKQM0AnQx0NHRcoAHRUpA3RUpAzQUZEyQEdFOh66+C1Ll4SOipQBOipSBuioSBmgE6CPh46KlAE6KlIG6KhIGaCjImWAjop0PPS1ts+eBToqUgboqEgZoKMiZYBOgD4eOipSBuioSBmgoyJlgI6KlAE6KtLx0D0qUgboqEgZoKMiZYCOipQBOgH6eOioSBmgoyJlgI6KlAE6KlIG6KhIx0MPqEgZoKMiZYCOipQBOipSBugE6OOhoyJlgI6KlAE6KlIG6KhIGaCjIh0PPaIiZYCOipQBOipSBuioSBmgE6CPh46KlAE6KlIG6KhIGaCjImWAjop0PPSEipQBOipSBuioSBmgoyJlgE6APh46KlIG6KhIGaCjImWAjoqUAToq0vHQMypSBuioSBmgoyJlgI6KlAE6Afp46KhIGaCjImWAjoqUAToqUgboqEiHQ7cbKlIG6KhIGaCjImWAjoqUAToB+njoqEgZoKMiZYCOipQBOipSBuioSMdDN6hIGaCjImWAjoqUAToqUgboBOjjoaMiZYCOipQBOipSBuioSBmgoyIdD92iImWAjoqUAToqUgboqEgZoBOgj4eOipQBOipSBuioSBmgoyJlgI6KdDx0h4qUAToqUgboqEgZoKMiZYBOgD4eOipSBuioSBmgoyJlgI6KlAE6KtLx0AkVKQN0VKQM0FGRMkBHRcoAnQB9PHRUpAzQUZEyQEdFygAdFSkDdFSk46F7VKQM0FGRMkBHRcoAHRUpA3QC9PHQUZEyQEdFygAdFSkDdFSkDNBRkY6HHlCRMkBHRcoAHRUpA3RUpAzQCdDHQ0dFygAdFSkDdFSkDNBRkTJAR0U6HnpERcoAHRUpA3RUpAzQUZEyQCdAHw8dFSkDdFSkDNBRkTJAR0XKAB0V6XjoCRUpA3RUpAzQUZEyQEdFygCdAH08dFSkDNBRkTJAR0XKAB0VKQN0VKTjoWdUpAzQUZEyQEdFygAdFSkDdAL08dBRkTJAR0XKAB0VKQN0VKQM0FGRDofuNlSkDNBRkTJAR0XKAB0VKQN0AvTx0FGRMkBHRcoAHRUpA3RUpAzQUZGOh25QkTJAR0XKAB0VKQN0VKQM0AnQx0NHRcoAHRUpA3RUpAzQUZEyQEdFOh66RUXKAB0VKQN0VKQM0FGRMkAnQB8PHRUpA3RUpAzQUZEyQEdFygAdFel46A4VKQN0VKQM0FGRMkBHRcoAnQB9PHRUpAzQUZEyQEdFygAdFSkDdFSk46ETKlIG6KhIGaCjImWAjoqUAToB+njoqEgZoKMiZYCOipQBOipSBuioSMdD96hIGaCjImWAjoqUAToqUgboBOjjoaMiZYCOipQBOipSBuioSBmgoyIdDz2gImWAjoqUAToqUgboqEgZoBOgj4eOipQBOipSBuioSBmgoyJlgI6KdDz0iIqUAToqUgboqEgZoKMiZYBOgD4eOipSBuioSBmgoyJlgI6KlAE6KtLx0BMqUgboqEgZoKMiZYCOipQBOgH6eOioSBmgoyJlgI6KlAE6KlIG6KhIx0PPqEgZoKMiZYCOipQBOipSBugE6OOhoyJlgI6KlAE6KlIG6KhIGaCjIh0OnTZUpAzQUZEyQEdFygAdFSkDdAL08dBRkTJAR0XKAB0VKQN0VKQM0FGRjoduUJEyQEdFygAdFSkDdFSkDNAJ0MdDR0XKAB0VKQN0VKQM0FGRMkBHRToeukVFygAdFSkDdFSkDNBRkTJAJ0AfDx0VKQN0VKQM0FGRMkBHRcoAHRXpeOgOFSkDdL0VacwP6PE9dJvMPrzNPB96Z6i3wOzHUG+92I8hgeGPGeqt5vox1FucdWNIU9Va6T3DGPZjYwyvQ52qwvnZUKeqK340VC9Kzd9NEqV17yaJko53kziUGMXdJGcqMUpm2ydZMkTPMXq3nya3309uf5Btv3NHTeycS5WDbU7HwU+/vI81KhprUjTWvNJYXcjHwSk+jfXs5j64kDXxr1xYNmiegYsRzsVSOIZK+f3BaaO94nGPQ22MJ8fmtP9uzn8ee+diweWUi3CNxcaFwOWUi3BNyMZFutbk4iJdl3Jxka5hubhI17tMXKJ0vcvFBXr3nAv07jkX6N1zLgQup1zU6t2wH2u2zZ6AUSt4a2DUKt4aGLWStwZGreatgElqRW8NjHTVS9vxUINqYMxNfOxW3576P4xO6eTocPxysE9vwaSdjHTdy0dGuvLlI0MgUyAjXf3ykZEuf/nISFczHyRD+8HheYA7maw4N4V9iCGkEzJL5SZv/EHm6bW2X2Tuo10q31RHu1QOqY52qbxQHa30Xsf3ZjQyj9H6yoxmsk3HBJhtfnkTJ0tvd3CyWUsj9GTjN+lND042a/U9+rKZV13e7Z9XA97tp8ntF6/T4tFs9S6+Pzgbt30dnJ8/DYjptI377hVsv4mXdFxgxKs/LjDipd/HwHR7k91v4jXiBBCNeDH5LYh555Ld04eepxB79jS9Ea8758AoXqLOgVG8Up4DIwFjD4xr1Q1sGNfSjJ/D+PYZm7fI1H/7+QM5b/Vm6sozD2/1Zt8qGr0ZtYpGb5asolmrv/atKbvrEwC7Vj+OEaRiLdYX5Fo9PD6QTnEfry9IJfXBfbBKVPx9sEp0+X2wtNJgb4XDPlgf4/v54PaQ47FEeXo8xjZ5+0KzlNLui2Yppd0XzVLauS+apdRwXzRL6duuaGgpxdoXzVIatC+apRRrXzR6dY09Hp1Z+2tUL2j0ZqjbPLub4f0ZGr0ZqobGK8lQ98EqyTn3wSrJIvfBLtX3CMcGZDla9/4Or7yFK335fT4wSymJnmCW6o98C0y/V47F70QwBcSlFO0zREevGWwpjVoZrPiNC7oOdinVmcL+JDJnU3lsaYM9atbgnt7Gy/4LzVIatR1NPEGzlKJtRkP2BA3pReOPzcJC8H+gObFjC3vxf/vzuZt2+iV2isc7Bim5ytHJ7jwSmT+OvbtoKXW9pouW0vlrumipKmJNFy1Vo6zpoqUqqyVdJH5jD7hI/B4jcJH47U40uMjvrJOPJy5SXNWLcdHBI/l04iKCiwS5KLgTF6Eu+oCLrHe7IdZ7e4Idtc5HsMdjiMH4E+yoXziwi993ZVHsqDNYsKN2YMGOeoAFOwE7B3YIyE+UVtnsb1yZfNYXkr8ZzZLYMwQkC3YISBbsEJAs2CEgWbATsI/HHuRvCyMEu6V9uTlnk69gdyEdPELKJ9iRUlmwI6WyYEdKZcGOlPoB7OSONY7JJXeCHW9qfwJ7PlphlFM6wY63rz+L3W/b2SSDNwdYsKPxy4IdjV8O7GvtNzUPdlSpLNhRpbJgR5XKgp2AnQM7qlQW7KhSWbCjSmXBjiqVBTuqVA7sFlUqC3ZUqSzYUaWyYEeVyoKdgJ0DO6pUFuyoUlmwo0plwY4qlQU7qlQO7GttaPhB7OZYNNUZX30Zzx3YnTt7PWmtrRVFYs8nL+OttW3jPNghIFmwQ0CyYIeAZMEOAcmBfa0tOOfBjsccLNjxmIMFO6pUFuwE7BzYUaWyYEeVyoIdVSoLdlSpLNhRpXJgX2sb7nmwo0plwY4qlQU7qlQW7ATsHNhRpbJgR5XKgh1VKgd2zXt7P2GPtoI9hn2AMT5+mMIXRejBHhQh73pQJLUUYzz2XU+bq1DMLtH+07Q9bXV39tPO52PWDdvDDhNPp+h8rBlrjXl/sDFb3N83vf2d07Mhd4fq1YFvHHpHo1erJZsPNH47QaO3D5oCHWhCeEWz1AaJZtu2/Sa5/U30Hk6Oxxg385Ro/NdkE1eabG48Ij2Gm00lcLa0D9Ja/xRlZ+nDhMd+kNFslYNvE/sxx7v0/uCU9xFmc3Jjx5XmvDU9tFIpu6aHVno2O6eHcnaPrJUqWj3kbTcjZFPR6snSjiPZYF/09FLbkcL533P+UpuiwvnfdP5KzU44/5vOX6lHC+d/0/krtZbh/G86n+B8vc5HQ0ux89ErE+z8u4vQLBPvInTLxLsIPS3pLlpqN/VFXYT+kHgXoYvD7SKz2e0wmraKnjc5HK8n5LzMS1kZZSV7HLpjQ94ba3syV6D6k+8jlH+yfJRPfIT6T76PUABK91HcUAHK9xFKQOmaIW6oAeX7CA/c5fuI4CPxPkKfQb6P0GeQ7yP0GeT7CH0G8T4yqGHl+wg17Fgf3amjKuWgjjqTgzqB+geo2+14sG7NCXXUghzUUd1xUEe9xkEdFRgHdTy7ZaBuodc/Qt2Fg3owr9ShYT5C/bGsk3vahfigDg3zCeqOjlh3iV6pQ8NwUIeG4aAODcNA3aEbz0Ed/XUO6tDrHNTRX+egTqD+AepkDzso0vuDA+1WhPAYoPNn7HJKT+OrHEzu+MSR6Kkv8evou/NRIit2Pip1xc5Hw2BZ5/ub676O9uYp5Z8fHYLbDjucOQkVdDkQKhdDBa0ZhMq1UCH0kxAqF0MFTTCEysVQQecOoXIxVNBuRKhcDBVCqCBUroUKOqoIlYuhgv4rQuViqKBbi1C5GCro1iJULoYKurUIlWuh4tGtRahcDBV0axEqF0MF3VqEysVQQbcWoXIxVAihglD5dXR0225zdDachAq6tQiVi6GCbi1C5WKooFuLULkYKujWIlS+QsX5I1R8PAkVdGsRKtdCJaBbi1C5GCro1iJULoYKurUIlddQCfYkVNBXQah8hUp6hEo++RA1oK+CULkYKuirIFQuhgr6KgiVi6GCvgpC5VqoRBTLCJV7qDxsjuTcSagQQgWhci1UIGsRKvdQSX4fYEzhLFQga9cNFTo2QvL0ZPLD+RCqep2f8EhPsfNRd6zr/HgUnT5tJ68zJzx2U+x8fPag2PkE5+t1Ph6hK3Y+Hoordj76gYqdjw7fws4P2+F8W2sGG5vD8eNu205es0voCCJYrgZLRgcRwXI5WNBxRLBcDhZ0KBEsXz7fjifYt7/PPg3I6GgiWC4HCyFYECxXgwUdUwTLHiw2PAWLq2qcSAcRG4OpHe992p/Y3/7O+SQY0cFFMIoJRnSUEYxighEdbgSjmGBEBx3BKCQY04YOPYJRTDDiCQCCUUww4gkDglFMMOIJBoJxWDBuRzCGbTsJRkIwIhgbg9G5p2CsWWPopgkPKMnYk2BENY1gHBWMPj2CMb4u1pIMqmkEo5hgRDWNYBQTjKimEYxighFv7SAY92BMh9HOWFsNLnOsm3H7m/xJcOEtHATXx4ILb9UguD4WXHhLBsH1seBCnw7B1Rpc4Sm40usX7Mmi74bg+lhwoY+G4PpYcKEvhuBqDa7H12m34KofX32WalFdIhhHBWOIT03aeBKMqEYRjGKCEdUrglFKMDpUuwhGMcGI6hjBKCYYUU0jGMUEI77ZQDCKCUZCMCIYpQQj3r9DMI4KxtrLoA7v6yEYxQQjnsAgGMUEI57AIBilBCOhz4hg/PK5sY/V4Y0/WaGA0AdEsFwOFvTpECyXg4UQLAiWq8GCPtfCwXIsq+SjP2lyEvpKip2PPo5i56Nvotj5eFNUr/M93sxU7Hx0KBU7Hx1Hxc5HB1Gx8wnO1+t8dPgUOx8dvnWdn/0O2ud0sp6RR52/rPPDlvz+y8ac3PkBdb5i56POV+x81PmKnY86X7HzCc7X63zU+Yqdjzpfr/MjSr11nW8O0MH8ZSOSu/MJztfrfOR8xc5HzlfsfLy9u7Dzj6OD/ctHG69HJ0u7zcmGx2esJn1FCl71RaRcixQ8L0SkXIqUhIoTkXItUvAkEpFyLVLw2BKRci1S8IwTkXItUgiRgki5FCnopCJSrkUK2q6IlK8BenfsnRd8ONmuLKFNi2C5HCzo1CJYLgcLmrUIlqvBktGvRbDswfIYYfDpLFjQXkGwfA0wPNZUDnE7efcwE4IFwfI1QPtIQ5HCSbCgyYJguRws6LMgWC4HC/osCJbLwYI+C4JlH2AKj2DJJ5t6ZPRZECwXgyVv6LMgWC4HC16NQ7BcDha8HYdguRws6OAiWC4HCyFYECxXgwUdXATL1wDTth3Bkow5CRZ0cBEsl4MFHVwEy+VgQQcXwbIP8Ol9lmSq2zjbx5LZt7+DqR3vfToeJ3if80kwokOMYJQSjAYdaASjmGBEhxvBKCYY0UFHMIoJRnToEYxigpEQjAhGKcGIJwwIRjHBiCcYCMZhwXg0vX3YtpNgxBMSBGNrMDr3FIw1awyl7fh9+uvv/w5Gi2oawTgqGH16BGM8eSvFoppGMIoJRkIwIhilBCOqaQSjmGDEWzsIxn2A/ulN43AWLHirBsFyNVgc3npBsFwOFryVgmC5HCzocyFYLgcL+lAIlsvBQggWBMvVYEEfB8FyOVjw1gKC5XKw4K0CBMvlYEEHF8FyOVjQwUWwXA0WQgcXwfI1wOTiESzJx5NgQQcXwXI5WNDBRbBcDhZ0cBEsl4OFECwIlqvBgqYcguVrgPnxaVDIgU6CBU05BMvVYPEonREse7CERxrKMZ8ECx4kIljuNkdrDqNvf/uTYEG7H8GyB4t3j2BJJ58ne7T7VQbLb+cHaBDFzkc7XrHz0V5f1/nWx8P5Kf7g6HuooLmOULkYKoRQQahcCxV0NBAqF0MFz2AQKhdDBU9gECp3m1N4LIRx+/vkCUxAnxTBcjlY0CdFsFwNloi+KoLlcrCgD4tguRws6NsiWC4HCzq3CJavYInGH8ES/cnmnJEQLAiWq8GC7i2C5XKwoH+LYLkcLOjgIlguBws6uAiWy8GCDi6C5WqwJHRwESyXgwUdXATL5WBBBxfBcjlY0MFFsFwOFkKwIFiuBgv6LAiWr2BJ27Ghckrm5GuhjGoIwfIVLPlpZsnuZGbJqIZ+HCx3kKgUOoGEiu4EkgDyGsjojlkyuvAKEs/PO4HEs+VOIFEPdAKJZ5KdQOJ5XQ+QtG2o3q6CDA/5E+wrSFQ2nUCisukEEpVNJ5AEkH1AorLpBBI68irI9JA/Tw3MHaRB1r4IMrnHcwCiV5DI2p1Aqsna9+Gqya334arJgPfhqunA3Yerpk92H64aFXIfrpqe0+/hWjWdoftw1SjB+3DV6LX7cHWpKku6hruWqqKH2RvF7T/eFh9heyzm/Cg9zK3WvaNZS4F1RbOWWuuKZi1l1xXNWiqwJxq3lmLsimYt/fE9NLRn7/A8wgON5gwVHi/uphM0ajLUfbhqss59uGoyye/h0lrZIdHxYGnL1r+/z41Jj722brf3g074grNW96EznLV6FZ3hrKUsOsMhwCnDWatr0hnOWqq0M5y1dGlnOGup2L5wvG6dk7YDTt7ME5zXo7M5LMnm6c2lHaTuzPYdkPZAku3zGL9A6s6CHUHqzpgdQarJrvfhqsmX9+Gu1fWpDXexXaTz43XiW5fLvQ53LX1THe5anZnqcNfqtVSHS7qGu5YSrA53Lb1WHe5aqqo63LVUVXW4a6mq2nAX20OuOlxdqmqtfbyMCY+WoEl/DPfkt23eX6Rxz4Z81cZr7VrVFw0BTQnNUsrum2hcyAeaP/rIr8eSOTCSNS8957X26uHDuJQS/RNjPslmSynR23Dt03Dz63CXUqI3645PL8ztOj+ahtfaN6MvmqUUbl80a6nh76Hpl3XW2i2ADyOti9HRSzZLqyln8zTc16dVaS2F6+lY6/smW372BctaewL0RbOWwu2KZi013BPNWvsm9EWzlhruioYUo3n/IeFaq1R/E837DwnXWnfapO3pJeOQ36OxMR6GxPjytt1aK0n3RGPWWhu6L5q1MlRXNGv1a7qiWasH0xUN6UVjYnhapD/QK5y1ujCd4azVs+kMZy1N3BmOYlVchbPWytjfhRMfnzHe/s4vcFRnq1v6fsBJ4QWOmmx1H66a/HMfrpqMch/uWjniZuox3Jzj63DX6obUhrvWGsf14a6V06vDXasTUR3uWt2F6nBJ13DXUlXV4a6lqqrDXUtVVYerS1WttWZwdbhrrQNsbzpiN9ua5+2dTtvcNpvDkO3x27+Wrb/DWUqD9YazlGLrDWcpfdcbDgHO3RB7Amcp7dgbzlJKszecpXTpN+G4o89tb4M8gbOUiu0NZynN2xnOWmuh94ajWSFX4WhWyFU4mhVyFQ4BThmOZoVchaNZIftjgUvrgzmBo1nn1OB4xdnq1qbYj3bb0/IiDziKs1UdzrzZ6m7/vAnlbv+8c/7dfumNi5gO+5M17w8OdKyxE7zJr4OV3ojoOljpCbfnYMUvn911sNIL/66DlS6Nug5WutTpOljSNFjpOqfrYKWLoq6D1aSgxC+X3XWwmhSU+KWyuw5Wk4ISv0x218FqUlDil7LuOlhNCkr8EtJdB6tJQYlf5rnrYDUpKPHLNn9nsHFLu9Vxy7nyy29XJjbiF21mA7OSMusKZiUV9z0w3ZZgNuKXYJ4C4kqqMxo6ID7vlX16MKWdoX8y4tdZL4f6uI/OP7nGfH3mJH6x6AkQrqSQmRCupLuZEK6k5nkQil/M+mMIH6/AeR+fEd65LFUidOSyVIXwHS4h7FxCtq9clioQvseFjmPDKxfSy2U3OVp65aJWxle4qNXmFS5LCW5rzDHW6N8fbCgeWx158/TGcTp7P/n9LgxG/Hr6k2BcSnhzYbTi1+mfBONSWp0P41LSng/jUsrugxjfbgpkxa/xLQXj2w2E7KY3U3tzrJPun3bI/IXxNxqjN/tW0ejNqFU0erNkFc1SPbDvTdlkHmh8Zcq+NVHTMcNnm//6jNeK36VgGpCKtVhfkEu15ThBKu7j9QU5b31wt39eYf7bfvE7MNTsly5xkzOH/XF7tV+4Dr3d7fsrCuRTZW6wt0ce+y/H9Hi6Gs3JwdkdJW92Mb4/+P17nVb61gtSKHZ7f9FK3/1hQeLCRfAHiZPZc0AmZ342UwjXG+QOQ8jRy8cgVvry9RS2Pd9RoNd8LX2dcErH3e3NdsJf+l1Ys194BVi1X3jhdev0H/bbWCm80rZPgsk9hmrj2fuf+dDBOf957J2L8HmNjYvw+oyLi/QVsNm4CM+vbFyE16lsXIRXnmxcCFxOuQjXj2xchOtSNi7Qu+dcoHfPuUDvnnLx0LvnXNTq3eN7J7Nt9gSMWsFbA6NW8dbAEMCcg1GreWtg1IreGhjpT2kqTzmkr5Ffs1/6svdV+8U/JfPHU76Q3av90t8Kqdkv/X2Mmv3CU3nVfulPKWv2S39KWbNfeNeG0vHLlHwlsYdwfCiXHi+wWeO/xio9V/ccq/S83nGs0hduf/OmwIng9NtutHlaYtX4rxtW+sLtfQcrPTtX3oGSvjx51X7p2blmv/TsfPvp3X7a0vuDzWPz1c1VytaOfVfpa5NPwVD8u5wTMJSuaEQwrLSrpK/QPgdE6RJsCojSG0dTQBSvj2eASID4c4hqv/lJ/uiw3Upfej74TkZ6DcJHRnplwUdGer3AR0Z6FcBGRvrC6oxkpOt1PjJqv+mvklH7nX6VDIFMgQw0cIkMNHCJDDRwiQw0cIkMNPA5GSd9fXNGMtDAJTLQwCUy0MAlMgQyBTLQwCUy0MAlMmo1cMeVBZ30/QsmoahWW3dcu85J3+lgEopqNfv3KHZbudJJ32thQeJ618OluO9ukf3mX1SR9D0ZGMkoXl+2QkZtjVElo7fGqJHRWzfUyCiuBd6Tkb4XAyMZxZq9Qkaxtq6QWUkD337tqGlvaN6TMdHvVYeJ4WGG/6oOltq7oS+ZlTRwXzIraeC+ZFbSwH3JrKSB+5JZSQN3JeNW0sB9yaykgb9HJuedjN2ePtXy551Rd3zXZegE40qC+ZMYt/wWo151nf1hxuZsBeMWjzb941BD9uyHU37MACmHpzV5sv2iTqDOQF1vVcBJXW/FwUldbzXDSV1vpcRJXW8Vxkhd+s5ji1JXXD0yUldcbDJSR23KQZ1AnYE6alMO6qhNOaijNuWgjtqUgzpqUwbq0ncJXJQ6alMO6qhNOaijNuWgTqDOQB21KQd11KYc1FGbclBHbcpBHbUpA3Xxe7KuSR21KQd11KYc1FGbclAnUGegjtqUgzpqUw7qqE05qKM25aCO2pSBuvi9wtekjtqUgzpqUw7qqE05qBOoM1BHbcpBHbUpB3XUphzUUZtyUEdtykA9oTbloI7alIM6alMO6qhNOagTqDNQR23KQR21KQd11KYc1FGbclBHbcpAPaM25aCO2pSDOmpTDuqoTX9G/U6RQLEDRdSOPSiiFrxE8bEM/NPvPiiitutBUW2tZs227z5ljXXPFO9k1NZTFTK0qa15qmTU1iVVMmprB2ucO8jk/EpGrb6vkiGQKZBRq8OrZNRq6yoZtXq5SkaxBq6QUayB35MxwpWeS87sv5zi9nzw3X7heqxqv3DVVLWfpNufDvuzNe8PNjE9+hHHoTbGk2PTtm8QnVyuHJvT3hvP+c9j7wyFq6ApGArXS1MwFK6sZDAM+7Fm2+wJROEibA6IwvXaFBCt8PbmHBDF6+MZIIoX6TNAlF4pZLcbQjaFCkQb0mG1eaph6dRmu/fkXUj5+eA7GQKZAhnplQUfGen1Ah8Z6VUAHxnp0p6PjHS9zkbGSRfhfGSkK2s+MtLlMh8ZaOASGQKZAhlo4BIZaOASGWjgEhlo4BIZaOACGYIGLpGBBi6RgQYukYEGLpEhrWRuhdH+8ODXhs0VjDYf74892/z1Rhip1ctdKarV1r/WL91/mWoUDcXjqZc3j8dpJqWTo8O2mxFseDr26wkZqVXtjMzV1gOMzNVWGnzMvdoahpG52uqIkTmBeX/mtB8cntEdzKFbPsA87DaHkE6YQ7dcYu6NP5g7+oP5nSO0SBeO0vdUnoYjNEMfjmr7r9/MSWQeHH0lJ5ls05HCss3xr10j6fseL0qdQJ2BuuI+MyN19KU5qCup8O6DVVJa3QerpP75PVjpm+t+b7DOPiRwiu/nA2uOG9ySCa9klio7upJZqpDoSmYpsd+VDIFMgcxSorkrmaWEbVcyS4nPrmSWUqpdySwla3uSkb6JJyMZaOASGWjgEhlo4BIZApkCGWjgEhlo4BIZaOASGWjgEhm9Gthv+9MP6582ZtnJSN8s8INkyB7LKXva3h/ccWlO6RsFLkhcr2bnIq63FuAiTiA+mLje2oWLuN6aiIu43lqLi7jeGo6LuN7akIe4l75Z44LEUXOOJo6aczRx1JyjiROI9yb+fucAL32XzRWRo+ocjhxl53DkqDuHI0fhORq5QeX5ivxOBhViiQwquRIZvWLUH2Y458L7g8mkw4rH75oUviiKSgO/TeLYbtAdKwJZV9s228aw++o2tT+WD/raCdtz7PTX1X47uf1ucvtpcvv95PaHye2Pk9ufpNufd0Nsespfh/15bvud+PxbsV94/nV2y/sv2ydNdtgvPP9W7Reef6v2C8+/VfuF59+b/dtb+4XP/47Msckz2e3VfuHzf81+Ej7/V+2XPv/X7Jc+/7vHhhVk/rD/rP3g9pudDL0ma5KeLL432GNmPh+s9MxC7sgs9GRHm2elp6HvDbbiWeE1o6NjzTpHOb3aL7xmrNovXjNU7BevGd7b78Vrhof9/unZ3GG/eM1QsV+6ZqjZL10G1OyXntmdPR4ZeRPfJzsT0p7ZTaTHYM3t7/topWe7mA6FHbP7mY7x0lPj9wb7Xsd46Xk0Hsvpur/0/k7ieMu7Gebm5JM4lp51k6VjtCdZN0jPujX7pWfdmv3Ss27NfulZt2a/9Kxbs196iVyzX7oOqNmv97XTjq8QrbVyORdFxUui96So90XSb1Gko+Txf1I8I54fyM1fd6Twipdl5yKu91NDLuIE4oOJ4+Xu0cT1fmjIRVzvd4ZcxFHvjSaO2nAwccXbCnARR805mjhqztHEUXOOJk4gPpg4as7RxFFzjiaOmnM0cdSco4mj5hxMXPE2HlzEUXOOJo6aczRx1JyjiROIDyaOmvMScXdADFQh/uaH78hRdA5HjqpzOHKUnd2Rp7xb4Www73/Y5HjAME8HG787CFWqaAcFxfuEMDjojhxV7XDkKGt/hvxOcSkZb0M6rDapBub4MJqIcmXOpePjHeONe+KYTo4OtB8cntGl+MV8KR0vhXncb6Dw9HHVg/lSQl4Mc3MwDyfMl1LykzBfSpzPwXyt3REmYb6U4J6E+VKKexLmSz1KmoQ5gXl/5mG3OYR0whx16HjmqEPHM0cdOp456tDxzFGHDmduUYeOZ446dDxz1KHjmaMOHc+cwHw4c9Sh45lL1+cxHUtoJ2veHxztsUdKtLGyzGPXx8pWuuSWgvH9k2InXUWLwfi2ieqkC+NJMErXupNglC5fJ8FIwNgDo3SROQlG6c8vJsEo/ZGEFIzvqxiHKqYLRlQxPTASqpguGFHFdMGIKqYLRlQxXTASMPbAiCqmC0ZUMV0woorpghFVTA+MXrpufN4V1sUKGWvsYbY1/ump4xka69P+1PH25+NBosnmC450NcgKR7rGY4VDgFOGI12PscKRrrJY4UjXTp+EE92xLWek7QSOdEXECkd6t5YTTpDeg2WFo1khV+FoVshVOJoVchUOAU4ZjmadE/LeC7n96V7hiN/G+ZNwUsq7IXnzJ3AUZyu32WO5sc2elA/iN1JmhaM4W9XhKM5Wbov2gJP+nJC/d/QdpeLuT2+UintF30MZkj8+SUnxQeRrcUnx+wRPA1JxD6ovSMX9qm+CvOngHWS2f93+IYjfrHcakKori54gVVchPUGqrlh6giSA7AMStU0nkKhsOoFEZdMJJCqbTiBR2fQBKX5LWEEgHwuSZP8KEpVNJ5CobDqBRGXTCSQBZB+QqGw6gURlcwryDgdvaf42JBK9wInid0tkhYO3NN/AwVuab+CofkvTPuC46vsI9tho3T2bHb5AEkD2Aan5+6iuIDV/S/U9kC7kA2R6Fq2vx5I5oJM18QW66m+0uKCr/vaLC7rqaoUJuvg9LJeErrq64oKuumrjgo5q8BT6HQ5phhMOQ2JMJ3BUV23p+GYv5nwCR3Ul9hQ5p3BUV0w1OKormwoc8Zu6ffRTWL+/HXP78wyOZv1UhaNZ51ThEOCU4WjWOVU4mnVOFY5mnZPIvoUjfjcvxlUtovg9uljhqNY5NTiqdU4NjupUXoOzVOFp0mHH7e+Q38MxMfrj8Nvfj8O/2qTiN7/5LJyYHnCedqr6giN+SxtWOEul8t5wlkrlveEslcp7wyHAKcNZSuf0hrNUy6I3nKVaFr3h6FbIFThQyGU4Hgr5DRwo5DdwaCk4no7RmmC393DC48PC5xF+beUU19pW5Zto4rFSQvInaNbSON9E825T7bjWlip90aylb7qiWUvd9ESz1mYqfdGspWy6olmr89cVzVp9v++hebt7Z1xrE5W+aDSr4QoazWq4gkazGq6g0ayGK2g0q+H3aNbarKkvGs1quIJGsxquoIEaLqIhoCmhgRouollK12yJ9k642bL179Hcnsik7SCZt+dtaF6PzuawJJv08un0WlvWMIJca8uaj4K0Zv/tbO0ryKUUFifIpfQYJ8il1BsnSALIqyCdOUC6lzf519qyhhPkUl1VTpBL9WA5QaKy6QQSlU0fkGttWcMJEpXNZZAHkpuOTC8gUdl0AonKphNIAsg+IFHZdAKJyqYTSFQ2nUCisukEEpVNF5Bprc2ZOEGisukEEpVNJ5CobDqBJIDsA3ItHUkPszeKP/oINq21Ec430bz9CDattV3Nd9G8+8QorbWpTF80a+mxrmjWUlhd0aylmbqiIaApoVmrY9sVzVo92O+hefsCd1pr+5S+aDSr4QoazWr4PRqrWQ1X0GhWwxU0mtVwBY1mNVxBQ0BTQqNZDVfQQA0X0UANl9CstcXOtkU60PzeF/cdGrulfZDWPu+N4c9+O6bj0UZ8+j7xdvAd5Foq6IMgb+3T/aeTza8g19JMjCDXUliMIAkg+4BcS70xglxL6zGCXEsZMoJcq6v6SR2Zj3Va0pZeQa7Vg+UDudaOY5wgUdl0AonKphNIVDadQBJA9gGJyqYTSFQ2nUCisukEEpVNJ5CobPqAXGunOE6QqGw6gURlc7WNFo6d//7Y+G8HicrmKsjD6tuz7O0VJAFkH5CobDqBRGXTCSQqm04gUdl0AonKpg/ItfaJ/ChIlw+QRK8gUdl0AonKphNIVDadQBJA9gGJyqYTSFQ2nUCisukEEpVNJ5CobPqAXGvPT06QqGw6gSSAvAbysQyJiWarHEz2sIMivT840OPbvMcAnT9jl1N6Gl/l4GD9DjrYVPvpX8vwPUIlPQ3x1/H3YIFWRrDswfJY4zHdHlieBAvqAQTL5WBBzYNguRwsqOsQLJeDBbUrguVqsCy2vzSC5aPBgh4EguVysOAJMoLlLFiCPQkWPCVHsBzBQo9gib7263k7FkvO5vHr5gx1ssdvJ/sUh7eD72FICEOEIX8YouuMMBQQhuhnIwwFhCE65QhDAWGIHjzCUEAYoruPMOQPw4znBghDAWGIJxIIw68wzPaxUmu24T9emsyZECwIlq85Kz/e/MzbyZufGVUngmWfWczj8VV25iVYbgGEYEGwXJtZbvIHwYJgOdEs7ixY8BYFguVysOAtCgTL5WAhBAuC5Wqw4I0EBMseLO7R7stPH9g+ggXvDSBYLgcL+iwIlsvBgmfwCJbLwYIn5QiWq8Fi0MFFsFwOFnRwESyXgwUdXATLHiy1B4kGHVwEy+VgIQQLguVqsKCDi2C5HCzo4CJYLgcLOrgIlsvBgg4uguVysKCDi2C5GiwWHVwEy+VgQQcXwXI5WNDBRbBcDhZ0cBEsl4OFECwIlqvBgj7LusFijqNvcbPVgiVad/x4tOROggV9FgTL5WBBnwXBsgdLcI9gifk1WBz6LAiWr2BxWzhG6Kw9CRb0WRAsl4MFfRYEy+VgQZ8FwXI5WAjBgmC5Gix4Uw7BcjlY8KYcguVysKCDi2DZg4WegsX7k2BBBxfBcjlY0MFFsFwNFkIHF8FyOVjQwUWw7MHinoMlnAQLOrgIlsvBgg4uguVysBCCBcFyNVjQwUWwXA4WdHARLJeDBR1cBMvlYEEHF8GyB0vaHsGSTl6rJHRwESxXg8Wjg4tguRws6OAiWC4HCzq4CJY9WOJTsOSTXUE8OrgIlsvBQggWBMvVYEEHF8FyOVjQwUWwXA4WdHARLJeDBR1cBMvlYEEHF8HyFSxkDqMj2ZMlNwI6uAiWy8GCDi6C5XKwoIOLYLkcLOjgIlj2YNmeg+VkJ7NACBYEy9VgQQcXwXI5WNDBRbBcDhZ0cBEsl4MFHVwEy+VgQQcXwXI1WCI6uAiWr2Cx6bFoMjlfO56cOY6n05WiIjq+CK7W4HL+EVzeVI9P/jCeUkwnwYiOMoKxNRj9Y5AunHSgIzrQCK4eM91pcBGCC8H1qeBChxvB9bHgQkccwfWx4EIHHcHVGlyHa25/Z9uhukSHHsHYGoz5MdPdGrYnwYWOPoKrw0x3GlwJTwAQXB8LLjwBQHB9LLjQ0UdwfSy40NFHcDUGF5n4CC7nfl5dJkIwIhgbg9E9zXTkT4ILTwAQXD1mutPgwhMABNfHggtPABBcHwsudPQRXB8LLnT0EVx7cPlHcNl0siRPRocewXI5WNBxR7BcDhZ00BEsl4MFHXEEy+VgIQQLguVqsKADjWC5HCzoKCNYLgcLOsQIlsvBgo4vguVysKCDi2C5Fix+29DBRbBcDhZ0cBEsl4OFECwIlvsAczieOocc80mwoM+CYNmDJT82gtk2exIs6LMgWC4HC/osCJbLwYI+C4LlcrCgz4JguRosBn0WBMvlYEGfBcFyOVjwphyC5XKw4E05BMvlYCEEC4LlarCgg4tguRws6OAiWC4HCzq4CJarwWLRZ1k2WPzNdV9He5OocnSksP/27c+TZ84WXRaEysVQQY8FoXIxVNBhQajcQyWYffXsGGw8CRVCqCBUroUKuisIlYuhgt4KQuViqKCzglC5GCp4Mw6hcjFU8F4cQuVaqDh0axEqF0MFfRWEyj1UfNptjj6fPANyqIAQKvdQiXn3YUzOnIQKKiCEysVQQQWEULmHSvLmCJXX/X9voYIKCKFyLVQIFRBC5WKo4H0VhMrFUMH7KgiVi6GCvgpC5WKoEEIFoXItVPC+CkLlYqigW4tQuRgq6NYiVC6GCrq1CJWLoYJuLULlWqh4dGsRKhdDBX0VhMo9VJ5fbTp7suwJoYJQuRYq6KsgVC6GCvoqCJWLoYK+CkLlK1TC8RZciOk1VAKeLCNUvkIl726J0fiTUEEFhFC5GCqEUEGoXAsVVEAIlYuhggoIoXIxVFABIVQuhgqeLCNUroVKxBv7CJV7qMRju9Tbn3QSKuirIFS+QuXpQ1TjKkcbSv4whdJZyy6iD4PQuodWMuEIrbMHAZEQKgiVl1noNFTQh0GoXAwV9GEQKhdDBX0YhMrFUEEfBqFyMVTwhj9C5VqoJPRhPhEq1u1WGxvM88F36mhRfIK6Mw98jl6pE6gzUEfhzEEdNSgHdZRzHNRRGXFQR5HBQD3ji9yP6PX4wLflV+p4sYGDOmpTDuqoTTmoE6gzUEdtykEdtSkHddSmHNRRm3JQR206nvrNTlBnoI7alIM6alMO6ivp9eyP9wmyj7HC3JJ7MH+8JW/y6Qht3l8pcM9Ghy+MKwlwRowrKepPYnQhHxhTfML4eiyZAzlZE1+QrySnJ0G+kpaeA7lZSUhPgnwlFT0J8pUk9CTIV3q2MwlyUovckT/MiFsFuY/7AH1+FH4mfVHUW/j1pKi37utJUW/Z15Oi3kquJ0W9xRmlva9oKacKxZC3/eiQn5K0OfvpZGm3I9lgX6BbveUZI3S9BRojdL0lGiN0vUUaI3QC9PHQ9VZ1jND1FoGM0PXqdG+Pxpu3/g/ov9E4vRrD03ag8dsJGr3zoz+2m7M+pBM0emexKhq9/akqGr1NpyoaxRmqgob09nuqaPR2ZapooGtOdE2DCiK9/ZDOIAkgr4AMye8/HVJ88Ph6ok+KVXlPjIoVfE+MitX+tzDmzR/tHPvymg4prgx6YlRcRXTE6BVXHD0xKq5OemJEJdMFI+qYLhgJGHtgRBXTBSOqmC4YUcV0wYgq5iLG43F9uP32C0ZUMT0wBlQxXTCiiumCEVVMF4yoYrpgJGAsPKZaam/ybPL+JWl2MbxH82tbmX2I/mkrVJPOjg6PAHumkeIXxqW04AcxxkNRJ3+CcSkt+EmMx9uyKbxijEtpQT6MS2lBPoxLaUE+jEtpQT6MBIw9MC7V0ebDuFRH+4MYw2OHx3SCEVVMF4yoYrpgRBXTA2NCFdMFI6qYLhhRxXTBiCqmC0YCxh4YUcV0wYgqpgtGVDE9MMrftXM7Fronyu8P7vqUSv7Omp8j8/7Bk/zdLz9I5m2HSv4OlWxkCGQKZMTLKjYy4pUSGxnx4oeNjPiuLBsZ8Y3Wz5F5q4Gt/N0B2cgo1sAVMoo1cIWMYg1cIUMgUyCjWANXyCjWwBUyijVwhYxiDVwhAw1cICN/Yz8uMoU9NeJuzk3wHCfZX5+YvBybtmMFZpcrx+a0PzXI+c9j78YYScZYScY4ScaQJGO8JGOCJGOiJGOSJGOyIGOcpBnYSZqB3dgZOBxZddvsiTVOlDUkyhovypogypooyZrCmtp0vKFhvH+c5sOpOftdm56kqiH7dQXz8SvYj1/BffwK9PEr+I9fIfz8Cn5/FyM9vRj06wonFdWW91LmVtA9jqbTH057qZaNrf2wy/s4b/fH45UQ5+hroFHLQJOWgWYlA/X1+T7+MdD7WabpLNt0Vvj0POXjx6+QPn6F/OkrhI8rg/BxZRCskts6OC0DJS0D9VoGGlqyRIhNZ6WWs85Xqbj92tdJ/mkBSPs1qvMlGSrnUMM5vuGc0HBObDgnNZyTv3/O+deglXNMwzkNcXD+UZsP+9JbPpjXc6jhHN9wznkc5ONDgaeb+zgnNpyTGs7J3z/n/OuOyjmm4RzbcI5rOIcazvEN5zTEQW6Ig/z9OHDn78rYaPYZ+zbTutezznNKCHveMiGZ17Ni01mp6azcclbhuXU8Pr4yMfvXs0zTWbbpLNd0FjWd5ZvOCk1nxaazUtNZueUs2xQbtik2bFNs2KbYsE2xYZtio/C89qZy97OyPTkrtpxVeCqxHTPbTYan17Ni01nncWjcMdsY/zrbFLYirZxVeKJQO8s0nXUehyb446z0SqPUCd92sXT78+Raoems2HRWajrr3F+Pjb/N8zqv+1mFjmDtLNN0lm06yzWdRU1n+aazQtNZsems1HRWU2wUeoC3Ivk4K79qtkJfr3aWbTrLNZ1FTWf5prNC01mx6azCG5+PTOTc67xRWhO2cpZpOss2neWazqKms3zTWaHprNh0Vmo6qyk2UlNslBaWOl6BNbep5fUs23SWazqLms7yTWeFprNi01lNyiHllrMKq2nUzjINZ1GhNv/Wq8+3I45O3dPDoq9Xn6lQyHe9RP74JQotgq6XMF0vQdvJJeznL+E+fwn6/CX8zy8Rjo8Ngg0nlwifv0T8/CXS5y+RP34Ju33+Eubzl7Cfv4T7/CXo85f4/N1tP39328/f3fbzd7f9/N3tPn93u8/f3a7HffF2tTJyPSLq7YdwVGiZenO0Fm8Ntz8ucT8tN51WaJpWTzNtpxXmXzKP03wF362nnejR385/3VmLSu9M970IjbiIH3GRMOIiccRF0oiL5AEX8fbjM5nvoVPeLmBInj5/Cf/5S4TPX6JHVnm7LBX59PlL5I9fImyfv4T5/CXs5y/hPn8J+rgUCv7zlwifv8TnNWNIn79E/vgl4vb5S5jPX8J+/hLu85f4/N0dP393x8/f3YXnVFs8Tvv1d/6rwis8qNpiPiqoLZnwcpptO821nUZtp507dkuPd2q29PTQfz8ttJ0W205LTacVHiJt2R/6f8tPrzzvpxVI5nQ8fDLb9kKysGhx9bTQdlpqG1tuOc0XlgPdcnZPRvqX00zbabbtNNd22rm7b4fmx2n22QGv886tq793u26t8fhyCf/5S4TPXyJ+/hLp85fIH79E4elq10uYllnDG9t2mms7jdpO822nhbbTYttpqe203HSa3dpOa4sS2xYlti1KbFuUlNaGisdZMT1tMXO2NJ+Nx0p+Nlr7coX86SuUVnHqeAXz8SvYj1/BffwK9PEr+I9fIXz8CvHjV/j4Pe0+fk/Tx+9p+vg9TR+/p+nj9zR9/J6mj9/T9PF7mj5+T9N37+n7WbnlLL81nWWazrJNZ7mms6jpLN90Vmg6Kzad1RQbvik2QlNshKbYCE2xEZpiIzTFRmiKjdAUG6EpNkJTbISm2IhNsRGbYiM2xUZsio3YFBuxKTZiU2zEptiITbERm2IjNcVGaoqN1BQbqSk2UlNspKbYSE2xkZpiIzXFRmqKjdwUG7kpNnJTbOSm2MhNsZGbYiM3xUZuio3cFBu5JTbCtjWdZZrOsk1nuaazqOks33RWaDorNp2Vms5qig3TFBumKTZMU2yYptgwTbFhmmLDNMWGaYoN0xQbpik2bFNs2KbYsE2xYZtiwzbFhm2KDdsUG7YpNmxTbNim2HBNseGaYsM1xYZrig3XFBuuKTZcU2y4pthwTbHhmmKDmmKDmmKDmmKDmmKDmmKDmmKDmmKDmmKjqS8amvqioakvGpr6oqGpLxqa+qKhqS8amvqioakvGpr6oqGpLxqa+qKhqS8amvqioakvGpr6oqGpLxqa+qKhqS8amvqioakvGpr6oqGpLxqa+qKhqS8amvqioakvGpr6oqGpLxqa+qKhqS8amvqioakvGpr6oqGpLxqa+qKhqS8amvqioakvGpr6oqGpLxqa+qKhqS8amvqioakvGpr6oqGpLxqa+qKhqS8amvqioakvGpr6orGpLxqb+qKxqS8am/qisakvGpv6orGpLxqb+qKxqS8am/qisakvGpv6orGpLxqb+qKxqS8am/qisakvGpv6orGpLxqb+qKxqS8am/qisakvGpv6orGpLxqb+qKxqS8am/qisakvGpv6orGpLxqb+qKxqS8am/qisakvGgt90fxY/Tv79HpWITaOjRfstuXns8722eq1i28s9VuZrEmirMmSrCn1nZmsMaKssaKscaKsIVHWeFHWiJqLSdRcTKLmYhI1F3tRc7EXNRd7UXOxFzUX+8Fz8fvt5qP3sswJssyJssxJsszJoswJ352R72eZprNs01mu6SxqOss3nRWazopNZ6Wms3LLWbEpNmJTbJw/XbVPi0ykp0/sT28Lcsex4Xm52LPVK+yj2eCMNe9/OGy0Hxy29PTTxn4Z7wQb74/9k4N/2ozxYTzNbLyf2fgws/FxZuPTzMbniY0/fytjFuPNzMZLzrBV42fOsGnmDJtmzrBp5gybZs6waeYMm2bOsHnmDJtnzrB55gybZ86weeYMm2fOsHnmDJtnzrB55gybJ86waZs4w6Zt4gybtokzbNomzrC3R04zGz9xhk3bxBk2bRNn2LRNnGHTNnOGNTNnWDNzhjUzZ1gzc4Y1M2dYM3OGNTNnWDNzhjUzZ1gzc4a1M2dYO3OGtTNnWDtzhrUzZ1g7c4a1M2dYO3OGtTNnWDtzhnUzZ1g3c4Z1M2dYN3OGdTNnWDdzhnUzZ1g3c4Z1M2dYN3OGpZkzLM2cYWnmDEszZ1iaOcPSzBmWZs6wNHOGpZkzLM2cYf3MGdbPnGH9zBnWz5xh/cwZ1s+cYf3MGdbPnGH9zBnWz5xhw8wZNsycYcPMGTbMnGHDzBk2zJxhw8wZNsycYcPMGTbMnGHjzBk2zpxhRa/pVDV+5gw785pOaeY1ndLMazqlmdd0SjOv6ZRmXtMpzbymU5p5Tac085pOaeY1ndLMazqlmdd0SjOv6ZRmXtMpzbymU5p5Tac085pOaeY1ndLMazqlmdd0SjOv6ZRmXtMpzbymU5p5Tac085pOaeY1nfLMazrlmdd0yjOv6ZRnXtMpbxNn2Dzzmk555jWd8sxrOuWZ13TKM6/plGde0ynPvKZTnnlNpzzzmk555jWd8sxrOuWZ13TKM6/plGde0ynPvKZTnnlNpzzzmk555jWd8sxrOuWZ13TKM6/plGde0ynPvKZTnnlNpzzzmk555jWd8sxrOuWZ13TKM6/plGde0ynPvKZTnnlNpzzzmk555jWd8sxrOuWZ13TKM6/plGde0ynPvKZTnnlNpzzzmk555jWd8sxrOuWZ13TKM6/plGde0ynPvKZTnnlNpzzzmk555jWd8sxrOuWZ13TKM6/plGde0ynPvKZTnnlNpzzzmk555jWd8sxrOuWZ13TKM6/plGde0ynPvKZTnnlNpzzzmk555jWd8sxrOuWZ13TKM6/plEWv6RQT7cYnl/8w/uxocxwcnsyIXwOVnI27DlRy5u46UMlZvutAJSuCjfaDw5boZIKRrAi2LXwdHFOIFS/54NzX0b+Wh34cbc+OTibuhiSTH79tY7qDEb2+FSsYyUqGFYxklcQKRrICYwVDAHMORrIaZAUjWT2yghGjNu/miNGEd3PEqLzf5shZ2exujhhFczdHjI64myMme9/NEZMz7+aIyVR3c8Tkh7s5smZlOStt3c2RNCvfsrekWflmjqRZ+WaOpFn5Zo6kWflmjqRZ+WaOpFn5ly6WZY6kWflmjqRZ+WaOrFlZzgpKd3NkzcpyVjm6myNrVpazEtHdHFmzspzVgu7myJqV5azoczdH1qwsZ9WduzmyZmU5K+PczZE1K8tZveZujqxZWc4KM3dzZM3KclaBuZsja1aWs1LL3RxZs7Kc1VTu5sialeWseHI3R9asLGdVkrs5smZlOSuH3M2RNSvLWd3jbo6sWVnOChx3c2TNynJWybibI2tWlrOSxd0cWbOynNUm7ubImpXlrAhxN0fWrCxn1Ya7ObJmZTkrK9zNkTUry1n94G6OrFlZzgoFd3NkzcpyVhG4myNrVpbzpf/dHFmzspyv8e/myJqV5XwxfzdH1qws56v2uzmyZmU5X57fzZE1K8v5OvxujqxZWc4X3HdzZM3Kcr6Gvpsja1aW82Xx3RxZs7KcL3Tv5sialeV8jXo3R9asLOfLy7s5smZlOV8Z3s2RNSuL+rbvZo6sWVnUt303c2TNyqK+7buZI2tWFvVt380cWbOyqG/7bubImpVFfdt3M0fUrGxkfdtnZH3bZ2R922dkfdtnNlGzspH1bZ+R9W2fkfVtn5Hzbd/rwR0XgbsNVPI6aj0HKud7xBPTHyvQhERbZaAUczhsduk42uazo00w8etoE9zDbOfcF5g51kVjADPHumgMYDpMjuY41sY/wPy+wre/C7ufZZvOck1nUdNZvums0HRWbDorNZ2VW8769mcv97OaYsM1xYZrig3XFBuuKTZcU2y4pthwTbHhmmKDmmKDmmKDmmKDmmKDmmKDmmKDmmKDmmKDmmKDmmLDN8WGb4oN3xQbvik2fFNs+KbY8E2x4ZtiwzfFhm+KjdAUG6EpNkJTbISm2AhNsRGaYiM0xUZoio3QFBuhKTZiU2zEptiITbERm2IjNsVGbIqN2BQbsSk2YlNsxKbYSE2xkZpiIzXFRmqKjdQUG6kpNlJTbKSm2EhNsZGaYuP80TCltC8ETNnQ61nm/CzzOOvXksHvquS07f2v5/aXjfHk2Jz2Ej/nP4+9W2NFWeNEWUOirPGirAmirImirEmirMmCrLHbJsoaSXOx3STNxXaTNBfbTdJcbLfBc3HYjzXbZk/MCbLMibLMSbLMyaLMMZssc75bl3z3GZLtsWpn5Qrh41eIH79C+vgV8qev0GNRy8oVOjwjp20/1v95hTNrHj98i4Hj6N0aK8oaJ8oaEmWNF2VNEGVNFGXN2Be+aulx8AKVNXMGL1BZNcfIMsfKMsfJMoeGmmN92A+24ek+P/3hW7Ntr/9u9pgn49OX8X5m48PMxseZjU8zG58nNn70op19jTczG29nNt7NbLzkDJvy3mC6dZr/NP6kw/R+u9TbUCXn485DlZy9Ow9Vcq7vPFTJyqDzUCXriL5D9ZJVR+ehStYo3xxq8PtQb09rToYqWdF0Hqpk/dN5qKRnqAuppdpQF1JLtaEupJZqQ11ILdWGupBaqgw1LKSWakPVo5bCOmrJmsdQva0cHTPtR8ecXeVod/RyyD4+27Z0NkKT9ycr1hr7fPAd+DqabRLgBOBjga+jXycBvo6KngT4Olp+EuDrVBSTAF+nrpkDeFynupoE+Do13iTAUWkOBo5KczBwAvCxwFFpDgaOSnMwcFSag4Gj0hwMHJXmWOAJleZg4Kg0BwNHpTkYOCrNwcAJwMcCR6U5GDgqzcHAUWkOBo5KczBwVJpjgWfo8M7ArXsAJ/8KHCqlM/B47O5ze5zmXoFDpQwGDpUyGDhUymDgUClDgbsN/fDBwNEPHwwcOnwwcPTDBwMnAB8LXMy22CdQ3FElx/i8wujpLqsmbjtCE8PTdsXu1D3HwSm6yrHW2f1gS/TTJTycnK2/9SAXs725HuSCt3BfFbngzeQXRS55W/tVkRsgH43cLoM82GO57BhDBeOtpWR2Q7YUBkN3gD4eOgH6eOhaa9BjB1OzbVXmjwWAbk+P44+Zay1COZlrrUI5mWstQzmZa61DGZlbrYUoJ3OtlSgnc62lqIm71TcGcTB0raUoK3QC9OHQneBID97vQw3+aSOaX9DvxguOmLrxgpsAdeMFV9N14wWXpXXjBdd3deMFF0pV40lwxVE3XrB0rxsvWAPXjZ85w47e6q2v8TNnWJo5w9LMGZZmzrA0c4b1M2dYP3OG9TNnWD9zhh29PVhf42fOsH7mDOtnzrB+5gzrJWfY2+OJ3fhsT4wPkjNs1XjJGbZqvOQMWzVecoatGi85w1aNl5xhq8ZLzrBV4yVn2KrxkjNs1XjJr9P4vH0dHIOnP4w/ebTn7P7LT4ve7OOMkl9h6TlOya+N9Byn5Fc1eo5T8tsRPcdJSsYp+XX0nuOU/Ap4z3Eqfe3ab/trep62P469Y1H6ZnQNi9KXlytYktL3i2tYlL4CXMOyzlu6XbGs8x5tVywELGdYlH4WWcOi9MvFGhatKjfsP+1zqhxL1u8MyaanITp/h5iV5q3vrS3xeOP+VlsdRx/v0GelWa4vRKU5sS9ELG7XASKWq+sAEQvQdYCIJeU6QMQicT+GSBuWfesAEQu5dV/ILTzWHN7yCXLUN8ORoxoajpyAfDRyVFrDkaMuG44cVdxw5Kj5hiNHhTgaOZYRH48c1edw5Kg+eyOfYv9gWmgpczj+W44nOF6n49EPUOp4dCWUOh69EaWOR4dGqePRJ9LpeLV7Dah3PHpmSh2Pzp1Sx6Nzp9TxBMfrdDw6d0odj86dUsejc6fU8ejcKXU8Onc6He/QuVPqeHTulDoenTuljkfnTqnjCY7X6Xh07pQ6Hp07pY5H506p49G5U+p4dO50Ol7yns9w/E8cb93D8U+7FxyOh6pf1PHxIG1vIF8dD1Wv1PFQ9UodD1Wv1PFQ9Tod7/E8Xqnj8TxeqeNRxyt1PJ7HK3U8wfE6Ha+0c5et+To4e1851m/x2L7JbM9h4r8gKu2C9YWotKPUF6LS7kxfiFo7HWnfeM5sTwMsUDTmQdGHV4pBa9ugL0WtNXhfiloL2r4UtVaHfSkSKHagqPWNg74UtT6+70tR67PwvhS1Plj+DkX7WL7eWvfnfnUnP11b7D6g0hnOPKIuGs8cVdR45qi5xjNHhTaeOYH5cOao/sYzR604njkqy/HMUYeOZ446tDvzOT4ZTKiGtXoeNblWz6MzoNXz6E9o9TzB80o9j16NVs+jY6TV8+hbafU8umdaPY8enlLPZ/TwtHoePTytnkcPT6vn0cPT6nmC55V6Hj08rZ5HD0+r59HD0+p59PC0eh49PJ2e9xt6eFo9jx6eVs+jh6fV8+jhafU8wfNKPY8enlbPo4en1fOo51f1/Psd2byBtl/V8+9X9PYG2l6r5wmeV+p5aHutnoe21+p5PJ/X6nk8n9fqedTzSj1v8Xxeq+fxfF6r52kZzwdLh+dj1Zl5O3qb2de25aNt2wOFNnqOKv+FcZ2k+S2Mbtv2TbHclqrQ3eMOcvHPO+g3RrdOBmLFuM50zopxnecbrBjXeVjAilFppu6NcZ02NivGdXrCrBjXabCyYlynW/lRjN/aXLyyoLZ3qHnGQydUSAzQUU8xQEf1xQAdtRoDdAL08dBRBzJAR9XIAB01JgN0VKQM0FGR9oc+x1dIHnWxWtejOlfrevQI1LoenQq1rie4Xqvr0bVR63r0jtS6Hh0sta5HH02t69HN0+r6gG6eWtejm6fW9ejmqXU9unlqXU9wvVbXo5un1vXo5ql1Pbp5al2Pbp5a16Obp9X1Ed08ta5HN0+t69HNU+t6dPPUup7geq2uRzdPrevRzVPretT1y7q+sv9TgsJf1vWVZYMTFL5a1xNcr9X1UPhqXQ+Fr9b1eF6v1vV4Xq/W9ajrtbo+43m9Wtfjeb1a12vt5pktHYY8//b5TlAxH8QTbU9Hf+0ElbV2xjpjJGDsgVFrx6YzRq3dDxMPjNbWMHpj9t/2xocTjFo7CZ0xaq3KO2PUWuF2xRg2rdViZ4xaK6/OGNVWMX0xqq1i+mIkYOyBUW0V8x2M39yfvLKYfthQ8zBAR4XEAB31FAN0VF/joRvUagzQUdkxQEcdyAAdVSMDdAL08dBRkTJAR0XaH/oUXxkGg7pYretRnat1PXoEWl1v0alQ63r0S9S6Hl0bta5H70it6wmu1+p69NHUuh7dPLWuRzdPrevRzVPrenTztLreoZun1vXo5ql1Pbp5al2Pbp5a1xNcr9X16OapdT26eWpdj26eWtejm6fW9ejmaXU9oZun1vXo5ql1Pbp5al2Pbp5a16OuX9b177d3CwSFv6zr368FHjwUvlrXQ+GrdT0UvlrXQ+GrdT3B9Vpdj+f1al2Pul6t6/G8Xq3r8bxeq+uD4Lo+bNs+zphCzfUuWbf/dPIPLC59rRMXBNexvYcquG7rPVTSM1TBurz3UAXr0N5DFay7eg9VsM7oPVTBT8k6DzUKfirUe6h61FLUo5aiHrUUSc9Q9ailqEctRT1qKepRS3EhtZSOn86b/2OoJ+0qs+1H337uYbbbvtozaSFt1RfMQkqsL5iFdFtfMAupvL5gCGDOwSykIPuCWUhv9gWzkDrtC2YdLZvddoDxuQLG+cNo83j4ZrZvHOvNF8J1NPIbhL+HmtdRvdWhrqNjq0NdR5lWh7qO1qwOlfQMdR09WB3qOgqvOtR1NFt1qAupsLD/NG25psKSifvRyeQ/39y6g1lIW/UEE7eFlFhfMAvptu+Beb8ba9wWUnl9wSykCfuCIYA5B7OQ3uwLZiF12hfMQlq2Lxi1yrcGRq3yrYAxapVvDQyUbwGMVuU7xZJV0WjV35O4h+Aeye7RWotM4h6tFdEk7tFal03iHq3V4STu0VqjzuEeq7VSnsQ9Wuv1SdyDroFo96BrINo9BPdIdg+6BqLdg66BaPegayDaPegaiHYPugaS3ePQNRDtHnQNRLsHXQPR7kHXQLR7CO6R7B50DUS7B10D0e5B10C0e9A1EO0edA0ku0fybtMa3PN+b9hIUG6CN/uIkndthnsiQbmJdg+Um2j3QLlJdo/kvcPhnih5f2+4J0regxvuiZL3yYZ7ouS9rOGeuNC+dlO6xx1DtM7Qq3vQNRDtHnQNRLsHXQPR7kHXQLJ7Ftpbckn3oGsg2j3oGvA+Lc32cM/2+rR0oX1Hl3QPwT2S3YOugWj3oGsg2j3oGoh2D7oGot2DroFk9yy0a/KS7kHXQLR7UJaKdo9gaXB7uru/H36rz2ruMcHuR5tbvfA42p0iNHG32lkbK0fbx2rt1rpYcc8k/TzJW8DC9R91veQtceH6z7pesFyC6z/resEPcOD6z7pesAqH6z/reoLrtbpe8EMtuP6jdb3kLdfh+s+6XvDDOLj+s65HN0+t69HNU+r6tKGbp9b16OapdT26eWpdj26eWtcTXK/V9WjpaHW90Srzts3shmypdrR19nA9kZnE9e97+MlolXlwvdEq8+B6Q3C9VtdrfWgL1xutCh+uN1of2sL1RutDWwWur9X1Wh/awvVW60NbuN6im6fW9ejmqXU9unlqXU9wvVbXo5un1vXo5ql1Pbp5al2Plo5W1ztaxvVx84frQ644MyW3H7xtVc8v+KFtcuuoPHj+e55fR+TB89/z/DoaD57/nufXeWALz3/P8+uIe3j+W56ndR7XwvPf8/w6T2vh+W/V87TOw1p4/nueX+dZLTz/Pc8TPK/U8+jhafU8enhaPY8enlbPo4en1fPo4Sn1vEcPT6vn0cnR6nmtCu84OEVXc/yKX9V6rQJPveO16jvtjg9a5Z16x2t9Qqve8VplvXrHa30+q97xBMev6fhKHR+0Pp1V73itD2fVOx6dO6WOR+dOqePRudPp+IjOnVLHo3On1PHo3Cl1PDp3Sh2PBo5Sxwsu54L3O5Tgk/nD8XfjBZckVeOTYFldN16wNKwbL1je1I0XnKLrxtPMxgvOkXXjBTfq68YLbjbXjZ85w6aZM2yeOcPmmTNsnjnD5pkzbJ45w+aZM2yeOcPmmTNsnjnD5okzbN4mzrB5mzjD5m3iDJu3iTNs3iRn2O14QTNke2a85AxbNV5yhq0aLznDVo2XnGGrxkvOsDXjjeQMWzVecoatGi85w1aNl/wg1+ft6+AYPP1h/MmzLrc/v3L0eHx1jFNwMu46TsnPZ3uOU/L75D3HKfn16Z7jlPy2cM9xSn45tuM4Re+L3HOcSl999Nu+JI2n7Y9j71iUvhhYw6L0tbkaFgKWMyxK37WrYVH6KWENi9IP7WpYlH6GVsOi9COtChan9BMmH/af9jlVjiXrd4Zk09MQnf+CuI4mlrN3qon7IJPJf67qeIe+juKeCPo6en4i6KQUuom71c7aWIP+vWVgq9DXqUUmgr5OpTMPdLUbxX3rC7cHchfPIOLD4A4Q8ZFtB4gEiD+HiK9+O0DEEmgdIGI5sQ4QsTRXB4hY5urnENXu5fO55SRq9Y1HfTMcOaqh4chRO3VHHh7r1Gz5BDkB+WjkqMuGI0cVNxw5ar7hyFEhDkeOenI0cmw1Nh45qs/hyFF9DkeO6nM4cgLyNRemNXmHZ62xzwffHY8aWKnjUYkrdTz6AUodj66EUsejN6LT8dhSSqvj0SdS6nh0q5Q6Hj0zpY4nOF6n49G5U+p4dO6UOh6dO6WOR+dOqePRudPpeMm7VsLxn3Q8OndKHY/OnVLHo3On1PEEx+t0PDp3Sh2Pzp1Sx6Nzp9Tx6NwpdTw6dzodn9G5U+p4dO6UOp7g+DUdb93D8U+7lx2Oh6pf1PHxIG1vIF8dD1Wv1PFQ9RodH7cNql6p46HqlToez+OVOh7P45U6nuB4nY7H83iljsfzeKWOV9q5y3bfeDJ7XznWb/HY1dZsz2HivyAq7YL1hai0o9QVolHanekLUWunI+37cZvtaYAFisY8KPpwQlFr26AvRa01eF+KBIodKGqtDvtS1Fpq9aWo9Y2DvhS1Pr7vS1Hrs/CuFK3WB8vfodh1j/obc1Q645mjLhrPHFVUf+ZvN9K4MScwH84cFdp45qjnxjNH9TeeOWrF8cxRWQ5n7lCHjmeOOnQ8c9Sh45mjDh3PnMC8N/MZPke+eR7VsFbPoybX6nl0BrR6Hv0JrZ5Hl0Sp5wm9Gq2eR8dIq+fRt9LqeXTPtHqe4HmlnkcPT6vn0cPT6nn08LR6Hj08rZ5HD0+p5z16eFo9jx6eVs+jh6fV8+jhafU8wfNKPY8enlbPo4en1fPo4Wn1PHp4Wj2PHp5Szwf08LR6Hj08rZ4neH5Rz7/d7fHmeWj7VT1f2S0gQNtr9Ty0vVLPR2h7rZ6HttfqeTyf1+p5PJ/X6nmC55V6Hs/ntXoez+e1en6dej5YOjwfq87M29HbzL625Sdt2x4otNFzVH1tWpHWSZrfwui2bd9wz22pCt097iAXT9bnT+tkIFaM60znrBjXeb7BinGdhwWsGJVm6s4Y8zptbFaM6/SEWTGu02BlxbhOt/KjGO2Bkcj8gfGkgK0tqJ0J0MdDR4XEAB31FAN0VF8M0FGrMUBHZTcc+q3fD+jjoaNqZICOGpMBOipSBugE6N2hT/EVktlQF6t1Papzta5Hj0Ct69GpUOt69Eu0ut6ga6PW9egdqXU9OlhqXY8+mlrXE1yv1fXo5ql1Pbp5al2Pbp5a16Obp9b16OZpdb1FN0+t69HNU+t6dPPUuh7dPLWuJ7heq+vRzVPrenTz1Loe3Ty1rkc3T63r0c3T6nqHbp5a16Obp9b1BNev6vr3+z8ZB4W/rOvfLxt8Gylcr9X1UPhaXU9Q+GpdD4Wv1vV4Xq/W9Xher9b1BNdrdT2e16t1PZ7Xq3W91m6e2dJhyPNvn+8EFfNBPNH2dLT/wqi1M9YZo9YuU1+MXmvHpjNGrd0PEw+M1tYwemP23/bGhxOMWjsJnTFqrco7YyRg7IFRa7XYGaPWyqszRrVVTF+MaquYvhjVVjFdMQa1Vcx3MH5zf/LaYvoBNQ8DdFRIDNBRTzFAJ0AfDx21GgN0VHYM0FEHMkBH1cgAHTXmeOgRFSkDdFSk/aHP8ZVhRF2s1vWoztW6nuB6ra5Hp0Kt69EvUet6dG3Uuh69I7WuRwdLq+sT+mhqXY9unlrXo5un1vXo5ql1PcH1Wl2Pbp5a16Obp9b16OapdT26eWpdj26eVtdndPPUuh7dPLWuRzdPrevRzVPreoLrtboe3Ty1rkc3T63r0c1T63p085S63m6o65d1/fvt3exGcP2qrn+/FrjdoPDVuh4KX63rofDVuh4KX63r8bxeq+sNnterdT3qerWux/N6ta7H83q1rhdc14dt28cZU6i53pvsvo72lh7AjbVfQxVcx/YequC6rfdQBdcpnYdqBevy3kMVrEN7D1Ww7uo9VME6o/dQSc9QBT8V6j1UPWrJ6lFLVo9asnrUktOjlpweteT0qCWnRy05WmaoFPef9v6p3/JrqCftKrPtR99+7mG2277aM24dbdUZzDpKrDOYdXRbZzDrqLzOYNbRhH3B0DoKsjOYdfRmZzDrqNPOYNbRsj7sTxh9ML4CxvnDaPMEcUvXj/XmCyFpQHgf6jqqtzrUdXRsdajrKNPqUNfRmtWhrqMea0P16+jB6lDXUXjVoa6j2apDXUeFBXd0FJPPFRWWzCFmk8l/vrl1B0MAcw5mHSXWGcw6uu2bYN7vxmr9OiqvM5h1NGFnMOsoyL5gwjp6szOYddRpZzDraNnOYNQq3xoYAphzMGqVbw0MlG8BjFblO8eSVUGr/p7EPVqrgDncE7XWIpO4R2tFNIl7tNZlk7hHa3U4iXsI7pHsHq2V8iTu0VqvT+IedA1EuwddA9HuQddAsnsSugai3YOugWj3oGsg2j3oGoh2D8E9kt2DroFo96BrINo96BqIdg+6BqLdg66BZPdkdA1EuwddA9HuQddAtHvQNRDtHoJ7JLsHdY/gvWHdBuUmeLMPJ3nXZrjHbVBuot0D5SbaPQT3SHYPnveIdg+e94h2D+oe0e7B8x7R7sHzHsnuMcTnnqcmxukPm3R0PEyidBxM4ct2P7HtYWLb48S2p4ltz/Pazrl/5o9tNxPbbie23U1s+8R51U6cV+3EedVOnFftxHnVTpxX3cR51U2cV93EedVNnFc5dyv8se1j8+pNg+xtgts0Uflh644V9qyLr4tuu8Gb/nU2Ps5sfJrZ+Dyx8YM3oetsvJnZeDuz8W5m40my8fYwnsj8YfxJB76yaKwj0fm471BFZ+++QxWd6/sOVbQy6DtU0Tqi61C9aNXRd6iiNUrfoYpWNH2HKlr/9B0q6RnqOmppiu9tnF9Hs00CfB3lOAnwdfTrJMDXUdFzAA/raPlJgK9TUUwCfJ26ZhLg61RXkwAnAB8LHJXmYOCoNAcDR6U5GDgqzcHAUWmOBR5RaQ4GjkpzMHBUmoOBo9IcDJwAfCxwVJqDgaPSHAwcleZg4Kg0BwNHpTkWeEKlORg4Ks3BwFFpDgYOHT52segElTJ2na0ElTIWeIZKGQwcKmUwcKiUwcDRDx8MnAB8LHDo8MHA0Q8fDBz98MHAB1eajvZFmh1t9v0Pe2P2Ktkb/7DCOP9lfJ7XeBq8IVRn483MxtuZjXczG08zG+9nNj7MbHyUa7x9fJh/6+rGmiqofMZPm+B83HuogrN356Eawbm+91AFK4PeQxWsI3oPVbDq6D1U0jNUwYqm91AF65/eQ9Wjlsw6ammKN0HIrKPZ5gBu11GOkwBfR79OAnwdFT0J8HW0/CTACcDHAl+nrpkE+DrV1STA16nxJgGOSnMwcFSaY4E7VJqDgaPSHAwcleZg4Kg0BwMnAB8LHJXmYOCoNAcDR6U5GDgqzcHAUWmOBU6oNAcDR6U5GDgqzcHAUWkOBk4APhY4Ks3BwKHDhy56RB4qZei3v+ShUgYDh0oZDJwAfCxwqJTBwNEPHwwc/fDBwKHDBwNHP3ws8IB++GDggyvNm8EH8OCff/huDg01h0xyD5JU+eHywXfb/cS2B7m2h+T3ZklI8bHYWPgyPc5reprX9CzY9Lztk2nINv7V9MH7D3Y13cxrup3XdDev6YLzac10wem0ZrrkbFoxXXI2rZguOZtWTJ83m6Z5s2maN5umebNpmjebpnmzaZo3m6Z5s2maN5umebNpmjeb5nmzaZ43m+Z5s2meN5sO3jOlq+nzZtM8bzbN82bTPG82zdNmU79Nm039Nm029du02dRv02ZTv02bTf0mOpvS8Rgs+1fTRWfT96aLzqbvTRedTd+bLjqbvjXdiM6m703/ZEq6XwHvQnZ+cclt+7HWGXo++A4c70IOBo53IccCx3rno4Hjq7vBwPHV3WDg+OpuMHAC8M5fTmd7AN/8K3B8dTcYOL66GwwcleZg4Kg0BwNHpTkWONY7Hw0cleZg4Kg0BwNHpTkYOAqfscBHL91qaTfdudoPW2cP4ERmjV7K6KVbAdwC+FjgDsDHAicAHwvcA/hY4AHAxwKPAD5WhycAHws8A/hQ4B6V5mDgqDQHA0elORg4Ks3BwAnAxwJHpTkYOCrNwcBR+IwFHsYmTZuPpXudseb9D4ftaEvEFB6P2Myv7Xxejr4NZX9655PPj6OtnbfzMnjtYLjnm+7xcI9k9wS4R7J7Itwj2T0J7pHsngz3CHbP4BXZ4Z7v1T2DV52He77pHgv3SHYPugai3UNwj2T3oGsg2j3oGoh2D7oGot2DroFo96BrINk9CWWpaPcIlgbRuX25yBh9zT0m2P1oE+PDZuNOEZq4W+3s02K350cvuepREiw74PrPul6wpIHrP+t6wXIJrv+o67PgBzhw/WddL1iFw/Wfdb3gB09w/WddL/ihFlz/0bp+8LZtcL0g1wt+GAfXf9b16OapdT26eWpdj26eWtejm6fU9WFDN0+t69HNU+t6dPPUup7geq2u1yrzts3shmypdvSKK1UGo1XmwfVGq8yD641WmQfXG60PbeF6Q3C9VtdrfWgL1xutD20VuL5S1xutD23heqP1oS1cb9DN0+p6i26eWtejm6fW9ejmqXU9unlqXU9wvVbXo5un1vVo6Wh1vVtH5sXNH64PueLMlPZ1kcy2VT2/4Ie2wa2j8uD573me4Hmlnl9H48Hz3/P8Og9s4fnveX4dcQ/Pf8/z6zyuhee/5/l1ntbC89+q52mdh7Xw/Pc8v86zWnj+e55HD0+r59HD0+p5gueVeh49PK2eRw9Pq+fRw9PqefTwlHreo5Oj1fNaFd5xcIqu5vgVv6r1WgWeesdr1XfqHa9V3ql3vNYntNodH7TKevWO1/p8Vr3jtT6eXd7xlTo+aH06q97xBMfrdDw6d0odj86dUsejc6fU8ejcKXU8Onc6HR/RuVPqeHTulDoeDRyljh8s7nzYD7bBxPc/bFLeX5Cym1ukRx4zgA8FnjYAHwvcAPhY4BbAxwJ3AD4WOAH4WOAewIfq8BQAfCzwCOBjgaPSHAwcleZY4BmV5mDgqDQHA0elORg4Ks3BwAnAxwJH4TMUeNxOgdMWjws8TDd0+ojNHc4xZB5Ybs/pvi4RP3+J9PlL5I9fwmyfv4T5/CXs5y/hPn8J+t4l7if5lpNCy0nn95Tb9pN+zRsvJ6WGk853xqJ4zEDP+8fcZq77Sb7lpNBy0ikIb/b9bbx1f5x0MkOmx1IaKZmnjPF1hfTxK+RPX8FtH7+C+fgV7Mev4D5+Bfr4FfzHrxA+foWP39Pu4/e0+/g9fb4Spqf97ShP8XW6PF9Qzcf9pEDbyUm54Urnyzh5v6dd/yzOj5POZ5G0S1if3clJtuUk13IStZx0fkem7TjpDERoOSm2nJRaTsoNJ52vAFA7ybScZN+fFLYTP51/tepjPk5KJyedRkQwe0QEl09O8pUrnd2E519aVe7c0HK7n3/hUTkpniI31u+DMjacoDh/07R+GrWd5ttOC22nxbbTUttpuem08/fh6qeZttMKUZLicVq2J6e5+mkntUGittN822mh7bTzKHHbPoXc/jyZeM6fn9ZPy02nnT/Lqp9m2k6zbae5ttOo7bSC38Lhbhdfs0zazkk+hKHxZE9OKyDJx/1GT829x2muflo+OY3aTvNtp4W203LTaeftqVu74/hOgJ56u4/TXNtp5yQpbMdpIZycFgunPcYWX5NwsoWx+SOUKZ3EpHVtp1HbaedRQvnYwNhvZ2MLbafFttNS22m5cHcffvP25DZ1W9tppslIZ9tOc22nUdtpvmmePG9O1E+LbaelptPINM1c1DZzUdvMRdRyWj5/hnFrh3ydFenp4RZ9nXNqYaZ9Hsnev55DDef4hnNCwznn0bQ9buctpNezUtNZueUsuzWdZZrOsk1nuaazqOks33RWaDqrKTZsU2zYpthwTbHhmmLjPKe8ny3OE0re9nyS7ck5DXf++eReuU7+/jnnOxdWzjEN59jvM6CGmZkaZmZq8A81zMzn7e/KOanhnPM4OLojOdqXc84b5pVzTMM5tuEc13AONZzjG86pxcHZOQ1x4Bvi4LxP/v6c8zZ55RzTcE7DfBAa5oPQMB+EhvkgNMwHoSEOQkMchIY4iA1xEBvi4Lwne+sv7C+7UTSPO8j57es013baaTTQrQexn3arT09O822nhbbTYttp5+/XpMerPOnpdb3HabnptPOebP0003aabTvNtZ1Gbaf5ttNC22mx7bSWKLn1jc9ftk/+eCc15cfN7dLpO6nk9pepbvV97Wjj0lO/0T3L92y/jHISjSKJRnmJRgWJRkWJRiWJRmWBRp03ALmNMp816n4RO+IibsRFaMRF/IiLhBEXiSMu0mUGOhRsev445nGRPOAidhtxETPiInbERdyIi9CIi/gRF+lxx7vjVcHkTfVoc7y5l0z+cy/Ou0lRnklJnklZnEluk2eSkWeSlWeSG29SeHzu+fT0/vwDzkor6TYAmn0AfvYBhNkHEGcfQJp9AFn6ACo9R9pmH4CZfQB29gGIz8S1AYjPxLUBiM/EtQGIz8S1AYjPxLUBiM/EtQHMnon97JnYz56JvahMfDdJVG69myQqW95NGp//hCz9ZI5vLKw1f30J7gYmAMw5mAgw52ASwJyDyQBzCiZsAHMOxgDMORgLMOdgHMCcgyGAOQcD5VsAA+VbAAPlWwAD5VsAA+V7DiZC+RbAQPkWwED5FsBA+RbAEMCcg4HyLYCB8i2AgfItgIHyLYCB8j0Hk6B8C2CgfAtgoHwLYNTqGOseYJ4+hzvAqM1K8VhRy0bnXsGozUoVMFltVqqBUZuVamDUZqUaGLX9mBoYAphzMGp1TA2M2n5MDYzafkwNzKnydduxG5PbnlZdPx+qMfGxRLWJtobG3v53qHH3dLTNX0blTxv16zLmfPOE/pcxYy5jx1zGjbkMjbmMH3OZMOYyccxluswZwW+Py8Rcm04r3+ibLQs0ymwSjTIcRr3/rMIYK9EoJ9EokmiUl2hUkGhUlGhUkmhUFmiU3SQaJXFGtxwz+hTPYYx1QFNCQ0BTQuOBpoQmAE0JTQSaEpoENCU0GWgKaNwGNCU0BmhKaKCGi2ighotoCGhKaKCGi2ighotooIaLaKCGi2ighktoCGq4iAZquIgGariIBmq4iIaApoQGariIBmq4iAZquIgGariIBmq4hMYr1jXvP7EzXnGGev8OtvGKM1QNjeIMVUOjOEPV0CjOUBU0QXG/poZGcb+mhkaxrqmhUdyvqaEhoCmhUZyh3LYfa52hFzRRcYaqoVGcoWpoFGeoGhrFGaqGRnGGqqFR3K+poVHcr7H5+HTfba9dvqi4X1NDo7hfU0OjWA1X0CTFariGRrEarqHR/ByqgkaxGq6hIaApoVGshmtoIPlKaPQu+VipoPQu+VgDQwBzDkbtko81MGqXfKyBUbvkYw2M2sXOa2DULnb+XsfYTe1i5zUwahc7r4FRq3xrYNQq3xoYAphzMHo3bamAUat8a2DUKt8aGLXKtwLGQOAVwJxmJR+OK/j4dJb5tZj96zXycQ23bemPo39f5HxN0d4XMSMuYkdcxI24yBDH+xEXCSMuEkdcJI24SB5wETfijncj7ng34o53I+54N+KOdyPueDfijncj7ng34o53I+54GnHH04g7nkbc8TTijqcRdzyNuONpxB1PI+54GnHH04g73o+44/2IO96PuOP9iDvej7jj/Yg73o+44/2IO96PuOP9iDs+jLjjw4g7Poy448OIOz6MuOPDiDs+jLjjw4g7Poy448OIOz6OuOPjiDs+jrjj44g7Po644+OIOz6OuOPjiDs+jrjj44g7Po2449OIOz6NuOPTiDs+jbjj04g7Po2449OIOz6NuOPTiDs+j7jj84g7Po+44/OIOz6PuOPziDs+j7jj84g7Po+44/OAO95t24iLmBEXsSMu4kZchEZcxI+4SBhxkTjiImnERUbc8WbEHW9G3PFmxB1vRtzxI169cmbEHW9G3PFmxB1vRtzxZsQdP+KdOzfinTs34p07N+KdOzfinTs34p07N+KdOzfinTs34p07N+KdOzfinTs34p07N+KdOzfinTs34p07N+KdOzfinTs34p07N+KdOzfinTs34p07N+KdOzfinTs34p07N+KdOzfinTs34p07N+KdOzfinTs34p07N+KdOzfinTs34p07N+KdOzfinTs34p07N+KdOzfinTs34p07N+KdOzfinTs34p07N+KdOzfinTs34p07N+KdOzfinTs34p07N+KdOzfinTs34p07N+KdOzfinTs34p07N+KdOzfinTs34p071+Odu9uDsX2HmVufuXZ03A2K8TiS4pc1SZQ1WZI1PV7362iNEWWNFWWNE2UNibLGi7ImiLJG1FycRM3FSdRcnEXNxVnUXJxFzcVZ1FycRc3FWdRcnCXNxbSdesrcnnt9nWNuEujx+7+k9cvRdGxDTunJFm+/LuE/f4nw+UvEz18iff4S+eOXOH+x73uX8I+bIZxdwnz+ErbDJeJ23NL55BLu85focHf7vLs7bO7kEv7zlwhdL2HMySXi5y+RPn+JDnd3iGa/RNpeL2G3z1+iw90d0r54Ych0cgn7+Ut0uLvj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",
      "brillig_names": [
        "is_contract_initialized"
      ]
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "constructor"
      ]
    },
    {
      "name": "refund_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2588366281349374274": {
            "error_kind": "fmtstring",
            "length": 136,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "3473764466780631008": {
            "error_kind": "fmtstring",
            "length": 106,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5533887251808526417": {
            "error_kind": "fmtstring",
            "length": 120,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "get_note_internal",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [
        "aztec::macros::functions::utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2588366281349374274": {
            "error_kind": "fmtstring",
            "length": 136,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "3473764466780631008": {
            "error_kind": "fmtstring",
            "length": 106,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5533887251808526417": {
            "error_kind": "fmtstring",
            "length": 120,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7b3briw7b9/7Lr72hQ7UKa8SbARO4gQfYNiB7Wxgw/C7756rR1X3XK3RWkNNqSjx7wtjzG+VWuSPknioKtZ//N3//Mf//n//93/72z//r3/5t7/7L//1P/7un/7lf/zDv//tX/759q//+M+//7v//q9/+6d/+tv//m/P//PfmV//zzrzx4B/+z//8M+//v1v//4P//rvf/dfrCGb//7v/vGf/+cff6d0+5H/9bd/+sfbv5z5z79/uT7l+HV1NnReG1Pl0uDC16UhmMfPEv3n//P3N3EshzjZp0OcUN6LQ758XUoxv4rjWMTJdIhT8ntxojnoRBdfxfEc4hTnvq4uPjTEyebr0mQqxqKqOD6bYwLrS7C/ifPHuNA5LnaOS53jcue40jfOm85xtnOc6xznO8d1rhffuV5853rxneuFqvO5nI/TyJvgnka5+6jUNSp3jSo9o4LpGmW7RrmuUb5rFHWNCl2jutZG6FoboWtthK61EbvWRuxaG7FrbcSutRG71kbsWhuxa23ErrURu9ZG7FobqWttpK61kbrWRupaG6lrbaSutZG61kbqWhupa22krrWRu9ZG7lobuWtt5K61kbvWRu5aG7lrbeSutZG71kbuWhula22UrrVRutZG6VobpWttlK61UbrWRulaG6VrbZSeteGM6Rplu0a5rlG+axR1jQpdo2LXqNQ1qro2fAhHncOH8ih0xHIfVDoGWdMzyPYMcj2DfM+g6qrw0fhjUHL5edBrCefmM8/iUI6P4lzytWpYOn44PJefAt2lCR9Lc9tTR6XwtlF+k+aPGeLwGdLwGfLwGcroGepVYdYZ7PAZ3PAZ/PAZaPgMw/e0Y9jT7jGD840zzAV7/LIL6VGlC7FWmj+P35ye6+2u9sP2vK1wOwofP0y1H3bZnm7xt0v/QJKA5M9IMpD8GUkBkj8h8QZI/ozEAsmfkTgg+TMSDyR/RkJA8mckAUj+jATR6wsSRK8vSBC9viBB9PpnJITo9QUJotcXJIheX5Agen1BQkDyZySIXl+QIHp9QYLo9QUJotcXJIhe/4wkIHp9QYLo9QUJotcXJIheX5AQAxI6hfG29VyLNedrXr/eXnpC8oc4QZY4UZY4SZY4WZY4RZQ40cgSx8oSx8kSx8sSR9apHGWdylHWqRxlncpR1qkcZZ3KSdapnGSdyknWqZxkncpJ1qmcZJ3KSdapnGSdyknWqZxkncpZ1qmcZZ3KWdapnGWdylnWqZxlncpZ1qmcZZ3KWdapnGWdykXWqVxkncpF1qlcZJ3KRdapXGSdykXWqVxkncpF1qlcRJ3K3og6lb0RdSp7I+pU9kbUqeyNqFPZG1GnsjeiTmVvRJ3K3og6lb2RdSpbWaeylXUqW1mnspV1KtvJp7InczQi8UTl/cWW0tEz1wbrz4ttzpWr4/nLv3XNzemuaNCiaNSiaNKiaNaiaFGiqDNaFLVaFHVaFPVaFCUtimqJjJyWyMhpiYzc9MgoHU/g++DT+4uLLUfmVfzTY/Upj6ZSQOWVijegUqFiQaVCxYFKhYoHlQoVApUKlQAqFSoRVCpUEqhUqCC2rVFBbFuhQohta1QQ29aoiI5tgzsULeHpG5ZVKs6m41N8zuZH2cGW2gcvXTo/3OeSe3yj4n4flETHtpdRIVCpUBEd215GRXRsexkV0bHtZVREx7aXUREd215FJYiObS+jIjq2vYwKYtsaFcS2NSoEKhUqiG1rVETHtjkeTdZKsY1Kgovh7CEXY3iiEmpyWHfe2Lfh+eqq1D4dKt7qdP63q/+gKDoWXoai6Nh5GYqiY+1VKEbRsfkyFEXH8stQFB37L0NRdK6wDEUCRQaKonORZSgid+GgiNyFgyJyFw6KyF0YKCbkLhwUkbtwUETuwkERuQsHRQJFBorIXTgoInfhoIjchYMichcOishdGChm5C4cFJG7cFBE7sJBEbkLB0UCRQaKyF04KCJ34aCI3IWDInIXDorIXRgoFuQuHBSRu3BQRO7CQRG5CwdFAkUGishdOCgid+GgiNyFgyJyFw6KyF0+p0gGuQsHReQuHBSRu3BQRO7CQZFAkYEichcOishdOCgid+GgiNyFgyJyFwaKFrkLB0XkLhwUkbtwUETuwkGRQJGBInIXDorIXTgoInfhoIjchYMichcGig65CwdF5C4cFJG7cFBE7sJBkUCRgSJyFw6KyF04KCJ34aCI3IWDInIXBoqyvzu9DEXkLhwUkbtwUETuwkGRQJGBInIXDorIXTgoInfhoIjchYMichcGirK/K74MReQuHBSRu3BQRO7CQZFAkYEichcOishdOCgid+GgiNyFgyJyFwaKsr8bvwxF5C4cFJG7cFBE7sJBkUCRgSJyFw6KyF04KCJ34aCI3IWDotbcxVE45HC5RZHKSTEYU14oRq25Cy9FrbkLL0WtuQsvRa25Cy9FAkUGilpzF16KWnMXXopacxdeilpzF16KyF0YKCbkLhwUkbtwUETuwkERuQsHRQJFBorIXTgoInfhoIjchYMichcOishdGChm5C4cFJG7cFBE7sJBEbkLB0UCRQaKyF04KCJ34aCI3IWDInIXDorIXRgoFuQuHBSRu3BQRO7CQRG5CwdFAkUGishdOCgid+GgiNyFgyJyFw6KyF0+p3j730CRgSJyFw6KyF04KCJ34aBIoMhAEbkLB0XkLhwUkbtwUETuwkERuQsDRYvchYMichcOishdOCgid+GgSKDIQBG5CwdF5C4cFJG7cFBE7sJBEbkLA0WH3IWDInIXDorIXTgoInfhoEigyEARuQsHReQuHBSRu3BQRO7CQRG5CwNFj9yFgyJyFw6KyF04KCJ34aBIoMhAEbkLB0XkLhwUkbtwUETuwkERuQsDRULuwkERuQsHReQuHBSRu3BQJFBkoIjchYMichcOishdOCgid+GgiNyFgWJA7sJBEbkLB0XkLhwUkbtwUCRQZKCI3IWDInIXDorIXTgoInfhoIjchYFiRO7CQRG5CwdF5C4cFJG7cFAkUGSgiNyFgyJyFw6KyF04KCJ34aCI3IWBYkLuwkERuQsHReQuHBSRu3BQJFBkoIjchYMichcOishdOCgid+GgiNyFgWJG7sJBEbkLB0XkLhwUkbtwUCRQZKCI3IWDouTcxRqT6Otqa2yxDY4mu0MQF56g1zDamA4L2WRN42JnzHGxs/n54j8gSk5dloEoOXNZBqLkxGUViEVy3rIMRMlpyzIQJWcty0CUnLQsA5EA8XOIklOWZSAiY2GAiIyFASIyFgaIyFg+hhgNMpa/ApHcKQclen9xpEOKGB8K+lCq1b78pF/j4mjPq6MLpnH1TauYHhr+qvG9//ViDiCx2IfgtoY6OzqAZBfd88V/rCqkcFhV/KsKOS1WFf+qQpKPVcW/qgirCquKfVWhDIRVxb+qUBfDquJfVSgUYlXxrypUTrGq+FcVSslYVeyryqK2jlXFv6pQW8eq4l9VqK1jVfGvKtTWsar4VxVhVWFVsa8q1NaxqvhXFWrrWFX8qwq1dawq/lWF2jpWFf+qQm0dq4p9VTnU1rGq+FcVautYVfyrCrX1dVaVC+lcVbn10zZHfxjx19/02/V/2B4VcL22J9here1RTdZre9R89doelVm9tkf9VK/tUeVUa3uPWqRe26NiqNf2qOvptT3qenptT7C9WtujrqfX9mrresmH0/b+t4v/4KK25tXgorYe1OCitlbynguprSM0uKjNsRtc1OafDS5qc7MGFwKXKhe1MX2DC+LdOhfEu3UuiHfrXBDvVrkE2fFuPr+WaE1x4T0Xa3M4qwc2p0eBJNbETuakmJx7uvYPLrLj3eu4yI53r+MiOt61gc6anY3OvOcSzeOh/seBcQN015TUaCo6JmXVVHSUyaqp6LiRVVPRkSCrpqJjO05No+hojVVT0fEXq6aiIypWTdXESJHUaKomRopqYqQoOkZy1h152O3v5/JHtVbiUz4FKY+E8I8iy3/8LMeLoiOqC7mIjr+u45JER2sXchEd213IRXQkeCEX0XHjhVwIXKpcRMekF3IRHcFeyAXxbp0L4t06F8S7VS4Z8W6dy07xLtnjU/aOyPzG5Q9dd4phW7ruFJe2dCVFuu4UP7Z03SkmbOm6U5zX0nWn2K2l607xWEPXslOM1dJVUdxUFMVNRVHcVEiRroripqIobiqK4qaiKG4qeuKmZPTETcnoiZtudTdFuuqJm5IhRbrqiZuS0RM3JaMnbkpGT9yUjKK4ySqKm6yiuEn2t+aZdVUUN8n+LjezroriJtnfMGbWVVHcJPt7r8y6KoqbZH8bk1lXRXGT7O8IMuuqKG6S/Z04Zl0VxU2yvwPGrKuiuEn2d56YdVUUN8n+jg+zroriJtnfaWHWVVHcJPs7HMy6KoqbZH9ngVlXRXGT7O8hMOuqKG6S/d0CZl0VxU2yvy/ArKuiuEn2dwCYdVUUN8nu18+sq6K4SXZffWZdFcVNsvvfM+uqKG6S3aeeWVdFcZPs7vPMuiqKm2R3oGfWVVHcJLsLPbOuiuIm2Z3omXVVFDfJ7kbPrKuiuEl2R3pmXRXFTbK70jPrqihu2qrXfEtXRXHTVj3hW7oqipu26t3e0lVR3LRVj/WWrrPjppRPXbOz7y+OFA8xYrDl+eI/ZI8Ly54Wlj0vLHtZV/bpvbY5ZbcLy+4Wlt0vLDstLPvCfjUv7Ffzwn41L+xX88J+tSzsV8vCfrUs7FfLwn51en9iTtkX9qtlYb9aFvarZWG/Wtb1q9ms61ezWdevZrOuX81mXb+azbp+NZt1/Wo26/rVbNb1q9ms61ezWdiv2oX9ql3Yr9qF/apd2K9O72/KKfvCftUu7Fftwn7VLuxX7cJ+1S3sV93CftUt7Ffdwn51ev9LTtkX9qtuYb/qFvarbmG/6hb2q35hv+oX9qt+Yb/qF/ar0/sjcsq+sF/1C/tVv7Bf9Qv7Vb+wX6WF/Sot7FdpYb9KC/vV6f3zOGVf2K/Swn6VFvartLBfpYX9aljYr4aF/WpY2K+Ghf3q9P5qnLIv7FfDwn41LOxXw8J+NSzsV+PCfjUu7Ffjwn41LuxXp/ff4pR9Yb8aF/arcWG/Ghf2q3Fhv5oW9qtpYb+aFvaraWG/Or0/E6fsC/vVhfst5YX7LeWF+y3lhfst5YX7LeWF+y3lhfst5YX7LeWF+y3lhfst5YX7LeWF+y3lhfst5YX7LeWF+y3lhfst5YX7LeWF+y3lhfst5YX7LeWF+y3lhfst5YX7LeWF+y2VhfstlYX7LZWF+y2VhfstFbOuXy0L91sqC/dbKgv3WyoL91sqC/dbKgv3WyoL91sqC/dbKgv3WyoL91sqC/dbKgv3WyoL91sqC/dbKgv3WyoL91sqC/dbKgv3WyoL91sqC/dbKgv3WyoL91sqC/dbKgv3WyoL91sqC/dbKgv3WyoL91sqC/dbKgv3WyoL91sqC/dbKgv3WyoL91sqC/dbKgv3WyoL91sqC/dbKgv3WyoL91sqC/dbKgv3WyoL91sqC/dbKgv3WyoL91sqC/dbKgv3WyoL91sqC/dbKgv3WyoL91sqC/dbKgv3WyoL91sqC/dbKgv3WyoL91sqC/dbKgv3WyoL91sqC/dbKgv3WyoL91sqC/dbKgv3WyoL91sqC/dbKgv3WyoL91sqC/dbKgv3WyoL91sqC/dbKgv3WyoL91sqC/dbKgv3WyoL91sqC/dbKgv3WyoL91sqC/dbKgv3WyoL91sqC/dbKgv3WyoL91sqC/dbKgv3WyoL91sqC/dbKgv3WyoL91sqC/dbskZ0w6XkrP26OLkU3l9sKdHXxTZYf15sc65xMfnA4uLTtekLi2SffSEWyeHAhVgkRxoXYiFgqWGRHB9diEVy6HUhFslR3YVYJAeMF2KRHIteh0V0+7MLsSDKrWJBlFvFgii3ioUmY8nenliSecnop7ePa8kThcmThMmThclTZMkzvcVaSx4rTB4nTB4vTB5h57MTdj47YeezE3Y+O2HnsxN2Pnth57MXdj57YeezF3Y+e2Hnsxd2Pnth57MXdj57YeezF3Y+k7DzmYSdzyTsfCZh5zMJO59J2PlMws5nEnY+k7DzmYSdz0HY+RyEnc9B2PkchJ3PQdj5HISdz0HY+RyEnc9B2PkchJ3PUdj5HIWdz1HY+RyFnc9R2PkchZ3PUdj5HIWdz1HY+RyFnc9J2PmchJ3PSdj5PL2NSM6nPKX1GIlNx7MezjyeC3EpVa7N5niIJPvSuLacj7KU8vu1dyYEJi9MApi8MIlg8sIkgckLkwwmL0wKmPyZyfR2NSswsWDywsSByQsTxLGvTAhMXpjMjmOLd18Xk8uxwcTFA4r19iFGotovRxcOmWMuzxffNY1qNE1qNM1qNC1aNJ3eTOk6Ta0aTZ0aTb0aTUmNpmpipKImRipqYqSiJkYqWmIka7TESNZoiZGs0RIjWaMlRrKG1GiqJUayRkuMZI2WGMkaLTGSNWpiJKsmRrJqYiSrJkayamKk6R2KrtNUTYxk1cRIVk2MZNXESFZNjOTUxEhOTYzk1MRITk2MNL1L2HWaqomRnJoYyamJkZyaGMmpiZG8mhjJq4mRvJoYyauJkaZ36rtOUzUxklcTI3k1MZJXEyN5NTESqYmRSE2MRGpiJFITI03vlnmdpmpiJFITI5GaGInUxEikJkYKamKkoCZGCmpipKAmRpresfY6TdXESEFNjBTUxEhBTYwU1MRIUU2MFNXESFFNjBTVxEjTu0Zfp6maGCmqiZGimhgpqomRopoYKamJkZKaGCmpiZGSmhhpetf06zRVEyMlNTFSUhMjJTUxUlITI2U1MVJWEyNlNTFSVhMjTe/IfZ2mamIkNX22rZo+21ZNn22rps+2VdNn26rps23V9Nm2avpsWzV9tq2aPttWTZ9tq6bPtlXTZ9uq6bPt1PTZdmr6bDs1fbadmj7bzpAaTbXESE5Nn22nps+2U9Nn26nps+3U9Nl2avpsOzV9tp2aPttOTZ9tp6bPtlPTZ9up6bPt1PTZdmr6bDs1fbadmj7bTk2fbaemz7ZT02fbqemz7dT02XZq+mw7NX22nZo+205Nn22nps+2U9Nn26nps+3U9Nl2avpsOzV9tp2aPttOTZ9tp6bPtlPTZ9up6bPt1PTZdmr6bDs1fbadmj7bTk2fbaemz7ZT02fbqemz7dT02XZq+mw7NX22nZo+205Nn22nps+2U9Nn26nps+3U9Nl2avpsOzV9tp2aPttOTZ9tp6bPtlPTZ9up6bPt1PTZdmr6bDs1fbadmj7bTk2fbaemz7ZT02fbqemz7dT02XZq+mw7NX22nZo+205Nn22nps+2U9Nn26nps+3U9Nl2avpsOzV9tp2aPttOTZ9tp6bPtlPTZ9up6bPt1PTZdmr6bDs1fbadmj7bTk2fbaemz7ZT02fbqemz7dT02XZq+mx7NX22vZo+215Nn22vps+2N6RGUy0xklfTZ9ur6bPt1fTZ9mr6bHs1fba9mj7bXk2fba+mz7ZX02fbq+mz7dX02fZq+mx7NX22vZo+215Nn22vps+2V9Nn26vps+3V9Nn2avpsezV9tr2aPtteTZ9tr6bPtlfTZ9vv02ebfIrHLxOV9xdbSnT8crD+vNjmXLk6mkOM6OLTtemL4TbR14UMt4nrLmRIYPgxw21i0QsZbhPlXshwm/j5QobbROYXMtwm5r+O4T4d6S9kiDzlc4bIUz5niDzlc4YEhh8zFJ2n+LPoZMNN4rdYnM0HFkc2vlSoZH9TgFVT0TE/q6aiI3NWTUXHz5yayv6mAKumomNRVk1FR4ysmoqO61g1JTWaqomRZH9TgFVTNTGS7G8KsGqqJkaS/U0BVk3VxEiyvynAqqmaGEn2NwVYNVUTI8n+pgCrpmpiJNnfFGDVVE2MJPubAqyaqomRZH9TgFVTNTGS7G8KsGqqJkaS/U0BVk3VxEiyvynAqqmaGEn2NwVYNVUTI8n+pgCrpmpiJNnfFGDVVE2MJPubAqyaqomRZH9TgFVTNTGS7G8KsGqqJkaS/U0BVk3VxEiyvynAqqmaGEn2NwVYNVUTI8n+pgCrplpiJJL9TQFWTbXESCT7mwKsmmqJkciQGk21xEgk+5sCrJpqiZFI9jcFWDVVEyPJ/qYAq6ZqYiTZ3xRg1VRNjCT7mwKsmqqJkWR/U4BVUzUxkuxvCrBqqiZGkv1NAVZN1cRIsr8pwKqpmhhJ9jcFWDVVEyPJ/qYAq6ZqYqTZ3xQgb05N/XMfM/8lT5Elz+z+/E15rDB5nDB5vDB5SJg8QZg8UZg8SZg8ws5nL+x8JmHnMwk7n0nY+UzCzmcSdj6TsPOZhJ3PJOx8JmHnMwk7n4Ow8zkIO5+DsPM5CDufg7DzOQg7n4Ow8zkIO5+DsPM5CDufo7DzOQo7n6Ow8zkKO5+jsPM5Cjufo7DzOQo7n6Ow8zkKO5+TsPM5CTufk7DzOQk7n5Ow8zkJO5+TsPM5CTufk7DzOQk7n7Ow8zkLO5+zsPM5Czufs7DzOQs7n7Ow8zkLO5+zsPM5Czufi7DzuQg7n4uw87kIO5+LsPO5CDufi7DzuQg7n4uw87nIOp+DkXU+ByPrfA5G1vkczPTzOZpDHjL5/cU2HV+ydcafl7qUKtdmczwXm31pXFvy8e3dUn6/9s6EwOSFSQCTFyazfSXZcjAJOby/2CV3PiiesntcbGtQQjhOiRwdPV981zSp0TSr0bRo0XR2H4YLNbVqNHVqNPVqNCU1mgY1mqqJkayaGMmqiZGsmhjJqYmRnJoYyamJkZyaGGl2H4YLNVUTIzk1MZJTEyM5NTGSUxMjeTUxklcTI3k1MZJXEyNN79FxnaZqYiSvJkbyamIkryZG8mpiJFITI5GaGInUxEikJkaa3ifnOk3VxEikJkYiNTESqYmRSE2MFNTESEFNjBTUxEhBTYw0vVfVdZqqiZGCmhgpqImRgpoYKaiJkaKaGCmqiZGimhgpqomRpveLu05TNTFSVBMjRTUxUlQTI0U1MVJSEyMlNTFSUhMjJTUx0vSejddpqiZGSmpipKQmRkpqYqSkJkbKamKkrCZGympipKwmRpreN/U6TdXESFlNjJTVxEhZTYyU1cRIRU2MVNTESEVNjFTUxEjTexdfp6maGKmoiZGKmhipqImRipYYKRotMVI0WmKkaLTESNFoiZGiITWaaomRopo+21FNn+2ops92VNNnO6rpsx3V9NmOavpsRzV9tqOaPttRTZ/tqKbPdlTTZzuq6bMd1fTZjmr6bEc1fbajmj7bUU2f7aimz3ZU02c7qumzHdX02Y5q+mxHNX22o5o+21FNn+2ops92VNNnO6rpsx3V9NmOavpsRzV9tqOaPttRTZ/tqKbPdlTTZzuq6bMd1fTZjmr6bEc1fbajmj7bUU2f7aimz3ZU02c7qumzHdX02Y5q+mxHNX22o5o+21FNn+2ops92VNNnO6rpsx3V9NmOavpsRzV9tqOaPttRTZ/tqKbPdlTTZzuq6bMd1fTZjmr6bEc1fbajmj7bUU2f7aimz3ZU02c7qumzHdX02Y5q+mxHNX22o5o+21FNn+2ops92VNNnO6rpsx3V9NmOavpsRzV9tqOaPttRTZ/tqKbPdlTTZzuq6bMd1fTZjmr6bEc1fbajmj7bUU2f7aimz3ZU02c7qumzHdX02U5q+mwnNX22k5o+20lNn+1kSI2mWmKkpKbPdlLTZzup6bOd1PTZTmr6bCc1fbaTmj7bSU2f7aSmz3ZS02c7qemzndT02U5q+mwnNX22k5o+20lNn+2kps92UtNnO6nps53U9NlOavpsJzV9tpOaPttJTZ/tpKbPdlLTZzup6bOd1PTZTmr6bCc1fbaTmj7bSU2f7aSmz3ZS02c7qemzndT02U5q+mwnNX22k5o+20lNn+2kps92UtNnO6nps53U9NlOavpsJzV9tpOaPttJTZ/tpKbPdlLTZzup6bOd1PTZTmr6bCc1fbaTmj7bSU2f7aSmz3ZS02c7qemzndT02U5q+mwnNX22k5o+20lNn+2kps92UtNnO6nps53U9NlOavpsJzV9tpOaPttJTZ/tpKbPdlLTZzup6bOd1PTZTmr6bKfpfbajsYemkezzxXd5SJg8QZg8UZg8SZg8WZg8RZY80zset+SxwuRxwuQRdj4XYedzEXY+F2HncxF2Phdh53ORdT5nI+t8zkbW+ZyNrPM5G1nnczayzudsZJ3P2cg6n7ORdT5nI+t8zkbY+WyFnc9W2PlshZ3PVtj5bIWdz1bY+WyFnc9W2PlshZ3PVtj57ISdz07Y+eyEnc9O2PnshJ3PTtj57ISdz07Y+eyEnc9O2PnshZ3PXtj57IWdz17Y+eyFnc9e2PnshZ3PXtj57IWdz17Y+UzCzmcSdj6TsPOZhJ3P07u+5Hg83xKsKa/yBGHyRGHyJGHyZGHyFFnyTO/s0ZLHCpPHCZPHC5OHhMkj7HwOws7nIOx8DsLO5yDsfI7Czuco7HyOws7nKOx8jsLO5yjsfI7Czuco7HyOws7nKOx8TsLO5yTsfE7Czuck7HxOws7nJOx8TsLO5yTsfE7Czuck7HzOws7nLOx8zsLO5yzsfM7Czucs7HzOws7nLOx8zsLO5yzsfC7Czuci7Hwuws7nIux8LsLO5yLsfC7Czuci7Hwuws7nIut8LkbW+VyMrPO5GFnnczGyzudiZJ3Pxcg6n4uRdT4XI+t8LkbW+VyMsPPZCjufrbDz2Qo7n62w89kKO5+tsPPZCjufrbDz2Qo7n62w89kJO5+dsPPZCTufnbDz2Qk7n52w89kJO5+dsPPZCTufnbDz2Qs7n72w89kLO5+9sPPZCzufvbDz2Qs7n72w89kLO5+9sPOZhJ3PJOx8JmHnMwk7n4W9P1iEvT9YhL0/WIS9P1iEvT9YhL0/WIS9P1iEvT9YhL0/WIS9P1iEvT9YhL0/WIS9P1iEvT9YhL0/WIS9P1iEvT9YhL0/WIS9P1iEvT9YhL0/WIS9P1iEvT9YhL0/WIS9P1hkvT/oDEf+ZVw85DGeXqdgWBL2obIN7mWKb7KA5MMxRU7p/RQ+ZnfKUx7y3D8sdZvCjp/CjZ/Cj5+Cxk8Rxk8Rx0+Rxk+Rx09Rhk8Rx+/uOH53x/G7O47f3XH87o7jd3ccv7vj+N0dx+/uOH53p/G7O43f3Wn87k7jd3cav7vT+N2dxu/uNH53p/G7O43f3Xn87s7jd3cev7vz+N2dx+/uPH535/G7O4/f3Xn87s7jd3cZv7vL+N1dxu/uMn53l/G7u4zf3WX87i7jd3cZv7vL8N1tjRk/hR0/hRs/BcPuzjGfFxf/OgWNnyKMnyKOnyKNnyKPn6IMn8Ka8VNY1imKodcpGHZ3NufFxbrnKV4vzoa+rs3+cTfF/Zrj5dqSj/sipfx+7V10v67otK7oYV3R47qip3VFz+uKXpYV3Zl1Rbfrir6uN3XrelO3rjd163pTJ9mbxuPaWxLuKrJLdqct2SX705bskh1qQ3Yv2aO2ZJfsUluyM/jU4u0pu3cvSbD346eg8VPE8VMwnJuFHgWJ9Frz8Hn8FGX4FGTGT2HHT+HGT+HHT0HjpwgcU9BjivA6RRk+BcNTwGToqPSTiem9l3DkzwefiR61yRC/5LHC5HHC5PHC5CFh8gRh8kRh8iRh8uTZ8rj8kCe+ylNkyRONMHlmn88hHNGpC9E/y1P55VvCdvyyrSy26EQLb8pb4Wef/MH6U/hk3wufzbHLMz2Sv1sw+SU7LSx7WFj2uLDsaWHZ88Kyl3VlT2Zh2e3Csos+38MhRU7xN9krP3wrdx0/fMtFz6up9sMun4Uz89uldyai/cZFTET7o4uYiPZzFzER7T8vYiLaL1/DJIv29xcxER1HXMTEgckLE9H1hIuYEJi8MEEc+8oEcewrE8Sxr0wQx74yQRz7wqQgjn1lss06McWdTEx8zyTnQ4jnB+7qP2xLtscv3/52Tw/SlXthzpltFtaVELfJqK6EuE0KdiXEbXK2KyESIH4OcZus8EqI26SRV0LcJu+8EuI2ieqVEJGxfA7RImNhgIiMhQEiMhYGiMhYGCASIH4OERkLA0RkLAwQkbEwQETGwgARGcvnEB0yFgaIyFgYICJjYYCIjIUBIgHi5xCRsTBARMbCABEZCwNEZCwMEJGxfA7RI2NhgIiMhQEiMhYGiMhYGCASIH4OERkLA0RkLAwQkbEwQETGwgARGcvnEAkZCwNEZCwMEJGxMEBExsIAkQDxc4jIWBggImNhgIiMhQEiMhYGiMhYPocYkLEwQETGwgARGQsDRGQsDBAJED+HiIyFASIyFgaIyFgYICJjYYCIjOVziBEZCwNEZCwMEJGxMEBExsIAkbaBmMoDYnoP8W1jTif7g1gXMdknn2Bjcu0HcPJ7Jike16YUX0WP64qe1hV9aCp0n6IMn2LsN0nuU3AEmeVo1Ew2NGzsKRzyeHqysQ30JZCTJpCXJhBJEyhIEyhKEyhJEyhLE6gIE4iljz6rQNJO6jL0pL5P4cdPQeOnCOOniOOnSOOnYDiVnKFjCp/c+yWez2uzf3yK1P2a4+Xako/Plpby+7V30cuqonuODztcJbpdV3S3ruh+XdFpXdHDuqLHdUVP64q+rDf1Zl1vatf1pnZdb8rR1tgmcwan+SU49RxNf1tTxPFTpPFT5PFTlOFTcLTibE1hx0/hxk/hx08xfne78bvbjd/dbvzuduN3txu/u/343e3H724/fnf78bvbj9/dfvzu9uN3tx+/u/343e3H724av7tp/O6m8bubxu9uGr+7afzupvG7m8bvbhq/u2n87g7jd3cYv7vD+N0dxu/uMH53h/G7O4zf3WH87g7jd3cYv7vj+N0dx+/uOH53x/G7O47f3XH87o7jd3ccv7vj+N0dx+/uNH53p/G7O43f3Wn87k7jd3cav7vT+N2dxu/uNH53p/G7O4/f3Xn87s7jd3cev7vz+N2dx+/uPH535/G7O4/f3Xn87i7jd3cZv7vL+N1dxu/uMn53l/G7u4zf3WX87i7jd3cZvrvJmPFT2PFTuPFT+PFT0Pgpwvgp4vgp0vgp8vgpxu9uO3532/G7247f3Xb87h7/rBqNf1aNxj+rRuOfVaPxz6rR+GfVaPyzajT+WTUa/6wajX9WjcY/q0ZO8psA8bjWGuN+u/guu+RXAVqyS34XoCW75JcBWrJLfhugIbuX/DpAS/ah7wPcp2A48/35agD5p3cDzin8+Clo/BRh/BRx/BR5/BRl+BQcjxe2prDjpxi/9Wj81qPxW4/Gbz0av/U4Hi9sTTF+d9P43R3G7+4wfneH8bs7jN/dYfzuDuN3dxi/u8P43R3G7+4wfnfH8bs7jt/dcfzujuN3dxy/u+P43R3H7+44fnfH8bs7jt/dafzuTuN3dxq/u9P43Z3G7+40fnen8bs7jd/dafzuTuN3dx6/u/P43Z3H7+48fnfn8bs7j9/defzuzuN3dx6/u/P43V3G7+4yfneX8bu7jN/dZfzuLuN3dxm/u8v43V3G7+4yfHcHY8ZPYcdP4cZP4cdPQeOnCOOniOOnSOOnyOOnGL+77fjdbcfvbjt+d9vxu9uO3912/O6243e3Hb+77fjdbcfvbjd+d7vxu9uN391u/O5243e3G7+73fjd7cbvbjd+d7vxu9uP391+/O4e/yBZGP8gWRj/IFkY/yBZGP8gWfDjd/f4Z9XC+GfVwvhn1QLHs2rJnh8Gydk+T/HhI65v20YHjmfgrhLdrys6CRb9/TPRgeNhwMtkjwvLnhaWPS8se1lXdo4nOYs5Lr7d2mnI/vaTpIHjoU9GaZwoafxIae5T0Pgpwvgp4vgp0vgp8vgpPj+3bhWjY83eyi6N9668K/n4ZW/p8ct3cRgeO2UVx8oSx00Wx8dyivP0gm3tO9NkT9HJ2fQiul9XdOIVvZiXXcjw+G1zijh+is9PxJDiYYqQqTJFHj9FGT4Fw+O3zSns+Cnc+Cn8+Clo/BRh/BRx/BTjd3cav7vT+N3N8PhtuOV/XxdHY8t7V0fnx4LDU8hgM32JY2WJ42SJ42WJQ7LECbLEibLESbLEybLEKXPFCe649lZIfBWnGFniWFniOFnieFnikCxxgixxoixxkixxJp/Kt7rkIzitiFMkiRONkSWOlSWOkyWOlyUOyRInyBInyhInyRJH1KkczdBT+Y8prBk/hR0/xecn4m2jHraIZN3rFH78FDR+ijB+ijh+ijR+ijx+ijJ8CoZXD5pT2PFTjN/dbvzuduN3txu/u9343e3G7243fne78bvbj9/dfvzu9uN3tx+/u/343e3H724/fnf78bvbj9/dfvzupvG7m8bvbhq/u2n87qbxu5vG724av7tp/O6m8bubxu/uMH53h/G7O4zf3WH87g7jd3cYv7vD+N0dxu/uMH53h/G7O47f3XH87o7jd3ccv7vj+N0dx+/uOH53x/G7O47f3XH87k7jd3cav7vT+N2dxu/uNH53p/G7O43f3Wn87k7jd3cav7vz+N2dx+/uPH535/G7O4/f3Xn87s7jd3cev7vz+N2dx+/uMn53l/G7u4zf3WX87i7jd3cZv7vL+N1dxu/uMn53l+G7Oxkzfgo7fgo3fgo/fgoaP0UYP0UcP0UaP0UeP8X43W3H7247fnePf1YtjX9WLY1/Vi2Nf1YtjX9WLY1/Vi2Nf1YtjX9WLY1/Vi2Nf1YtjX9WLY1/Vi2Nf1YtjX9WLY1/Vi2Nf1YtjX9WLY1/Vi2Nf1YtjX9WLY1/Vi1xPKsWvDumCNG/TsGwu8mdWkQXnqd4vZiv92XieAbuKtHjuqKndUXP64pelhWd49nFq0S364ru1hXdryv6ut6U1vWmtK43pXW9Ka3rTWldbxoke9P3TaRTkOxOW7JL9qct2SU71Jbskj1qS3bJLrUl+1Cfep8ijZ8ij5+iDJ8imvFT2PFTuPFT+PFT0Pgpwvgpxu/uOH53x/G7O47f3Wn87k7jd3cav7vT+N2dxu/uNH53p/G7O43f3Wn87k7jdzfHs9eRzNfFt2ijvI8ByT6+U/D4XZvjlzhhpDj3KT5ffamk48sM2Zj0XuNfDvPr4l9nxHlxOFROwuTJwuQpsuRheCqbVx4rTB4nTB4vTB6aLU857rC7/NTl+pQnCJMnCpNn8vnsnTk/++OefOQpTxYmTxElTzZGmDx2ujzmrTyTzx9P9uiH6cmZV3mCMHmiMHmSMHlmnz/+8UE5sr/JU0sv/LH4yRK9Cl9EC3+eJFXh7eyTjfx5slGwn5G3VrTwDfJutvApnsKX/CqPFyYPCZMnCJMnXidPeLp9dsqThMmThclTZMnjZp/8/qwa+mDT+8PTxnyc/DY9fdTU3v6+Sz/79ExnB3Z/S/8/81vOixb+vd9ys8/lRKfwf8qlK+vGlONbrPZmhMq6mX2K33idv1w5xV0UJk8SJk8WJk+RJY83wuSxwuRxwuT5/PRkvDeWfZAlTpQlTpIlTpYlThElDsc7N5ziWFniiLonnzned/mROOe1FH4XpyZ6ecj+lKgcotO6ood1RY/rip7WFT2vK3pZVvRg1hXdriu6W1f0db0px7suV4m+rjcN63rTsK43Det607CuN43retO4rjeN63rTuK435XhT6yrR1/WmcV1vGmd7U39KE6khevMecMwrC18WFj6ZlYW3KwvvVhberyw8rSx8WFn4KFf4ZNzxlFWi4t7/sC3peATK2fh4ftQG+tJUsDtm1lSw736j6V12wa67JXsW47nv4tQ9QjTHU1w+ufxeHGfpsdTCk8b+awpimCL6x2our1OE8VPE8VOk8VPk8VOUz6dw5x5yztPzFJWLyZ8XU+VxyW9e7b1OHitMHidMHi9MHhImTxAmTxQmT5otj8sPeeKrPFmYPEWUPMXMPp9DOB5nd8/N6XteJCjGihb+7YsExcw++YM9I4eQGm/vZXP8cKbykpIW4xeWnRaWPSwse1xY9rSu7NZIlj0cifetzPWb7LXUxz9luo8fptoPu8crX+a3S+9MLJi8MBHtjy5iItrPXcREtP+8iIlov3wRE9H+/iImouOIi5hkMHlhUsDkz0wc4thXJohjX5j4beJY8+iiaE18z+R2K/Hr2mJd44dtyfb45dvf7ulbEOUrafTbBL5XQiRA/BziNqH1lRC3icWvhLhN8H4lxG2i/SshbpMeXAiRtsknroS4TQJyJURkLAwQkbEwQCRA/BwiMhYGiMhYGCAiY2GAiIyFASIyls8hBmQsDBCRsTBARMbCABEZCwNEAsTPISJjYYCIjIUBIjIWBojIWBggImP5HGJExsIAERkLA0RkLAwQkbEwQCRA/BwiMhYGiMhYGCAiY2GAiIyFASIyls8hJmQsDBCRsTBARMbCABEZCwNEAsTPISJjYYCIjIUBIjIWBojIWBggImP5HGJGxsIAERkLA0RkLAwQkbEwQCRA/BwiMhYGiMhYGCAiY2GAiIyFASIyls8hFmQsDBCRsTBARMbCABEZCwNEAsTPISJjYYCIjIUBIjIWBojIWBggImP5FKI3BhkLA0RkLAwQkbEwQETGwgCRAPFziMhYGCAiY2GAiIyFASIyFgaIyFg+h7jPV/+uhIiMhQEiMhYGiMhYGCASIH4OERkLA0RkLAwQkbEwQETGwgARGcvnEPf5vuOVEJGxMEBExsIAERkLA0QCxM8hImNhgIiMhQEiMhYGiMhYGCAiY/kcokfGwgARGQsDRGQsDBCRsTBAJED8HCIyFgaIyFgYICJjYYCIjIUBIjKWzyHim/ccEJGxMEBExsIAERkLA0QCxM8hImNhgIiMhQEiMhYGiMhYGCAiY/kcIr55zwERGQsDRGQsDBCRsTBAJED8HCIyFgaIyFgYICJjYYCIjIUBIjKWzyHim/ccEJGxMEBExsIAERkLA0QCxM8hImNhgIiMhQEiMhYGiMhYGCAiY/kcIr55zwERGQsDRGQsDBCRsTBAJED8HCIyFgaIyFgYICJjYYCIjIUBIjKWzyHim/ccEJGxMEBExsIAERkLA0QCxM8hImNhgIiMhQEiMhYGiMhYGCAiY/kcIr55zwERGQsDRGQsDBCRsTBAJED8HCIyFgaIyFgYICJjYYCIjIUBIjKWjyFafPOeAyIyFgaIyFgYICJjYYBIgPg5RGQsDBCRsTBARMbCABEZCwNEZCyfQ8Q37zkgImNhgIiMhQEiMhYGiASIn0NExsIAERkLA0RkLAwQkbEwQETG8jlEfPOeAyIyFgaIyFgYICJjYYBIgPg5RGQsDBCRsTBARMbCABEZCwNEZCyfQ8Q37zkgImNhgIiMhQEiMhYGiASIn0NExsIAERkLA0RkLAwQkbEwQETG8jlEfPOeAyIyFgaIyFgYICJjYYBIgPg5RGQsDBCRsTBARMbCABEZCwNEZCyfQ8Q37zkgImNhgIiMhQEiMhYGiASIn0NExsIAERkLA0RkLAwQkbEwQETG8jlEfPOeAyIyFgaIyFgYICJjYYBIgPg5RGQsDBCRsTBARMbCABEZCwNEZCyfQ8Q37zkgImNhgIiMhQEiMhYGiASIn0NExsIAERkLA0RkLAwQkbEwQETG8jlEfPOeAyIyFgaIyFgYICJjYYBIgPg5RGQsDBCRsTBARMbCABEZCwNEZCyfQ8Q37zkgImNhgIiMhQEiMhYGiASIn0NExsIAERkLA0RkLAwQkbEwQETG8jFEh2/ec0BExsIAERkLA0RkLAwQCRA/h4iMhQEiMhYGiMhYGCAiY2GAiIzlc4j45j0HRGQsDBCRsTBARMbCAJEA8XOIyFgYICJjYYCIjIUBIjIWBojIWD6HiG/ec0BExsIAERkLA0RkLAwQCRA/h4iMhQEiMhYGiMhYGCAiY2GAiIzlc4j45j0HRGQsDBCRsTBARMbCAJEA8XOIyFgYICJjYYCIjIUBIjIWBojIWD6HiG/ec0BExsIAERkLA0RkLAwQCRA/h4iMhQEiMhYGiMhYGCAiY2GAiIzlc4j45j0HRGQsDBCRsTBARMbCAJEA8XOIyFgYICJjYYCIjIUBIjIWBojIWD6HiG/ec0BExsIAERkLA0RkLAwQCRA/h4iMhQEiMhYGiMhYGCAiY2GAiIzlc4j45j0HRGQsDBCRsTBARMbCAJEA8XOIyFgYICJjYYCIjIUBIjIWBojIWD6HiG/ec0BExsIAERkLA0RkLAwQCRA/h4iMhQEiMhYGiMhYGCAiY2GAiIzlc4j45j0HRGQsDBCRsTBARMbCAJG2gZjKA2J6D/FWdznUM/b50juTfRIQPib75BN8TPZJD/iY7BPt8zHZJ3jnYuKv/TZifs8kxePalOKr6HZd0d26og+N9u5T0PgpwvgpODw1pWOKG5X3NiZrjkOBLNGzje/yJGHyZGHylLny/DoFjl/2Pjcuvjn08+KnX/6SneV7UVfJbheW3UmW3cdyXpzTk+y1zXHqSc6mFz29Ej1psp6O4ik6lfcXZ0NHhOgfl7qUKteWfPxuKb9fe9czKNEzKtEzKdEzK9Gz6NDTGyV6WiV6OiV6eiV6khI9lcRDXkk85JXEQ36beCge11pjXEXRbQKihqK0TUTUUnSbkKil6DYxUUvRbYKilqI0WVEyZxGSWopaSqf0t7s+58U258rV8fzl6J7uOuZD06BG06hG06RG06xG06JF0+D20ZSOi2OwFU03OnvjcTcnxlzRVPTZG2w4NX26zf9L07v0os/TpvSiz8im9KLPvZb00Yje4WQf0ofGDrfF5fNAKK683FmNVpGusn0Ur65eka6kSFc50cddHjkxwl0eOV7/Ls90P57O4kvw6f3FxXpzlLGfH71LuVrWefvIVSxKFE1Gi6J2G0X5nkRLDlBeoXjRUMqhZ/FPD85XobDWRFj6M26IJQBLDUsElhqWBCw1LLLjyquwZNkxyzgs72vWLH23VsTyvsCd9/FErZpm3se7NFXdx2M0Vd3HCzRVlV1f+NERxloRLLLrEReC2SgW4AUju4ZxIZiN6hi8YGhNMHfhF43y7sIvGrfdhRcdiQV3rPkSUnq/n25Fz0cLsvy4zWOL+VJVdCTGq6roSIxTVTKiYyteVUVHS7yqio5/eFUVHdHwqkp6VBUd0fCquo9fdWfp2t3+flXV7nMCBzruQ7sQaqrucwI3VV30BL4Lv+iZehd+0VPyLrzovC+eDZlLcv79Dnn/lBFZ0Tkip6KiPRmnoqLzwx8pyvaIFDnRmeRVUERHPM9QPL2c0E50DNMSXnRU0hKeJAuf41F5L8U2yvQuujMniP7paYYSvlQVHcP0q5oqqoqOeLpVJVdRVXTM8zNVw9lsOcbwm6oVOUw8kqXbn8/ZfvXNmZzOe1g5+8bV2R08Mtnfrr0jFx197YlcdBy4JXIvOsrcE7noGHZP5KIj7z2Ri84X9kROQD4b+UbZlhjk4cjlc0gV5BtlfWKQnzxyyBXkyD5HIo/+FTkhLv8LyF3whyC3e6mughGx9l/CmE4Vow0VjIifWTAiJmbBSMDIgRGxKwtGxKMsGBFjcmAMCHj+Sqhe7PFEgi21vD4g4GHBiICHBSMBIwdGBDwsGBHwsGBEwMOBMWp1MY6O9hfe5dDA6GM+ecRcKhi1uhhmjFpdDDNGrS6GGaNWF/MjjLc7iscNR/K5ci9GdkdmMRjLWZqgkit3EWX3exaIMRhT2dSyu0mvg1FroYwZo9ZCGTNGZDEsGAkYOTAii2HBiCyGBSOyGBaMyGJYMCKL4cCYkcWwYEQWw4IRWQwLRmQxLBgJGDkwIothwYgshgUjshgWjMhiWDAii+HAKPtLGutgRBbDghFZDAtGrQGPPZtQeRuaD5/4E+Ovr0pVMGoNePoxlsrDJ7I/E7EORq0BDyvGIPvzFutg1BrwMGPUGvAwY9RatmXGSMDIgVFr2ZYZI7IYFozIYlgwIothwYgshgOjRRbDghFZDAtGZDEsGJHFsGAkYOTAiCyGBSOyGBaMyGJYMCKLYcGILIYDo+wPxK2DkbbEmFwDY4qHgik9fpjiF5U945dPqewZjnxKZZ/oIqXzO2zZ+AaV4vP5RV4yT58qqP20D49PoEbzkOPXNy4rR1w5e2Q5a99fbK1Jx/NPt79LfhbkbqB94pY3Brqruk9skV05Vf3tO+Ffqm70UaMc6VQ1xoqqkk8Ya4w5FuXtb6L3ypbkzovt08Ebvjarl7xZb/oleohfbMOwJh/KOheeVkHtOLXx8f2MZE3j4ttBd555Pr+/OJdDw2JrG0nymbElcdFfN9mTuOR7NWsSL8U/Tv3ciBVjMYcYsdhGrJgdHTiyi+4lnhP9ORYY84fGlHzfCsb8oTEJxtzHmJJrYDDmD40puXQHY/7QmMLrATDmT4yJgsdGxkQtZaIx/0AeUEyZjhzVlOnIUfOYjhyVienICchnI0eWz43cGmdOock04k9b4nn7tJRtHroISGvY15U/P3hkfXGVvYzsYzrziPRjLPNSYY78Yz5zJCDzmSMDmc+cwHy6D0UOMp85bgjOZ477dvOZIw+dzxx56HTmor+Luitz5KHzmSMnms+cwPwj5neKyHI4KCJv4aCITOSvUHTmvJHnbIUicgsOisgWGCiK/qLoOhQR0XNQxL0iDoqIF/8SRR9PitG+UoSP/ksUH20Z/NNXoU6K8NF/haKncy36TC8URX8vbx2K8NEcFOGjOSiiGslBkUCRgSLiRQ6KqC9yUER98a9QJHfKQYneXxzpkCLGh4I31JVrS85P+jUuJn++IkL0lIf+uvpuTKRQGxkTmdw2xoyiv0cKY/52cbjdW/+6Otgnl1m/OkZvTjm8rZgeWbBa0yN1V2t61BvUmp5geq2mR2VHrelRjlJretTQ1JoeFTe1pkd9TqvpRX+XG6YfanpU89SaHtU8taZHNU+t6Qmm12p6VPPUmh7VPLWmRzVvU9Mnbw6Zk3exYnpU89SaHtU8raZ3qOapNT2qedua3ofT9CFVTI9qnlrTo5qn1vQE02s1Pap5Gkz/9K3Hh+mR129r+vwwfam8eOWQ12s1vUder9b0yOvVmh55vVrTE0y/qekfMifyvmJ63LTVanpCmLer6XM4FEw51kyPMG8d09PZ6D7Qk8gPYyJw28iYuMWykTEJxlzGmOlMkkI2lccbCbdBNjImHlPeyJjIYTcyJm45bmRM3ETcx5gB9aKNjIkK0ELGjOY0pmsV/6wr8fxxb0zlsZ6AipFi46PCpNj4BOPrNT4qWLsa35vzjt/t79qjvAEVL8XGR4VMsfFRUdvX+C4+Gd83Y4REJxGXom1dH0I+7nDe/i6lsrhQ4cPiGrW4IiqOWFzDFhcqoFhcwxYXKqxYXMMWFyq4WFzDFhdhcWFxjVpcqEBjcQ1bXKhwY3F1Ly5zLq5oKo/yR1TQsbiOxeX90+JqSWMpm5MgZVup0Cdki1hcvYsr5MfiSpWX+xOyRSyuYYuLsLiwuEYtLmSLWFzDFheeith3ceVTaG+day4We77HffubQmWx4CkHLJa/ulgynlrAYvnLiwVPIWCx/OXFgjoRFsuxWOLTYsmVNzwz6j5YLH95sRAWCxbLX10sqMtgsRyL5fH2yW2xtK9v3gsryJ6wuHoXV0xPRb/Kp2wKsi0srmGLC9kZFtewxYVsDotr2OIiLC4srlGLC9kiFtewxYVnvrG4hi0uPPONxTVsceH5Iyyu3sXVerit4HklLK5BiysZVOixuIYtLlTosbiGLS7C4tp1cVn36H5rg6kYH3UoxcZHnUix8VHHUWx81FkWMv7ZtiOkkCrGRF1jH2Na1BE2Miby9o2MiSfZNjImnhzbyJgEY+5jTFSkNjImKkwbGRMVo42MiQrQRsZEBWgdY5ZwgA4lv/azSA555jLGjOb8oni0trIzHfLMjYxJMOY+xkSeuZExkWduZEzkmRsZE3nmRsZEnrmPMT1Sk3WMaU/Q0f6pMfjdmPCZGxkTPnMjY8Jn7mNMwtN5CxnzvDq6Pz0E/Xp1dnTInF18vFZl85fl8SifVsvjfoxWyyND0mp5guWVWh63hbRaHveQtFoexTOtlkelTavlUZbb1PI2Bn9+qyWG+Po5jRRQxlNsfFTyFBsfxTzFxkc9b1/jPzSMIdeMj/R+W+PHRw/FmEzlWaeADH9b4yf3OPZvRbyK8ZHkKzY+8ny9xo/I8xUbH3n+vsbP8WH8UmlqHZHnKzY+8nzFxicYX6/x8fSOYuOjwqfY+KjwKTY+KnzbGj8bcxo/W1sxPip8eo2fUOFTbHxU+Pb1+U/387NtfubOPVpk3v6OtnV9CPksH4dQSmVxoYKIxTVscaFCicU1bHERFhcW16jFhQorFtewxYUKLhbXsMWFCjEW17DFhQo0FtewxYUKNxZX9+I6i6ghmsqnoDMq6Fhcx+Ly/mlxtaSxlM35+/Tn378vLmSLWFy9iyvkx+JKlbv+GdkiFtewxYVsEYtr2OJCtojFNWpxFTwVse/iCk9PQsaa8fHUgmLj46kCxcYnGF+v8VFnUWx81EEUGx91CsXGRx1BsfFxV1it8bPBXVvFxkeFT7HxUeFTbHxU+PZ93dWn0/g5pIrxCcbXa3xU+BQbHxU+xcZHhU+x8VHk2db45fEofyyRXo1vUeRRbHykevsaPz6O/ZJKxfi4sbOr8ZOzp9C3v8Or8R3Ku/saP/iH8bOpGB/l3S2MfzcmfPhGxiQYcx9jopy6jjFdSKcxc/rg6rvpUUxVa3qUUtWaHhm1WtOjhq7V9B4V9E1Nb3N8vDh9+7tSQfeooyk2Pupoio2Pupti4xOMr9f4qOspNj4qe9saP9lwGj8FWzE+anuKjY/qnmLjo76n1/iECp9i46PCp9j4qPApNj4qfIqNTzC+XuOjwqfY+KjwKTY+Knx6jR+Q529r/GzOD+DlbCtP6wdE+9savzzt/OJrO59g/D8b/w4GkfA3YBAlfgNGbQSV/HnKJB9fwai9f9gCo/beWgNMVBuPtsCovSfTAqP2fkULjNroPsWHu47uFQwBTB2M2si3BUZt5NsCozfybYDRG/m+B5P0xjH54a6fCjgnGLVeKftHnZLoFYxar9QCs6xXuou/rO+4i7/sCX8Xf9kKxB/i52XrBHfxl/WCd/GXzbnv4i+bGd/Fp7XFX9af38Vf2+vmtb1ulu11ybhTfErmfTAYzaOZ3iMUtLfc4K6qbA/NqWqR7c1ZVZXt+VlVlR0lsKoqO6JgVVW2//uZqnR4m/j0cNxD1Z1O4Ph4MCm/qFqEf/j0jap38Zc9Ve/iL3tS3sWXffplOguvprjwfp9Ymx+95G/b46Ft/FKWNCkrO1djVla2Z2NWVnYeyKys7KyRWVnZUQuvssK/5cWsrOwoh1nZvfxsNqeyt2j1SdnXq4s9JSn26U7xAWavk/snYNwZiBb3rOMXmL1OeUYwe3kEPjBuWe9xF39Zf3AXX3bW2xRfdtZbHo8b3bJ2/yq+bP/aFF92ZtoUX3au2RRfdgzSFF92pNAUX7Y/b4kv/OsRTfFle92m+LK9blP8tb2u8C7qTfFFe11r46OkYPNv4ld+25XjRqd/FuQrN5Dd9ZpXVdHenFdV0Z7/h6r6WE5Vf6sTvV5L9sRCzr7UlGT3+r0Mi+wuuL9jKa+ntew+rjfx3ZP45VV80ZGKdeZ8VNHe5vnoWJLdd5NXVdKjquxo6WeqMp6qsiOry7DIjsJ+w+Lp9bSWHlnZJ/Ffq7kkOwIKdPYKu7nNj57gLLJ7/vGqKjsCYlVVdrTEqqrsaIlVVdKjqmz/9zNV3z5YXmR3ufqhqu8fLJfdt8pm8/QQUizvVXUpnYKk9PI0gexOVLyqyj6BWVWVfQKzqio7X2VVVXYOyqpq2kdVm+JT07tIr8rKzkKZlZWds/Iqm2THTMzKbhQ1tZXdyMPalB6Ptd/+Li/KbnUa39zNQ9kcX5Rd9jS+i7/s+fqH+LJ7JLXFl30G3mqLp/ilpFfxZWeDTfFlZ3hN8WX7lKb4sjOxpviys6um+LJ9dFN82V63Kb5sr9sSX3Yvo7b4a3td2T2H2uKL9rrOuvOJLWef29dWy1Ku2FMQ8/jtX23d7sqK9tHcyor26NzKivb/3MqKjhY+UNa6irKiYwtuZUVHIqzKkpHdAeyHyvqzLuV8CRVlRUc53MqKjom4ld0pgmoqS5qU3SmCaiq7UwTVVHanCKqp7E4RVFPZnSKocDYEcSHaV2XtTn62qexGp/EtrTuu9ubp9cKHshudxm1l5ZzGd3nkHJh3eeScaX/IM72J1e1G//HL2dn3F0c631GN4ekj96fwdmXh3crC+5WFp5WFDysLH1cWPq0sfF5Z+LKw8H5lD+tX9rB+ZQ/rV/aw0xtVsQq/sof1K3tYv7KH9St7WL+yh6WVPSyt7GFpZQ9Lkj1senzrO5lSGr/8rpPQTVHJ3phVUcmem1VRyV7+Z4pytUC6QZEcPVwGRXJUkiydUJ6/VVK9mPLBJDwJ8WvUy6UhHdqFJ9Q2fyGRHOtcgyRIjqAuQiI5LrsIieRo7yIkomPInyB53LIPIT0juetJSvQUHUH+RM8YDz1jca96ig4gf6YnndfGVz1Fx4Q/0/MQOTl61XObMK+h5zax23s9o+iAzFl7yp7C+4stpbP1a7BPTwzl2vNFb7v83bCIDsquwyI6MLsOi+jg7DosBCw1LKJDv+uwiI4sBmJ514SVTNLqid41bL1h2ccTBXv2HQtPHet/Ybmruo93aaq6j8doqrqPF2iqKroG8LMjjOxD1dA4wmxx+Tzxiisv90yS6KLBlWA2igV4wYguS1wIJm9Ux+AFIyd+vMsjJ3C7yyMnurrLQ5Plyd6e8iTzKs/kOOW2+o9bZhRyY6+4W0nz+OWUH3cfkq1cXPyZUhSf0vuLG8/FzG4dKIUK3/Mis7sXbkgwb0OQ7HEmFvL2o505uzMgeXNYnzy9Pvw5u30cRXOc5xTp1b/M7gNG+dwdwZoKnyxMniJKHju74dWtMnfK41IjsM3n1xazf4juUu35lnLGPaX8fu1dT6tET6dET69ET1KiZ1CiZ1SiZ1KiZ1aiZ9Ghp1USD1kl8ZBVEg9ZJfGQpV30PJ/3veVgrqLoNgFRS9FtIqKWotuERC1Ft4mJWopuExQ1FJ3doK5RZbSze8415fHC5KHZ8oSzSh2Lf5UnCJMnCpMnCZMnC5OnyJJndi80enwmknJo9QuJ54PQ+XHD3dnwJbtdWHa3sOxezJ2fSgAQzBEA2KcWMzYcC55WFn72af/+nq2d3R6sKU8WJs/s0/7204c8ZPL7i+2j2b/xjbCase4xuzfYEkwsmLwwcRqZNNLX2R3S1oBCgPIKJQDKK5QIKK9QEqC8QtnmmdEczgrALRWh54vvmhYtms7uqXahplaNpk6Npl6NpqRG023eGWpqus17QE1Nt3lfp6mpmhgpqImRopoYKaqJkaKaGCmqiZFmtwy7UFM1MVJUEyNFNTFSVBMjRTUxUtomRmLs9GDTNvEUK5VtYi/G3gM2bROnsVIhnVTYOn3YtE8PnqsI7tOvh9LRbbEEE169+D59dVqabtT/pqHpNjFoS9O8Twza0nSfuLKl6UaxYkPTjeK/hqakRtONYq+GppJjpNuvnTnGTdX3mt4C5iPKvEV+DzHCVzQouvcgr6aSYyReTSXHSKyaFskxEq+mkmMkXk0lx0i8mkqOkXg1pW00LeXQ1JmnR5tDvRLjz+egLVWwSA6oRmIx5S2WfaKvEk4xjHcNLCadZbvHpZZc7Ydzeey4XOLTO7zFfVHcJ7K7kuI+UeOVFPeJSK+j6Mw+0e6VFPeJpK+kuE+UfiXFfTKAKykSKDJQ3CgZuZAichcOishdOCgid+GgiNyFgaJF7sJBEbkLB0XkLhwUkbtwUCRQZKCI3IWDInIXDorIXTgoInfhoIjchYGiQ+7CQRG5CwdF5C4cFJG7cFAkUGSgiNyFgyJyFw6KyF04KCJ34aCI3IWBokfuwkERuQsHReQuHBSRu3BQJFBkoIjchYMichcOishdOCgid+GgiNyFgSIhd+GgiNyFgyJyFw6KyF04KBIoMlBE7sJBEbkLB0XkLhwUkbtwUETuwkBR9JcI16GI3IWDInIXDorIXTgoEigyUETuwkERucvvFO9UkIvUqCC3qFFRmis82jo+/e5JRfQXNq+jsk0s76w5uoc76/wzlbum28TbTU23iYmbmpIaTbeJLZ31/tS0lFdNt4n/mppuE9M1Nd0mTmtquk3s1dJU9Nc4eTXdKEZqaLpRjNTQlOZq6rO3xy/nZJ4vvssThMkThcmTZsuTT3mKs+8vtik/8rFHRevXJ2xfrs3m+CBS9qVxbcnntyjL79femWQweWFSwOTPTGZ/s1AGk3hca41xFSgWUF6hOEB5heIB5RUKAcorlAAor1BmR5LFuyOnuE3egHIrTRzSe/uUU1Dtl6M7anQ+5vJ88V3TpEbTrEbTokXT2V9tvFBTq0ZTp0ZTr0ZTUqNpUKOpmhipqImRipoYqWiJkbzREiN5oyVG8kZLjOSNlhjJG1KjqZYYyRstMZI328RI5P1RHCRPpYHlFjIdCj7LHL+obBNPsVLZJvYin467mEQtKpbSWXUO9lHOtjlXro7mECO6+HTtvULt7TZR3YUMt4kXL2S4TSR6IcNtYtwLGRIYfsxwoxhuHEM6Lo7BvjJ08Mt/gWE8ZI4xVxgq9cvBhpOhp98Y3rko9bVNLkr9Z5OLUp/Y5LJN/emHZzTZB5fQOKNtcfk80svtHtifs3i3TW3rUopaYy5eihvV2S6kqLUux0rRL5oB3IVfNPS+C79ofHwXXnQQ690jpMrp/X5y9twgjmx81ZTUaCo60GTVVHQwyKqp6ICNVVPRQRWrpqIDH05NSXRwwqqp6EiGVVPRYQ+rpmpipNkfZrhQUzUxEqmJkUhNjERqYiRSEyMFNTFSUBMjhX1ipGCOaqULT41UT033iZHIne2wApn3F/O1nvGzG8tvSHCfmO4qgvvEilcR3CcGvYrgPrHtVQT3iZkvIhj3icWvIrhPjH8VwX1yh6sIIif5lCCB4IcEkZN8ShA5yacEkZM0Cb7vzOgjkpKPESIr+RRhQlryMULkJR8jRGLyMUINmcldU1KjqYZI/67pPsFQOMXw3sf3F5PNpxSP37X56wWMsR8EuE/BcGz4841p51ufEXIpnl/aS+nxenU4VCZh8gRh8kRh8iRh8mRh8hRZ8nD0GWeVx86WpxwHv8tP5+EpjxMmjxcmz+Tz2TtzfKPOuycfecoThMkThcmThMmTp8tj3shDZvL548meH40hZ17lccLk8cLkIWHyzD5//KMhJdnf5KmlF4/Pz1uiV+GjaOHPk6Qu/OyT7XZ4ncI/NczqI59FC98gX2YLf/ZA8FTyizzWCJPHCpPHCZPHXydPeKqdnvKQMHmCMHmiMHlmn/zenSW9YNP7w9PGfJz8NtFDeHv7+y797NMzPT5TmIr/zG85I1r4937LzT6XEz2+qv17Ll1ZN6YcYtibEV7XjZt9imdHp/SVU9x5YfKQMHmCMHmiMHmSMHmyMHmKLHlkN9S66BYdye7UdRmVfR5G4KRCOqnQGVKG36nUCJYHQvvnjoS0URuyqwju8+jzVQT3efT5KoJKH/ZhJLjPg88XEdyofdxVBJXmA4wEleYOjASV5hmMBAkEPySInORTgshJPiWInORTgshJPiWInORDghu1a7yKIHKSTwkiJ/mUIHKSTwkSCH5IEDnJpwSRk3xKEDnJpwSV5iT+hBKpQfDND98RKk1KGBFu1LjyMoRK05KfIMzlkMK7aN//sC3phGGfLrbhAK40i7kOuNKkhwf4HSEB4acIlaY93yK8U9H6Senz4WcbrH/ikitXRzoujk+vR9qcvhhq/aD0jximY4HHHF4Zym41KIahPRnGCsNFv2otiuGiH9cWxVB0vLcIQwLDjxmKjvgWYSi61L0IQ9HFbikM4yFzjLnCEHnK5wyRp3zMMCNP+Zwh8pTPGSJP+Zwh8pTPGRIYfswQecrnDJGnfM4QecrnDJGnfMywzI4P0/k9M5+dfX9xcmfP1+RSo20O622m4pRieX/nqHitWN4WnTh6se+IJQBLDUsElhqWBCw1LBlYalgKsLxiCcYoxfI2yg1Ga5TbwKI1ym1g0RrlNrAQsNSwaI1yG1i0RrkNLFqj3AYWrVFuA4vWKPc9Fosot4oFUW4VC03G8vzVFJ8amjrrDulvf4enuwo1VV3Ix12F25+PGwW22C9lgyZloyZlkyZlsyZliyJlndlI2eTPz3okMhVlrSZlnSZlvSZlSZOyO0VQTWV3iqCayu4UQbWU9Tv52ViO3PH2p68ou9NpnPPx8URXTKgou9Fp7M3ji57GVcJFv9Fp3FZ2o9O4rexGp7E3yZ3K5t8PqJ9dfUezUfbLjWajXPlnaGIO5yOrOT2qrffmMoE28ve8YDbKwXnBbJSv/xDMLa46wBSXXsBsFE3ygiGAqYPZKkrlBLNVRMsJRm302wKjNvZtgdEb+b4HE/RGvg0weiPfBhhEvt+AURz5Pl4ILeEVDAFMHYziyPc9GMWR73swiiPf92AUR77vwSiJfP9QNm77FA1VlN32KZqasqRJ2W2foqkpu9VTNO6hrG/er3Pnh7P8s9hfJ3fc6okbTjA7Pd/MCmanZ6F/BsbHcoLJz0HQ67Xvv1cX0lbPWF8Fcatnt6+CuFU0exXEraLkqyASIH4Ocauo/iqISrKFu7JbZQDxFCSlXFF2q6g+n8/cp1J5fjdtFak/WbambN4qom4pu1Xk21KWdnp1JBx3d29/1pTdyX83ld3JzzaV3cnPNpXdyc82ld3Jz7aULTv52UzuvbKa3lqc3iP7UmW38rMtZbfysy1lt3I975WNRnQiYPMpx+3vWN4ra1MK5+W3v8ufyjLRiC5V/1jZlB/KPnWKPpQV7Xq4lRXteriVFe16uJUV7Xq4lRWd4nErK9rPcisrOsVjVtaKTvG4ld0rgmooqymCspoiKNktdLmVle1nA53S2+jMe2Xff+Yuym6z+kNV3366LspusvpTVd99BCjKbrHKq6ps/8qqqmzvyqqqbN/Kqqpsz8qqquzKBKuqsusSP1P17dcVouymqryq7hQtNVTdKVp6r6rsRrm8qu4ULTVU3Slaaqi6U7TUUJX0qLpTtNRQVU+0JLvpMa+qeqIl2S1mTaajMmZNceG9qrcKajYnmWKe28a+Xl3sKUmx+c+vukTZLWavBCPaZw8F4+zx28W5VzAEMHUwouOBK8GIjh6uBCM61hgLxtsTjH950k92i9krwYiu+lwIRnaL2SvB6I18G2D0Rr4NMIoj3/dgSC8Y4x5xTH4BozjyfQ9GceT7HoziyPc9GMWR73swiiPft2Ci4sj3PRjFke97MIoj3/dgFEe+78EQwNTBIPL9Bgwi32/AIPKtg5HdEtfQKfzt7/TZSx2yG9f+UNX3L3XIbi/7U1XfPlIsuwksr6qkR1XZHp5VVdk+m1VV2V6YVVXZFSVWVWXXiH6m6vsH2mS3O+VVdadoqaHqTtFSQ9WdoqWGqqRH1Z2ipYaqO0VLDVV3ipYaqu4ULTVU1RMtyW5ay6uqbL9qEp2q/vEdj3eqOpPP/rzuuVdmqP12ymfpMj09z3+7+A5GthceCCbbI2uy2ZVXMLJ99oVgZHv4C8HIjgcuBCM7ergQjOxY4zIwyciOTC4EI7vqMzKOOb9NZrPJr2Bk14guBKM38m2AIYCpg1Eb+bbAqI18W2DURr4tMGoj3xYYtZFvA4zsLuNXgkHk+w0YRL7fgEHk+w0YApg6GL0133h2ov+tEf0BRm/N95T6di/JvILRW/NtgNFb822A0VvzfQ9Gdvf/K8GojXxbYNRGvi0waiPf7MsJhugVDAFMHYzeyLcBRm/k2wCjN/JtgNEb+TbA6I1834OR/SWHK8HojXwbYPRGvg0wiHy/AUMAUwejNo55vDZqb7cdGxeTO+WgRO8vjvR4Fv+hoA81diXnJ/0aF0cXDtDR5dZP/2rD8TB9flLx1/V346uN1RQY/9GzJefgK8ZXG4/C+InUxtwwfhL+3RsYf6jx1eZOMH4S/v0iGH+o8QnG12t8tXe4lBk/uorx1d7F02B8ehg/hdavF3M2Syv28eu2hjq787eze1pXt4vvywq1QyyrAcsKVUksqwHLCvVOLCv+ZSX8G4NYVosuK9RosawGLCtUf7GsBiwr1JWxrAYsK8Ky2nVZFffo9FVcfC1aCv8aKIz/yZlSHk+mFVN5Mk349yth/E92vn3crijeVoyPaELxzicYX4XP9zXj4y61YuPjLrVi4yPaV2x83PHd1/j+UT4qTy+gPYyP+7J6jS/8+84w/lDj4x6nYuPjTqRi46PCp9j4BOPrNT4qfHpv7CRU+BQbHxU+xcZHhU+x8VHh02v8jAqfYuOjwqfY+KjwKTY+KnyKjU8wvl7jo8Kn2Pio8Ck2Pip8eo1fkOevY3x7Xn1bB6Zl/OT8+ePJUaW7XEGer9j4yPP3Nf7jw7jJpVIxPvL8bY3vTTw19K7SV7IQjK/X+MjzFRsfeb5i4yPPV2x8PMmj2Ph4kket8bNBhW9f49OT8UOoGB8VPsXGR4VPsfFR4VNsfILxtzW+fzZ+rBgfFT7FxkeFT7HxUeFTbHxU+BQbHxU+vca3qPApNj4qfPsaP5uH8XOpGB8VPsXGR4VPsfEJxtdrfFT49jV+ejJ+MRXjo8Kn2Pio8Ck2Pip8io2PCp9e4ztU+BQbHxU+xcZHhW9b45M9hU7kfMX4qPApNj7B+HqNjwqfYuOjwrev8c2z8alifFT4FBsfFT7FxkeFT6/xPSp8io2PCp9i46PCp9j4qPDt24QxP5owkg+t68nb83qqdvLwhMWCxfK1WHx4LJZgm9fncApPOeXK4kLFEYvrWFzhoaSPlQqlR4USi6V2ElUXCyqaWCx/ebGgAorF8pcXCyqmWCx/dbEQKqxYLMdiOU1z+7u4z7MnQgUXi+tYXOVxEt0KgJXFgoovFkvlJKovFlSIsVj+8mIhLBYslr+6WFDxxWL5y4sFFV8sli8dyabHYvGeIXtChRiL61hc/ukkolBZLKgQY7HUTqLqYkGFGIvlry6WgAoxFstfXiyo+GKx/OXFgorvvoslPBaLy5UWDgEVXMXGJxhfr/FRYVVsfFRMFRsfFU3FxkeFUrHxUXHUa/yICqJi46MiqNj4qPApNj4qfIqNTzC+XuMjz9/V+LHE865eLKlUjI88f1/jl0djdmMqzVgi8ny9xk/I8xUbH3m+YuMjz1dsfOT5io1PML5e4+NJHsXGx5M8io2PCp9i46PCp9j4qPDpNX5GhU+x8ZHnL2P8YH35ujrYTI2rE8Xjt29/Vu7pZYLptZoeOb5a0yPD39X00R7dOFN0qWJ65PdqTY/sXq3pkdtrNX1BZq/W9HhyR63p8dyOWtOjmqfW9MjrdzV9yIfMKZRKDb8gwt/V9KkcNkzZ2xfTF4MIX63pEeHvavoc7Gn6yvfdikGEr9b0iPDVmp5geq2mx/16taZHXq/W9Lhfr9b0uF+v1vSo5mk1vUU1T63pUc1Ta3pU89SaHtU8taZHXq/hUY3anTuLvF6t6ZHXqzU98nqtpnfI67c1fTyf0okpV0yPO3fbmr4cZknJhorpEeGrNT0ifLWmR4Sv1vSI8LWa3iPCV2t63LlTa3qC6Xd9++b8HNbtT6qYHnm9hhevrG9cbX99A/tUMddKQB51gG1v8tp4LpVa4dejDqD19UyPOoBa06MOoNX0hDqAWtOjDqDW9HiCV63pUQf4K6Z3/pDaumifL75TRIr8Vyh6e/yy9Z5eKSLb5KCIxI2DInIgBooB6QQHRUTmHBQR5HJQxBtffyleTA+KprxSJFBkoIjchYMichcOishdOCgid+GgiNyFgWJE7sJBEbkLB0XkLhwUkbtwUCRQZKCI3IWDouR48VZxOiDe0oPUYOjIPxg+ntq0xdTkcOW4ZeifhY5fWCQHgNdhSZIjupFYfCwnlpyesLxeS/ZESM6mF4SSw7lFEEqO5RZBKDmQWwQhAeGnCCWHcIsglFx7XgSh5MLzzxB6CqcYyTQQhnQoGMojMbD5i8o+iQEnlX3yAkYqeZ+0gJPKPpE+J5V9gnfKRx3G3fRqUInFHFfH8uSEbO2ns6NDjuyie4W4T/h+IUQCxM8h7hPCXwhxnyD+Qoj7hPEXQtwn6r8Q4j5JwnUQyz5xYnBnYSO48BvEu6r7+NBA5lQ1mIqq+5wv4fy8w+2Oba6ous8p8F7VYER/g55Z1X2S+qaqG53ALVX3yaebqpIeVVX41R974RuYffJNZjD75JA/AhNzOH465vR4WC1+YdkoauPEslGEx4hF9DdMR2IpJpzpr0svWDaKHDmxbBRlcmLZKCLlxELAUsOiNNJtYVEa57awaI1yG1i0RrkNLFqj3PdYRH/R70IsaqPc83ZWvP32Cxa1Ue57LGqj3PdYCFhqWNRGue+xqI1y32NREeX+oarob48VW443NYpP8b2qv9oCf11sw9OnV2yuXR0fCyDYp2vTFxbRschALOmM0HKoYBEdi4zEcj6dlGMFi+hY5DosBCw1LKJjkeuwiI5FrsMiOha5Dovoitt1WERX3AZiiY8vPuRXLKK/rHMhFq1RbgOL1ii3gUVrlNvAQsBSw6I1ym1g0RrlNrBojXIbWLRGuQ0siHJrWER/8OVCLNPjFnM2QiQq7y9mrVrP/7LFOE3fF6Lnf31ioKZvM/r5X4i4TNOkRtOsRtOiRdP5Xyy4TFOrRlO3j6bvY6S4UYzU0JTUaLpRjNTQdKMYqaHpRjFSQ9ONYqSGphvFSO81TRvFSA1NN4qRGpqqiZGSmhip3tbapkMcZx4TuF+PoL5cm83ZocuXxrUlH1XEUn6/9i5MliRMESRMvXfyVcJYScI4ScJ4ScKQJGGCJGGiJGEkncBZ0gmc557A8fSqxrhXaYoRJY0VJY0TJY0XJQ2JkqZ+2tB5x9aG8BgWYlWcY9fmp1DVkvuaIQ+foQyewdZbVbLOYIfP4IbP4D+fIRz3fvPTgwK/ZqhkVLdj5tgz1jyupuoP5yNVK9a1ftiXQ09H5nEL2nv6UpS0KBq0KBq1KNo+79Nvit5H5a5RpWeU9aPPKUvDZwjDZ4jDZ0jDZ8jDZyhKtrUzWhS1WhR1WhT1PV7CUdeo0DOKvllzPym73674uji4p4Pqq+xuyY2fwo+fgsZPEVinIFOZIo6fIo2fIo+fonw+RTxvdEX3+hiWDWb8FHb8FG78FH78FDR+ijB+ijh+ijR+ijx+ivG7O47f3XH87o7jd3ccv7vj+N0dx+/uyLEv3r5pYxPHinr7EIatP1hz+91wTuHptynuw3zfMOobFvqGfXP+kn0MCw18trh80i6u/LmLm/3mKRbmSfKMScqESb55moR5EjtjEjdjEj9jkjj8JMscccrbl/VszuOnKMOnKGb8FBxe5e0rLba48VP48VPQ+CnC+Cni+CnS+Cny8FColNFTOGPGT2HHT+HGT+HHT0Hjpwjjp4jjp0jjp8jjpxi/u+343f3N/WSTzmG//i5/ivDcNzeJTSpnBmWyjS/DYt+w1Dcs9w2rG9Zk7x/DnppSfw375jZmc5jtG+b6hn1jt3J+WPT2d7Qvw74hWfLRpttaY15IutI1zJu+Ya5Lt3oX5PawbzZOKf5JyPAyLPQNi33DUt+wurlvl5bHMPdsgNdzh24R1tfFdNvAL1OU4VPUu2fyTmHHT+HGT+HHT0HjpwhdpwbFvmGpb1jfQUp9B2noO0i/uavYHOb6hvm+YdQ3rG+VhL5VEvpWSehbJd/czEnpHJXyU7uz6veikzkfpUnOvczgh89Aw2cIw2eIw2dIw2fIw2coo2dIZvgMdvgMw/d0Gr6n0/A9nYbv6TR8T6fhezoN39Np+J7Ow/d0Hr6n80/39H2U7xpFXaNC16jYNSp1jcpdo0rPqGK6RtmuUV1ro3StjdK1NkrX2ihda6N0rY3StTZKz9rwxnSNsl2jXNco3zWKukaFrlGxa1TqGpW7RnWtDdu1NmzX2rBda8N2rQ3btTZs19qwXWvDdq0N27U2bNfacF1rw3WtDde1NlzX2nBda8N1rQ3XtTZc19pwXWvDda0N37U2fNfa8F1rw3etDd+1NnzX2vBda8N3rQ3ftTZ819qgrrVBXWuDutYGda0N6lob1LU2qGttUNfaoK61QV1rI3StjdC1NkLX2ghdayN0rY3QtTZC19oIXWsjdK2N0LU2YtfaiF1rI3atjdi1NmLX2ohdayN2rY3YtTZi19qIXWsjda2N1LU2UtfaSF1rI3WtjdS1NlLX2khdayN1rY3UtTZy19rIXWujqy7qu+qivqsu6rvqor6rLuq76qK+qy7qu+qivqsu6rvqor6rLuq76qK+qy7qu+qivqsu6rvqor6rLuq76qLUVRelrrooddVFqasuSl11Ueqqi1JXXZS66qLUVRelrrooddVFqasuSl11Ueqqi1JXXZS66qLUVRelrrooddVFqasuSl11Ueqqi1JXXZS66qLUVRelrrooddVFqasuSl11Ueqqi1JXXZS66qLUVRelrrooddVFqasuSl11Ueqqi1JXXZS66qLUVRelrrooddVFqasuSl11Ueqqi1JXXZS66qLUVRelrrooddVFqasuSl11Ueqqi1JXXZS66qLUVRelrrooddVFqasuSl11Ueqqi1JXXZS66qLUVRelrrooddVFqasuSl11UfqmLlrs+fZJCfll1Hd10XK8fumMKc+jaj1eub4gQd/VWy+SxomSxouShkRJE0RJE0VJk0RJk0VJUyRJk0WdxVnUWZxFncVZ1FmcRZ3FWdRZnEWdxVnUWZwnn8XvP3VEuYgSpxhZ4lhZ4jhZ4nhZ4vz0RL6PCl2jYteo1DUqd40qHaOCMV2jbNco1zXKd42irlGha1R1bbinJhP56RX76ra4VbiPa+Nzu9ha9wr3KDZ46+z7H46GjoujyU8/bd2X8Emw8OH8dkcM2VaEzysLXxYWvn7nfRXh7crCu5WF9ysLTysLH1YWXrKHbQq/soe1K3tYu7KHdSt7WLeyh3Ure1i3sod1K3tYt7KHdSt7WLeyh3Ure1i3sof1K3tYv7KH9St7WL+yh/Ure1i/sof1K3tYv7KH9St7WL+yh6WVPSyt7GFpZQ9LK3tYWtnD0soellb2sLSyh6WVPSyt7GHDyh42rOxhw8oeNqzsYcPKHjas7GHDyh42rOxhw8oeNqzsYePKHjau7GHjyh42ruxh48oeNq7sYePKHjau7GHjyh42ruxh08oeNq3sYdPKHjat7GHTyh42rexh08oeNq3sYdPKHjat7GHzyh42r+xh88oeNq/sYfPKHjav7GHzyh42r+xh88oeNq/sYcvKHras7GHLyh62rOxhy8oetqzsYcvKHras7GHLyh62LOxho1nYw0azsIeNZmEPG83CHjaahT1sNAt72Ci6p1NT+IU9bFy5p1NcuadTXLmnU1y5p1NcuadTXLmnU1y5p1NcuadTXLmnU1y5p1NcuadTXLmnU1y5p1NcuadTXLmnU1y5p1NcuadTXLmnU1y5p1NcuadTXLmnU1y5p1NcuadTXLmnU1y5p1NcuadTXLmnU1y5p1NcuadTXLmnU1y5p1NcuadTXLmnU1y5p1NcuadTXLmnU1y5p1NcuadTXLmnU1y5p1NcuadTXLmnU1y5p1NcuadTXLmnU1y5p1NcuadTXLmnU1y5p1NcuadTXLmnU1y5p1NcuadTXLmnU1y5p1NcuadTXLmnU1y5p1NcuadTXLmnU1y5p1NcuadTXLmnU1y5p1NcuadTXLmnU1y5p1NcuadTXLmnU1y5p1NcuadTXLmnU1y5p1NcuadTXLmnU1y5p1NcuadTXLmnU1y5p1NcuadTXLmnU1y5p1NcuadTXLmnU1y5p1NcuadTXLmnU1y5p1NcuadTXLmnU1y5p1NcuadTWrmnU1q5p1NauadTWrmnUzILe9i0ck+ntHJPp7RyT6ckuqdTynQIn335Tfja1fa8OD6Jkb4UleyNORUV3SuKVVHJXp5VUckRgaHj4mgyvR4wontQGRO/Lk45poaVfr2L/HV1yOHJpq52dbbpECTb8vhtl/IXGAKYOhjJkcylYCRHSZeCkRyBXQpGcnR3KRjJ0eCVYET3QbsUjJho8y6OmJjwLo6YKO8uDskSR0xEcxdHTBxxF0eM976LI8Zn3sUR46n+EEdOF6+7OLJOZTmdtu7iyDqV5XTDuosj61SW07HqLo6sU1lOV6m7OLJOZTmdn+7iyDqV5XRnuosj61SW00HpLo6sU1lOl6O7OLJOZTmdiO7iyDqV5XQLuosj61SW09HnLo6sU1lO1527OLJOZTmdce7iyDqV5XSvuYsj61SW02HmLo6sU1lOF5i7OLJOZTmdWu7iyDqV5XRTuYsj61SW0/HkLo6sU1lOV5K7OLJOZTmdQ+7iyDqV5XT3uIsj61SW04HjLo6sU1lOl4y7OLJOZTmdLO7iyDqV5XSbuIsj61SW0xHiLo6sU1lO14a7OLJOZTmdFe7iyDqV5XQ/uIsj61SW06HgLo6sU1lOF4G7OLJOZTlv+t/FkXUqy3kb/y6OqFM5y3lj/i6OqFM5y3mr/S6OqFM5G1GncpbzLvldHFGncpbzvvddHFGncpbznvUf4sh5G/oujqxTWc6bxXdxZJ3Kct7QvYsj61SW8zbqXRxZp7KcNy/v4sg6leW8ZXgXR9apLOvdvizr3b4s692+LOvdvizr3b4s692+LOvdvizr3b4s692+LOvdvizr3b4s692+LOvdvizr3b4s692+LOvdvizr3b4s692+LOvdvizr3b4s592+14s5m8BlOW8NjlZUjCepiP7oQBNvG7OhKN3uJ54y+3xe7Urtahtt+rraRv8Q23v/BWaNvmgXgFmjL9p8MByv2NnzWpd+A3Of4adr8j4qdo1KXaNy16jSM+rHrxbdR9muUa5rlO8aRV2jutZG7FobsWttxK61EbvWRupaG6lrbaSutZG61kbqWhupa22krrWRutZG6lobqWtt5K61kbvWRu5aG7lrbeSutZG71kbuWhu5a23krrWRu9ZG6VobpWttlK61UbrWRulaG6VrbZSutVG61kbpWhulZ20UY7pG2a5RrmuU7xpFXaNC16jYNSp1jcpdo7rWhu1aG7ZrbdiutWG71obtWhu2a23YrrVhu9aG7VobtmttuK614brWhutaG65rbdRvDdMtejlG3ZbP66hQH2Ufo361DH6XJWdz1L+ey18upcq1JR8pfim/X3uXJoqSJomSJouSpkiSpn7z9jJprChpnChpvChpSJQ0os5iL+os9qLOYi/qLPaTz+J4XGuNca/ikJEljpUljpMljpclDskSh+HhjLf3kApH1873M3A04mzMYIfP4IbP4IfPQMNnYLhHTua4Nvw+Q02axw87+7j6kCaKkiaJkiaLkqZIkoajRSWjNFaUNHMf+Gq5x8kNKpvikCxxgixxoixxkixxJj+GG+JxsYtP+7z6w/bmSw/hy9N3rI/Ps5XZ7SxZhZ/d/JJXeLuy8G5l4f3KwtPKwoeVhY8rC59WFl6yh83lKDA5438XvlJhanwutSTJ/phX1SzZezOrKtnXM6sqOTJgVlVyHMGsKulRVXKM8kNVYzhUdaZUVJUc0TCrKjn+YVZ1o2ippepG0VJD1bJRtNRSdaNoqaXqRtFSS9WNoqWWqqRHVT3RUtknWnL2oWpwjatToePqdNvFjav9Wcsh93ht21FNQ1uOOyvOWfd88R34PjHbIsD3iRwXAb5P/LoC8GjMPlH0IsD3ieUXAb5PRrEI8H3ymkWAE4DPBb5PjrcIcGSak4Ej05wMHJnmZODINOcCt8g0JwNHpjkZODLNycCRaU4GTgA+FzgyzcnAkWlOBo5MczJwZJqTgSPTnAvcIdOcDByZ5mTgyDQnA0emORk44nBm4M4/gFN4BY4ohRl4Or/u45L3L8A9opTJwBGlTAaOKGUycEQpk4ETgM8Fjnr4ZOCIwycDRz18MnDUwycDF/NZ7AoUf2bJKT13GK1+ZdUmcyC0KT59rthXzXNenJNvXOu8Oy52RB+28IhGzqe/9SAX83lzPcgFf8J9V+SCPya/K3IC8tnIA5DPRh63QR7d2S47pdjA6I2xhyAmx8nQE6DPh54BfT50rTno+QVTa0yT+aMB0O3ucfqUedCahF7JXGsWeiVzrWnolcy15qFXMicwn85cayZ6JXOtqahNh9TePX8jcQp0ranopdC1pqJXQo+CV3oM4VA1hqcP0fyCfhde8IppCy+4CNAUPgnOptvCC05L28ILzu/awgtOlNrC08rCCw7d28ILjoHbwq/sYdPKHjat7GHzyh42r+xh88oeNq/sYWd/1oxX+JU9bF7Zw+aVPWxe2cPmlT1sWdnDlpU9bFnZwxbJHvZ2e+IQvria8JI9bFN4yR62KbxkD9sUXrKHbQov2cM2hZfsYRvCWyPZwzaFl+xhm8JL9rBN4SU/ThOK+bo4xUC/CV+5tefd8ctPTW9OPQU7Y1Y9JT82wqmn5Ec1OPWU/HQEp56SH0jg1FPy4+iMelrJj4Bz6qn0setgjsf0Apnfrr1jUfpkdAuL0oeXW1gIWGpYlD4C3MKyz1O6rFj2eY6WFcs+T7qyYlH6WmQDi1P65mILi9YoNx4/HUpuXEsuHAzJ5ScVffiCqNRv/ay3xOOJe59en6G3TqmX44Wo1CfyQkRzu88herSrY4CIBnQMENFSjgEimsQxQCRA/BwiGrmxN3KLj57DplSQI7+ZjhzZ0HTkyJ2mI0emNRs52ojPR44sbjpy5HzTkSNDnI6cgHw2cmSf05Ej++RGvsT3g+1Grcxh+B8ZHpm4UsOjHqDT8Gr7yqs3PGojSg2PCo1Sw6NOpNTwBMPrNDxqZkoNj8qdUsOjcqfU8KjcKTU8Knc6DR9RuVNqeFTulBoelTulhkflTqnhCYbXaXhU7pQaHpU7pYZH5U6p4VG5U2p4VO50Gl7y12dh+JGGR+VOqeFRuVNqeFTulBoeefymhnf+YfinrxechkdUv6nh00na3UC+GF7yF69h+JGGR1Sv1PCI6pUaHlG9UsMTDK/T8Lgfr9TwyOOVGh7345UaHvfjlRpeaeWuOPt1cQmhcW0w6fx8kzXPy+Tri0xFaRWMF6LSihIvRKXVGV6IWisd+fjwnDVPCn5D0doHxRArFAkUGShqzcF5KWpNaHkpas0OeSlqTbV4KWp94oCTojNab9/zUtR6L5yXotYbyz+h6B7t653zv3+vrvLTjWb3ziDTmc+cwHw6c2RR85kj55rPHBnafObI5+YzR/Y3nblFrjifOTLL+cyRh85njjyUnfkSrww6S7C8UssjJ9dqeVQGtFoe9QmtlkeVRKvlUatRanmHipFWy6NupdXyqJ5ptTxqeFotT7C8UsujhqfV8qjhabU8anhaLY8anlbLo4an1PIeNTytlkcNT6vlUcPTannU8LRanmB5pZZHDU+r5VHD02p51PC0Wh41PK2WRw1PqeUJNTytlkc+v6vl33+RzRFi+10t/76jtyPE9lotj9heq+UR2yu1fEBsr9XyuD+v1fK4P6/V8sjntVqeYHmllsf9ea2W3yefv6Wop+VT05jFnLXNElqf5SNjjoVChp5X1Vdj+biP0/wRRm/M8VEsb3ITun/sIJ9+30F3jPt4oEsx7nOcX4pxn/sbl2Lc52bBpRiVempujPuUsa/EmPapCV+KcZ8C66UY96lWDsX4o4+LtxpqJ+Q8F0AnQJ8PHfnUBdCRfV0AHbnaBdCR2V0AHXngfOgZWeMF0JFjXgAdGekF0JGR8kNf4y2kTDC9VtMjO1dretQI1JoelQq1pke9RK3pUbXRavqC2pFa06OCpdb0qKOpNT2qeWpNTzC9VtOjmqfW9KjmqTU9qnlqTY9qnlrTo5qn1PQ3AjC9VtOjmqfW9KjmqTU9qnlqTU8wvVbTo5qn1vSo5qk1Pap5ak2Pap5a06Oap9X0FtU8taZHXr+t6d9//8lbRPjbmv5922BvEeGrNT0ifLWmR4Sv1fQOEb5a0+N+vVrT4369WtMjr1dreoLptZoe9+vVml5rNc+afAry/Nv1L0GlchLPZJ6uDl8YtVbGmDFqrTIxY9RaseHF6LVWP2w6MTrXwhisPX472BArGLVWEpgxas3KmTFqzXCZMRIwcmDUmnkxY1SbxfBiVJvF8GJUm8XwYlSbxfwE4w+/T95opu8JOc8F0JEhXQAd+dQF0JF9XQCdAH0+dGR2F0BHHngBdGSNF0BHjnkBdGSk86EHZKT80Nd4yzAgL1ZremTnak2PGoFa0xNMr9X0qJeoNT2qNmpNj9qRWtOjgqXW9KijaTV9RDVPrelRzVNrelTz1Joe1Ty1pieYXqvpUc1Ta3pU89SaHtU8taZHNU+t6VHN02r6hGqeWtOjmqfW9KjmqTU9qnlqTU8wvVbTo5qn1vSo5qk1Pap5Wk2fkddva/rG590yIvxtTd/oBZ4JptdqekT4ak2PCF+t6RHhqzU97terNT3u12s1fUFer9b0uF+v1vS4X6/W9ILz+mjMoWfKsWV6n50/fjqHB5ZbJPulquA8lltVwXkbt6qC8xRuVQXH5byqkhEch3KrKjju4lZVcJzBrargu2TcqpIeVdVES2TUREtk1ERLZNRES2T0REtWT7Rk9URLVk+0ZDeKlvL508WE31StlKusOa6+/dxDbG/oCwwBTB3MRpEYL5iN4jZeMBtFebxgNooJecFsFEGygnEbxZu8YDaKTnnB7BPLFm9OMKE0wPhwCm0fN9+s+cG1wX4h3CdGfoPwrirpUXWfOLap6j6RaVPVfWLNpqr7RI9NVfeJB1uq+n0ivKaq+8RsTVU3isLi8dO3Qn8rCss2HVdnW35/cusOZqPYihcMAUwdzEZx28/AvP8aK/mNojxeMBvFhLxgNoogecFsFG+ygqGNolNeMBvFsrxg1Ea+LTBqI98WGAKYOhhEvt+A0Rr5LtGyikhr/L2IebRmAYuYR2susoZ5gtaMaBHzaM3LFjGP1uxwEfNozVEXMQ/BPJLNozVfX8Q8qBqINg+qBqLNg6qBaPOgaiDZPBFVA9HmQdVAtHlQNRBtHlQNRJuHYB7J5kHVQLR5UDUQbR5UDUSbB1UD0eZB1UCyeRKqBqLNg6qBaPOgaiDaPKgaiDYP8h7B34alhMhN8Mc+SPJXm2EeyojcRJsHkZto8yByE20egnkkmwf3e0SbB3mPaPPgfo9o8+B+j2TzbPRduyXN408Vnbf0Z/OEjb7Ft6V5UDUQbR5UDUSbB1UD0eYhmEeyeVA1EG0eVA2uvVta3GkeE17Ng6qBaPOgaiDaPKgaSDbPRt+k3dI8qBqINg+qBqLN42EeyeYhmEeyeVA1EG0epKWSzSP5U6q3u7vH8+EphZZ5bHTH1Talh8zWVxHadEjtnUuNq92jW7tzPjXMs0g9T/InYGH6saYnmF6r6QWHSzD9WNMLvoED0481veAoHKYfa3rBN55g+rGmF3xTC6YfmtdL/uQ6TD/W9IJvxsH0Y02Pap5a06Oap9b0BNNrNT2qeWpNj2qeWtOjmqfW9KjmaTU9oaSj1vRawzxj7CGIya2rnXen6YnsIqZv1PBJa5gH05PWMA+mJ61hHkxPWm/awvRBa4QP0wetN21h+qD1pq0C0zfy+qD1pi1MHwim12p6VPPUmh7VPLWmRzVPrelRzVNrelTztJo+opqn1vSo5qk1PUo6ak2/T5iXTDhNH0vDmDn742Jjmpbf8UXbuE+UB8v/yPJpnyAPlv+Z5feJ8WD5n1l+nxu2sPzPLL9PcA/L/8zyBMsrtfw+d2th+R/l82mfm7Ww/M8sv8+9Wlj+Z5ZHDU+r5VHDU2r5jBqeVsujhqfV8qjhabU8anhaLU+wvFLLo5Kj1PJFa4R3XpyTbxl+x7dqi9YAT73htcZ36g1PMLxOw2u9Q6ve8FrDevWG13p/Vr3htd6e3d7wrTxe691Z5YaPRuvNWfWGR+VOqeFRuVNqeFTulBqeYHidhkflTqnhUblTanhU7pQaHgUcnYa3gtO5X714vy7+9TD4b4a/Cy84JWkLTysLLzg0bAsvOLxpCy/YRbeFF3yDqC28YB/ZFN4JLtS3hRdcbG4Lv7KHdSt7WLeyh3Ure1i3sod1K3tYt7KHdSt7WL+yh/Ure1i/sof1K3tYv7KH9St7WL+yh/Ure1gv2cOa8wHNWFxNeMketiU8SfawTeEle9im8JI9bFN4yR62KbxkD9sUXrKHbQov2cM2hZd8IzcU83VxioF+E75yr8sf9688PW5fnXpKfuOAU0/J92cZ9RT9jXVOPSU/Ps2pp+SnhTn1lPxwLKeepERPpY8+BnO0pAlkfrv2jkXpg4EtLEofm2thUfo6aAuL0mftGlg2+iAnKxalL9q1sCh9Da2FRelLWi0spBRLPH46lNy4llw4GJLLTyr68AVxn5hYzrdTbTqUzLb83tXxDn2fiHsh6PvE8wtB3ydb+Bl0mw6pvXOpBf1nbWCb0PfJRdaBvtFXaReCjpeZ/8Ibbg/kPtUg4sVgBoh4yZYBIlrNMUDEW7+fQ1T7fSpWiGgnxgARrbkYIKLNFQNEAkTmdhKt/CYjv5mOHNnQdOTIndiRx0efGlMqyJFpTUeOvGw28oIsbjpy5HzTkSNDnI4c+eR05ATks5Ej+5yOHNnndOTIPqcjR/a5aWNaWw54zln3fPHd8MiBVRo+4ZNSWg2PeoBSw6MqodTwqI0oNTzB8DoNjzqRUsOjWqXU8KiZKTU8KndKDY/KnU7DW1TulBoelTulhkflTqnhUblTaniC4XUaHpU7pYZH5U6p4VG5U2p4VO6UGh6VO52Gl/x1aBh+pOFRuVNqeFTulBoelTulhicYXqfhUblTanjk8Zsa3vmH4Z++XnYY3iOq39Tw6STtbiBfDY+oXqnhEdUrNTzB8DoNj6heqeFxP16p4XE/XqnhkccrNTzux+s0POF+vFLDK63cFXd8eLKE0Lg2mHR+1daa52USviAqrYLxQlRaUeKFSID4OUStlY58fI/bmicFv6Fo7YNiiBWKWssGvBS15uC8FLUmtLwUtWaHrBSD1lSLl6LWJw54KWq9fc9LUeu9cF6KBIpNirzfqE8Bmc585siL5jNHFsXP/P2HNFJAzjWfOTK06cwj8rn5zJH9zWeOXHE+c2SW85kTmE9njjx0PnPkofOZIw+dzxx5KDvzNV5HjsiGlVo+ISfXanlUBrRaHvUJrZZHlUSr5QmWV2p5VIy0Wh51K62WR/VMq+VRw9NqedTwlFo+o4an1fKo4Wm1PGp4Wi2PGp5WyxMsr9TyqOFptTxqeFotjxqeVsujhqfV8qjhKbV8QQ1Pq+VRw9NqedTwtFoeNTytlidYXqnlUcPTannk87ta/v3XHrNBbL+r5d9/LSAbxPZaLY/YXqvlCZZXannE9lotj/vzWi2P+/NaLY98XqvlcX9eqeUt7s9rtfw++Xx0dFo+NY1ZzFnbLKH1yU8y5lgoZOh5VYUvjPs4zR9h9MYcH9zzJjeh+8cO8um1P3+2+3igKzG6fY7zSzHuc3/jUoz73Cy4FKNST82NkYCRA+M+NeFLMe5TYL0U4z7VyqEY3YmRyP6GsZLANhpqZ4ec5wLoyJDmQ/fIpy6AjuzrAujI1S6AjszuAugE6POhI2u8ADpyzAugIyO9ADoyUn7oS7yFlD3yYq2mJ2Tnak2PGoFa06NSodb0qJeoNT3B9FpNj9qRWtOjgqXW9KijqTU9qnlqTY9qnlbTB1Tz1Joe1Ty1pkc1T63pUc1Ta3qC6bWaHtU8taZHNU+t6VHNU2t6VPPUmh7VPK2mj6jmqTU9qnlqTY9qnlrTo5qn1vQE02s1Pap5ak2PvH5b0ze+/5QQ4W9r+kbb4IQIX63pEeGrNT3B9FpNjwhfrelxv16t6XG/Xq3pkderNT3u12s1fcb9erWm11rNsyafgjz/dv1LUKmcxDOZp6u/vgSVtVbGmDFqrTIxYyRg5MCotfph04nRuRbGYO3x28GGWMGotZLAjFFrVs6MUWuGy4xRa7bIi7FozbyYMarNYngxqs1ieDGqzWJ4MRIwtjH+8PvkrWb6BTnPBdCRIV0AHfnUBdCRfV0AHbnadOjFILO7ADrywAugI2u8ADpyzAugE6DPh46MlB/6Em8ZFoO8WK3pkZ2rNT1qBGpNj0qFVtNb1EvUmh5VG7WmR+1IrelRwVJreoLptZoe1Ty1pkc1T63pUc1Ta3pU89SaHtU8raZ3qOapNT2qeWpNj2qeWtOjmqfW9ATTazU9qnlqTY9qnlrTo5qn1vSo5qk1Pap5Wk3vUc1Ta3pU89SaHtU8taZHXr+t6d9/3q14RPjbmv59L/DiEeFrNT0hwldrekT4ak2PCF+t6XG/Xq3pCabXanrk9WpNj/v1ak2P+/VaTR8E5/XRmEPPlGPL9MEW/3V1cPQAbp37UlVwHsutquC8jVtVwXkKt6qkR1XBcSi3qoLjLm5VBccZ3KoKvkvGrargu0LMqkY90VLUEy1FPdFS1BMtRdKjqp5oKeqJlqKeaCnuEy1ROn46hKd6yy9VK+Uqa46rbz/3ENubr/JM3Ce24gWT9onEmMHsE7cxg9knymMGs09MyAyGAKYOZp94kxnMPtEpM5h9YtkQjzuMIdrQAOPDKbR9gmjyX7822C+E+8TIbxDeVd0n6m2pmveJY5uq7hOZNlXdJ9ZsqrpP9NhUlfSouk+E11R1n5itqeo+UVj0Z0Uxh9KIwrI9g9lsy+9Pbt3B7BNbMYPZJxLjBVP2idt+CKbxNdayT5THDGafmJAZzD4RJDMYApg6mH2iU2Yw+8SyzGDURr4tMGoj3xYYtZHvWzDJGES+34DRGvmu0LLqZh6t8fci5tGaBSxiHoJ5JJtHa0a0iHm05mWLmEdrdriIebTmqIuYR2umvIZ5rNZ8fRHzoGog2jyoGog2D6oGos1DMI9k86BqINo8qBqINg+qBqLNg6qBaPOgaiDZPA5VA9HmQdVAtHlQNRBtHlQNRJuHYB7J5kHVQLR5UDUQbR5UDUSbB1UDyeaR/LVpDeZ5+23Ym3kI5hH7sY+beRC5iTYPIjfR5kHkJto8iNxEmwf3eySbR/L3vWEeI/kb3DCPkfydbJjHSP6WNcxj6MLI7amIUf1hm8+Kh82Uz4spfsle1pX9ym9/fiy7XVh2t7DsfmHZaWHZw8Kyx4VlTwvLvrBfDQv71biwX40L+9W4sF+NC/vVK7+0+LHsC/vVuLBfjQv71biwX538QUHv6CgTeN/6YefPDnvOp5em28lM/ugfs/B2ZeHdysL7lYWnlYUPKwsfVxY+rSx8liy8O4Unsr8JX6nAt5rGJtH+mFXVLNp786oq2tfzqio6MuBVVXQcwasq6VFVdIzCq6roiIZXVdHxD6+qeqKlvE+0tMb7NmWfmG0R4PtEjosA3yd+XQT4PlH0IsAJwOcC3yejWAT4PnnNIsD3ya4WAb5PjrcIcGSaU4Fbg0xzMnBkmpOBI9OcDByZ5mTgBOBzgSPTnAwcmeZk4Mg0JwNHpjkZODLNucAtMs3JwJFpTgaOTHMycGSak4ETgM8FjkxzMnBkmpOBIw6f2izaOkQpU/tsWYcoZTJwAvC5wBGlTAaOKGUycNTDJwNHPXwycMThc4F71MMnA0c9fDLwyZmmp6NJsyfj3v9wuNUyvy4ONjyksD58Ce9XFp5WFj6sLHxcWfi0svB5ZeHLwsJP/ogJs/BWrvDu8WL+raqbWlFB4zV+S4L9Mbeqgr03t6qkR1XBkQG3qoLjCG5VBUcd3KoKjlG4VRUc0TCrGgTHP9yq6omWwj7R0hpPgoR9YrZFgBOAzwW+T/y6CPB9ouhFgO8Tyy8CfJ+MYhHg++Q1awCP+2RXiwDfJ8dbBDgyzcnAkWlOBk4APhc4Ms3JwJFpTgaOTHMycGSak4Ej05wLPCHTnAwcmeZk4Mg0JwNHpjkZOAH4XODINCcDR6Y5GTgyzcnAkWlOBo5Mcy7wjDh8btOjjChl7ru/GVHKZOCIUiYDR5QyGTiilLnAC+rhk4GjHj4ZOOLwycBRD58MnAB8LvDJmeZN4BN4DM8/fBdnbpRKNvsHSWr88PcX32Uvy8ruJn9X80eyxxyOYknM6dFsLH6JbtcV3a0ruhcsejHHYRqLSy+i07qih3VFj+uKntYVXbA/bYku2J02RLeSvWlDdMnetCG6ZG/aEH1dbzr5G0usoq/rTe263tSu603tut7UrutN3bre1K3rTd263tSt600nfwuIVfR1valb15u6db2pW9ebunW9qV/Xm/p1valf15v6db3p5O9KsIq+rjf163pTv6439et6Uy/am9J5G6yEF9FJtDd9L7pob/pedNHe9L3oor3pe9FFe9P3oo90SX/MsFGncSEPLnlzXHsL/On54jtwPAs5GTiehZwMnAB8LnC8dTcZON66mwwcb91NBo637rjfnC7uBG7CK3C8dTcXOPqdzwaOTHMycGSak4Ej05wMnAB8LnBkmpOBI9OcDByZ5mTgSHzmAp/duvV2E+sA7ls/7Lw7gRPZPWops1u3AngE8LnAE4DPBZ4BfC7wAuBTgWcD4HOBWwCfGofPbk4M4B7A5wInAJ8LHJnmZODINCcDR6Y5GTgyzcnAkWnOBV6QaU4GjsRnMvC5TtOVs3Wvt86+/+FozrJEyvFxi83++pzPy9Uh+uPuXcihPK52bt3Ky+TewTDPD81TYB655vGTO0DDPD80j4V5JJvHwTySzeNhHsnmIZhHbt7jJ3edh3l+aJ4I80g2D6oGos2DqoFo86BqINk8FlUD0eZB1UC0eVA1EG0eVA1EmwdpqWTzOMGhQfL+aBeZUmiZx0Z3XG1TeshsfRWhTYfU3j01u61fvWPXI+8Ehx0w/VjTCw5pYPqxphccLsH0Y01PML1W0wuOwmH6saYXfOMJph9resE3tWD6sXm94BtmMP1Y0wu+GQfTDzW9RzVPrelRzVNrelTz1Joe1Ty1pieYXqvpUc1Ta3pU89SaHiUdraYnrWGeMfYQxOTW1Tt2qvSTv+cL0wsyvdYwD6YnrWEeTE9ab9rC9KQ1wofpSetNW5g+aL1pq8D0jbw+aL1pC9MHrTdtYfqAap5a0xNMr9X0qOapNT2qeWpNj2qeWtOjmqfW9KjmaTV9RElHren3CfOSCafpY2kYM+ejL5I1pmn5HV+0jftEebD8zyy/T5AHy//M8vvEeLD8jyyf9rlhC8v/zPL7BPew/M8sv8/tWlj+Z5bf524tLP+jfD4RLK/U8vvcq4Xlf2Z51PC0Wh41PK2WRw1Pq+VRw1Nq+YwanlbLo4an1fKo4Wm1PMHySi2vNcI7L87Jtwy/41u1RWuAp97wWuM79YbXGt6pN7zWO7TqDU8wvE7Da70/q97wWm/Pbm/4Rh5ftN6dVW94rTdn1RselTuVhieDyp1Sw6Nyp9TwqNwpNTwqd0oNTzC8TsOjcqfU8Cjg6DS8nRzchXhc7KJN73/Y5nI8IOWM36NGTtYD+FzgBOBzgQcAnws8Avhc4AnA5wLPAD4XeAHwqXG4MwA+F7gF8LnAkWlOBo5MczJwAvC5wJFpTgaOTHMycGSak4Ej05wL3CPxmQucqsBvdwDPCR6iW6reYvOncSzZB5bbfbqvKez4Kdz4Kfz4KWj8FGH8FHH8FGn8FPlnU9wHlY5BwfQMqu8pb45Bv86Nl0GuY1D9GzmUzhPo+fsxt5PrPsj1DPI9g6p7Jtjj+zbB+d8GVU7I/GilkbN98hhfM4ThM8ThM6ThM+ThM5TRM9S/FcA6gx0+gxs+gx8+w/A9nYbv6TR8T9d7owU6no4KlF6Py3pzpZCOQZFMZVDsmal+5ITD7Ybn4PwcVD9F8hHChuIrg0rHoHrLmdYg2zOoviOzOQdVQNTbJLQGUc+g0DMo9gxKPYNyz6DyflA0r3YK9VeZQirnoFwZVF0R0R4rIvpSGeQaM1U2Yag/fv9+5wZDPYNCz6AqcuvCoZR1sYLCmr5htm+Y6xvm+4ZR37DQNyz2DUt9w3LfsG9WSU7nsOJehznTHhYrw2zfMNc3zPcNq68Sb44j5PZn5eCp3+xoD4t9w1LfsNw3rHQNq9cO28Ns37Bv7BZPc/tU8TK+TvIRGNpAlR3gv0FSzv1GT8W9cxiZ9rDKNiXbN8z1DfN9w2LfsDpJOp/mt/RU2z2H1as07WF1khTNOSxWDoVA3wx76JYqTjh8o1s4lzLlypqMpm+Y7RtWXyW36PXcAaaiW7061B5GfcNC37D4ze4+7XY7uCvDUt+w3Cdk6RqWTN8w2zfMdZ2T9eJEexj1DQt9w3LXyZX6Tq7cd3Jl2zMsflOYTsafRWb7QOKD+Rrm+obVS8bZncOyrw2jvmGhb1jsG1a/yZEfNwby082/x7DcN6x0Dau7jvYw2zfM9Q3zfcOob1joGxb7hvWtkm8K0S6e5cmnnuL0NcZ1jPEdY6hjTOgYEzvGpI4xuWNM+fmY+kHfGNOxDuqfZghnSHsLDF/H+I4x1DGmvg7OYCM+eZFzTOwYkzrG5I4x5edjviltvx9jO8a4jjG+Ywx1jOlYB6VjHZSfr4NUL8q6dEb7Lnn/Oqoea96c2xGPxWxfR8WuUalrVO4aVY9q03nb36by8thS+qZu3Bplu0a5rlG+axR1jQpdo2LXqNQ1KneN6lobrmttuK614brWhutaG65rbXxTKC7nLSpbXGVU7BpVf08wh/O5yfwkoc/V5ybJH/pkotbV1uenmpiPj0LtrxsJfwj1zSOlFwtlJQrlJArlJQpFEoUKEoWKEoVKEoXKY4W6T1ImTEJmxiR2xiRuxiR+xiQ0YxKWE+isi+bnFzgek8QZk6QZk+QZk5QJkwQzYxI7YxI3YxKOHe/Px9lysM2r7fl0Wbbl9+9F3kUieSIFeSJFeSIleSJleSIVcSJFM1+k+Hgl8ekOc/0lw9YNyhTt6gq41RXwqytAqysQVlcgSlfg/Z3sFNPqCuTVFSiLK5DEe+KWAuI9cUsB8Z64pYB4T9xSQLwnbikg3hO3FFjdE6fVPXFa3RMnUZ74D5GyKN96F0mUt7yLNN//CWlPZM9HpZyrPCuVPcDUwRDA1MEEgKmDiQBTB5MApg4mA0wdTAGYKphiAKYOxgJMHQwi32/AIPL9BgwBTB0MIt9vwCDy/QYMIt9vwCDy/QYMIt8qmGwQ+X4DBpHvN2AQ+X4DBpHvN2AIYOpgEPl+AwaR7zdgEPl+AwaR7zdgEPnWwVi1cYzzDzBPr8OdYNR6pfetTLJV65VaYNR6pRYYtV6pBUatV2qAcWrrMS0wausxLTBq45gWGLX1mBYYApg6mGrk6835xSBvnjqD11W1Nj3aKNvkWmjc7f/OaNw/Xe3Kl1BxtFD3adKcafKcacqUaeo9uvinsXOmcXOm8XOmoTnTsJwZMZjHNKm0jtPGO/rZR4lCJYlC5SuEev9aRfZFoFBkJAplJQrlJArlJQpFEoUKEoWKEoVKEoWSeKLTFSf6GvdhggGa79BYoPkOjQOa79B4oPkODQHNd2gC0HyHJgLNd2gS0HyHJgPNd2gQDX+HJiIa/hYNouFv0SAa/hYNouFv0RDQfIcG0fC3aBANf4sG0fC3aBANf4sG0fB3aBKi4W/RIBr+Fg2i4W/RIBr+Fg0BzXdoEA1/iwbR8LdoFMc1jVfssmIP1XgGOyv2UC00ij1UC41iD9VCo9hDtdAorte00Ciu17TQKI5rGmiK4npNC43iek0LjWIP5c1xrfOWXtEo9lAtNIo9VAuNYg/1Hk0xij1UC41iD9VCo7he00KjuF7jyvnqvjfhFQ0BzXdoFNdrWmgUR8MtNIqj4RYaxdFwC43m+1Dv0VjF0XALjeJouIVGcTTcQkNA8x0atS0fGxmU3paPLTBqWz62wKht+dgCo7blYwsMAUwdjNpm5y0wapudN+IYp7bZeQuM2mbnLTBqI98GGK828m2BURv5tsDo/WhLA4zayLcFhgCmDkZt5NsCgwCvDqbebDfEc4aQnkbZX83sX+co5xzemPzb1fdJ0oxJ8oxJyoRJ6t0zuSeZYfh6R0fuSfyMSWjGJGHGJHHGJDN2fJix48OMHR9n7Pg4Y8fHGTs+ztjxccaOjzN2fJyx4+OMHR9n7Pg4Y8enGTs+zdjxacaOTzN2fJqx49OMHZ9m7Pg0Y8enGTs+zdjxecaOzzN2fJ6x4/OMHZ9n7Pg8Y8fnGTs+z9jxecaOzzN2fJmx48uMHV9m7PgyY8eXGTu+zNjxZcaOLzN2fJmx48v4HZ+NMTMmsTMmcTMm8TMmoRmThBmTxBmTpBmT5BmTzNjxdsaOtzN2vJ2x4+2MHW9n7Hg7Y8fbGTveztjxdsaOtzN2vJux492MHe9m7Hg3Y8e7GTvezdjxbsaOdzN2vJux492MHe9n7Hg/Y8f7GTvez9jxfsaO9zN2vJ+x4/2MHe9n7Hg/Y8fTjB1PM3Y8zdjxNGPH04wdTzN2PM3Y8TRjx9OMHU8zdnyYsePDjB0fZuz4MGPHhxk7PszY8WHGjg8zdnyYsePDjB0fZ+z4OGPHxxk7Ps7Y8XHGjo8zdnycsePjjB0fZ+z4OGPHpxk7Ps3Y8WnGjk8zdnyasePTjB2fZuz4NGPHpxk7Ps3Y8XnGjs8zdnyesePzjB2fZ+z4PGPH5xk7Ps/Y8XnGjs8zdnyZsePLjB1fZuz4MmPHlxk7vszY8WXGji8zdnyZseNnPHNnZzxzZ2c8c2dnPHNnZzxzZw3Djve35XNM4mzr6nQIlNJ5JaUvaYIoaaIoaZIoabIoaYokaTieNGSUxoqSxomSxouSRtRZbEWdxVbUWWxFncVW1FlsRZ3FTtRZ7ESdxU7UWexEncX1h/ys9+lrjPXZPn7/V2j9cjWdnyGn/CRLcF9TuPFT+PFT0Pgpwvgp4vgp0udThMdmiLUp8vgpCsMUyZxburxOUX+kj3cKht0dymHuaHxlCjd+Cs86hbWVKWj8FGH8FAy7OyZ7TJFNZYo0fgqG3R3z0bwwFqpMUYZPERh2dzKHl082V6aw46dwrFO4WJnCj5+Cxk/BsLtTOftzmtqKiuOnYNjd+QSVqysqj5+CYXdnf/RhzeRep4hm/BSWdYpQOWmjGz+FHz8Fw+4u9ri41HZ3DOOnYNjdxR+OtVAlPIhp/BQMu7uckXmJNVBl+BTJsE6RKidtsuOncOOnYNjdt5th53foTKzs70QzJqnvcHKHv7xFvrExibdnO25vy+Nq92vC16tNevpc38ONeVPrmu2TPQ5Bn55OwV9X3xWIqyuQVlcgr65AWVyB+sOVKylgV1fAra6AX10BWl2B1T1xXt0T59U9cV7dE+fVPXFZ3ROX1T1xWd0Tl9U9cVndE5fVPXFZ3ROX1T1xWd0Tl8U9sTOLe2JnFvfEzizuiZ1Z3BM7c4EnPu+T+Ntd1YYCv24wfV19E/bxHE/9W4uUzKEuJfu4c+hvqt/VDbrUjbrUTbrUzbrULarUtUaXulaXuk6Xul6XuqRLXV1RldUVVVldUZXVFVVZXVGV0xVVOV1RldvM756PpN/+jBV19zqZszkeW6Tb5RV1Fz6Z7wosfNb+oYBf+PS8KyD9PLzF0qcCwTV2TCp0XP3ri5yNq/35wDI97S5XE+MWFRxF5psLcc8X3zFKz14XwSg9K14EIwEjB0bpWfwiGKVXBxbBKD22XQSj9Jh5EYzSI/c1MJL0/GERjMhiWDAii2HBiCyGBSMBIwdGZDEsGJHFsGBEFsOCEVkMC0ZkMRwYA7IYFozIYlgwIothwYgshgUjASMHRmQxLBiRxbBgRBbDghFZDAtGZDEcGCPixr+E0fkHRgqvGOGp/xLGZI/GxC55/4oRnpoFIzw1C0Z4ahaM8NQcGBPqjSwYUW9kwYi4kQUj6o0sGAkYOTByZDHenBj9LymeMN4niTMmSTMmyTMmKRMmYekL3pzEzpjEzZjEz5iE40xzLp2TPLUJq59pvxrcH6eULem3c+cuUpAnUpQnUpInUpYnUhEnEktPZmaRrDyR3HyRGu/zsnRCZhaJ5IkU5IkU5YmU5ImU5YlUpInkjZEnkpUnkrjT25v5p/cS92ZvpQSAqYMJAFMHEwGmDiYBTB1MBpg6mAIwVTDWAEwdjAWYOhgHMHUwiHy/AUMAUweDyPcbMIh8vwGDyPcbMIh8vwGDyLcOxiHy/QYMIt9vwCDy/QYMIt9vwBDA1MEg8v0GDCLfb8Ag8v0GDCLfb8Ag8q2D8Yh8vwGjNo55/0Ks92q90vtn7L1X65VaYNR6pRYYtV6pAYbUeqUWGLX1mBYYtfWYFhi1cUwLDAFMHYzaekwLDEfkS/4EQ9k2wLhUjg8iutvtm8dvx8rFtoTjvTNb0uO9M5tqEM0R5D9/aPF26V3TpEbTvJGm/vjhROVV07KTpu7QNPoXTVn690rRNJfzrEuvmlo1mrp9NM3ucEmZXk8klka1YjQ9/XqIr5rSRpqm40TKtdUbdtS0VPwpS0dWOuOwm6auoSnF82qKwTxrepcoiZMoi5OoSJMoGnESWXESOXESeXESkTiJgjiJxJ3ZUdyZHcWd2VHcmZ3EndlJ3JmdxJ3ZSdyZncSd2UncmZ3EndnpgjPb2FOi6N7nOGTtefFzW79T/Ly2+GVp8bNZW3y7tvhubfH92uLT2uKHtcWPa4sv3evmo2h5u/1qX8WX7nUb4gv3us48bn6715CtCPe6LfGFe13nwyn+8w3ZQ3zhXrclvnCv+yx+5eBkaeN4ofjCvW5LfHavGxvi21ucdf62De/FD9YeN7mCDf79xamcv5yNf3USJSnSNSvStajRlYxRpKtVpKvbR9dszudCswnlVVevSFeq62ryd7reh4W+YbFrmN4eCv5MbJy39HzxHYzaZ/ZbYAhg6mDUPrPfAqP2bdUWGLVvq7bAqH1btQVG7duqrrgTjHl5I5709lBogVH7tmoLjNrItwVGb9eNBhgCmDoYtZFvC4zayLcFRm3k2wKjNvJtgNHbjqQFhuPwVfB15kZmxdJYABhZuhYAI0tLBGBk6bcAjCzNHICRpVMEMLK0oVCAsRE3svS4AEaWBhrAGJDFsGBEFsOCEVkMC0ZkMSwYkcVwYIzIYlgwIothwYjwmwWj9IDHxgdGUxpgKJXzlZ30JIkP5ktd6YHJz9TN9ng2+/ZnqagrPYD4obrOn+p6V1FXuqPnVTdJd8jM6kp3nMzqSi/TMasr3Z8zq0u61JVenvqhuuZsqZCfIrCHuntFVU11N4uqWupuFlW11N0sqmqomzeLqlrqbhZVtdTdLKpqqbtZVNVSl3SpqyuqyrqiqnpnKzofwSV6+oBCoaqyj68tuN+uvU9gR0/gRk/gR09AoycIoyeIoydIoyfIoycoYycIxoyewI6eoL6Tz24fRNSY4KqPYId6y5Q1RKd1RQ/rih7XFT2tK3peV/SyrOjWrCu6XVf0db2pXdeb2nW9qV3Xm9p1vald15vadb2pXdebunW9qVvXm7p1valb15u6db2pW9ebunW9qVvXm7p1valb15t6wee68w/RKbyKLviESWf3Z5e8fxVd8AnTEl3wCdMSXfAJ0xJd8AnTEJ0Ex+st0QXH6y3RBZ/rLdEFx+st0Wld0QWfMO97bYQg+IRpiS74hGmJLviEaYku+IRpiS74hGmJLjheb4kuOF5//+5pCILj9ZboguP1luiCvWlD9CjYm7ZEF+xNW6JLrsM0RBfsTVuiC/amLdEFe9OW6Ou6pG9ejzZnbmVNzK+jXNeo+msl1h9vgVob7Oso6hoVukbFrlH1Fxkfz/Vbm19pfPfGmDneNLj9+TrXdy9eNUa5rlG+a1TdXuF819fe8tvXUaFrVOwalbpG5a5RpWfUN58nb42yXaNc1yjfNaprbXzzxefbKXSOKq83gr750HJrVOoalbtGlY5R8ZsP0rZG2a5RrmtU3cr+9Ie389S+jgpdo2LXqNQ1KneNKj2j6o/YNkfZrlGua5TvGtW1NmzX2rDfrA1K56hoXkelrlG5a1TpGeVM1yjbNcp1jeqJHOJ33zhtjApdo2LPqPr37nxO56eRi3/QsM5VInLrczzDZPLPcfLtLL1PY+dM4+ZM4+dMQ3OmCXOmiXOmSXOmyXOmKT+d5o9hZPqG2b5hrm+Y7xtGfcNC37BvVq3L5zBKlWGpb1juG1a6hgXTN8z2DXN9w3zfMOobFvqG9a2S+o0fX84yC5mnyln9EOFtUBbrN3SuFamIE6l+A+Zakaw8kZw8kfx8kd63N4n1GxzXihTkiRTliZTkiZTliVTEiZSMPJGsPJGcPJHknd5J3umd5J3eafDpfZ8kzZgkz5iE48wU8t2F9y83xWz0qGr1qOr0qOr1qEp6VA16VI16VE16VM16VNUTLRU90VLREy0VPdFS0RMtFT3RUtETLRU90VLREy0VPdFSURMtJaMmWkpGTbSUjJpoKRk10VIypEdVNdFSMmqipWQ28qvvu7olu9EJ/L7lTrIbncAtVTc6gVuqbnQCt1Td6ARuqbpRvtpSdaN8taXqRn61oarbKF9tqbpRvtpSdaMT+H0PruQ2OoFbqm50ArdU3egEbqjqNzqBW6pudAK3VN0oX22pulG++r7PU/Ib5astVTfKV1uqbhQttVTdKFpqqbpRtNRSdac68HtVaaNoqaXqRtFSS9WNoqWWqqRG1fprmLfT6pCGXisX9TcACx0TlfA6T/0VvcYY6hgTOsbUOyS97/GZvumF2RqVu0aVnlHf9N1sjbJdo1zXKN81irpGha5RXWsjd62N3LU2ctfaKF1ro/5E8vvTov5obzHHreTiKmM6dn79scTGPLljTPnxmFx/4qwxxv6YQTauY4zvGEMdY0LHmNgxJnWMqa+DcKzrktzrmPLzMfVel40xtmOM6xjjO8ZQx5jWOqiN6VgHtmMd1O+fNsaUn4+p39FrjOk4D1zHeeA6zgPXcR64jvPAdawD17EOXMc6cB3rwHesg2++nZnM2eEoPT2GdrRayN98t7I5rN7wP8Wz439KtjIs9w2rf3ul0b0pf/Odwuaw+jdHGk0r8jff52sO833DqG9Y6BsW+4alvmG5b1jpGvbNt+aaw36+Sv7z9s//9x/+9W//8N//6R//7Tbo13/9v//8P/79b//yz1///Pf/7/8c/+W//+vf/umf/va//9v/+dd/+R//+D//77/+43/7p3/5H7/+29+Zr//3X1M09u9ve8fdBPolza1Ckf7+lruH279/raoUcvr7FEr69d9/DbC3iNwS/fqn/WO8z7fxZG6S3aT7/wE=",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "add_lock_public_user",
      "is_unconstrained": true,
      "custom_attributes": [
        "internal",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "2722406262643068352": {
            "error_kind": "string",
            "string": "HashlockAlreadySet"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16870384257694633552": {
            "error_kind": "string",
            "string": "Function add_lock_public_user can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "add_lock_public_user"
      ]
    },
    {
      "name": "commit_private_user",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "src_receiver",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 48
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2588366281349374274": {
            "error_kind": "fmtstring",
            "length": 136,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "3473764466780631008": {
            "error_kind": "fmtstring",
            "length": 106,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5533887251808526417": {
            "error_kind": "fmtstring",
            "length": 120,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6652550611004701521": {
            "error_kind": "string",
            "string": "Funds Not Sent"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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aQLyJIQEvDQBeRJCAl6ZgI4nISTgpQnIkxAS8NIE5EkICXhpAvIkhAS8NAEjCUgCXpmAPAkhAS9NQJ6EkICXJiBPQkjASxOQJyEk4KUJyJMQEvDKBPQ2n4S0NZq+1fyagHcqJu355JcHleRjeadi0jPOS8mP5ba0+E7FpJG5SyVCZYOKSctnl4pJH2KXiklxvEvFpGLbpWJSRuxRCSZr210qJmvbXSrUtltUqG23qESobFChtt2iQm27RYXadosKte0WFWrbDSqR2naLCrXtFhVq2y0q1LZbVCJUNqhQ225RobbdokJtu0XFZG1bS3k8Ua2lvT9njiZr2z0qyWRtu0vFZG27S8VkbbtLxWRtu0slQmWDisnadpeKydp2l4rJ2naXCrXtFhVq2w0qmdp2iwq17RYVatstKtS2W1QiVDaoUNtuUaG23aJCbbtFhdp2iwq17QaVQm27RYXadosKte0WFWrbLSoRKhtUqG23qFDbblGhtt2iQm27RYXadoNKpbbdokJtu0WF2naLCrXtFpUIlQ0q1LZbVKhtt6hQ225RobbdokJtu0GlUdtuUaG23aJCbbtFhdp2i0qEygYVatstKtS2W1SobbeoUNtuUaG2faeSFmrbLSrUtltUqG23qFDbblGJUNmgQm27RYXadosKte0WFWrbLSrUthtUbL7FepcKte0WFWrbLSrUtltUIlQ2qFDbblGhtt2iQm27RYXadosKte0GFZvvJdulQm27RYXadosKte0WlQiVDSrUtltUqG23qFDbblGhtt2iQm27QcXme8l2qVDbblGhtt2iQm27RSVCZYMKte0WFWrbLSrUtltUqG23qFDbblCx+V6yXSrUtltUqG23qFDbblGJUNmgQm27RYXadosKte0WFWrbLSrUthtUeC/ZJhVq2y0q1LZbVKhtt6hEqGxQobbdokJtu0WF2naLCrXtFhVq2w0qvJdskwq17RYVatstKtS2W1QiVDaoUNtuUaG23aJCbbtFhdp2iwq17QYV3ku2SYXadosKte0WFWrbLSoRKhtUqG23qFDbblGhtt2iQm27RYXadoMK7yXbpEJtu0WF2naLCrXtFpUIlQ0q1LZbVKhtt6hQ225RobbdokJtu0GF95JtUqG23aJCbbtFhdp2i0qEygYVatstKtS2W1SobbeoUNtuUaG2faeSeS/ZJhVq2y0q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WaxM1FmZqLcy0WBlotHKRI1URmExUhmFxUhlFBYjlVFYxCujsr4UIIXy+eLm1peJtVD+eJPcuVTcApUNKg4qG1Q8VDaoBKhsUIlQ2aCSoLJBJUNlg0qBygaVCpUNKtS2G1Q8te0WFWrbLSrUtltUVNe2yT8m2tLLi26/eG/m+qp27+rTdnBt2bq6LOvVxT/fUXF/A3eX5lLzUVFd215GRXVtexkV1bXtZVRU17aXUVFd215FJaiubS+jorq2vYyK6tr2MirUtltUIlQ2qFDbblGhtt2iorq2rfnRZK01t+Mk+JzWHnI5pxcqaWsczq8P9l16vXpz1KE8phhCC39c/RdF1bXwMBRV186jUIyqa+1hKKquzYehqLqWH4ai6tp/GIoRih0oqtYWw1BUrUWGoYh26UER7dKDItqlA8WEdulBEe3SgyLapQdFtEsPihGKHSiiXXpQRLv0oIh26UER7dKDItqlA8WMdulBEe3SgyLapQdFtEsPihGKHSiiXXpQRLv0oIh26UER7dKDItqlA8WCdulBEe3SgyLapQdFtEsPihGKHSiiXXpQRLv0oIh26UER7dKDItqlA8WKdulBEe3SgyLapQdFtEsPihGKHSiiXXpQRLv0oIh26UER7dKDItqlA8WGdulBEe3SgyLapQdFtEsPihGKHSiiXXpQRLv0oIh26UER7dKDItrl5xTjgnbpQRHt0oMi2qUHRbRLD4oRih0ool16UES79KCIdulBEe3SgyLapQNF3e+RHoYi2qUHRbRLD4polx4UIxQ7UES79KCIdulBEe3SgyLapQdFtEsHirrfEz4MRbRLD4polx4U0S49KEYodqCIdulBEe3SgyLapQdFtEsPimiXDhR1vwd+GIpolx4U0S49KKJdelCMUOxAEe3SgyLapQdFtEsPimiXHhTRLh0oRqvaxcf0GIevexRjWymmZWnvFK1ql74UrWqXvhStape+FCMUO1C0ql36UrSqXfpStKpd+lK0ql36UrSqXbpSTGiXHhTRLj0ool16UES79KAYodiBItqlB0W0Sw+KaJceFNEuPSiiXTpQzGiXHhTRLj0ool16UES79KAYodiBItqlB0W0Sw+KaJceFNEuPSiiXTpQLGiXHhTRLj0ool16UES79KAYodiBItqlB0W0Sw+KaJceFNEuPSiiXTpQrGiXHhTRLj0ool16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DhBRLB0golg6QESxdIA4j2Ip7QmxfIb4sTGn1/1CrIuYzKMnujG59gU49TOTkh/XlpLfh+7GHbofd+inSqH7LeL5t0jn36JHkdkejZqjSzsxDjE9xhPiS4xdir8HVLQNqGobUFM2oC6vdeg6IKdtQF7bgIK2AUVtA0raBqRtp46n7tT3W9Tzb9FOv0Vazr+FO/8W/vxbdNiV/BIftwjFf07xul5bw/NVpP7XPd6ubfXx2tLW/rz2PvQ47tDTuEPP4w69jDv0Ou7Q27BD79Em/6qhu3GH7scd+rinaY/251cNfdzTNI97mvZoa+zKshan9b047dH0d+8W7vxb+PNvEc6/RTz/Fun8W+Tzb1HOv0U9/xbnr+56/uqu56/uev7qruev7nr+6q7nr+56/uqu56/uev7qruev7nb+6m7nr+52/upu56/udv7qbuev7nb+6m7nr+52/upup6/usCzn38Kdfwt//i3C+beI598inX+LfP4tyvm3qOff4vzV7c5f3e781e3OX93u/NXtzl/d7vzV7c5f3e781e3OX93u/NXtz1/d/vzV7c9f3f781e3PX93+/NXtz1/d/vzV7c9f3f781R3OX93h/NUdzl/d4fzVHc5f3eH81R3OX93h/NUdzl/d4fzVHc9f3fH81R3PX93x/NUdz1/d8fzVHc9f3fH81R3PX93x/NWdzl/d6fzVnc5f3en81Z3OX93p/NWdzl/d6fzVnc5f3en81Z3PX935/NWdz1/d+fzVnc9f3fn81Z3PX935/NWdz1/d539XLZz/XbVw/nfVwvnfVQvnf1ctnP9dtXD+d9XC+d9VC+d/Vy2c/121cP531ULV/EuA/LjWLYv/4+L72DX/FGBv7Jp/C7A3ds0/Btgbexx47Jp/DrA39lN/D3C/RYc9P6w/DYjh5bcB6y3q+bdop9+ixzcY927hzr9FOP8W8fxbpPNvkc+/xflLr52/9NrpSy8uy/m3cOffwp9/i3D+LeL5t0jn3yKff4ty/i3q+bc4f3W781e3O391u/NXtzt/dbvzV7c7f3W781e3O391u/NXtzt/dfvzV7c/f3X781e3P391+/NXtz9/dfvzV7c/f3X781e3P391h/NXdzh/dYfzV3c4f3WH81d3OH91h/NXdzh/dYfzV3c4f3XH81d3PH91x/NXdzx/dcfzV3c8f3XH81d3PH91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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "notify_created_nullifier_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "debug_log_oracle_wrapper",
        "random",
        "decompose_hint",
        "lte_hint",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "get_htlc_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "view",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "key",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "Train::HTLC_Public",
            "fields": [
              {
                "name": "src_receiver",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "amount",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "token",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "hashlock_high",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "hashlock_low",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "secret_high",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "secret_low",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "timelock",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "claimed",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 8
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "9174444391250494040": {
            "error_kind": "string",
            "string": "Function get_htlc_public can only be called statically"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7Z3bbty2Fobfxde54DrwlFcpNoIkTQsDRlIk6QY2ir771jiWRo44w9EiY5Piuinshr/J/1s8i6L+ufv904e//3x3//mPL9/u3v72z93Dl4/vv99/+Tz99s+/b+4+fL1/eLj/8936f9+Z038g4qPg21/vP59+//b9/dfvd2+9D/7N3afPv9+9DQB++hN/3D98unsLaP79z5tJ5QQqNCBSeYkKRHmByBeiSCXKi0S+SJQXm5QKCK15kgFRsM90b7bpDeKc3DCeU59y3KRm5+ApNTtvltTOJhIHa+xswCKsEz+W39Ypf4xzcoD4guW3lfjbsPAPOf5g/VwnwBFdL3+0cTYbHfGm/KF2+QGfl/+Ui6OXyMXDi+SSbKeAU+WYZWiZMrn4qco+JfdT+kwM0c3NM2KwP8cwwC0lspu+IziZLgrzi1GkI8PpuJL1q7ieq7a1ybA6OncRq/A4SKUObk4cw5KWwP4oUGisQECtFag1QtgaIWyNEGFrBXKNFYihtQLZly+QnQuEBp8VKDHGRZ6nTj7G819GHxKpafnLjOc5GXIiKULkuRQIeD2xxfnvWvTrpI8EoxIsI2hZCRYS1DpYSNBpHSwlqHWwkKAnJVhIUOtgIcGg/WAhwWiUYCFBXZOUEWQDSjBP0M17utbBhqDWwUKCoP1gKUEdi28guKR1z5OeCJK24lKCOqMuJMjaiksJah0sJKg7rMUEtQ4WEnS6u1VKUOtgIUGv/WAhwaCrulKCuiYpJBh1d6uUoFOCRQSt0X7wZ4KPWHSATWLRmVsKC+iSIInFK5YEFkTFksKiY3kKC+kAncSiq48kFh2gU1hYB+gklqBYElisDtBJLDpAp7A43cVJYtHJfwqL19qSxKJ9SwpLHHXegnTGsnoN+gcWN+yBMg/zm/LoV7cd7E38yHDUud8ehuDO/lz4+WCjG3bLoiJD0rZcznDUVX9FhsNuEexi6P3yEr6Pm3F52P2EigyH3XyoyVDH5WKGbtTnDjUZsjIsZqhjSjHDYV/Ir8lQ62Exw6Bzm3KGOrcpZjjs1QY1GbIyLGaoY0opQ290TClnqGNKMcNhr4nYxTDCcrl6xC1D7Q+LGdY5XQxhufh7/fw1zdBaP6eeNtbPFAEpWX5rl/L7Verp55OBOgdeX9NA6NwAu84N2BsO2bDx1w2Qg7kfIUfhWSbb1M6EuUjOxPNnF9IfUgg0uw3BPkv8WHxXu/jsN4wcvEQmL+HE13GypCbnYyba7JYOmx1zJrW3YT7N4p2x1+uGRzu7nX7kn+uGtwOZveUl7eOYHSmycaTIxoEiG8xAkQ1mqMjGgczecsT0OGbDQGbRDWT2li/ZHMesH8gsjxRZHqnN2oHWs8EdLLLBLGbDz1/IDOFYHdRUkjkx+Y3Z2H419mezmPn2KZ0/P0a4uqiepu36R7ftrwTquY0dLPJquuWh3La/GKjo9parmw7ktv0BqKJbHGkEih2sayu67WBhu8ft+avWNE0ht26PFduMWz5Wu825HSq2HSxua7odKrZuqNh2sHNR0a0/1oov5/ZYq/mc2/Yf7FV028EmXEW38Vjr25zbY+1dXHcLxhwsuHHePCcCfmZ3mxrC8uFQCGQTcA7WzqvCgYMtn+vCOdjMriocPNhEsC6cg80bq8LhkWuOWV4dmn5059T2Cc7R1s774DhY4HiTgNNWs/pRprYWTY9luuWzcC9epteYkvv5yAl7k3tzBxwt79O51cs4BE8OAnXvwPfu4FUOk9R10HsMwGD3DrqPAfTeDgBs9w5i7w6Qu3fQ/qwiLCXxELYOqP1ZRc5B9zHg9ke0nAPXuwNrunfQ/oiWceC6j8EtN6027qD73tR335v69tcHGQeh+fWBt3FxsLpD5uyg+REt5yA235tmHTTfm2YdNL9GyzhA03sM0DQ/ouUcQPMjWtZB770pYu+9Kba/25J10H1Lpu5bMnXfkrn7lsztt+Tlc5IQVg/pzw7anxdlHNjm902zDppfZeYcuPZ705yD7mPg21/p5xw0v2+addB9b9r+2Zasg+5bcvtnW7IOum/JHewXXXdApveWTO2fzglkFge0PZVA7Z9tyTpovh2sHawPUs8O2t9tyTroPgZUPQbR5coUzfL2QWRYlck8lSm2VyZuv8++viNC3PvOIHWwn5Bz0H0MXPcxaP/0Rs6B7z4G7b9pknPQwWo856D7GMTuYxB7jwF3sJbNOeg+BtB9DKD7GGD3Mej+5AC3/55G1kH3Meh+nczdr5O5+3Uyd79O5u7Xydz9Opm7Xydz9+tk7n6dzN2vk7n7dTJ3v0623a+TbffrZNv9OtnakS8ty9zLZe3B7sbdB2epZ2BCfAZnmzospQ7EmbQ2zNc72EBb6G7ke01fDfrI96X+MugO5mI4SnQvfuR7WF8Nutb0l4feweftjwc9Dn3l6mtB15r+4tDdwb5I2Ql0Vui/ALqdT426k6mfoQ99df+rQdcp48tDH/o2/deCTjqQvgJ0HUhfAfrBPhZV85MLjofegs3B0ZpzGc7RvnlaFY5+5uUanKEn2Rk4jX3bpTE4Qz+lzcAZe+c9A2fsHfIcHK05V+Bon3MRjh/6y7Q5OB18QjOc4Rh7HY7HMMOZfoR14h9u+VBuGebgesaE2/Z7hT1uKbprbjvYt9rlNtDZLV5PDEB+ud0D2MQNnA6+d7oLjptPSnry26rA7c8VKrq1Q8XWtr/fVdFtB6dPa7o92IB13a1vf3OyotvQ/m5jTbftbx9WdBvbPwZS0+1IsQ1mpHYbzEgzx0A3uKXVa1pJt9MWw/LMfFqInMvvIJV6eQ6OZvUcHJLFj8sLUT7G819GH1LUl7/Mqz0U5ERSpOUyRFzvoUyJH7ncsloakovWlySXW+6jGJJLUC4pLk7rS5qL1pckl1vezDskF4y4cFlNdpKJwSzzqMlq2EJ0CrEYYhh1ZrQL4sRg8WdhC3HUbq4mxKjNuRhivGVxrxBzEEddFe2DuGxFwNQDbiCiNucbILJZPnbBZlsTSUfnChBZIZZD1ClOOUTWZd8NEC0u/qw1W4heIRZDtFoTyyE6HZ0rQNTJdjlEr8u+ChB1ilMOMYz6JKQqxKgQiyFGVojlELUmlkJEY7RPvAWixwVixA1E0ClOBYi6KVsO8ZZ3zhRiDqIOLOUQSQeWChB1P7EcIuvoXA7R6n7iDRAJ8EwDthB1P7ECRB2dyyEOeyi4KkQdncsh6uOBGhB1YCmHqMeNa0DUmlgBok5xyiFGneJUgKhTnGKIoAffb4LIZxrObCFqTSyHCKwQyyHq6FwOEXWeWA5RX8GoAVGP1pVD1LcHil/BmCDqCYhyiPqgqgZErYnlEPXtgQ3EExdMb1Z7mu+C8EwbTfoF/MhzRtFu8qH0l1EzGhZown7NhW9ZXr0QY1I5iQpBpBLlRaK8SJQXi/JiUV5WFC8rysuJfF3obXKqKFF5Eqm8RBVwd29BId1bmPkyw4hbTYTdrZjTrfhqPgz7y8bp7yZkNCzQ7O/JOH3OL6MR5MP7RwC2gphaQT5OkE+6vUY71+voN4ew2BuBRpBP+kWpjCbs10RBPnF/PtZgJj4pjd8dUwso0AjySW+eXdeQEWj2twXLJNDs7w+sZYEm7tc4QT5O4McL6o4XxCfsrwfuwgwy0vK5n8jna4rJmidZFMku3ImSk13YgsrKfFZmw1Z24ShnTnbh3F1O5kEmS9YPNBCWVSK5rSxdRfIyK5JFWW5RlJs3RiZjkQxkuYHMW7qZ5mWiWuIJZTIvkqWHlbwsiGRWFu70+JKVOVm4vaxyyTqFC5/UyMtk4Y6yyhVF4Q4GZTKRt4AXcrO8yBxsZZdawPLexvRjSMiCKDd7oZDBLrJoEzIvkjlZbpdaQE52ob0FOMsScbs0LOZkstwiyWRBIouGZDJZboCSqhzBi2Qoy42MTGZFMgaZLIhklmSyKJI5lslkuXmZtyALQLxQyHh+BjL9vNrWjHgSTg8nvFAIIBVKi4okFUo9Xppb5oXSHFmaI0tztNI4ppee7Jcvlk77dwlZ+ka4vIxlsiCSpRtvXibLLf1sIS9zwshFlgqDTDg9UREKL61c80KWCoXdE6A0R5TmSNIcSRpHFtVUSHdOWVm6a8rLRB0TyDqmC8cr8rIoknnhGAheGvIgzTEIRySIIBUKexk0IBVKc5TOnvDSnlxeKKpwiCyTiUZCJJTJRP0LynozTD8CzsqscChDKw25k+boWCoU9jIo7ddQ2q+htF/DIM0xolQoqnBkQCazMpmofyFgmUyWG5JMJhzKSLqAJOkCkhikQmEvQ9J+jaT9Gkn7NXLiHIVTdJItJEm2kCTZQvLCObWsLMr6F1lvxsbIZMKhjI0w5CxdeTLsDnryMPj8QAXWJ6SnHuVHJvt7QEkmL+GEhAM4S7tIZltuy/v5qZxfHXZfTFnz67P45S5cep8IHCxvHDh0G5lPr6aysvQe0TMZcUJmRTLcn9u/06//ff/1/v2Hh0/fJtHpX//+/PH7/ZfPT79+/99f8798+Hr/8HD/57u/vn75+On3v79+evfw5ePp3+7M039+c1OoPPipOI/WGeMbJj79eqrZfnruO5VyynXK+f8=",
      "brillig_names": [
        "get_htlc_public"
      ]
    },
    {
      "name": "add_lock_private_user",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2588366281349374274": {
            "error_kind": "fmtstring",
            "length": 136,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "3473764466780631008": {
            "error_kind": "fmtstring",
            "length": 106,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5533887251808526417": {
            "error_kind": "fmtstring",
            "length": 120,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17476367995570638746": {
            "error_kind": "string",
            "string": "NoAllowance"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert"
      ],
      "verification_key": "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"
    },
    {
      "name": "lock_private_solver",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 48
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2588366281349374274": {
            "error_kind": "fmtstring",
            "length": 136,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "3473764466780631008": {
            "error_kind": "fmtstring",
            "length": 106,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5533887251808526417": {
            "error_kind": "fmtstring",
            "length": 120,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6418028854678020178": {
            "error_kind": "string",
            "string": "FundsNotSent"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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E5+raeJzNU98ruaJz9U88bmaJz5Xh/eX5bR94nM1T3yu5onP1TzxuZonPlfLxOdqmfhcLROfq2Xic3V4/1FO2yc+V8vE52qZ+FwtE5+rZd5zNZt5z9Vs5j1Xs5n3XM1m3nM1m3nP1WzmPVezmfdczWbeczWbec/VbCY+V+3E56qd+Fy1E5+rduJzdXj/Qk7bJz5X7cTnqp34XLUTn6t24nPVTXyuuonPVTfxueomPleH97fjtH3ic9VNfK66ic9VN/G56iY+V/3E56qf+Fz1E5+rfuJzdXj/M07bJz5X/cTnqp/4XPUTn6t+4nOVJj5XaeJzlSY+V2nic3V4fyxO2yc+V2nic5UmPldp4nOVJj5Xw8Tnapj4XA0Tn6sT91vKE/dbyhP3W8oT91vKE/dbyhP3W8oT91vKE/dbyhP3W8oT91vKE/dbyhP3W8oT91vKE/dbyhP3W8oT91vKE/dbyhP3W8oT91vKE/dbyhP3W8oT91vKE/dbyhP3W8oT91vKE/dbyhP3W8oT91vKE/dbyhP3W8oT91vKE/dbyhP3W8oT91vKE/dbyhP3W8oT91vKE/dbyhP3W8oT91vKE/dbyhP3W8oT91vKE/dbyhP3W8oT91vKE/dbKhP3WyoT91sqE/dbKhP3Wypm3nO1TNxvqUzcb6lM3G+pTNxvqUzcb6lM3G+pTNxvqUzcb6lM3G+pTNxvqUzcb6lM3G+pTNxvqUzcb6lM3G+pTNxvqUzcb6lM3G+pTNxvqUzcb6lM3G+pTNxvqUzcb6lM3G+pTNxvqUzcb6lM3G+pTNxvqUzcb6lM3G+pTNxvqUzcb6lM3G+pTNxvqUzcb6lM3G+pTNxvqUzcb6lM3G+pTNxvqUzcb6lM3G+pTNxvqUzcb6lM3G+pTNxvqUzcb6lM3G+pTNxvqUzcb6lM3G+pTNxvqUzcb6lM3G+pTNxvqUzcb6lM3G+pTNxvqUzcb6lM3G+pTNxvqUzcb6lM3G+pTNxvqUzcb6lM3G+pTNxvqUzcb6lM3G+pTNxvqUzcb6lM3G+pTNxvqYjut5SctV8XJ5fC9cWWEn1dbIP1+8U25yMsJm9UXHy6Nt2pSD6xP0ZFdI+oz1GRrDI+R0WyfvkcFcnK6HNUCFQOqEhWc5+jIlknfo6KZAX6OSrQtkdUoG0PqIju0/Y5KtC2R1RGa9vs7U4lmT+m8MPbxVXM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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "notify_created_nullifier_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "debug_log_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_integer_quotient",
        "directive_invert"
      ],
      "verification_key": "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"
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000001"
            },
            {
              "kind": "string",
              "value": "HTLC_Private"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Train"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "contracts_private",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "contracts_public",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "events": [
        {
          "fields": [
            {
              "name": "Id",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::TokenRefunded"
        },
        {
          "fields": [
            {
              "name": "Id",
              "type": {
                "kind": "field"
              }
            },
            {
              "name": "hashlock",
              "type": {
                "kind": "array",
                "length": 32,
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 8
                }
              }
            },
            {
              "name": "secret",
              "type": {
                "kind": "array",
                "length": 32,
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 8
                }
              }
            }
          ],
          "kind": "struct",
          "path": "Train::TokenRedeemed"
        },
        {
          "fields": [
            {
              "name": "Id",
              "type": {
                "kind": "field"
              }
            },
            {
              "name": "amount",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            },
            {
              "name": "token",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "timelock",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 64
              }
            },
            {
              "name": "src_receiver",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::TokenCommitted"
        },
        {
          "fields": [
            {
              "name": "Id",
              "type": {
                "kind": "field"
              }
            },
            {
              "name": "amount",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            },
            {
              "name": "token",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "timelock",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 64
              }
            }
          ],
          "kind": "struct",
          "path": "Train::TokenLocked"
        },
        {
          "fields": [
            {
              "name": "Id",
              "type": {
                "kind": "field"
              }
            },
            {
              "name": "timelock",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 64
              }
            }
          ],
          "kind": "struct",
          "path": "Train::TokenLockAdded"
        }
      ],
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::refund_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::refund_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "secret",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::redeem_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::redeem_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "key",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::get_htlc_public_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "src_receiver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "hashlock_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "hashlock_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "secret_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "secret_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "claimed",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::HTLC_Public"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::get_htlc_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "Train::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::refund_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::refund_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 48
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::lock_public_solver_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::lock_public_solver_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "src_receiver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 48
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::commit_private_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::commit_private_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 48
                    }
                  },
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "src_receiver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::commit_public_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::commit_public_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::add_lock_private_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::add_lock_private_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "secret",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::redeem_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::redeem_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::add_lock_public_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::add_lock_public_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 48
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::lock_private_solver_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::lock_private_solver_abi"
        }
      ]
    }
  },
  "file_map": {
    "103": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "106": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/keys/ecdh_shared_secret.nr",
      "source": "use dep::protocol_types::{\n    address::aztec_address::AztecAddress, point::Point, scalar::Scalar, traits::FromField,\n};\nuse std::{embedded_curve_ops::multi_scalar_mul, ops::Neg};\n\n/// Computes a standard ecdh shared secret: [secret] * public_key = shared_secret.\n/// The input secret is known only to one party. The output shared secret is derivable\n/// by both parties, through this function.\n/// E.g.:\n/// Epk = esk * G // ephemeral keypair\n/// Pk = sk * G // recipient keypair\n/// Shared secret S = esk * Pk = sk * Epk // see how this function can be called with two different sets of inputs, depending on which secret the caller knows (either esk or sk)?\n// See also: https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman\npub fn derive_ecdh_shared_secret(secret: Scalar, public_key: Point) -> Point {\n    let shared_secret = multi_scalar_mul([public_key], [secret]);\n    shared_secret\n}\n\n/// Computes a standard ecdh shared secret using the address public key of the given address:\n/// [ephemeral_secret] * recipient_address_public_key = shared_secret.\n/// The intention is that the _creator_ of a shared secret would call this function,\n/// given the address of their intended recipient.\npub fn derive_ecdh_shared_secret_using_aztec_address(\n    ephemeral_secret: Scalar,\n    recipient_address: AztecAddress,\n) -> Point {\n    derive_ecdh_shared_secret(ephemeral_secret, recipient_address.to_address_point().inner)\n}\n\n#[test]\nunconstrained fn test_consistency_with_typescript() {\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let shared_secret = derive_ecdh_shared_secret(secret, point);\n\n    // This is just pasted from a test run.\n    // The original typescript code from which this could be generated seems to have been deleted by someone, and soon the typescript code for encryption and decryption won't be needed, so this will have to do.\n    let hard_coded_shared_secret = Point {\n        x: 0x15d55a5b3b2caa6a6207f313f05c5113deba5da9927d6421bcaa164822b911bc,\n        y: 0x0974c3d0825031ae933243d653ebb1a0b08b90ee7f228f94c5c74739ea3c871e,\n        is_infinite: false,\n    };\n    assert_eq(shared_secret, hard_coded_shared_secret);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let shared_secret = derive_ecdh_shared_secret(secret_a, pk_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_from_address_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let mut pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let mut pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let address_b = AztecAddress::from_field(pk_b.x);\n\n    // We were lazy in deriving the secret keys, and didn't check the resulting y-coordinates\n    // of the pk_a or pk_b to be less than half the field modulus.\n    // If needed, we negate the pk's so that they yield valid address points.\n    // (We could also have negated the secrets, but there's no negate method for\n    // EmbeddedCurvesScalar).\n    pk_a = if (AztecAddress::from_field(pk_a.x).to_address_point().inner == pk_a) {\n        pk_a\n    } else {\n        pk_a.neg()\n    };\n    pk_b = if (address_b.to_address_point().inner == pk_b) {\n        pk_b\n    } else {\n        pk_b.neg()\n    };\n\n    let shared_secret = derive_ecdh_shared_secret_using_aztec_address(secret_a, address_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n"
    },
    "107": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/keys/ephemeral.nr",
      "source": "use std::embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul};\n\nuse dep::protocol_types::{point::Point, scalar::Scalar};\n\nuse crate::oracle::random::random;\n\npub fn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n\n    // Safety: we use the randomness to preserve the privacy of both the sender and recipient via encryption, so a\n    // malicious sender could use non-random values to reveal the plaintext. But they already know it themselves anyway,\n    // and so the recipient already trusts them to not disclose this information. We can therefore assume that the\n    // sender will cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // TODO(#12757): compute the key pair without constraining eph_sk twice (once in from_field, once in the black box\n    // called by fixed_base_scalar_mul).\n    let eph_sk = EmbeddedCurveScalar::from_field(randomness);\n    let eph_pk = fixed_base_scalar_mul(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n"
    },
    "108": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "112": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    discovery::private_notes::MAX_NOTE_PACKED_LEN,\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{\n            stub_registry,\n            utils::{check_each_fn_macroified, create_message_discovery_call},\n        },\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_notes` utility function PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_notes = generate_sync_notes();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_notes\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_notes() -> Quoted {\n    let message_discovery_call = create_message_discovery_call();\n\n    // TODO(https://github.com/noir-lang/noir/issues/7912): Doing the following unfortunately doesn't work. Once\n    // the issue is fixed uncomment the following and remove the workaround from TS (look for the issue link in the\n    // codebase).\n    // let utility: fn(FunctionDefinition) -> () = crate::macros::functions::utility;\n    // quote {\n    //     #[$utility]\n    //     unconstrained fn sync_notes() {\n    //         $message_discovery_call\n    //     }\n    // }\n\n    quote {\n        #[aztec::macros::functions::utility]\n        unconstrained fn sync_notes() {\n            $message_discovery_call\n        }\n    }\n}\n"
    },
    "113": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "116": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_slice, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_view,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_SLICE_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args =  &[];\n    // serialized_args = serialized_args.append(aztec::protocol_types::traits::Serialize::serialize(target_address));\n    // serialized_args = serialized_args.push_back(fee_juice_limit_per_tx as Field);\n    // ```\n    let serialized_args_slice_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_SLICE_NAME = &[];\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append = add_to_field_slice(SERIALIZED_ARGS_SLICE_NAME, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n"
    },
    "117": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "120": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, &[], false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "122": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher, poseidon2::Poseidon2Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, &[], true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "123": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use std::{collections::umap::UHashMap, hash::{BuildHasherDefault, poseidon2::Poseidon2Hasher}};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\nuse super::utils::is_note;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract. Only a single struct in the entire contract\n/// should have this macro (or `storage_no_init`) applied to it.\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot }, false);\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n/// Only a single struct in the entire contract should have this macro (or `storage`) applied to it.\npub comptime fn storage_no_init(_s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(\n    typ: Type,\n    slot: Quoted,\n    parent_is_map: bool,\n) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot }, true);\n        (quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }, 1)\n    } else {\n        let storage_size = if parent_is_map {\n            // Variables inside a map do not require contiguous slots since the map slot derivation is assumed to result\n            // in slots very far away from one another.\n            1\n        } else {\n            let (_, container_struct_generics) = typ.as_data_type().unwrap();\n            let stored_struct = container_struct_generics[0];\n\n            if is_note(stored_struct) {\n                // Private notes always occupy a single slot, since the slot is only used as a state variable\n                // identifier.\n                1\n            } else {\n                get_storage_size(typ)\n            }\n        };\n\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        (quote { $struct_name::new(context, $slot)}, storage_size)\n    }\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "127": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_interface::{NoteHash, NoteType},\n    retrieved_note::RetrievedNote,\n    utils::{compute_note_hash_for_nullify_from_read_request, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::notify_created_note;\nuse protocol_types::traits::Packable;\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    let note_hash_counter = context.side_effect_counter;\n\n    let note_hash = note.compute_note_hash(storage_slot);\n\n    let packed_note = Note::pack(note);\n    notify_created_note(\n        storage_slot,\n        Note::get_id(),\n        packed_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(note, storage_slot, note_hash_counter)\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n\n    destroy_note_unsafe(context, retrieved_note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_from_read_request(retrieved_note, note_hash_for_read_request);\n    let nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash = if retrieved_note.metadata.is_settled() {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifying so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, note_hash)\n}\n"
    },
    "129": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub note: Note,\n    pub storage_slot: Field,\n    pub note_hash_counter: u32, // a note_hash_counter of 0 means settled\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note, storage_slot: Field, note_hash_counter: u32) -> Self {\n        Self { note, storage_slot, note_hash_counter }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "132": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/note/note_getter.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n    retrieved_note::RetrievedNote,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::oracle;\nuse crate::utils::{array, comparison::compare};\nuse dep::protocol_types::{\n    constants::{GET_NOTES_ORACLE_RETURN_LENGTH, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL},\n    traits::{Packable, ToField},\n};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    packed_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the packed note.\n    // This allows easier packing and custom (un)packing schemas. A note property is located\n    // inside the packed note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = packed_note[selector.index].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_packed_note<let N: u32>(packed_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(packed_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (RetrievedNote<Note>, Field)\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    // Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do\n    // is check that the metadata is correct, and that the note exists.\n    let retrieved_note = unsafe { get_note_internal::<Note, N>(storage_slot) };\n\n    // For settled notes, the contract address is implicitly checked since the hash returned from\n    // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n    // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the contract\n    // address returned from the oracle matches. Since branching in circuits is expensive, we perform this check on all\n    // note types.\n    assert(\n        retrieved_note.contract_address.eq(context.this_address()),\n        \"Note contract address mismatch.\",\n    );\n\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (retrieved_note, note_hash_for_read_request)\n}\n\n/// Returns a BoundedVec of notes that have been proven to have been created by this contract, either in the current or\n/// past transactions (i.e. pending or settled notes). A second BoundedVec contains the note hashes used for the read\n/// requests, which can save constraints when computing the note's nullifiers.\n///\n/// WARNING: recall that notes are never destroyed! Note existence therefore does not imply that the note is _current_\n/// or _valid_ - this typically requires also emitting the note's nullifier to prove that it had not been emitted\n/// before. Because of this, calling this function directly from end-user applications should be discouraged, and safe\n/// abstractions such as aztec-nr's state variables should be used instead.\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // Safety: The notes are constrained below.\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the notes (as opposed to simply removing some), the private\n    // kernel will later validate that these note actually exist, so transformations would cause for that check\n    // to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = array::collapse(filtered_notes);\n    let mut note_hashes = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_packed_note = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let retrieved_note = notes.get_unchecked(i);\n\n            // For settled notes, the contract address is implicitly checked since the hash returned from\n            // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n            // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the\n            // contract address returned from the oracle matches. Since branching in circuits is expensive, we perform\n            // this check on all note types.\n            assert(\n                retrieved_note.contract_address.eq(context.this_address()),\n                \"Note contract address mismatch.\",\n            );\n\n            let packed_note = retrieved_note.note.pack();\n            check_packed_note(packed_note, options.selects);\n            if i != 0 {\n                check_notes_order(prev_packed_note, packed_note, options.sorts);\n            }\n            prev_packed_note = packed_note;\n\n            let note_hash_for_read_request =\n                compute_note_hash_for_read_request(retrieved_note, storage_slot);\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> RetrievedNote<Note>\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let opt_notes: [_; 1] = oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_fields,\n    );\n\n    opt_notes[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_fields,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\n/// Unconstrained variant of `get_notes`, meant to be used in unconstrained execution contexts. Notably only the note\n/// content is returned, and not any of the information used when proving its existence (e.g. nonce, note hash, etc.).\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteType + Packable<N> + Eq,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n\n    // We fetch the notes from the same oracle we use in the constrained case, except we don't bother inspecting the\n    // metadata in order to prove existence.\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_fields,\n    );\n\n    // Even though we don't expect for the opt_notes array to be sparse, collapse is still useful in this case to\n    // convert it into a BoundedVec.\n    array::collapse(opt_notes).map(\n        // view_notes just returns the actual note, so we drop the metadata\n        |retrieved_note| retrieved_note.note,\n    )\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
    },
    "135": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "138": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "141": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "142": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "143": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "144": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "145": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "146": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "150": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "151": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "152": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "153": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use crate::discovery::MAX_LOG_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    log_content: BoundedVec<Field, MAX_LOG_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        log_content,\n        tx_hash,\n        log_index_in_tx,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    log_content: BoundedVec<Field, MAX_LOG_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n) {}\n"
    },
    "154": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr",
      "source": "use crate::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn sync_notes(pending_tagged_log_array_base_slot: Field) {\n    sync_notes_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "156": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::{\n    note::{note_interface::NoteType, note_metadata::NoteMetadata, retrieved_note::RetrievedNote},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::IndexedTaggingSecret,\n    traits::{FromField, Packable},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {\n    // This wrapper exists to extract the ORACLE_RETURN_FIELD_LENGTH generic numeric param into a value and pass it to\n    // the oracle, so that it knows how big the return array must be.\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        ORACLE_RETURN_FIELD_LENGTH,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let MAX_NOTES: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    _placeholder_fields: [Field; ORACLE_RETURN_FIELD_LENGTH], // TODO: Compute this value automatically from MAX_NOTES\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let fields: [_; ORACLE_RETURN_FIELD_LENGTH] = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n\n    let mut opt_notes = [Option::none(); MAX_NOTES];\n    for i in 0..opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let maybe_nonce = fields[read_offset];\n            let maybe_note_hash_counter = fields[read_offset + 1] as u32;\n            let packed_note = array::subarray(fields, read_offset + 2);\n\n            let note = Note::unpack(packed_note);\n            let retrieved_note = RetrievedNote {\n                note,\n                contract_address,\n                metadata: NoteMetadata::from_raw_data(maybe_note_hash_counter != 0, maybe_nonce),\n            };\n\n            opt_notes[i] = Option::some(retrieved_note);\n        };\n    }\n    opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "157": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "158": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "159": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        embedded_curve_add_unsafe(point1, point2)\n    } else {\n        // In a constrained context we need to do some black magic in order to satisfy the backend's\n        // expectations about the inputs to an `embedded_curve_add` opcode.\n        //\n        // TODO: document this better.\n        let x_coordinates_match = point1.x == point2.x;\n        let y_coordinates_match = point1.y == point2.y;\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: x_coordinates_match,\n        };\n        // point1_1 is guaranteed to have a different abscissa than point2\n        let mut result = embedded_curve_add_unsafe(point1_1, point2);\n        result.is_infinite = x_coordinates_match;\n\n        // dbl if x_match, y_match\n        let double = embedded_curve_add_unsafe(point1, point1);\n        result = if double_predicate { double } else { result };\n\n        // infinity if x_match, !y_match\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"
    },
    "161": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "163": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/state_vars/private_immutable.nr",
      "source": "use dep::protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\nuse crate::context::{PrivateContext, UtilityContext};\nuse crate::note::{\n    lifecycle::create_note,\n    note_emission::NoteEmission,\n    note_getter::{get_note, view_notes},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateImmutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context, let N: u32> Storage<N> for PrivateImmutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateImmutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateImmutable>` type (for example), because the storage slot often also identifies an actor.\n    // e.g. the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<Note> PrivateImmutable<Note, &mut PrivateContext> {\n    // docs:start:initialize\n    pub fn initialize<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: NoteType + NoteHash + Packable<N>,\n    {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:get_note\n    pub fn get_note<let N: u32>(self) -> Note\n    where\n        Note: NoteType + NoteHash + Packable<N>,\n    {\n        let storage_slot = self.storage_slot;\n        let retrieved_note = get_note(self.context, storage_slot).0;\n\n        // Because the notes obtained from PrivateImmutable are not meant to be nullified and get_note(...) function\n        // has already constrained the note (by pushing a read request to the context), we can return just the note\n        // and skip the additional data in RetrievedNote.\n        retrieved_note.note\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateImmutable<Note, UtilityContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    // docs:start:is_initialized\n    pub unconstrained fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // view_note does not actually use the context, but it calls oracles that are only available in private\n    // docs:start:view_note\n    pub unconstrained fn view_note<let N: u32>(self) -> Note\n    where\n        Note: Packable<N>,\n    {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "172": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable.nr",
      "source": "use dep::protocol_types::{\n    shared_mutable::{\n        ScheduledDelayChange,\n        ScheduledValueChange,\n        shared_mutable_values::{unpack_delay_change, unpack_value_change},\n        SharedMutableValues,\n    },\n    traits::Packable,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\n\nmod test;\n\npub struct SharedMutable<T, let INITIAL_DELAY: u32, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// This will make the Aztec macros require that T implements the Packable and Eq traits, and allocate `M` storage\n// slots to this state variable.\nimpl<T, let INITIAL_DELAY: u32, Context, let M: u32> Storage<M> for SharedMutable<T, INITIAL_DELAY, Context>\nwhere\n    WithHash<SharedMutableValues<T, INITIAL_DELAY>, _>: Packable<M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in blocks. Reads in private are only valid as long as they are included in a block not too far into the\n// future, so that they can guarantee the value will not have possibly changed by then (because of the delay).\n// The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, let INITIAL_DELAY: u32, Context> SharedMutable<T, INITIAL_DELAY, Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PublicContext>\nwhere\n    T: Eq,\n{\n\n    pub fn schedule_value_change<let N: u32>(self, new_value: T)\n    where\n        T: Packable<N>,\n    {\n        let _value_change = self.schedule_and_return_value_change(new_value);\n    }\n\n    pub fn schedule_and_return_value_change<let N: u32>(\n        self,\n        new_value: T,\n    ) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n        let current_delay = delay_change.get_current(block_number);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let block_of_change = block_number + current_delay;\n        value_change.schedule_change(new_value, block_number, current_delay, block_of_change);\n\n        self.write(value_change, delay_change);\n\n        value_change\n    }\n\n    pub fn schedule_delay_change<let N: u32>(self, new_delay: u32)\n    where\n        T: Packable<N>,\n    {\n        let mut delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n\n        delay_change.schedule_change(new_delay, block_number);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    pub fn get_current_delay<let N: u32>(self) -> u32\n    where\n        T: Packable<N>,\n    {\n        let block_number = self.context.block_number() as u32;\n        self.read_delay_change().get_current(block_number)\n    }\n\n    pub fn get_scheduled_value<let N: u32>(self) -> (T, u32)\n    where\n        T: Packable<N>,\n    {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay<let N: u32>(self) -> (u32, u32)\n    where\n        T: Packable<N>,\n    {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change<let N: u32>(self) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        // We don't read ScheduledValueChange directly by having it implement Packable because ScheduledValueChange\n        // and ScheduledDelayChange are packed together (sdc and svc.block_of_change are stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_value_change::<T, N>(packed)\n    }\n\n    fn read_delay_change<let N: u32>(self) -> ScheduledDelayChange<INITIAL_DELAY>\n    where\n        T: Packable<N>,\n    {\n        // Since all ScheduledDelayChange member are packed into a single field, we can read a single storage slot\n        // here and skip the ones that correspond to ScheduledValueChange members. We are abusing the fact that\n        // the field containing the ScheduledDelayChange data is the first one in the storage layout - otherwise we'd\n        // need to offset the storage slot to get the position where it'd land.\n        // We don't read ScheduledDelayChange directly by having it implement Packable because\n        // ScheduledValueChange and ScheduledDelayChange are packed together (sdc and svc.block_of_change are\n        // stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_delay_change::<INITIAL_DELAY>(packed)\n    }\n\n    fn write<let N: u32>(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>,\n    )\n    where\n        T: Packable<N>,\n    {\n        // Whenever we write to public storage, we write both the value change and delay change to storage at once.\n        // We do so by wrapping them in a single struct (`SharedMutableValues`). Then we wrap the resulting struct in\n        // `WithHash`.\n        // Wrapping in `WithHash` makes for more costly writes but it also makes private proofs much simpler because\n        // they only need to produce a historical proof for the hash, which results in a single inclusion proof (as\n        // opposed to 4 in the best case scenario in which T is a single field). Private shared mutable reads are\n        // assumed to be much more frequent than public writes, so this tradeoff makes sense.\n        let values = WithHash::new(SharedMutableValues::new(value_change, delay_change));\n\n        self.context.storage_write(self.storage_slot, values);\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext>\nwhere\n    T: Eq,\n{\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction block number as this proof\n        // will only be valid for however many blocks we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n        let (value_change, delay_change, historical_block_number) =\n            self.historical_read_from_public_storage();\n\n        // We use the effective minimum delay as opposed to the current delay at the historical block as this one also\n        // takes into consideration any scheduled delay changes.\n        // For example, consider a scenario in which at block 200 the current delay was 50. We may naively think that\n        // the earliest we could change the value would be at block 251 by scheduling immediately after the historical\n        // block, i.e. at block 201. But if there was a delay change scheduled for block 210 to reduce the delay to 20\n        // blocks, then if a value change was scheduled at block 210 it would go into effect at block 230, which is\n        // earlier than what we'd expect if we only considered the current delay.\n        let effective_minimum_delay =\n            delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon =\n            value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any block after the block horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_tx_max_block_number(block_horizon);\n        value_change.get_current_at(historical_block_number)\n    }\n\n    fn historical_read_from_public_storage<let N: u32>(\n        self,\n    ) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u32)\n    where\n        T: Packable<N>,\n    {\n        let header = self.context.get_block_header();\n        let address = self.context.this_address();\n\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        let values: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::historical_public_storage_read(header, address, self.storage_slot);\n\n        (values.svc, values.sdc, historical_block_number)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, UtilityContext>\nwhere\n    T: Eq,\n{\n    pub unconstrained fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let smv: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::utility_public_storage_read(self.context, self.storage_slot);\n\n        let block_number = self.context.block_number() as u32;\n        smv.svc.get_current_at(block_number)\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "184": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "186": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/utils/array/mod.nr",
      "source": "pub mod append;\npub mod collapse;\npub mod subarray;\npub mod subbvec;\n\npub use append::append;\npub use collapse::collapse;\npub use subarray::subarray;\npub use subbvec::subbvec;\n\n// This will eventually be replaced by `BoundedVec::for_each`, once that's implemented.\npub unconstrained fn for_each_in_bounded_vec<T, let MaxLen: u32, Env>(\n    vec: BoundedVec<T, MaxLen>,\n    f: fn[Env](T, u32) -> (),\n) {\n    for i in 0..vec.len() {\n        f(vec.get_unchecked(i), i);\n    }\n}\n"
    },
    "187": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "188": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "190": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "191": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "193": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "195": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "196": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/utils/random.nr",
      "source": "use crate::oracle::random::random;\n\n/// Returns as many random bytes as specified through N.\npub unconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n"
    },
    "199": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "215": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "217": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "24": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "260": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "275": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "277": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "278": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "279": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr",
      "source": "use crate::traits::{Deserialize, Serialize, ToField};\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\nuse std::meta::derive;\n\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\n\n#[derive(Serialize, Deserialize)]\npub struct IndexedTaggingSecret {\n    app_tagging_secret: Field,\n    index: u32,\n}\n\nimpl IndexedTaggingSecret {\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\n        poseidon2_hash(\n            [self.app_tagging_secret, recipient.to_field(), self.index as Field],\n        )\n    }\n}\n"
    },
    "288": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "292": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `omit`: A list of field names (as `Quoted`) to be excluded from the serialized output.\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, &[], false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, &[], false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], &[], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, &[], false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with Omitted Field and packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// Serializing while omitting `value2`:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, MyStruct, &[quote { self.value2 }], true)\n/// // Returns:\n/// // ([`value_packed[0]`], [`let value_packed = self.value.pack()`])\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    omit: [Quoted],\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // Proceed if none of the omit rules omits this name\n    if !omit.any(|to_omit| to_omit == name) {\n        // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n        let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n        let packable_constraint =\n            quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n        if (should_pack & typ.implements(packable_constraint)) {\n            // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n            // method, add the resulting field array to `aux_vars` and each field to `fields`.\n            let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n            // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n            let name_at_one_token = collapse_to_one_token(name);\n            let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n            // We add the individual fields to the fields array\n            let pack_method = get_trait_impl_method(\n                typ,\n                quote { crate::traits::Packable<$packed_len> },\n                quote { pack },\n            );\n            let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n            for i in 0..packed_len {\n                fields = fields.push_back(quote { $packed_struct_name[$i] });\n            }\n\n            // We add the new auxiliary variable to the aux_vars array\n            aux_vars = aux_vars.push_back(packed_struct);\n        } else if typ.is_field() {\n            // For field we just add the value to fields\n            fields = fields.push_back(name);\n        } else if typ.as_integer().is_some() | typ.is_bool() {\n            // For integer and bool we just cast to Field and add the value to fields\n            fields = fields.push_back(quote { $name as Field });\n        } else if typ.as_data_type().is_some() {\n            // For struct we pref\n            let nested_struct = typ.as_data_type().unwrap();\n            let params = nested_struct.0.fields(nested_struct.1);\n            let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n                let maybe_prefixed_name = if name == quote {} {\n                    // Triggered when the param name is of a value available in the current scope (e.g. a function\n                    // argument) --> then we don't prefix the name with anything.\n                    param_name\n                } else {\n                    // Triggered when we want to prefix the param name with the `name` from function input. This\n                    // can typically be `self` when implementing a method on a struct.\n                    quote { $name.$param_name }\n                };\n                generate_serialize_to_fields(\n                    quote {$maybe_prefixed_name},\n                    param_type,\n                    omit,\n                    should_pack,\n                )\n            });\n            let struct_flattened_fields = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n            );\n            let struct_flattened_aux_vars = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n            );\n            fields = fields.append(struct_flattened_fields);\n            aux_vars = aux_vars.append(struct_flattened_aux_vars);\n        } else if typ.as_array().is_some() {\n            // For array we recursively call `generate_serialize_to_fields(...)` for each element\n            let (element_type, array_len) = typ.as_array().unwrap();\n            let array_len = array_len.as_constant().unwrap();\n            for i in 0..array_len {\n                let (element_fields, element_aux_vars) = generate_serialize_to_fields(\n                    quote { $name[$i] },\n                    element_type,\n                    omit,\n                    should_pack,\n                );\n                fields = fields.append(element_fields);\n                aux_vars = aux_vars.append(element_aux_vars);\n            }\n        } else if typ.as_str().is_some() {\n            // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n            // then we add each byte to fields as a Field\n            let length_type = typ.as_str().unwrap();\n            let str_len = length_type.as_constant().unwrap();\n            let as_member = name.as_expr().unwrap().as_member_access();\n            let var_name = if as_member.is_some() {\n                as_member.unwrap().1\n            } else {\n                name\n            };\n            let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n            let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n            for i in 0..str_len {\n                fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n            }\n            aux_vars = aux_vars.push_back(as_bytes);\n        } else {\n            panic(\n                f\"Unsupported type for serialization of argument {name} and type {typ}\",\n            )\n        }\n    }\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) =\n        generate_serialize_to_fields(quote { self }, typ, &[], packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "294": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "295": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "304": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize, ToField},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "308": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_delay_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initially equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation\n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the\n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a\n// reduced delay, invalidating prior private reads.\npub struct ScheduledDelayChange<let INITIAL_DELAY: u32> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option,\n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pub(crate) pre: Option<u32>,\n    pub(crate) post: Option<u32>,\n    // Block at which `post` value is used instead of `pre`\n    pub(crate) block_of_change: u32,\n}\n\nimpl<let INITIAL_DELAY: u32> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u32>, post: Option<u32>, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current block number - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_block_number: u32) -> u32 {\n        // The post value becomes the current one at the block of change, so any transaction that is included in the\n        // block of change will use the post value.\n        if current_block_number < self.block_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the block at which it will become the current\n    /// delay. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u32, u32) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.block_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current block number. This function is only meaningful\n    /// when called in public with the current block number.\n    /// The block at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u32, current_block_number: u32) {\n        let current = self.get_current(current_block_number);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let blocks_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior constraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value block of change\n            //       block                 block of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   blocks until change               new delay            |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.block_of_change = current_block_number + blocks_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical block number. It only returns a meaningful value when called in private with historical blocks. This\n    /// function can be used alongside `ScheduledValueChange.get_block_horizon` to properly constrain the\n    /// `max_block_number` transaction property when reading mutable shared state.\n    /// This value typically equals the current delay at the block following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is\n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_block_number: u32) -> u32 {\n        if self.block_of_change <= historical_block_number {\n            // If no delay changes were scheduled, then the delay value at the historical block (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // block of change the current delay will be the scheduled one, with an overall delay from the historical\n            // block number equal to the number of blocks until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //         block                  delay                  actual earliest value\n            //           v                block of change              block of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest block in            |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |         blocks                  new delay                      |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest block in\n            //                             which to scheduled value change\n            let blocks_until_change = self.block_of_change - (historical_block_number + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                blocks_until_change + self.post.unwrap_or(INITIAL_DELAY),\n            )\n        }\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Empty for ScheduledDelayChange<INITIAL_DELAY> {\n    fn empty() -> Self {\n        Self { pre: Option::none(), post: Option::none(), block_of_change: 0 }\n    }\n}\n"
    },
    "310": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_value_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some block\n// called the `block_of_change`. The value can only be made to change by scheduling a change event at some future block\n// of change after some minimum delay measured in blocks has elapsed. This means that at any given block number we know\n// both the current value and the smallest block number at which the value might change - this is called the\n// 'block horizon'.\npub struct ScheduledValueChange<T> {\n    pub(crate) pre: T,\n    pub(crate) post: T,\n    // Block at which `post` value is used instead of `pre`\n    pub(crate) block_of_change: u32,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given block. This function can be called both in public\n    /// (where `block_number` is simply the current block number, i.e. the number of the block in which the current\n    /// transaction will be included) and in private (where `block_number` is the historical block number that is used\n    /// to construct the proof).\n    /// Reading in private is only safe if the transaction's `max_block_number` property is set to a value lower or\n    /// equal to the block horizon (see `get_block_horizon()`).\n    pub fn get_current_at(self, block_number: u32) -> T {\n        // The post value becomes the current one at the block of change. This means different things in each realm:\n        // - in public, any transaction that is included in the block of change will use the post value\n        // - in private, any transaction that includes the block of change as part of the historical state will use the\n        //   post value (barring any follow-up changes)\n        if block_number < self.block_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the block at which it will become the current\n    /// value. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u32) {\n        (self.post, self.block_of_change)\n    }\n\n    // Returns the previous value. This is the value that is current up until the block of change. Note that this value\n    // might not be the current anymore since block of change might have already passed.\n    pub fn get_previous(self) -> (T, u32) {\n        (self.pre, self.block_of_change)\n    }\n\n    /// Returns the largest block number at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_block_number`,\n    /// since due to its asynchronous nature private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum number of blocks that need to\n    /// elapse from the next block until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical block number is only safe to use\n    /// if the transaction's `max_block_number` property is set to a value lower or equal to the block horizon computed\n    /// using the same historical block number.\n    pub fn get_block_horizon(self, historical_block_number: u32, minimum_delay: u32) -> u32 {\n        // The block horizon is the very last block in which the current value is known. Any block past the horizon\n        // (i.e. with a block number larger than the block horizon) may have a different current value. Reading the\n        // current value in private typically requires constraining the maximum valid block number to be equal to the\n        // block horizon.\n        if historical_block_number >= self.block_of_change {\n            // Once the block of change has been mined, the current value (post) will not change unless a new value\n            // change is scheduled. This did not happen at the historical block number (or else it would not be\n            // greater or equal to the block of change), and therefore could only happen after the historical block\n            // number. The earliest would be the immediate next block, and so the smallest possible next block of change\n            // equals `historical_block_number + 1 + minimum_delay`. Our block horizon is simply the previous block to\n            // that one.\n            //\n            //      block of      historical\n            //       change         block            block horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n            historical_block_number + minimum_delay\n        } else {\n            // If the block of change has not yet been mined however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the block horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the block of change is in the past: the time horizon is the\n            //      block prior to the earliest one in which a new block of change might land.\n            //\n            //         historical\n            //           block                        block horizon      block of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` blocks away from the historical block number, in which case\n            //      the block of change would become the limiting factor for the time horizon, which would equal the\n            //      block right before the block of change (since by definition the value changes at the block of\n            //      change).\n            //\n            //           historical                         block horizon\n            //             block     block of change       if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the block of change to an arbitrary\n            // value, and therefore scenario a) is not currently possible. However implementing #5501 would allow for\n            // this to happen.\n            // Because historical_block_number < self.block_of_change, then block_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.block_of_change - 1,\n                historical_block_number + minimum_delay,\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current block number. This function is only meaningful when\n    /// called in public with the current block number.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_block_number: u32,\n        minimum_delay: u32,\n        block_of_change: u32,\n    ) {\n        assert(block_of_change >= current_block_number + minimum_delay);\n\n        self.pre = self.get_current_at(current_block_number);\n        self.post = new_value;\n        self.block_of_change = block_of_change;\n    }\n}\n\nimpl<T> Eq for ScheduledValueChange<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n\nimpl<T> Empty for ScheduledValueChange<T>\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        Self { pre: T::empty(), post: T::empty(), block_of_change: 0 }\n    }\n}\n"
    },
    "312": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/shared_mutable_values.nr",
      "source": "use crate::{\n    hash::poseidon2_hash,\n    shared_mutable::{\n        scheduled_delay_change::ScheduledDelayChange, scheduled_value_change::ScheduledValueChange,\n    },\n    traits::{Hash, Packable},\n    utils::arrays,\n};\nuse std::meta::derive;\n\nmod test;\n\n/// SharedMutableValues is just a wrapper around ScheduledValueChange and ScheduledDelayChange that then allows us\n/// to wrap both of these values in WithHash. WithHash allows for efficient read of values in private.\n///\n/// Note that the WithHash optimization does not work in public (due to there being no unconstrained). But we also want\n/// to be able to read the values efficiently in public and we want to be able to read each value separately. Reading\n/// the values separately is tricky because ScheduledValueChange and ScheduledDelayChange are packed together (sdc and\n/// svc.block_of_change are stored in the same slot). For that reason we expose `unpack_value_change` and\n/// `unpack_delay_change` functions that can be used to extract the values from the packed representation. This\n/// is \"hacky\" but there is no way around it.\n#[derive(Eq)]\npub struct SharedMutableValues<T, let INITIAL_DELAY: u32> {\n    pub svc: ScheduledValueChange<T>,\n    pub sdc: ScheduledDelayChange<INITIAL_DELAY>,\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutableValues<T, INITIAL_DELAY> {\n    pub fn new(svc: ScheduledValueChange<T>, sdc: ScheduledDelayChange<INITIAL_DELAY>) -> Self {\n        SharedMutableValues { svc, sdc }\n    }\n}\n\npub fn unpack_value_change<T, let N: u32>(packed: [Field; 2 * N + 1]) -> ScheduledValueChange<T>\nwhere\n    T: Packable<N>,\n{\n    let svc_pre_packed = arrays::subarray(packed, 1);\n    let svc_post_packed = arrays::subarray(packed, N + 1);\n    ScheduledValueChange::new(\n        T::unpack(svc_pre_packed),\n        T::unpack(svc_post_packed),\n        packed[0] as u32,\n    )\n}\n\npub fn unpack_delay_change<let INITIAL_DELAY: u32>(\n    packed: Field,\n) -> ScheduledDelayChange<INITIAL_DELAY> {\n    // This function expects to be called with just the first field of the packed representation, which contains sdc\n    // and svc block_of_change. We'll discard the svc component.\n    let svc_block_of_change = packed as u32;\n\n    let mut tmp = (packed - svc_block_of_change as Field) / TWO_POW_32;\n    let sdc_block_of_change = tmp as u32;\n\n    tmp = (tmp - sdc_block_of_change as Field) / TWO_POW_32;\n    let sdc_post_is_some = tmp as bool;\n\n    tmp = (tmp - sdc_post_is_some as Field) / TWO_POW_8;\n    let sdc_post_inner = tmp as u32;\n\n    tmp = (tmp - sdc_post_inner as Field) / TWO_POW_32;\n    let sdc_pre_is_some = tmp as bool;\n\n    tmp = (tmp - sdc_pre_is_some as Field) / TWO_POW_8;\n    let sdc_pre_inner = tmp as u32;\n\n    ScheduledDelayChange {\n        pre: if sdc_pre_is_some {\n            Option::some(sdc_pre_inner)\n        } else {\n            Option::none()\n        },\n        post: if sdc_post_is_some {\n            Option::some(sdc_post_inner)\n        } else {\n            Option::none()\n        },\n        block_of_change: sdc_block_of_change,\n    }\n}\n\nglobal TWO_POW_32: Field = 2.pow_32(32);\nglobal TWO_POW_8: Field = 2.pow_32(8);\n\n// We pack to `2 * N + 1` fields because ScheduledValueChange contains T twice (hence `2 * N`) and we need one extra\n// field to store ScheduledDelayChange and the block_of_change of ScheduledValueChange.\nimpl<T, let INITIAL_DELAY: u32, let N: u32> Packable<2 * N + 1> for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; 2 * N + 1] {\n        let mut result = [0; 2 * N + 1];\n\n        // We pack sdc.pre, sdc.post, sdc.block_of_change and svc.block_of_change into a single field as follows:\n        // [ sdc.pre_inner: u32 | sdc.pre_is_some: u8 | sdc.post_inner: u32 | sdc.post_is_some: u8 | sdc.block_of_change: u32 | svc.block_of_change: u32 ]\n        result[0] = self.svc.block_of_change as Field\n            + ((self.sdc.block_of_change as Field) * 2.pow_32(32))\n            + ((self.sdc.post.is_some() as Field) * 2.pow_32(64))\n            + ((self.sdc.post.unwrap_unchecked() as Field) * 2.pow_32(72))\n            + ((self.sdc.pre.is_some() as Field) * 2.pow_32(104))\n            + ((self.sdc.pre.unwrap_unchecked() as Field) * 2.pow_32(112));\n\n        // Pack the pre and post values from ScheduledValueChange\n        let svc_pre_packed = self.svc.pre.pack();\n        let svc_post_packed = self.svc.post.pack();\n        for i in 0..N {\n            result[i + 1] = svc_pre_packed[i];\n            result[i + 1 + N] = svc_post_packed[i];\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; 2 * N + 1]) -> Self {\n        let svc = unpack_value_change::<T, N>(fields);\n        let sdc = unpack_delay_change::<INITIAL_DELAY>(fields[0]);\n        Self::new(svc, sdc)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32, let N: u32> Hash for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn hash(self) -> Field {\n        poseidon2_hash(self.pack())\n    }\n}\n"
    },
    "315": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "329": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n"
    },
    "333": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "334": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "350": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "351": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "353": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "359": {
      "path": "/home/nerses/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "388": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    encrypted_logs::log_assembly_strategies::default_aes128,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER},\n        hash::poseidon2_hash_with_separator,\n        traits::{Deserialize, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// The returned `PartialUintNote` value must be sent to public execution via a secure channel, since it is not\n    /// possible to verify the integrity of its contents due to it hiding information. The recommended ways to do this\n    /// are to retrieve it from public storage, or to receive it in an internal public function call.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log = default_aes128::note::compute_partial_note_log(\n            private_log_content,\n            storage_slot,\n            recipient,\n            sender,\n        );\n        context.emit_private_log(encrypted_log);\n\n        PartialUintNote { commitment }\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nimpl PartialUintNote {\n    pub fn commitment(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, value: u128, context: &mut PublicContext) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; 2] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n"
    },
    "46": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "47": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "54": {
      "path": "/home/nerses/contracts/chains/aztec/contracts/train/src/lib.nr",
      "source": "pub fn bytes_to_u128_limbs(bytes: [u8; 32]) -> (u128, u128) {\n    let mut high: u128 = 0;\n    let mut low: u128 = 0;\n    for i in 0..16 {\n        high = (high << 8) + (bytes[i] as u128);\n    }\n    for i in 16..32 {\n        low = (low << 8) + (bytes[i] as u128);\n    }\n    (high, low)\n}\n\npub fn u128_limbs_to_bytes(high: u128, low: u128) -> [u8; 32] {\n    let mut bytes: [u8; 32] = [0; 32];\n\n    let mut temp = high;\n    for i in 0..16 {\n        bytes[15 - i] = (temp & 0xff) as u8;\n        temp >>= 8;\n    }\n\n    temp = low;\n    for i in 0..16 {\n        bytes[31 - i] = (temp & 0xff) as u8;\n        temp >>= 8;\n    }\n\n    bytes\n}\n"
    },
    "55": {
      "path": "/home/nerses/contracts/chains/aztec/contracts/train/src/main.nr",
      "source": "mod lib;\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract Train {\n    use crate::lib::{bytes_to_u128_limbs, u128_limbs_to_bytes};\n    use dep::aztec::encrypted_logs::log_assembly_strategies::default_aes128::note::encode_and_encrypt_note;\n    use dep::aztec::protocol_types::traits::{Packable, Serialize};\n    use dep::aztec::state_vars::{private_immutable::PrivateImmutable, SharedMutable};\n    use dep::sha256;\n    use dep::token::Token;\n    use aztec::macros::{\n        events::event,\n        functions::{initializer, internal, private, public, utility, view},\n        notes::note,\n        storage::storage,\n    };\n    use aztec::prelude::{AztecAddress, Map};\n    use std::meta::derive;\n\n    #[note]\n    #[derive(Eq)]\n    struct HTLC_Private {\n        owner: AztecAddress,\n        randomness: Field,\n    }\n    #[derive(Eq, Packable, Serialize)]\n    pub struct HTLC_Public {\n        src_receiver: AztecAddress,\n        amount: u128,\n        token: AztecAddress,\n        hashlock_high: u128,\n        hashlock_low: u128,\n        secret_high: u128,\n        secret_low: u128,\n        timelock: u64,\n        claimed: u8,\n    }\n\n    // TODO: Figure out how to emit all required data while staying within the public log size limit.\n    #[derive(Serialize)]\n    #[event]\n    struct TokenCommitted {\n        Id: Field,\n        amount: u128,\n        token: AztecAddress,\n        timelock: u64,\n        // dst_chain: str<8>,\n        // dst_asset: str<8>,\n        // dst_address: str<48>,\n        src_receiver: AztecAddress,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct TokenLockAdded {\n        Id: Field,\n        // hashlock: [u8; 32],\n        timelock: u64,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct TokenRefunded {\n        Id: Field,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct TokenLocked {\n        Id: Field,\n        // hashlock: [u8; 32],\n        amount: u128,\n        token: AztecAddress,\n        timelock: u64,\n        // dst_chain: str<8>,\n        // dst_asset: str<8>,\n        // dst_address: str<48>,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct TokenRedeemed {\n        Id: Field,\n        hashlock: [u8; 32],\n        secret: [u8; 32],\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor() {}\n\n    #[storage]\n    struct Storage<Context> {\n        contracts_private: Map<Field, PrivateImmutable<HTLC_Private, Context>, Context>,\n        contracts_public: Map<Field, SharedMutable<HTLC_Public, 1, Context>, Context>, // later block deplay number can be changed to smth reasonable\n    }\n\n    #[private]\n    fn commit_private_user(\n        Id: Field,\n        src_receiver: AztecAddress,\n        timelock: u64,\n        token: AztecAddress,\n        amount: u128,\n        dst_chain: str<8>,\n        dst_asset: str<8>,\n        dst_address: str<48>,\n        randomness: Field,\n    ) {\n        assert(amount > 0, \"Funds Not Sent\");\n\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address())\n            .commit_public_user(\n                dst_chain,\n                dst_asset,\n                dst_address,\n                Id,\n                src_receiver,\n                timelock,\n                token,\n                amount,\n            )\n            .enqueue(&mut context);\n\n        let htlc_note = HTLC_Private { owner: context.msg_sender(), randomness: randomness };\n        storage.contracts_private.at(Id).initialize(htlc_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n\n        Token::at(token)\n            .transfer_in_private(context.msg_sender(), context.this_address(), amount, randomness)\n            .call(&mut context);\n    }\n\n    #[internal]\n    #[public]\n    fn commit_public_user(\n        dst_chain: str<8>,\n        dst_asset: str<8>,\n        dst_address: str<48>,\n        Id: Field,\n        src_receiver: AztecAddress,\n        timelock: u64,\n        token: AztecAddress,\n        amount: u128,\n    ) {\n        assert(context.timestamp() + 900 < timelock, \"InvalidTimelock\");\n        let htlc_public = HTLC_Public {\n            src_receiver: src_receiver,\n            amount: amount,\n            token: token,\n            hashlock_high: 0 as u128,\n            hashlock_low: 0 as u128,\n            secret_high: 0 as u128,\n            secret_low: 0 as u128,\n            timelock: timelock,\n            claimed: 1 as u8,\n        };\n        storage.contracts_public.at(Id).schedule_value_change(htlc_public);\n        let log_msg = TokenCommitted {\n            Id: Id,\n            amount: amount,\n            token: token,\n            timelock: timelock,\n            // dst_chain: dst_chain,\n            // dst_asset: dst_asset,\n            // dst_address: dst_address,\n            src_receiver: src_receiver,\n        };\n        context.emit_public_log(log_msg);\n    }\n\n    #[private]\n    fn add_lock_private_user(Id: Field, hashlock: [u8; 32], timelock: u64) {\n        let htlc_private = storage.contracts_private.at(Id).get_note();\n        assert(htlc_private.owner == context.msg_sender(), \"NoAllowance\");\n\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address()).add_lock_public_user(Id, hashlock, timelock).enqueue(\n            &mut context,\n        );\n    }\n\n    #[internal]\n    #[public]\n    fn add_lock_public_user(Id: Field, hashlock: [u8; 32], timelock: u64) {\n        assert(context.timestamp() + 900 < timelock, \"InvalidTimelock\");\n\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n        assert(htlc_public.hashlock_high == (0 as u128), \"HashlockAlreadySet\");\n        assert(htlc_public.hashlock_low == (0 as u128), \"HashlockAlreadySet\");\n\n        let hashlock_tuple = bytes_to_u128_limbs(hashlock);\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: hashlock_tuple.0,\n            hashlock_low: hashlock_tuple.1,\n            secret_high: htlc_public.secret_high,\n            secret_low: htlc_public.secret_low,\n            timelock: timelock,\n            claimed: htlc_public.claimed,\n        };\n        storage.contracts_public.at(Id).schedule_value_change(modified_htlc_public);\n        // let log_msg = TokenLockAdded { Id, hashlock, timelock };\n        let log_msg = TokenLockAdded { Id, timelock };\n        context.emit_public_log(log_msg);\n    }\n\n    #[private]\n    fn refund_private(Id: Field, randomness: Field) {\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address()).refund_public(Id).enqueue(&mut context);\n\n        let htlc_private = storage.contracts_private.at(Id).get_note();\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n\n        Token::at(htlc_public.token)\n            .transfer_in_private(\n                context.this_address(),\n                htlc_private.owner,\n                htlc_public.amount,\n                randomness,\n            )\n            .call(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn refund_public(Id: Field) {\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n        assert(htlc_public.timelock < context.timestamp(), \"NotPassedTimelock\");\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: htlc_public.hashlock_high,\n            hashlock_low: htlc_public.hashlock_low,\n            secret_high: htlc_public.secret_high,\n            secret_low: htlc_public.secret_low,\n            timelock: htlc_public.timelock,\n            claimed: 2 as u8,\n        };\n\n        storage.contracts_public.at(Id).schedule_value_change(modified_htlc_public);\n        let log_msg = TokenRefunded { Id };\n        context.emit_public_log(log_msg);\n    }\n\n    #[private]\n    fn lock_private_solver(\n        Id: Field,\n        hashlock: [u8; 32],\n        amount: u128,\n        timelock: u64,\n        token: AztecAddress,\n        randomness: Field,\n        dst_chain: str<8>,\n        dst_asset: str<8>,\n        dst_address: str<48>,\n    ) {\n        assert(amount > 0, \"FundsNotSent\");\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address())\n            .lock_public_solver(\n                Id,\n                hashlock,\n                amount,\n                token,\n                timelock,\n                dst_chain,\n                dst_asset,\n                dst_address,\n            )\n            .enqueue(&mut context);\n\n        let htlc_note = HTLC_Private { owner: context.msg_sender(), randomness: randomness };\n        storage.contracts_private.at(Id).initialize(htlc_note);\n\n        Token::at(token)\n            .transfer_in_private(context.msg_sender(), context.this_address(), amount, randomness)\n            .call(&mut context);\n    }\n\n    #[internal]\n    #[public]\n    fn lock_public_solver(\n        Id: Field,\n        hashlock: [u8; 32],\n        amount: u128,\n        token: AztecAddress,\n        timelock: u64,\n        dst_chain: str<8>,\n        dst_asset: str<8>,\n        dst_address: str<48>,\n    ) {\n        assert(context.timestamp() + 2700 < timelock, \"InvalidTimelock\");\n        let hashlock_tuple = bytes_to_u128_limbs(hashlock);\n        let htlc_public = HTLC_Public {\n            src_receiver: AztecAddress::zero(),\n            amount: amount,\n            token: token,\n            hashlock_high: hashlock_tuple.0,\n            hashlock_low: hashlock_tuple.1,\n            secret_high: 0 as u128,\n            secret_low: 0 as u128,\n            timelock: timelock,\n            claimed: 1 as u8,\n        };\n        storage.contracts_public.at(Id).schedule_value_change(htlc_public);\n\n        let log_msg = TokenLocked {\n            Id: Id,\n            // hashlock: hashlock,\n            amount: amount,\n            token: token,\n            timelock: timelock,\n            // dst_chain: dst_chain,\n            // dst_asset: dst_asset,\n            // dst_address: dst_address,\n        };\n\n        context.emit_public_log(log_msg);\n    }\n\n    #[private]\n    fn redeem_private(Id: Field, secret: [u8; 32], randomness: Field) {\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address()).redeem_public(Id, secret).enqueue(&mut context);\n\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n\n        if htlc_public.src_receiver == AztecAddress::zero() {\n            Token::at(htlc_public.token)\n                .transfer_in_private(\n                    context.this_address(),\n                    context.msg_sender(),\n                    htlc_public.amount,\n                    randomness,\n                )\n                .call(&mut context);\n        } else {\n            Token::at(htlc_public.token)\n                .transfer_in_private(\n                    context.this_address(),\n                    htlc_public.src_receiver,\n                    htlc_public.amount,\n                    randomness,\n                )\n                .call(&mut context);\n        }\n    }\n\n    #[public]\n    #[internal]\n    fn redeem_public(Id: Field, secret: [u8; 32]) {\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public.amount > 0, \"HTLCNotExists\"); // If it doesn't exist, all parameters will default to zero values.\n        let hashed_secret = sha256::sha256_var(secret, secret.len() as u64);\n        let hashed_secret_tuple = bytes_to_u128_limbs(hashed_secret);\n        assert(htlc_public.hashlock_high == hashed_secret_tuple.0, \"HashlockNotMatch\");\n        assert(htlc_public.hashlock_low == hashed_secret_tuple.1, \"HashlockNotMatch\");\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: htlc_public.hashlock_high,\n            hashlock_low: htlc_public.hashlock_low,\n            secret_high: htlc_public.secret_high,\n            secret_low: htlc_public.secret_low,\n            timelock: htlc_public.timelock,\n            claimed: 3 as u8,\n        };\n\n        storage.contracts_public.at(Id).schedule_value_change(modified_htlc_public);\n\n        let log_msg = TokenRedeemed {\n            Id: Id,\n            hashlock: u128_limbs_to_bytes(htlc_public.hashlock_high, htlc_public.hashlock_low),\n            secret: secret,\n        };\n\n        context.emit_public_log(log_msg);\n    }\n\n    // This utility function should be invoked by the frontend before each function call\n    // where the existence or non-existence of an HTLC is a critical security check.\n    #[utility]\n    unconstrained fn is_contract_initialized(Id: Field) -> bool {\n        storage.contracts_private.at(Id).is_initialized()\n    }\n\n    #[view]\n    #[public]\n    fn get_htlc_public(key: Field) -> pub HTLC_Public {\n        storage.contracts_public.at(key).get_current_value()\n    }\n\n}\n"
    },
    "56": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n}\n"
    },
    "57": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "64": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use dep::protocol_types::debug_log::debug_log_format;\n\nuse crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n\n        // WARNING(https://github.com/AztecProtocol/aztec-packages/issues/10558): if you delete this debug_log_format line, some tests fail.\n        debug_log_format(\n            \"Context.note_hashes, after pushing new note hash: {0}\",\n            self.note_hashes.storage().map(|nh: NoteHash| nh.value),\n        );\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index],\n                },\n            );\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "65": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(gas_for_call(gas_opts), contract_address, calldata);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(gas_for_call(gas_opts), contract_address, calldata);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_opcode(gas, address, args)\n}\n\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "66": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "67": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "69": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/discovery/mod.nr",
      "source": "use crate::encrypted_logs::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\nuse protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\n/// We reserve two fields in the note private log that are not part of the note content: one for the storage slot, and\n/// one for the combined log and note type ID.\nglobal PRIVATE_LOG_EXPANDED_METADATA_LEN: u32 = 1;\n\n/// The maximum length of the log's content, i.e. after log type ID and metadata extraction.\npub global MAX_LOG_CONTENT_LEN: u32 =\n    PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS - PRIVATE_LOG_EXPANDED_METADATA_LEN;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "70": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/discovery/nonce_discovery.nr",
      "source": "use crate::{\n    discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    array::for_each_in_bounded_vec(\n        unique_note_hashes_in_tx,\n        |expected_unique_note_hash, i| {\n            // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n            // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n            let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n            // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n            // the note hash at the array index we're currently processing.\n            // TODO(#11157): handle failed note_hash_and_nullifier computation\n            let hashes = compute_note_hash_and_nullifier(\n                packed_note,\n                storage_slot,\n                note_type_id,\n                contract_address,\n                candidate_nonce,\n            )\n                .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n            let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n            let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n            if unique_note_hash == expected_unique_note_hash {\n                // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n                // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n                // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n                // PXE may fail to realize that a given note has been nullified already, and calls to the application\n                // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n                // application already has more direct means of making a call to it fail the transaction.\n                discovered_notes.push(\n                    DiscoveredNoteInfo {\n                        nonce: candidate_nonce,\n                        note_hash: hashes.note_hash,\n                        inner_nullifier: hashes.inner_nullifier,\n                    },\n                );\n\n                // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n                // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n                // notes containing random values in order to hide their contents.\n            }\n        },\n    );\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n"
    },
    "71": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    discovery::{\n        ComputeNoteHashAndNullifier,\n        MAX_LOG_CONTENT_LEN,\n        nonce_discovery::{attempt_note_nonce_discovery, DiscoveredNoteInfo},\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_LOG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private log (e.g.\n/// the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_LOG_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_LOG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    log_metadata: u64,\n    log_content: BoundedVec<Field, MAX_LOG_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_log(log_metadata, log_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    let mut i = 0;\n    while i < pending_partial_notes.len() {\n        let pending_partial_note: DeliveredPendingPartialNote = pending_partial_notes.get(i);\n\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            i += 1 as u32;\n            // Note that we're not removing the pending partial note from the PXE DB, so we will continue searching\n            // for this tagged log when performing message discovery in the future until we either find it or the\n            // entry is somehow removed from the PXE DB.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the log sans the extra fields) to get the\n            // complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            array::for_each_in_bounded_vec(\n                discovered_notes,\n                |discovered_note: DiscoveredNoteInfo, _| {\n                    // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                    // temporary node connectivity issue - is simply throwing good enough here?\n                    assert(\n                        deliver_note(\n                            contract_address,\n                            pending_partial_note.storage_slot,\n                            discovered_note.nonce,\n                            complete_packed_note,\n                            discovered_note.note_hash,\n                            discovered_note.inner_nullifier,\n                            log.tx_hash,\n                            pending_partial_note.recipient,\n                        ),\n                        \"Failed to deliver note\",\n                    );\n                },\n            );\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n\n            // We don't increment `i` here, because CapsuleArray is contiguous and its `remove(...)` function\n            // shifts the elements to the left if the removed element is not the last element.\n        }\n    }\n}\n\nfn decode_partial_note_private_log(\n    log_metadata: u64,\n    log_content: BoundedVec<Field, MAX_LOG_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = log_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        log_content.len() > PARTIAL_NOTE_PRIVATE_LOG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note log: all partial note private logs must have at least {PARTIAL_NOTE_PRIVATE_LOG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_LOG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private log encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_LOG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_LOG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = log_content.get(0);\n    let note_completion_log_tag = log_content.get(1);\n\n    let packed_private_note_content = array::subbvec(log_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "73": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/discovery/private_logs.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    discovery::{\n        ComputeNoteHashAndNullifier,\n        MAX_LOG_CONTENT_LEN,\n        partial_notes::process_partial_note_private_log,\n        pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n        PRIVATE_LOG_EXPANDED_METADATA_LEN,\n        private_notes::process_private_note_log,\n    },\n    encrypted_logs::{\n        log_assembly_strategies::default_aes128::aes128::AES128,\n        log_encryption::LogEncryption,\n        log_type::{\n            PARTIAL_NOTE_PRIVATE_LOG_TYPE_ID, PRIVATE_EVENT_LOG_TYPE_ID, PRIVATE_NOTE_LOG_TYPE_ID,\n        },\n        metadata_packing::from_expanded_metadata,\n    },\n    oracle::{logs::store_private_event_log, message_discovery::sync_notes},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n// TODO(#12750): don't make these values assume we're using AES.\nuse crate::encrypted_logs::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `syncNotes` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    sync_notes(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get logs from capsules\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    let len = logs.len();\n\n    // We iterate over the logs in reverse order to avoid shifting elements.\n    let mut i = len;\n    while i > 0 {\n        i -= 1;\n\n        // Get and process each log\n        let log = logs.get(i);\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n\n        // Remove the log from the capsule array\n        logs.remove(i);\n    }\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (log_type_id, log_metadata, log_content) = decode_log_plaintext(log_plaintext);\n\n    if log_type_id == PRIVATE_NOTE_LOG_TYPE_ID {\n        debug_log(\"Processing private note log\");\n\n        process_private_note_log(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            log_metadata,\n            log_content,\n        );\n    } else if log_type_id == PARTIAL_NOTE_PRIVATE_LOG_TYPE_ID {\n        debug_log(\"Processing partial note private log\");\n\n        process_partial_note_private_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            log_metadata,\n            log_content,\n        );\n    } else if log_type_id == PRIVATE_EVENT_LOG_TYPE_ID {\n        debug_log(\"Processing private event log\");\n\n        // In the case of event logs, the log metadata is the event selector.\n        let event_selector = EventSelector::from_field(log_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            log_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n        );\n    } else {\n        debug_log_format(\n            \"Unknown log type id {0} (probably belonging to an event log)\",\n            [log_type_id as Field],\n        );\n    }\n}\n\n/// Decodes a log's plaintext following aztec-nr's standard log encoding.\n///\n/// The standard private log layout is composed of:\n///  - an initial field called the 'expanded metadata'\n///  - an arbitrary number of fields following that called the 'log content'\n///\n/// ```\n/// log_plaintext: [ log_expanded_metadata, ...log_content ]\n/// ```\n///\n/// The expanded metadata itself is (currently) interpreted as a u128, of which:\n///  - the upper 64 bits are the log type id\n///  - the lower 64 bits are called the 'log metadata'\n///\n/// ```\n/// log_expanded_metadata: [  log_type_id    |  log_metadata  ]\n///                        <---  64 bits --->|<--- 64 bits --->\n/// ```\n///\n/// The meaning of the log metadata and log content depend on the value of the log type id. Note that there is\n/// nothing special about the log metadata, it _can_ be considered part of the content. It just has a different name\n/// to make it distinct from the log content given that it is not a full field.\nunconstrained fn decode_log_plaintext(\n    log_plaintext: BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>,\n) -> (u64, u64, BoundedVec<Field, MAX_LOG_CONTENT_LEN>) {\n    assert(\n        log_plaintext.len() >= PRIVATE_LOG_EXPANDED_METADATA_LEN,\n        f\"Invalid log plaintext: all logs must be decrypted into at least {PRIVATE_LOG_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If PRIVATE_LOG_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the log encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_LOG_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for PRIVATE_LOG_EXPANDED_METADATA_LEN\",\n    );\n\n    // See the documentation of this function for a description of the log layout\n    let expanded_log_metadata = log_plaintext.get(0);\n    let (log_metadata, log_type_id) = from_expanded_metadata(expanded_log_metadata);\n    let log_content = array::subbvec(log_plaintext, PRIVATE_LOG_EXPANDED_METADATA_LEN);\n\n    (log_type_id, log_metadata, log_content)\n}\n"
    },
    "74": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/discovery/private_notes.nr",
      "source": "use crate::{\n    discovery::{\n        ComputeNoteHashAndNullifier,\n        MAX_LOG_CONTENT_LEN,\n        nonce_discovery::{attempt_note_nonce_discovery, DiscoveredNoteInfo},\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note log content that are not the note's packed representation.\nglobal PRIVATE_NOTE_LOG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the log (e.g. log type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_LOG_CONTENT_LEN - PRIVATE_NOTE_LOG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_log<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    log_metadata: u64,\n    log_content: BoundedVec<Field, MAX_LOG_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_log(log_metadata, log_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private log\",\n        [discovered_notes.len() as Field],\n    );\n\n    array::for_each_in_bounded_vec(\n        discovered_notes,\n        |discovered_note: DiscoveredNoteInfo, _| {\n            // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n            // issue, and we should perhaps not have marked the tag index as taken.\n            assert(\n                oracle::message_discovery::deliver_note(\n                    contract_address,\n                    storage_slot,\n                    discovered_note.nonce,\n                    packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    tx_hash,\n                    recipient,\n                ),\n                \"Failed to deliver note\",\n            );\n        },\n    );\n}\n\nfn decode_private_note_log(\n    log_metadata: u64,\n    log_content: BoundedVec<Field, MAX_LOG_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = log_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        log_content.len() > PRIVATE_NOTE_LOG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note log: all private note logs must have at least {PRIVATE_NOTE_LOG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_LOG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the private note log encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_LOG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_LOG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = log_content.get(0);\n    let packed_note = array::subbvec(log_content, PRIVATE_NOTE_LOG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "75": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypt/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::utils::point::point_to_bytes;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n"
    },
    "78": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/log_assembly_strategies/default_aes128/aes128.nr",
      "source": "use crate::{\n    encrypted_logs::{\n        encrypt::aes128::derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256,\n        log_assembly_strategies::default_aes128::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n        log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n    },\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\nuse std::aes128::aes128_encrypt;\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        encrypted_logs::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "82": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/log_assembly_strategies/default_aes128/note.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    encrypted_logs::{\n        log_assembly_strategies::default_aes128::{aes128::AES128, utils::prefix_with_tag},\n        log_encryption::LogEncryption,\n        log_type::{PARTIAL_NOTE_PRIVATE_LOG_TYPE_ID, PRIVATE_NOTE_LOG_TYPE_ID},\n        metadata_packing::to_expanded_metadata,\n    },\n    note::{note_emission::NoteEmission, note_interface::NoteType},\n};\nuse protocol_types::{\n    abis::note_hash::NoteHash, address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS,\n    traits::Packable,\n};\n\n// TODO: it feels like this existence check is in the wrong place. In fact, why is it needed at all? Under what circumstances have we found a non-existent note being emitted accidentally?\nfn assert_note_exists<let N: u32>(context: PrivateContext, note_hash_counter: u32) {\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists =\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n}\n\n/// This particular log assembly strategy (AES 128) requires the note (and the\n/// note_id and the storage_slot) to be converted into bytes, because the aes function\n/// operates on bytes; not fields.\n/// NB: The \"2\" in \"N + 2\" is for the note_id and the storage_slot of the note:\nfn compute_note_plaintext_for_this_strategy<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    log_type_id: u64,\n) -> [Field; (N + 2)]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let packed_note = note.pack();\n\n    let mut fields = [0; N + 2];\n\n    // We pack log type id and log metadata into the first field. Search for `decode_log_plaintext` function to see\n    // where the value gets decoded.\n    fields[0] = to_expanded_metadata(Note::get_id() as u64, log_type_id);\n    fields[1] = storage_slot;\n    for i in 0..packed_note.len() {\n        fields[i + 2] = packed_note[i];\n    }\n\n    fields\n}\n\npub fn compute_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PRIVATE_NOTE_LOG_TYPE_ID,\n    )\n}\n\npub fn compute_partial_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PARTIAL_NOTE_PRIVATE_LOG_TYPE_ID,\n    )\n}\n\nfn compute_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    log_type_id: u64,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let plaintext = compute_note_plaintext_for_this_strategy(note, storage_slot, log_type_id);\n\n    let ciphertext = AES128::encrypt_log(plaintext, recipient);\n\n    let log = prefix_with_tag(ciphertext, sender, recipient);\n\n    log\n}\n\npub unconstrained fn compute_note_log_unconstrained<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_note_log(note, storage_slot, recipient, sender)\n}\n\n/// Sends an encrypted message to `recipient` with the content of the note, which they will discover when processing\n/// private logs.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n        assert_note_exists(*context, note_hash_counter);\n\n        let encrypted_log = compute_note_log(note, storage_slot, recipient, sender);\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n\n/// Same as `encode_and_encrypt_note`, except encryption is unconstrained. This means that the sender is free to make\n/// the log contents be whatever they wish, potentially resulting in scenarios in which the recipient is unable to\n/// decrypt and process the payload, **leading to the note being lost**.\n///\n/// Only use this function in scenarios where the recipient not receiving the note is an acceptable outcome.\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n\n        assert_note_exists(*context, note_hash_counter);\n\n        // Safety: this function does not constrain the encryption of the log, as explained on its description.\n        let encrypted_log =\n            unsafe { compute_note_log_unconstrained(note, storage_slot, recipient, sender) };\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n"
    },
    "83": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/log_assembly_strategies/default_aes128/utils.nr",
      "source": "use crate::{\n    oracle::notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n    prelude::AztecAddress,\n};\n\npub(crate) fn prefix_with_tag<let L: u32>(\n    log_without_tag: [Field; L],\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> [Field; L + 1] {\n    // Safety: we assume that the sender wants for the recipient to find the tagged note, and therefore that they will\n    // cooperate and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the\n    // note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    let mut log_with_tag = [0; L + 1];\n\n    log_with_tag[0] = tag;\n    for i in 0..log_without_tag.len() {\n        log_with_tag[i + 1] = log_without_tag[i];\n    }\n\n    log_with_tag\n}\n\nmod test {\n    use super::prefix_with_tag;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn prefixing_with_tag() {\n        let sender = AztecAddress::from_field(1);\n        let recipient = AztecAddress::from_field(2);\n\n        let app_tagging_secret = 42;\n        let index = 5;\n\n        // I am using the deserialize trait instead of directly instantiating the IndexedTaggingSecret struct because\n        // direct instantiation functionality is not exposed.\n        let indexed_tagging_secret = IndexedTaggingSecret::deserialize([app_tagging_secret, index]);\n\n        // Mock the tagging oracles\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(indexed_tagging_secret);\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        let log_without_tag = [1, 2, 3];\n        let log_with_tag = prefix_with_tag(log_without_tag, sender, recipient);\n\n        let expected_result = [indexed_tagging_secret.compute_tag(recipient), 1, 2, 3];\n\n        // Check tag was prefixed correctly\n        assert_eq(log_with_tag, expected_result, \"Tag was not prefixed correctly\");\n    }\n}\n"
    },
    "87": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/metadata_packing.nr",
      "source": "global U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\npub fn to_expanded_metadata(log_metadata: u64, log_type: u64) -> Field {\n    let metadata_field = log_metadata as Field;\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (log_type as Field) * U64_SHIFT_MULTIPLIER;\n    type_field + metadata_field\n}\n\npub fn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let metadata = (input as u64);\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    let log_type = ((input - (metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    (metadata, log_type)\n}\n\nmod tests {\n    use super::{from_expanded_metadata, to_expanded_metadata};\n\n    global U64_MAX: Field = 2.pow_32(64) - 1;\n    global U128_MAX: Field = 2.pow_32(128) - 1;\n\n    #[test]\n    fn packing_metadata() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX as u64, U64_MAX as u64);\n        let (metadata, log_type) = from_expanded_metadata(packed);\n        assert(metadata == U64_MAX as u64, \"Metadata bits should be all 1s\");\n        assert(log_type == U64_MAX as u64, \"Log type bits should be all 1s\");\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(0, U64_MAX as u64);\n        let (metadata, log_type) = from_expanded_metadata(packed);\n        assert(metadata == 0, \"Metadata bits should be 0\");\n        assert(log_type == U64_MAX as u64, \"Log type bits should be all 1s\");\n\n        // Test case 3: Only metadata bits set\n        let packed = to_expanded_metadata(U64_MAX as u64, 0);\n        let (metadata, log_type) = from_expanded_metadata(packed);\n        assert(metadata == U64_MAX as u64, \"Metadata bits should be all 1s\");\n        assert(log_type == 0, \"Log type bits should be 0\");\n\n        // Test case 4: Zero\n        let packed = to_expanded_metadata(0, 0);\n        let (metadata, log_type) = from_expanded_metadata(packed);\n        assert(metadata == 0, \"Metadata bits should be 0\");\n        assert(log_type == 0, \"Log type bits should be 0\");\n    }\n\n    #[test]\n    fn unpacking_metadata() {\n        // Test case 1: All bits set\n        let input = U128_MAX;\n        let (metadata, log_type) = from_expanded_metadata(input);\n        assert(metadata == U64_MAX as u64, \"Metadata bits should be all 1s\");\n        assert(log_type == U64_MAX as u64, \"Log type bits should be all 1s\");\n\n        // Test case 2: Only log type bits set\n        let input = U128_MAX - U64_MAX;\n        let (metadata, log_type) = from_expanded_metadata(input);\n        assert(metadata == 0, \"Metadata bits should be 0\");\n        assert(log_type == U64_MAX as u64, \"Log type bits should be all 1s\");\n\n        // Test case 3: Only metadata bits set\n        let input = U64_MAX;\n        let (metadata, log_type) = from_expanded_metadata(input);\n        assert(metadata == U64_MAX as u64, \"Metadata bits should be all 1s\");\n        assert(log_type == 0, \"Log type bits should be 0\");\n\n        // Test case 4: Zero\n        let input = 0;\n        let (metadata, log_type) = from_expanded_metadata(input);\n        assert(metadata == 0, \"Metadata bits should be 0\");\n        assert(log_type == 0, \"Log type bits should be 0\");\n    }\n\n    #[test]\n    fn roundtrip_metadata(original_metadata: u64, original_type: u64) {\n        let packed = to_expanded_metadata(original_metadata, original_type);\n        let (unpacked_metadata, unpacked_type) = from_expanded_metadata(packed);\n        assert(original_type == unpacked_type, \"Log type bits should match after roundtrip\");\n        assert(\n            original_metadata == unpacked_metadata,\n            \"Metadata bits should match after roundtrip\",\n        );\n    }\n}\n"
    },
    "91": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    }
  }
}
