{
  "transpiled": true,
  "noir_version": "1.0.0-beta.4+0000000000000000000000000000000000000000",
  "name": "Train",
  "functions": [
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "772057049813214347": {
            "error_kind": "string",
            "string": "HTLCNotExists"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2570651705007895968": {
            "error_kind": "string",
            "string": "HashlockNotMatch"
          },
          "2722406262643068352": {
            "error_kind": "string",
            "string": "HashlockAlreadySet"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3559210201980528457": {
            "error_kind": "string",
            "string": "Function commit_public_user can only be called internally"
          },
          "3564161243949231814": {
            "error_kind": "string",
            "string": "Function refund_public can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6012086182631426650": {
            "error_kind": "string",
            "string": "NotAnOwner"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "9174444391250494040": {
            "error_kind": "string",
            "string": "Function get_htlc_public can only be called statically"
          },
          "9323748002447105156": {
            "error_kind": "string",
            "string": "NotPassedTimelock"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "15001264570739363109": {
            "error_kind": "string",
            "string": "Function lock_public_solver can only be called internally"
          },
          "16870384257694633552": {
            "error_kind": "string",
            "string": "Function add_lock_public_user can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17814817983036354427": {
            "error_kind": "string",
            "string": "Function redeem_public can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIB2JwAABAMnAgIEAScCAwQAHxgAAwACgHUuCIB1AAElAAAARSUAAAI/KAIAAQSAdicCAgQAOw0AAQACKQCAQwRqCeZnKQCARAS7Z66FKQCARQQ8bvNyKQCARgSlT/U6KQCARwRRDlJ/KQCASASbBWiMKQCASQQfg9mrKQCASgRb4M0ZLgAAAYBLKACATAQACQEAAAGATAABKAGASwQAAQEAgEsAAoBMLgCATIBNLgKAQ4BNAQCATQACgE0uAoBEgE0BAIBNAAKATS4CgEWATQEAgE0AAoBNLgKARoBNAQCATQACgE0uAoBHgE0BAIBNAAKATS4CgEiATQEAgE0AAoBNLgKASYBNAQCATQACgE0uAoBKgE0oAIBMBABAKACATQQABCgAgE4EADgoAIBPBAANKACAUAQAECgAgFEEAA4oAIBSBAEAKACAUwABACgAgFQEAAMoAIBVAQAAKACAVgIAACgAgFcEAAAoAIBYBgAAKACAWQAAACgAgFoBAAEoAIBbBAABKACAXAAAASgAgF0EAAIoAIBeAAACKACAXwQABSgAgGAEAAYoAIBhBAAHKACAYgIACCgAgGMEAAgoAIBkBAAJKACAZQQACigAgGYAAAooAIBnBAALKACAaAQADCgAgGkAAAwoAIBqBAAXKACAawQAHygAgGwCACAoAIBtBAAgKACAbgQAIigAgG8EADAoAIBwBABBKACAcQQARSgAgHIAAFAoAIBzAABXKACAdAQAhCYlAABBdikCAAIAF/EoiAo4AQIDJwIEBAAnAgYEAwA4BAYFLQgBAgAQAQUBJwMCBAEAKAICBS0OBAUAKAUCBS0OBAUnAgUEAwA4AgUELQ0CBAAoBAIELQ4EAiQCAAMAAAKlIwAAAucnAgMEBC0IAAQAEAADACUAAEGfLQQAAC0NAgMAKAMCAy0OAwIAKAICBS0NBQQnAgYEAgA4BQYDOw0AAwAEIwAAAucpAgADAOnnsIoKOAEDBCcCAwAGKAIABQUDhCcCBgIBJAIABAAAAxMjAAAMBC0IAQcnAggERgAQAQgBJwMHBAEAKAcCCB8kgFuAcQAILQgBCAAAAQIBLQ4HCC0IAQcAAAECAS4KgFcABycCCgQLLQgACy0MCAwtDAcNLQwDDgAQAAoAJQAAQ6ktBAAALQwMCScCCwQMLQgADC0MCA0tDAcOLQwDDwAQAAsAJQAAQ6ktBAAALQwNCi0IAQsnAgwEMQAQAQwBJwMLBAEAKAsCDCcCDQQwADgNDA0tDAwODDgODQ8WDA8PJAIADwAAA+QuCoBZAA4AKA4CDiMAAAPDLQgBDAAAAQIBLQ4LDC4IgFcABCMAAAP8DSgABIBvAAskAgALAABA9SMAAAQRLQ0ICy0NBw0BKAANgG8ADg44DQ4PJAIADwAABDMlAABFHS0OCwgtDg4HLQ0MCycCDQQOLQgADi0MCw8AEAANACUAAEUvLQQAAC0MDwwnAg0EDi0IAA4tDAgPLQwHEAAQAA0AJQAARhYtBAAALQwPCwEoAAuAWwAOLQ0ODScCDgQPLQgADy0MCBAtDAcRLgiAaQASABAADgAlAABGjS0EAAAtDBALJwIPBBAtCAAQLQwIES0MBxIAEAAPACUAAEYWLQQAAC0MEQ4nAhAEES0IABEtDA4SABAAEAAlAABHJC0EAAAtDBIPJwIQBBEtCAARLQwIEi0MBxMuCIBpABQAEAAQACUAAEaNLQQAAC0MEg4nAhEEEi0IABItDAgTLQwHFAAQABEAJQAARhYtBAAALQwTECcCCAQRLQgAES0MEBIAEAAIACUAAEdJLQQAAC0MEgctCAEIAAABAgEuCoBVAAgtCAEQAAABAgEuCoBZABAtCAERAAABAgEnAhIA0i0OEhEnAhIEEy0IABMtDAgULQwQFS0MERYAEAASACUAAEduLQQAAB4CABIBHgIAEwAKOBITFCQCABQAAAXSJQAAR5MeAgASBgA4EgUTDjgSExQkAgAUAAAF7iUAAEUdDDgTDxIkAgASAAAGACUAAEelJwIWBBctCAAXLQwIGC0MEBktDBEaLgiAXgAbLgiAcwAcLQwNHQAQABYAJQAAR7ctBAAALQwYEi0MGRMtDBoULQwbFScCKgQrLQgAKy0MEiwtDBMtLQwULi0MFS8tDAswLQwHMS0MDjIuCIBYADMuCIBYADQuCIBYADUuCIBYADYuCIBYADcuCIBYADgtDA85LQwGOgAQACoAJQAASU4tBAAALQwsCC0MLRAtDC4RLQwvFi0MMBctDDEYLQwyGS0MMxotDDQbLQw1HC0MNh0tDDceLQw4Hy0MOSAtDDohLQw7Ii0MPCMtDD0kLQw+JS0MPyYtDEAnLQxBKC0MQiktCAESAAABAgEcDAcTABwMDwcALQgBDycCFAQKABABFAEnAw8EAQAoDwIULQwUFS0ODRUAKBUCFS0OExUAKBUCFS0ODhUAKBUCFS0OBxUAKBUCFS4KgFkAFQAoFQIVLgqAWQAVACgVAhUuCoBZABUAKBUCFS4KgFkAFQAoFQIVLgqAWQAVLQ4PEi0IAQcnAg0EIAAQAQ0BJwMHBAEAKAcCDScCDgQfADgODQ4tDA0PDDgPDhMWDBMTJAIAEwAAB84uCoBWAA8AKA8CDyMAAAetLQgBDQAAAQIBLQ4HDS4IgFcABCMAAAfmDSgABIBjAAckAgAHAABAqCMAAAf7LQ0SBy0NDQgnAg0EEy0IABMtDAgUABAADQAlAABXAS0EAAAtDBQJLgQAB4ADKACABAQACiUAAFfALgiABQAIACgIAg0BKAANgE0ADi0OCQ4tDggSLQgBBycCCAQgABABCAEnAwcEAQAoBwIIJwIJBB8AOAkICS0MCA0MOA0JDhYMDg4kAgAOAAAIli4KgFYADQAoDQINIwAACHUtCAEIAAABAgEtDgcILgiAVwAEIwAACK4NKAAEgGMAByQCAAcAAEBbIwAACMMtDRIHLQ0ICScCCgQTLQgAEy0MCRQAEAAKACUAAFcBLQQAAC0MFAguBAAHgAMoAIAEBAAKJQAAV8AuCIAFAAkAKAkCCgEoAAqAXwANLQ4IDS0OCRItCAEHJwIIBCAAEAEIAScDBwQBACgHAggnAgkEHwA4CQgJLQwICgw4CgkNFgwNDSQCAA0AAAleLgqAVgAKACgKAgojAAAJPS0IAQgAAAECAS0OBwgtCAEHJwIJBCAAEAEJAScDBwQBACgHAgknAgoEHwA4CgkKLQwJDQw4DQoOFgwODiQCAA4AAAmyLgqAVgANACgNAg0jAAAJkS0IAQkAAAECAS0OBwkuCIBXAAQjAAAJyg0oAASAawAHJAIABwAAQA4jAAAJ3y4IgGsABCMAAAnqDSgABIBvAAckAgAHAAA/pCMAAAn/LQ0SBy0NCAonAgwEEy0IABMtDAoUABAADAAlAABXAS0EAAAtDBQILgQAB4ADKACABAQACiUAAFfALgiABQAKACgKAgwBKAAMgGAADS0OCA0tDQkHJwIJBBMtCAATLQwHFAAQAAkAJQAAVwEtBAAALQwUCC4EAAqAAygAgAQEAAolAABXwC4IgAUABwAoBwIJASgACYBhAAwtDggMLgQAB4ADKACABAQACiUAAFfALgiABQAIACgIAgkBKAAJgGMACi0OCwotDggSLQgBBycCCQQKABABCQEnAwcEAQAoBwIJLQwJCi4KgFkACgAoCgIKLgqAWQAKACgKAgouCoBZAAoAKAoCCi4KgFkACgAoCgIKLgqAWQAKACgKAgouCoBZAAoAKAoCCi4KgFkACgAoCgIKLgqAWQAKACgKAgouCoBZAAotCAEJAAABAgEtDgcJLgiAVwAEIwAAC1oNKAAEgGQAByQCAAcAAD9XIwAAC28tDQkEJwIJBAkGKAkCBycCCwQDADgJCwotCAEIABABCgEnAwgEAQAoCAIKLQ4JCgAoCgIKLQ4JCicCCwQDADgICwoAKAQCCy4EAAuAAy4EAAqABC4EAAmABSUAAFhOACgIAgotDQoJJwILBAIAOAoLBDcNAAQACQAoAgIJLQ0JCCcCCgQCADgJCgQ7DQAEAAgjAAAMBCkCAAQA7z5h9Ao4AQQHJAIABwAADB8jAAAUzS0IAQcnAggEIwAQAQgBJwMHBAEAKAcCCB8kgFuAbgAILQgBCAAAAQIBLQ4HCC0IAQcAAAECAS4KgFcABycCCgQLLQgACy0MCAwtDAcNABAACgAlAABYlC0EAAAtDAwJASgACYBbAAstDQsKLQgBCScCCwQhABABCwEnAwkEAQAoCQILJwIMBCAAOAwLDC0MCw0MOA0MDhYMDg4kAgAOAAAM0S4KgFkADQAoDQINIwAADLAtCAELAAABAgEtDgkLLgiAVwAEIwAADOkNKAAEgG0ACSQCAAkAAD7WIwAADP4tDQgJLQ0HDAEoAAyAbQANDjgMDQ4kAgAOAAANICUAAEUdLQ4JCC0ODQctDQsJJwIMBA0tCAANLQwJDgAQAAwAJQAAWQstBAAALQwOCycCDAQNLQgADS0MCA4tDAcPABAADAAlAABYlC0EAAAtDA4JJwIIBAwtCAAMLQwJDQAQAAgAJQAARyQtBAAALQwNBy0IAQgAAAECAS4KgFUACC0IAQkAAAECAS4KgFkACS0IAQwAAAECAScCDQDBLQ4NDCcCDQQOLQgADi0MCA8tDAkQLQwMEQAQAA0AJQAAR24tBAAAHgIADQEeAgAOAAo4DQ4PJAIADwAADfwlAABaQB4CAA0GADgNBQ4OOA0ODyQCAA8AAA4YJQAARR0MOA4HBSQCAAUAAA4qJQAAR6UnAhAEES0IABEtDAgSLQwJEy0MDBQuCIBeABUuCIBzABYtDAoXABAAEAAlAABHty0EAAAtDBIFLQwTDS0MFA4tDBUPHgIAEAUcDBASBBwMEhEAHAwREAQnAigEKS0IACktDAUqLQwNKy0MDiwtDA8tABAAKAAlAABaUi0EAAAtDCoRLQwrEi0MLBMtDC0ULQwuFS0MLxYtDDAXLQwxGC0MMhktDDMaLQw0Gy0MNRwtDDYdLQw3Hi0MOB8tDDkgLQw6IS0MOyItDDwjLQw9JC0MPiUtDD8mLQxAJww4ECcFFgwFDRwMBQ4AHAwNDwAEOA4REAQ4DxwRADgQERwcDAUQBhwMDREGBDgQEicEOBEdEgA4JxIdBDgOExIEOA8eDgA4Eg4PBDgQFA4EOBEfEgA4DhITBDgQFQ4EOBEgEgA4DhIUBDgQFg4EOBEhEgA4DhIVBDgQFw4EOBEiEgA4DhIWBDgQGA4EOBEjEgA4DhIXBDgQGQ4EOBEkEAA4DhARHAwFDgIcDA0FAgQ4DhsNBDgFJg4AOA0OBQo4BQYNJAIADQAAD9MlAABdqAsoABOAWAAFJAIABQAAD+glAABdugsoABSAWAAFJAIABQAAD/0lAABdui0NCwUAKAUCBS0OBQsnAg4EJi0IACYtDAsnABAADgAlAABdzC0EAAAtDCcFLQwoDScCFAQmLQgAJi0MCCctDAkoLQwMKS4IgF4AKi4IgHMAKy0MCiwAEAAUACUAAEe3LQQAAC0MJw4tDCgQLQwpEi0MKhMnAi8EMC0IADAtDA4xLQwQMi0MEjMtDBM0LQwcNS0MHTYtDA83LQwFOC0MDTktDBU6LQwWOy0MFzwtDBE9LQwHPi0MBj8AEAAvACUAAElOLQQAAC0MMQgtDDIJLQwzDC0MNBQtDDUYLQw2GS0MNxstDDgeLQw5Hy0MOiAtDDshLQw8Ii0MPSMtDD4kLQw/Ji0MQCctDEEoLQxCKS0MQyotDEQrLQxFLC0MRi0tDEcuLQgBBQAAAQIBLQgBDScCDgQFABABDgEnAw0EAQAoDQIOLQwODy0OCg8AKA8CDy4KgFkADwAoDwIPLgqAWQAPACgPAg8uCoBZAA8tDg0FLQ0LCgAoCgIKLQ4KCy0IAQonAg0EIAAQAQ0BJwMKBAEAKAoCDScCDgQfADgODQ4tDA0PDDgPDhAWDBAQJAIAEAAAEcEuCoBWAA8AKA8CDyMAABGgLQgBDQAAAQIBLQ4KDS4IgFcABCMAABHZDSgABIBrAAgkAgAIAAA+iSMAABHuLQ0FBC0NDQgnAgoEDC0IAAwtDAgNABAACgAlAABXAS0EAAAtDA0JLgQABIADKACABAQABSUAAFfALgiABQAIACgIAgoBKAAKgFsADC0OCQwBKAALgG0ACi0NCgQtCAEKJwILBCAAEAELAScDCgQBACgKAgstDAsMLQ4EDAAoDAIMLgqAVgAMACgMAgwuCoBWAAwAKAwCDC4KgFYADAAoDAIMLgqAVgAMACgMAgwuCoBWAAwAKAwCDC4KgFYADAAoDAIMLgqAVgAMACgMAgwuCoBWAAwAKAwCDC4KgFYADAAoDAIMLgqAVgAMACgMAgwuCoBWAAwAKAwCDC4KgFYADAAoDAIMLgqAVgAMACgMAgwuCoBWAAwAKAwCDC4KgFYADAAoDAIMLgqAVgAMACgMAgwuCoBWAAwAKAwCDC4KgFYADAAoDAIMLgqAVgAMACgMAgwuCoBWAAwAKAwCDC4KgFYADAAoDAIMLgqAVgAMACgMAgwuCoBWAAwAKAwCDC4KgFYADAAoDAIMLgqAVgAMACgMAgwuCoBWAAwAKAwCDC4KgFYADAAoDAIMLgqAVgAMACgMAgwuCoBWAAwAKAwCDC4KgFYADCcCCwQMLQgADC0MCg0AEAALACUAAFcBLQQAAC0MDQQuBAAIgAMoAIAEBAAFJQAAV8AuCIAFAAoAKAoCCwEoAAuAXQAMLQ4EDBwMBwgALgQACoADKACABAQABSUAAFfALgiABQAHACgHAgsBKAALgFQADC0OCAwtDgcFASgAB4BbAAotDQoFJwIKBAQnAgwEAwA4CgwLLQgBBwAQAQsBJwMHBAEAKAcCCy0OCgsAKAsCCy0OCgsnAgsEAwA4BwsKLQwKCy0OBQsAKAsCCy0OCQsAKAsCCy0OBAsAKAsCCy0OCAsAKAcCCC0NCAUnAgkEAgA4CAkENw0ABAAFACgCAgctDQcFJwIIBAIAOAcIBDsNAAQABSMAABTNKQIABACSExo2CjgBBAUkAgAFAAAU6CMAABkELQgBBCcCBQQCABABBQEnAwQEAQAoBAIFHySAW4BbAAUtCAEFAAABAgEtDgQFLQgBBAAAAQIBLgqAVwAEJwIIBAktCAAJLQwFCi0MBAsuCIBmAAwAEAAIACUAAF7OLQQAAC0MCgctCAEEAAABAgEuCoBVAAQtCAEFAAABAgEuCoBZAAUtCAEIAAABAgEnAgkAvS0OCQgnAgkECi0IAAotDAQLLQwFDC0MCA0AEAAJACUAAEduLQQAAB4CAAkBHgIACgAKOAkKCyQCAAsAABW8JQAAX2knAg0EDi0IAA4tDAQPLQwFEC0MCBEuCIBeABIuCIBzABMtDAcUABAADQAlAABHty0EAAAtDA8JLQwQCi0MEQstDBIMHgIADQUcDA0PBBwMDw4AHAwODQQnAiUEJi0IACYtDAknLQwKKC0MCyktDAwqABAAJQAlAABaUi0EAAAtDCcOLQwoDy0MKRAtDCoRLQwrEi0MLBMtDC0ULQwuFS0MLxYtDDAXLQwxGC0MMhktDDMaLQw0Gy0MNRwtDDYdLQw3Hi0MOB8tDDkgLQw6IS0MOyItDDwjLQw9JAw4DSQJFgwJChwMCQsAHAwKDAAEOAsODQQ4DBkOADgNDhkcDAkNBhwMCg4GBDgNDyQEOA4aDwA4JA8aBDgLEA8EOAwbCwA4DwsMBDgNEQsEOA4cDwA4Cw8QBDgNEgsEOA4dDwA4Cw8RBDgNEwsEOA4eDwA4Cw8SBDgNFAsEOA4fDwA4Cw8TBDgNFQsEOA4gDwA4Cw8UBDgNFgsEOA4hDQA4Cw0OHAwJCwUcDAoNBQQ4CxcPBDgNIgsAOA8LDRwMCQsCHAwKCQIEOAsYCgQ4CSMLADgKCwkKOAkGCiQCAAoAABd+JQAAXageAgAJBgw4DQkKJAIACgAAF5UlAABfeycCFQQbLQgAGy0MBBwtDAUdLQwIHi4IgF4AHy4IgHMAIC0MByEAEAAVACUAAEe3LQQAAC0MHAktDB0KLQweCy0MHw8nAgQCAicCLAQtLQgALS0MCS4tDAovLQwLMC0MDzEtDBkyLQwaMy0MDDQtDBA1LQwRNi0MEjctDBM4LQwUOS0MDjotDA07LQwEPAAQACwAJQAASU4tBAAALQwuBS0MLwgtDDAVLQwxFi0MMhctDDMYLQw0Gy0MNRwtDDYdLQw3Hi0MOB8tDDkgLQw6IS0MOyItDDwjLQw9JC0MPiUtDD8mLQxAJy0MQSgtDEIpLQxDKi0MRCsnAgkEAScCCwQDADgJCwotCAEEABABCgEnAwQEAQAoBAIKLQ4JCgAoCgIKLQ4JCicCCgQDADgECgktDAkKLQ4HCgAoBAIKLQ0KCScCCwQCADgKCwc3DQAHAAkAKAICCS0NCQcnAgoEAgA4CQoEOw0ABAAHIwAAGQQpAgAEADqMVHMKOAEEBScCBAAWJAIABQAAGSQjAAAoQy0IAQcnAggEhQAQAQgBJwMHBAEAKAcCCB8kgFuAdAAILQgBCAAAAQIBLQ4HCC0IAQcAAAECAS4KgFcABycCCgQLLQgACy0MCAwtDAcNABAACgAlAABfjS0EAAAtDAwJASgACYBbAAstDQsKJwILBAwtCAAMLQwIDS0MBw4tDAQPABAACwAlAABgBC0EAAAtDA0JJwIMBA0tCAANLQwIDi0MBw8tDAQQABAADAAlAABgBC0EAAAtDA4LJwINBA4tCAAOLQwIDy0MBxAAEAANACUAAF+NLQQAAC0MDwwnAg4EDy0IAA8tDAwQABAADgAlAABHSS0EAAAtDBANJwIOBA8tCAAPLQwIEC0MBxEAEAAOACUAAF+NLQQAAC0MEAwBKAAMgFsADy0NDw4nAg8EEC0IABAtDAgRLQwHEgAQAA8AJQAAX40tBAAALQwRDCcCEAQRLQgAES0MDBIAEAAQACUAAEckLQQAAC0MEg8nAhAEES0IABEtDAgSLQwHEy0MAxQAEAAQACUAAGFQLQQAAC0MEgwnAhEEEi0IABItDAgTLQwHFC0MAxUAEAARACUAAGFQLQQAAC0MExAtCAEDJwIRBDEAEAERAScDAwQBACgDAhEnAhIEMAA4EhESLQwREww4ExIUFgwUFCQCABQAABslLgqAWQATACgTAhMjAAAbBC0IAREAAAECAS0OAxEuCIBXAAUjAAAbPQ0oAAWAbwADJAIAAwAAPggjAAAbUi0NCAUtDQcSASgAEoBvABMOOBITFCQCABQAABt0JQAARR0tDgUILQ4TBy0NEQUnAggEES0IABEtDAUSABAACAAlAABFLy0EAAAtDBIHLQgBBQAAAQIBLgqAVQAFLQgBCAAAAQIBLgqAWQAILQgBEQAAAQIBJwISAKwtDhIRJwISBBMtCAATLQwFFC0MCBUtDBEWABAAEgAlAABHbi0EAAAeAgASAR4CABMACjgSExQkAgAUAAAcDiUAAGLEHgIAEgYoAgATBQqMADgSExQOOBIUFSQCABUAABwxJQAARR0MOBQPEiQCABIAABxDJQAAR6UtDQkSACgSAhItDhIJJwIUBBUtCAAVLQwJFgAQABQAJQAAXcwtBAAALQwWEi0MFxMtDQsUACgUAhQtDhQLJwIWBBctCAAXLQwLGAAQABYAJQAAXcwtBAAALQwYFC0MGRUnAhoEGy0IABstDAUcLQwIHS0MER4uCIBeAB8uCIBzACAtDAohABAAGgAlAABHty0EAAAtDBwWLQwdFy0MHhgtDB8ZJwIuBC8tCAAvLQwWMC0MFzEtDBgyLQwZMy4IgFkANC0MDTUtDA42LQwSNy0MEzguCIBYADkuCIBYADotDBQ7LQwVPC0MDz0tDAY+ABAALgAlAABJTi0EAAAtDDAFLQwxCC0MMhEtDDMaLQw0Gy0MNRwtDDYdLQw3Hi0MOB8tDDkgLQw6IS0MOyItDDwjLQw9JC0MPiUtDD8mLQxAJy0MQSgtDEIpLQxDKi0MRCstDEUsLQxGLS0IARIAAAECAS0IARMnAhQEDgAQARQBJwMTBAEAKBMCFC0MFBUtDgoVACgVAhUuCoBZABUAKBUCFS4KgFkAFQAoFQIVLgqAWQAVACgVAhUuCoBZABUAKBUCFS4KgFkAFQAoFQIVLgqAWQAVACgVAhUuCoBZABUAKBUCFS4KgFkAFQAoFQIVLgqAWQAVACgVAhUuCoBZABUAKBUCFS4KgFkAFQAoFQIVLgqAWQAVLQ4TEi0NCQoAKAoCCi0OCgktCAEKJwITBCAAEAETAScDCgQBACgKAhMnAhQEHwA4FBMULQwTFQw4FRQWFgwWFiQCABYAAB6gLgqAVgAVACgVAhUjAAAefy0IARMAAAECAS0OChMuCIBXAAMjAAAeuA0oAAOAawAFJAIABQAAPbsjAAAezS0NEgUtDRMIJwIRBBMtCAATLQwIFAAQABEAJQAAVwEtBAAALQwUCi4EAAWAAygAgAQEAA4lAABXwC4IgAUACAAoCAIRASgAEYBbABMtDgoTASgACYBtAAotDQoFLQgBCScCCgQgABABCgEnAwkEAQAoCQIKLQwKES0OBREAKBECES4KgFYAEQAoEQIRLgqAVgARACgRAhEuCoBWABEAKBECES4KgFYAEQAoEQIRLgqAVgARACgRAhEuCoBWABEAKBECES4KgFYAEQAoEQIRLgqAVgARACgRAhEuCoBWABEAKBECES4KgFYAEQAoEQIRLgqAVgARACgRAhEuCoBWABEAKBECES4KgFYAEQAoEQIRLgqAVgARACgRAhEuCoBWABEAKBECES4KgFYAEQAoEQIRLgqAVgARACgRAhEuCoBWABEAKBECES4KgFYAEQAoEQIRLgqAVgARACgRAhEuCoBWABEAKBECES4KgFYAEQAoEQIRLgqAVgARACgRAhEuCoBWABEAKBECES4KgFYAEQAoEQIRLgqAVgARACgRAhEuCoBWABEAKBECES4KgFYAEQAoEQIRLgqAVgARACgRAhEuCoBWABEnAgoEEy0IABMtDAkUABAACgAlAABXAS0EAAAtDBQFLgQACIADKACABAQADiUAAFfALgiABQAJACgJAgoBKAAKgF0AES0OBREtDgkSLQ0LBQAoBQIFLQ4FCy0IAQUnAggEIAAQAQgBJwMFBAEAKAUCCCcCCQQfADgJCAktDAgKDDgKCREWDBERJAIAEQAAITMuCoBWAAoAKAoCCiMAACESLQgBCAAAAQIBLQ4FCC4IgFcAAyMAACFLDSgAA4BrAAUkAgAFAAA9biMAACFgLQ0SBS0NCAknAgoEEy0IABMtDAkUABAACgAlAABXAS0EAAAtDBQILgQABYADKACABAQADiUAAFfALgiABQAJACgJAgoBKAAKgFQAES0OCBEBKAALgG0ACC0NCAUtCAEIJwIKBCAAEAEKAScDCAQBACgIAgotDAoLLQ4FCwAoCwILLgqAVgALACgLAgsuCoBWAAsAKAsCCy4KgFYACwAoCwILLgqAVgALACgLAgsuCoBWAAsAKAsCCy4KgFYACwAoCwILLgqAVgALACgLAgsuCoBWAAsAKAsCCy4KgFYACwAoCwILLgqAVgALACgLAgsuCoBWAAsAKAsCCy4KgFYACwAoCwILLgqAVgALACgLAgsuCoBWAAsAKAsCCy4KgFYACwAoCwILLgqAVgALACgLAgsuCoBWAAsAKAsCCy4KgFYACwAoCwILLgqAVgALACgLAgsuCoBWAAsAKAsCCy4KgFYACwAoCwILLgqAVgALACgLAgsuCoBWAAsAKAsCCy4KgFYACwAoCwILLgqAVgALACgLAgsuCoBWAAsAKAsCCy4KgFYACwAoCwILLgqAVgALACgLAgsuCoBWAAsAKAsCCy4KgFYACycC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",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "refund_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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X8BBhfwCDirkF3AIcM7haK6Qa+/QB80VchWO5gq5BidqrnOqcDTPVrU3FaPm2aoKR/NsVYWjebaqwtE8W1XhaO7nVOFo7ufU4CTNdU4VjuZ+ThWO5n5OFY7m2crvK6PfjIQ9gKN5tqrC0Txb1eBk1a48lx2OOXDlWfNsVYWjebaqwtHcz6nCIcA5h6P66UMNjuqnDzU4qp8+1OBorpCrcDRXyDU4BUXgCzikdn2NmrNSvHxjFY3exbGqaPQujlW91+hdHKuKRvGin6/RJKN3cawqGr2LY1XR6F0qtopG71KxVTQENGdoFC9mXkOjeDHzGhpUw2doBiz6yboZdrLTb4a9K+H2z3IwADf7ANy+n3r27mAAXvoASPoAgvQBROkDSNIHkGcfgEn7AJw5GEARPgA3+0xcHcD0M3FtANPPxLUBTD8T1wYw/UxcG8D0M3FtAMe30Zsr+Trt9sTycRHr7f2042Xv6qflttPagjxeRKx+mm07zbWd5ttOo7bTQttpse20NpVQm0qoTSWhTSWhTSWhTSWhTSWhTSWhTSWhTSWhTSWhTSWhTSWxTSWxTSWxTSWxTSWxTSWxTSWxTSWxTSWxTSWxTSWpTSWpTSWpTSWpTSWpTSWpTSWpTSWpTSWpTSWpTSW5TSW5TSW5TSW5TSW5TSW5TSW5TSW5TSW5TSW5TSWlTSWlTSWlTSWlTSWlTSWlTSWlTSWlTSWlTSWlSSXZmLbTbNtpru0033YatZ0W2k6LbaelttNy22ltKrFtKrFtKrFtKrFtKrFtKrFtKrFtKrFtKrFtKrFtKnFtKnFtKnFtKnFtKnFtKnFtKnFtKnFtKnFtKmlr/WXfphLfphLfphLfphLfphLfphLfppK23mtu673mtt5rbuu95rbea27rvea23mtu673mtt5rbuu95rbea27rvea23mtu673mtt5rbuu95rbea27rvea23mtu673mtt5rbuu95rbea27rvea23mtu673mtt5rbuu95rbea27rvea23mtu673mtt5rbuu95rbea27rvea23mtu673mtt5rbuu95rbea27rvea23mtu673mtt5rbuu95rbea27rvea23mtu673mtt5rbuu95rbea27rvea23mtu673mtt5rPu69elP2D9OdDd9OO3iBfbtEeryuQv7r74eL/368+O+ni/9+vvjvl0v/fjHm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acM3acM3acM3aaOpO3eyQVftLGrSxv/X3BntSI0DUfRf9rkf4qqyy/UtK4SARSskBGgWVtoH/n2dnonTEKczvoxDvYzo6ZzK7enKdXJJbIF6Q6DeEKg3BOoNgXoDykUZykUZykUZykUZykUZykUZykUZykUZykUZykUZykUZykUZykUZykUZykUZykUZykUZykUZykUZykUZykUZykUZykUZykUZykUZykUZykUZykUZykUZykUZykUZykUZykUZykUZykUZykUZykUZykUZykUZykUZykUZykUZykUZykUZykUZykUZykUZykUZykUZykUZykUZykUZykUZykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykV3Ft8qMfAyPUtJ4uIP1PaWnjoFuq4P9Ak/lpex5ePY8mlseR1bPo8tb0PLt2PjlysfxpanseXHHrU09qilsUctjT1qaexRS2OPWhp71PLYo5bHHrU89qjdycE15SeE9PYB+nmELq9k3rYdQmpYHqYvNVYwxtZU4blO3Hh7j27Z9tXe4iZd5cOy1Hn8YWLqx/IytnwcWz6NLa9jy+ex5W1o+XaYq9Na3o7Kp7Dcby5J1q3L/7c3tqYc6tnyOhub3FnV4zdpIUda+FwtIfHisSHFH7d+tbeSx++TE33JSb7kqC852ZcccyVHJ19ygi855EuOL1fW0105L2vvBg15Iyf6kpN8yVFfcrIvOeZKTp58yQm+5JAvOWe7skarcm7ChUWO+JITfclJvuSoLznZlxxzJccmX3KCLznkS44vVzZfrmy+XNl8ubL5cmXz5crmy5XDdLot2zrbCU1bPcGZHnKmh53pEWd6ojM9yZkedaYnO9NjvvQEZ/4cnPlzcObPwZk/B2f+HJz5c3Dmz+Fsf848VT1sWz3ZmR77jXokbfTQ5ExPcKbnBfw5LVcwoiEd6CEK9eYxinGrh0/Xo1VP2vYziTM98WQ9PC030hDfrHFZ9SRnetSZnny2HopVT2z0j52uR6oe5Y0enk7WI3UNapLQ0BOc6SFnes72Z6HqhxLzVo+cridVPbo93jk603O2P4vV8T1Oje9LnenJzvSc7c+R6vEe47Z/ZDpdTx1PY9qeH8rZ/hxtWe+a0rTN54Wc6WFnes7257ReXyTZHl8ST9dTx6+UGsfX2f683u5TLi90q0ed6cnO9JgvPXFypif4Gk8j+dLTvq8lGC+jXjC5+atGeaQIohiiBKLiIXV79r5QCaIUojJEGUDtrFhG0zo2TZy2VIAogiiGKIGoCFEJohSiMkQZQgWoNwLUGwHqjQD1RoB6I0C9EaDe2Jmid4o1oZpuz9AWaudz1eemyz+3DrAzAe7Rvna6N9dMb7K4pTJEGULtTIB7RAWIIohiiNr5lutjpIXadtTOBLhHVIIoRfpwZwLcI8oQamcC3CMqQBRBFEMU5AA7E+AeUTvnG0b1NkEzXvuX7HpeubPw1jO4AHIEcgxyAnIR5BLIKchlkAP7pT1PgagtabJkzlsqQBRBFEOUQFSEqARRYIcksEMS2CEKOoqCjqKgoyjoKAo6ioKOoqCjKNgv7YdQj7qz/azoEZUhN8mQm2TITTLkJhlykwx2SAY7JIMdkkFHyaCjGOgoBjqKgY5ioKMY6CgGjT4GjT7t7OyQgrzEEC/ZWbbrkAoQhXXIzsJdz+AE5CLIJZBTkMsghznKzjJez+ACyCFjz85SXoeUQFSEqARRClEZosAOIbBDCOwQAh2FQEch0FEIdBQCHYVARyHQUQgaexgaexgaexjyEoa8hCEvYchLGOwQBjuEwQ5h0FEEdBQBHUVARxHQUQR0FAEdRaCxR6CxR6CxRyAviZCXRMhLIuQlYBbLYBbLYBbLYBbLYBbLYBbLYBa7swDYMzjQURLoKFAiy1Aiy1Aiy1Aiu7MM2CEFeUmCvATMYhnMYhnMYncWA7v36RpPrMlUn8CU2ycwWR/3ISfsI56wD9DVwDyY+/Pg7WdSXW6wUOPtJ7LRe+jPmTv3sLPUQ1jv4g2J0pZKEKWHFMuWyhBl3VR5Fedt2zuM9U6WRFTBIE/RXzfSvvS6j4R+hPoR7kTKqzRv2Q5VQph0uROl/NtuZpvPV1b32Vyfzco37RS00eVJqr7It5uWT9TObV6qeP7V4vU2mJTzz8Xtl4svT0Pr9LPydlT0IsXLi3zna62PUGSzZ31i48XwLOp9UYf9ZtdjvGl7iZchJU/rgBIeLaXtefcR7UdyP2LdSNt87iNN88l1EM6SNwj1I9yPSD8S+5HUj2g/0jaTLK3jhVvtXy4knrYtJ47r+BYfy9vQ8u2k6OXKh7HlaWx5HltexpaPY8unFyyfeVNex5bPY8u3h8T6HLTdrsrz6CPtLO4+EvoR6ke4H5F+JPYjqRtpxyj3kdyP9H/72v/ta/+3r/3f/s7a6VLvVE/6c/PvLJx+F4n9SPsOda2P/tnmqNxZL/0ukvsR60Z2lkm/i4RO5Ht5+e+bhw9v3n58/09B5ne/fXr39cPnT08vv/73ZXnn7cOHjx8//P36y8Pnd+//+vbw/vXHz+/m9/6Ynn78qZztohKm+QqgvM5C4ZKFbT5pub5fzunLRnF+fwZEdbqUH9dfzITO80KUH3k+xQ9z3ZljuggtTAyXmOa36XppMv+q7IWuv+KFkFjqpmlhiMsWnOoyf9d9T3NVXjYJxedDtkUIl2yGLdc04Vq07DlUGXSJul40X0vYhWS9Fr7uWC5k63XU9Vd6YapXMNdfpemS6p8g66XI+P69fD3/Aw==",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "get_note_internal",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "call_private_function_internal",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "refund_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3564161243949231814": {
            "error_kind": "string",
            "string": "Function refund_public can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "9323748002447105156": {
            "error_kind": "string",
            "string": "NotPassedTimelock"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBOJwAABAMnAgIEAScCAwQAHxgAAwACgE0uCIBNAAElAAAARSUAAACMKAIAAQSATicCAgQAOw0AAQACKACAQwQAAygAgEQBAAAoAIBFBAAAKACARgAAACgAgEcBAAEoAIBIBAABKACASQQABCgAgEoEAAsoAIBLBAAXKACATAAAUyYlAAAUUC0IAQMAAAECAS4KgEQAAy0IAQQAAAECAS4KgEYABC0IAQUAAAECAScCBgACLQ4GBR4CAAcAHgIACAAzOAAHAAgACSQCAAkAAADgJQAAFHkeAgAHAR4CAAgACjgHCAkkAgAJAAAA/CUAABSLJwILBAwtCAAMLQwDDS0MBA4tDAUPLQwGEC4IgEwAES0MARIAEAALACUAABSdLQQAAC0MDQctDA4ILQwPCS0MEAoeAgALBRwMCw0EHAwNDAAcDAwLBC0IAQwnAg0EGAAQAQ0BJwMMBAEAKAwCDScCDgQXADgODQ4tDA0PDDgPDhAWDBAQJAIAEAAAAZguCoBGAA8AKA8CDyMAAAF3LQgBDQAAAQIBLQ4MDS4IgEUAAiMAAAGwDSgAAoBLAAckAgAHAAAUASMAAAHFLQ0NBy0IAQgAAAECAS0OBwgtCAEHAAABAgEuCoBFAActCAEJJwIKBBgAEAEKAScDCQQBACgJAgonAgwEFwA4DAoMLQwKDQw4DQwOFgwODiQCAA4AAAIsLgqARgANACgNAg0jAAACCy0IAQoAAAECAS0OCQouCIBFAAIjAAACRA0oAAKASwAJJAIACQAAE3UjAAACWS0NCgctDQcIACgIAggtDggHJwIJBAwtCAAMLQwHDS4IgEgADgAQAAkAJQAAFoYtBAAALQwNCC0NBwkAKAkCCS0OCQcnAgkEDCcCDAQNLQgADS0MBw4tDAkPABAADAAlAAAWhi0EAAAtDA4KJwIXBBgtCAAYLQwIGQAQABcAJQAAF7QtBAAALQwZDC0MGg0tDBsOLQwcDy0MHRAtDB4RLQwfEi0MIBMtDCEULQwiFS0MIxYnAiEEIi0IACItDAojABAAIQAlAAAXtC0EAAAtDCMILQwkFy0MJRgtDCYZLQwnGi0MKBstDCkcLQwqHS0MKx4tDCwfLQwtIAEoAAeASAAhLQ0hChwMCiEEHAwhBwAcDAcKBAw4CwoHFgwHChwMBwsAHAwKIQAEOAsMIgQ4IQgMADgiDAgcDAcMBhwMCiIGBDgMDSMEOCIXDQA4Iw0XBDgLDg0EOCEYCwA4DQsOBDgMDwsEOCIZDQA4Cw0PBDgMEAsEOCIaDQA4Cw0QBDgMEQsEOCIbDQA4Cw0RBDgMEgsEOCIcDQA4Cw0SBDgMEwsEOCIdDQA4Cw0TBDgMFAsEOCIeDAA4CwwNHAwHCwUcDAoMBQQ4CxUUBDgMHwsAOBQLDBwMBwsCHAwKBwIEOAsWCgQ4ByALADgKCwcnAgoCAQo4BwoLJAIACwAABFolAAAaSx4CAAcGDDgMBwokAgAKAAAEcSUAABpdJwIVBBgtCAAYLQwDGS0MBBotDAUbLQwGHC4IgEwAHS0MAR4AEAAVACUAABSdLQQAAC0MGQctDBoKLQwbCy0MHBQtCAEDJwIEBBgAEAEEAScDAwQBACgDAgQnAgUEFwA4BQQFLQwEFQw4FQUWFgwWFiQCABYAAAT5LgqARgAVACgVAhUjAAAE2C0IAQQAAAECAS0OAwQuCIBFAAIjAAAFEQ0oAAKASwADJAIAAwAAEyYjAAAFJi0NBAMtCAEEAAABAgEtDgMELQgBAwAAAQIBLgqARQADLQgBBScCBwQYABABBwEnAwUEAQAoBQIHJwIKBBcAOAoHCi0MBwsMOAsKFRYMFRUkAgAVAAAFjS4KgEYACwAoCwILIwAABWwtCAEHAAABAgEtDgUHLgiARQACIwAABaUNKAACgEsABSQCAAUAABKaIwAABbotDQcDLQ0DBAAoBAIELQ4EAycCBQQYLQgAGC0MAxkuCIBIABoAEAAFACUAABaGLQQAAC0MGQQtDQMFACgFAgUtDgUDJwIHBBgtCAAYLQwDGS0MCRoAEAAHACUAABaGLQQAAC0MGQUnAh0EHi0IAB4tDAQfABAAHQAlAAAXtC0EAAAtDB8HLQwgCS0MIQotDCILLQwjFS0MJBYtDCUYLQwmGS0MJxotDCgbLQwpHCcCJwQoLQgAKC0MBSkAEAAnACUAABe0LQQAAC0MKQQtDCodLQwrHi0MLB8tDC0gLQwuIS0MLyItDDAjLQwxJC0MMiUtDDMmASgAA4BIACctDScFHAwFJwQcDCcDABwMAwUELwwAFAADHAwDKAQcDCgnAAI4AycoLAIAAwAtXgmLgro3tDuZoTFhGP0g1C9RZsnp8T+16mWpbR4KbQQ4KAMnHAwnKQQcDCkoABwMKCkEAjgnKCoEOCoDJxwMJysBHAwrKgAcDCorAQI4JyosLAIAJwAwM+okblBuiY6X9XDK/9cEywu0YDE/tyCynhOeXBAAAQQ4LCctHAwtLgQcDC4sABwMLC4EAjgtLC8EOC8DLBwMLC0BHAwtAwAcDAMtAQI4LAMvBDgvJywcDCwvBBwMLycAHAwnLAQWDC0nHAwDLQQcDCcvBAQ4LSwnFgwrLBwMKisEHAwsLQQEOCsuLB4CACsFHAwrMAQcDDAuABwMLisEDDgrKS4kAgAuAAAIDCMAAAfsHAwqKQQEOCksLgUoAC2AQwApADguKS0tDC0CIwAACCwcDAMpBAQ4KSctBSgAL4BDACkAOC0pLi0MLgIjAAAILAA4KwItDjgrLS4kAgAuAAAIQyUAABpvDDgrBQIWDAIFHAwCKwAcDAUuAAQ4KwcvBDguBAcAOC8HBBwMAgcGHAwFLwYEOAcJMAQ4Lx0JADgwCR0EOCsKCQQ4Lh4KADgJCh4EOAcLCQQ4Lx8KADgJCgsEOAcVCQQ4LyAKADgJChUEOAcWCQQ4LyEKADgJChYEOAcYCQQ4LyIKADgJChgEOAcZCQQ4LyMKADgJChkEOAcaCQQ4LyQHADgJBwocDAIHBRwMBQkFBDgHGxoEOAklBwA4GgcJHAwCBwIcDAUCAgQ4BxwFBDgCJgcAOAUHAi0IAQUAAAECARwMLQcAJwIaACAnAhwELS0IAC0tDAYuLQwaLwAQABwAJQAAGoEtBAAALQwuGwQ4KBsaADgHGhsnAgcAQCcCHAQtLQgALS0MBi4tDAcvABAAHAAlAAAagS0EAAAtDC4aBDgqGgcAOBsHGhwMLAcAJwIbAEgnAh8EKi0IACotDAYrLQwbLAAQAB8AJQAAGoEtBAAALQwrHAQ4BxwbADgaGwcnAhoAaCcCHAQqLQgAKi0MBistDBosABAAHAAlAAAagS0EAAAtDCsbBDgDGxoAOAcaAxwMJwcAJwIaAHAnAhwEKi0IACotDAYrLQwaLAAQABwAJQAAGoEtBAAALQwrGwQ4BxsaADgDGgctCAEDJwIaBBgAEAEaAScDAwQBACgDAhotDBobLQ4HGwAoGwIbLgqARgAbACgbAhsuCoBGABsAKBsCGy4KgEYAGwAoGwIbLgqARgAbACgbAhsuCoBGABsAKBsCGy4KgEYAGwAoGwIbLgqARgAbACgbAhsuCoBGABsAKBsCGy4KgEYAGwAoGwIbLgqARgAbACgbAhsuCoBGABsAKBsCGy4KgEYAGwAoGwIbLgqARgAbACgbAhsuCoBGABsAKBsCGy4KgEYAGwAoGwIbLgqARgAbACgbAhsuCoBGABsAKBsCGy4KgEYAGwAoGwIbLgqARgAbACgbAhsuCoBGABsAKBsCGy4KgEYAGwAoGwIbLgqARgAbLQ4DBScCBwQqLQgAKi0MHSsAEAAHACUAABuBLQQAAC0MKwMnAhoEKi0IACotDAsrABAAGgAlAAAbgS0EAAAtDCsHJwIaBCotCAAqLQwVKwAQABoAJQAAG4EtBAAALQwrCycCGgQqLQgAKi0MFisAEAAaACUAABuBLQQAAC0MKxUnAhoEKi0IACotDBgrABAAGgAlAAAbgS0EAAAtDCsWJwIaBCotCAAqLQwZKwAQABoAJQAAG4EtBAAALQwrGCcCGgQqLQgAKi0MCisAEAAaACUAABuBLQQAAC0MKxkcDAkKABwMAgkAASgAA4BIABotDRoCASgAB4BIABotDRoDASgAC4BIABotDRoHASgAFYBIABotDRoLASgAFoBIABotDRoVASgAGIBIABotDRoWASgAGYBIABotDRoYLQgBGScCGgQMABABGgEnAxkEAQAoGQIaLQwaGy0OBBsAKBsCGy0OAhsAKBsCGy0OHhsAKBsCGy0OAxsAKBsCGy0OBxsAKBsCGy0OCxsAKBsCGy0OFRsAKBsCGy0OFhsAKBsCGy0OGBsAKBsCGy0OChsAKBsCGy0OCRsnAgMEKi0IACotDBcrABAAAwAlAAAbgS0EAAAtDCsCJwIEBCotCAAqLQwPKwAQAAQAJQAAG4EtBAAALQwrAycCBwQqLQgAKi0MECsAEAAHACUAABuBLQQAAC0MKwQnAgkEKi0IACotDBErABAACQAlAAAbgS0EAAAtDCsHJwIKBCotCAAqLQwSKwAQAAoAJQAAG4EtBAAALQwrCScCCwQqLQgAKi0MEysAEAALACUAABuBLQQAAC0MKwonAg8EKi0IACotDA0rABAADwAlAAAbgS0EAAAtDCsLHAwMDQABKAACgEgADy0NDwwBKAADgEgADy0NDwIBKAAEgEgADy0NDwMBKAAHgEgADy0NDwQBKAAJgEgADy0NDwcBKAAKgEgADy0NDwkBKAALgEgADy0NDwotCAELJwIPBAwAEAEPAScDCwQBACgLAg8tDA8QLQ4IEAAoEAIQLQ4MEAAoEAIQLQ4OEAAoEAIQLQ4CEAAoEAIQLQ4DEAAoEAIQLQ4EEAAoEAIQLQ4HEAAoEAIQLQ4JEAAoEAIQLQ4KEAAoEAIQLQ4NEAAoEAIQLQ4GEC4IgEUAKSMAAA6pDSgAKYBKAAIkAgACAAAR1SMAAA6+LQ0FAy0NAwQAKAQCBC0OBAMtCAEEJwIFBAQAEAEFAScDBAQBACgEAgUtDAUGLgqARgAGACgGAgYuCoBGAAYAKAYCBi4KgEYABisCAAUAAAAAAAAAABcAAAAAAAAAAC0IAQYnAgcEBQAQAQcBJwMGBAEAKAYCBy0MBwguCoBGAAgAKAgCCC4KgEYACAAoCAIILgqARgAIACgIAggtDgUILQgBBQAAAQIBLQ4EBS0IAQQAAAECAS0OBgQtCAEGAAABAgEuCoBFAAYtCAEHAAABAgEuCoBEAActDQMIACgIAggtDggDLgiARQACIwAAD60NKAACgEsACCQCAAgAABGLIwAAD8InAgkEFS0IABUtDAUWLQwEFy0MBhgtDAcZABAACQAlAAAbrC0EAAAtDBYILQgBBCcCBQQZABABBQEnAwQEAQAoBAIFJwIGBBgAOAYFBi0MBQcMOAcGCRYMCQkkAgAJAAAQNC4KgEYABwAoBwIHIwAAEBMtCAEFAAABAgEtDgQFLgiARQACIwAAEEwNKAACgEsABCQCAAQAABE+IwAAEGEtDQUDLgQAA4ADKACABAQAGSUAABwgLgiABQAEACgEAgYBKAAGgEsABy0OCActDgQFJwIDBBguCIBFAAIjAAAQogw4AgMFJAIABQAAEQ8jAAAQtCcCAwQBJwIFBAMAOAMFBC0IAQIAEAEEAScDAgQBACgCAgQtDgMEACgEAgQtDgMEJwIEBAMAOAIEAy0MAwQtDgEEACgCAgQtDQQDJwIFBAIAOAQFATcNAAEAAyYcDAIFAAA4FAUGACgEAgcAOAcCCC0NCAUwDAAFAAYBKAACgEgABS0MBQIjAAAQoi0NBQQAKAMCBwA4BwIJLQ0JBi4EAASAAygAgAQEABklAAAcIC4IgAUABwAoBwIJADgJAgotDgYKLQ4HBQEoAAKASAAELQwEAiMAABBMACgDAgkAOAkCCi0NCggnAgkEFS0IABUtDAUWLQwEFy0MBhgtDAcZLQwIGgAQAAkAJQAAHK4tBAAAASgAAoBIAAgtDAgCIwAAD60tDQUCASgAKYBIAAMAKBkCBgA4BikHLQ0HBA0oAAOASwAGJAIABgAAEgQlAAAd1y4EAAKAAygAgAQEABglAAAcIC4IgAUABgAoBgIHADgHAwgtDgQIASgAA4BKAAIOOAMCBCQCAAQAABJEJQAAGm8AKAsCBwA4BykILQ0IBA0oAAKASwAHJAIABwAAEmclAAAd1y4EAAaAAygAgAQEABglAAAcIC4IgAUABwAoBwIIADgIAgktDgQJLQ4HBS0MAykjAAAOqS0NBwUtDQQKLQ0DCw0oAAuASwAVJAIAFQAAErslAAAd1wAoCgIWADgWCxgtDRgVASgAC4BIABYOOAsWGCQCABgAABLjJQAAGm8tDgoELQ4WAy4EAAWAAygAgAQEABglAAAcIC4IgAUACgAoCgILADgLAhYtDhUWLQ4KBwEoAAKASAAFLQwFAiMAAAWlLQ0EAxwMAgUAADgUBQcvDAAHAAUuBAADgAMoAIAEBAAYJQAAHCAuCIAFAAcAKAcCCgA4CgILLQ4FCy0OBwQBKAACgEgAAy0MAwIjAAAFES0NCgktDQgMLQ0HDQ0oAA2ASwAOJAIADgAAE5YlAAAd1wAoDAIPADgPDRAtDRAOASgADYBIAA8OOA0PECQCABAAABO+JQAAGm8tDgwILQ4PBy4EAAmAAygAgAQEABglAAAcIC4IgAUADAAoDAINADgNAg8tDg4PLQ4MCgEoAAKASAAJLQwJAiMAAAJELQ0NBxwMAggAADgKCAkvDAAJAAguBAAHgAMoAIAEBAAYJQAAHCAuCIAFAAkAKAkCDAA4DAIOLQ4IDi0OCQ0BKAACgEgABy0MBwIjAAABsCgAgAQEeAANAAAAgASAAyQAgAMAABR4KgEAAQX3ofOvpa3UyjwBAQImKgEAAQW+Hj//PqT2+jwBAQImKgEAAQUxdnHEg87uxjwBAQImJQAAFFAtCAELJwIMBAQAEAEMAScDCwQBACgLAgwtDAwNLgqARgANACgNAg0uCoBGAA0AKA0CDS4KgEYADSsCAAwAAAAAAAAAAAIAAAAAAAAAAC0IAQ0nAg4EBQAQAQ4BJwMNBAEAKA0CDi0MDg8uCoBGAA8AKA8CDy4KgEYADwAoDwIPLgqARgAPACgPAg8tDgwPLQgBDAAAAQIBLQ4LDC0IAQsAAAECAS0ODQstCAENAAABAgEuCoBFAA0tCAEOAAABAgEuCoBEAA4nAg8EEC0IABAtDAwRLQwLEi0MDRMtDA4ULQwEFQAQAA8AJQAAHK4tBAAAJwIEBA8tCAAPLQwMEC0MCxEtDA0SLQwOEy0MBhQAEAAEACUAAByuLQQAACcCBgQPLQgADy0MDBAtDAsRLQwNEi0MDhMAEAAGACUAABusLQQAAC0MEAQnAgYAUQo4BQYLCygABIBGAAYkAgALAAAWSyMAABYICygABYBMAAskAgALAAAWIScCDAQAPAkBDAsoAAaARAAFJAIABQAAFjYlAAAd6S0MAQctDAIILQwDCS0MBAojAAAWdQsoAAaARAAFJAIABQAAFmAlAAAd6S0MAQctDAIILQwDCS0MBAojAAAWdS0MCgQtDAcBLQwIAi0MCQMmJQAAFFABKAACgEoABA44AgQFJAIABQAAFqUlAAAabw0wgEsABAAFCygABYBEAAQkAgAEAAAWwiUAAB37LQgBBCcCBQQMABABBQEnAwQEAQAoBAIFJwIGBAsAOAYFBi0MBQcMOAcGCBYMCAgkAgAIAAAXCS4KgEYABwAoBwIHIwAAFugtCAEFAAABAgEtDgQFLgiARQADIwAAFyENKAADgEoABCQCAAQAABc7IwAAFzYtDQUBJi0NBQQAOAMCBg44AwYHJAIABwAAF1YlAAAabw0oAAaASwAHJAIABwAAF2slAAAd1wAoAQIIADgIBgktDQkHLgQABIADKACABAQADCUAABwgLgiABQAGACgGAggAOAgDCS0OBwkBKAADgEgABC0OBgUtDAQDIwAAFyElAAAUUAEoAAGASAADLQ0DAicCAwQCADgBAwUtDQUELQgBAycCBQQCABABBQEnAwMEAQAoAwIFLQwFBi0OBAYnAgUEBi0IAAYtDAMHABAABQAlAAAeDS0EAAAtDAcEASgAAYBDAAUtDQUDASgAAYBJAAYtDQYFLQgBBicCBwQCABABBwEnAwYEAQAoBgIHLQwHCC0OBQgnAgcECC0IAAgtDAYJABAABwAlAAAeDS0EAAAtDAkFJwIGBAUAOAEGCC0NCActCAEGJwIIBAIAEAEIAScDBgQBACgGAggtDAgJLQ4HCScCCAQJLQgACS0MBgoAEAAIACUAAB4NLQQAAC0MCgcnAgYEBgA4AQYJLQ0JCC0IAQYnAgkEAgAQAQkBJwMGBAEAKAYCCS0MCQotDggKJwIJBAotCAAKLQwGCwAQAAkAJQAAHg0tBAAALQwLCCcCBgQHADgBBgotDQoJLQgBBicCCgQCABABCgEnAwYEAQAoBgIKLQwKCy0OCQsnAgoECy0IAAstDAYMABAACgAlAAAeDS0EAAAtDAwJJwIGBAgAOAEGCy0NCwotCAEGJwILBAIAEAELAScDBgQBACgGAgstDAsMLQ4KDCcCCwQMLQgADC0MBg0AEAALACUAAB4NLQQAAC0MDQonAgYECQA4AQYMLQ0MCy0IAQYnAgwEAgAQAQwBJwMGBAEAKAYCDC0MDA0tDgsNJwIMBA0tCAANLQwGDgAQAAwAJQAAHg0tBAAALQwOCycCBgQKADgBBg0tDQ0MHAwMDQUcDA0GABwMBgwFASgAAYBKAA0tDQ0GHAwGDQIcDA0BABwMAQYCLQwCAS0MBAItDAUELQwHBS0MCQctDAsJLQwGCy0MCAYtDAoILQwMCiYqAQABBVVFTwUJdio6PAEBAiYqAQABBYFkm2itHhyEPAEBAiYqAQABBUWnynEZQeQVPAEBAiYlAAAUUC0IAQQAAAECAScCBQABLQ4FBCcCBwQCJwIIAQEtCAEGJwIJBCEAEAEJAScDBgQBACgGAgknAgoEIEMD8AACAAcACgAIAAknAgsEIC4EAAmAAy4EAAuABCUAAB4yJwICBCEnAgcEIC4IgEgAAyMAABr3DDgDAggkAgAIAAAbDiMAABsJLQ0EASYtDQQIBDgICAkCOAcDCA44AwcKJAIACgAAGy4lAAAesgw4CAcKJAIACgAAG0AlAAAd1wAoBgILADgLCAwtDQwKHAwKCAAEOAkBCgQ4CAoLAjgFCAoEOAoJCAA4CwgJLQ4JBAEoAAOASAAILQwIAyMAABr3JQAAFFAcDAECAC0IAQEnAgMEAgAQAQMBJwMBBAEAKAECAy0MAwQtDgIEJiUAABRQLQ0EBQsoAAWARAAGJAIABgAAG84nAgcEADwJAQcnAgUEBi0IAAYtDAEHLQwCCC0MAwktDAQKABAABQAlAAAexC0EAAAtDQEFLQ0CBi0NAwctDgUBLQ4GAi0OBwMuCoBHAAQBKAAGgEgAAi0NAgEmLgGAA4AGCwCABgACgAckAIAHAAAcOyMAABxGLgCAA4AFIwAAHK0uAAABgAUBAAABgAQAAQEAgAOABIAJLgCAA4AKLgCABYALCwCACoAJgAwkAIAMAAAcmS4BgAqACC4CgAiACwEAgAoAAoAKAQCACwACgAsjAAAcaCgBgAUEAAEDAIAGAAKABiMAABytJiUAABRQLQ0DBi0NBAcLKAAHgEQACCQCAAgAABzUJwIJBAA8CQEJCygABoBDAAckAgAHAAAdYyMAABzpLQ0BBi0NAgctDQMILQ0ECQ0oAAiAQwAKJAIACgAAHQ4lAAAd1y4EAAaAAygAgAQEAAQlAAAcIC4IgAUACgAoCgILADgLCAwtDgUMASgACIBIAAUOOAgFBiQCAAYAAB1OJQAAGm8tDgoBLQ4HAi0OBQMtDgkEIwAAHdYnAgYEBy0IAActDAEILQwCCS0MAwotDAQLABAABgAlAAAexC0EAAAtDQEGLQ0CBy0NBAguBAAGgAMoAIAEBAAEJQAAHCAuCIAFAAkAKAkCCgEoAAqARQALLQ4FCy0OCQEtDgcCLgqASAADLQ4IBCMAAB3WJioBAAEFxWvEWg4QAAI8AQECJioBAAEFAtxuJ4B2Ep08AQECJioBAAEF9C7lhLv0IdE8AQECJiUAABRQASgAAYBIAAMtDQMCHAwCAwYcDAMBABwMAQIGLQwCASYoAIAGBAACBwCABIAGgAUuAIAEgAgoAIAJBAAADQCACYAFgAoXAIAKgAokAIAKAAAesQMAgAgAAoAIAQCAA4AJgAsuAYALgAYBAIADgAiACy4BgAuABwEAgAOACYALLgKAB4ALAQCAA4AIgAsuAoAGgAsBAIAJAAKACSMAAB5OJioBAAEFKIaSsEfc/UM8AQECJiUAABRQLgiARQAFIwAAHtQNKAAFgEMABiQCAAYAAB8/IwAAHuktDQEFLQ0CBi0NAwctDQQILQ0GCQAoCQIJLQ4JBi0IAQknAgoEBQAQAQoBJwMJBAEAKAYCCicCCwQEACgJAgw/DwAKAAwtDgUBLQ4JAi0OBwMtDggEJi0NAwYMOAUGBwEoAAWASAAGJAIABwAAH10jAAAfyS0NAQctDQIILQ0DCS0NBAoAKAgCDAA4DAUNLQ0NCwAoBwINADgNBQ4tDQ4MADgLDA0uBAAIgAMoAIAEBAAFJQAAHCAuCIAFAAsAKAsCDAA4DAUOLQ4NDi0OBwEtDgsCLQ4JAy0OCgQjAAAfyS0MBgUjAAAe1A==",
      "debug_symbols": "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",
      "brillig_names": [
        "refund_public"
      ]
    },
    {
      "name": "add_lock_private_user",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17476367995570638746": {
            "error_kind": "string",
            "string": "NoAllowance"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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wfwais37G6y2OF/5aUtl/3wzJPf807/H6hSN1SsaKykaa1A01qhorEnRWLOisRY9YyWjaKyK8iZSlDeRoryJFOVNpChvIkV5EynKm0hR3kSK8qagKG8KivKmoChvCorypqAobwqK8qagKG8KivKmoChvCorypqgob4qK8qaoKG+KivKmqChviorypqgob4qK8qaoKG+KivKmpChvSorypqQob0qK8qakKG9KivKmpChvSorypqQob0qK8qasKG/KivKmrChvyorypqwob8qK8qasKG/KivKmrChvyorypqIobyor5U2uxG2s3jxtw3lGJtFOxj79dj7qSTTb5o/RPX3umP0d40op2UCMK2V7AzESMHJgXClHHYhxpfR3IMaVMuuBGFdK2gdiXMkPDMPozUpWYyBGuBgWjHAxLBjhYlgwEjByYFzJxdyurbRjLLWOWJvc/uO2mKdf/yXBtdhXcj2CsK/kkgRhX8lVCcK+kguTg92u5NoEYV/J5QnCvpIrFIR9JRcpCDsB+wjscKlDsMOlDsEOlzoEO1zqEOyKXaozYeuJdbcRV7C7m0wfhzubn6DkeHR0MvvRyT3e7Yu/sTvFLnUkdsUudSR2xS51JHbFLnUkdgL2EdgVu9SR2BW71JHYFbvUkdgVu9SR2OFSR2D3cKlDsMOlDsEOlzoEu2aX6nPesRPVCr8u7n1xMYbH0cUe9cW67cdvj/Cejv4l2Nejfdp77ov/dPRvmQgySZBJswsWJJNm1yxIJs0uW5BMml25IJk0u3g5Mi219erCMmmuEgiSSXNVQZBMqEKIkIkgkwSZUIUQIROqECJkQhVChEyoQoiQCVUICTIttZH5wjKhCiFCJlQhRMiEKoQImQgySZAJVQgRMqEKIUImVCFEyIQqhAiZUIWQIFNEFUKETKhCiJAJVQgRMqEKIUImgkwSZEIVQoRMqEKIkAlVCBEyoQohQiZUISTIlFCFECETqhAiZEIVQoRMqEKIkIkgkwSZUIUQIROqECJkQhVChEyoQoiQCVUICTJlVCFEyIQqhAiZUIUQIROqECJkIsgkQSZUIUTIhCqECJlQhRAhE6oQImRCFUKCTAVVCBEyoQohQiZUIUTIhCqECJkIMkmQCVUIETKhCiFCJlQhRMiEKoQImVCFECATGVQhRMiEKoQImVCFECETqhAiZCLIJEEmVCFEyIQq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SQePw0USHoeLJDwOF0l4HC6SBJJMJOFxuEjC43CRhMfhIgmPw0USHoeJpIfH4SIJj8NFEh6HiyQ8DhdJAkkmkvA4XCThcbhIwuNwkYTH4SIJj8NEkuBxuEjC43CRXMnjkN2PJlvip6Pvo13Jh9RHS6pGu1I+Xx/tSjl3fbQr5cX10a6Uu9ZHu1J+WR3tUvvA10e7Up5WH62qXGqpPc/royVVo1WVSy21v3d9tKpyqaX2ya6PVlUutdR+0/XRqsqlltq3uT5aVbnUUvsf10erKpdaah/h+mhV5VJL7cdbH62qXGqpfW3ro1WVSy21P2x9tKpyqaX2Wa2PVlUutdR+pfXRqsqlltr3sz5aVbnUUvtn1kerKpdaah/K+mhV5VJL7edYH62qXGqpfRHro1WVSy21v2B9tKpyqaX26auPVlUutdR+d/XRqsqllto3rj5aVbnUUvuv1UerKpdaah+z+mg15VJ5qf3A6qPVlEvlpfbVqo92qVyKrN9Gm6w5GC2pGu1SuVR1tEvlUtXRLpVLVUe7VC5VHe1SuVRttEvtO1Qf7VK5VHW0S+VS1dGqyqWW2genPlpVudRS+8nUR6sql1pqX5b6aFXlUkvtb1Ifrapcaql9QuqjVZVLLbXfRn20qnKppfatqI9WVS611P4P9dGqyqWW2kehPlpVudRS+xHUR6sql1pqXf/6aFXlUkutj18frapcaql15uujVZVLLbVee320qnKptdY9r45WVS611rrn1dGqyqXWWve8OlpVudRa655XR6sql1pr3fPqaFXlUmute14drapcaq11zyujLQMqrDFtR4eY/fNo7z0aEG3mwd/Erz06zsCc34TwPuVKj3wsZjs6m6/bUpWTIhLzSXKPk5QOJzmpVDCfxPY4ietxEt/jJNTjJKHHSXpc8dTjiqceVzz1uOJDjys+9LjiQ48rPvS44kOPKz70uOJDjys+9LjiQ48rPvS44mOPKz72uOJjjys+9rjiY48rPva44mOPKz72uOJjjys+9rjiU48rPvW44lOPKz71uOJTjys+9bjiU48rPvW44lOPKz71uOJzjys+97jic48rPve44nOPKz73uOJzjys+97jic48rPnNc8TntRxdjv56kmB4nsT1O4nqcxPc4CfU4SehxktjjJIn5JNYdnITjis/74x9fnPl0kq9H5/0RS/aPJywu24Nj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1bbVXm1b7dW21V5tW+3VttVebVvt1bbVXm1b7dW21V5tW+3VttVebVvt1bbVXm1b7dW21V5tW+3VttVebVvt1bbVXm1b7dW21V5tW+3VttVebVvt1bbVXm1b7dW21V5tW+3VttVebVvt1bbVXm1b7dW21V5tW+3VttVebVvt1bbVXm1b7dW21V5tW+3VttVebVvt1bbVXm1b7dW21V5tW+3VttVebVvt1bbVXm1b7dW21V5tW+3VttVe7UnttexvGNpC9qDZSZTsS/rZUtynZkdL+TJtFHLrTpmqO2e14lHdsXN1x83VHT9Xd2iu7oS5uhPn6k6aqztz3ZXzXHflMtdducx1Vy5z3ZXLXHflMtdducx1Vy6978ov97i69SdN1p88WX/KVP1xxkzWHztZf44XUL8l9h/NnLOh0p9bPcDs3Y/pj6sX3E7ie5yEepwksJzEx8dJon86ycEXedlvCwN587zukzleTtXsa64Z//j2vpiP/sfJ+x92/jF4/7X/SXj/s/D+F9n9P37xQVD/rfD+O+H998L7T8L7P/v8W+u/8PnXCp9/rfD51wqff53w+dcJn3+d8PnXCZ9/nfD51wmff53w+dcJn3+d8PnXCZ9/vfD51wuff73w+dcLn3+98PnXC59/vfD51wuff73w+dcLn39J+PxLwudfEj7/kvD5l4TPvyR8/iXh8y8Jn39J+PxLwuffIHz+DcLn3yB8/g3C598gfP4NwuffIHz+DcLn3yB8/g3C598ofP6NwuffKHz+jcLn3yh8/o3C598ofP6NwuffKHz+jcLn3yR8/k3C598kfP5NwuffJHz+TcLn3yR8/k3C598kfP5NwuffLHz+zcLn3yx8/s3C598sfP7NwuffLHz+zcLn3yx8/s3C598ifP4twuffInz+LcLn3yJ8/i3C598ifP4twuffInz+LbLnX29kz7/eyJ5/vZE9/3oje/71Rvb866df/6rWf9nzrxe+/pUXvv6VF77+lRe+/pUXvv6VF77+lRe+/pUXvv6VF77+lRe+/pUXvv6VF77+lRe+/pUXvv6VF77+lRe+/pUXvv6VF77+lRe+/pUXvv6VF77+lRe+/pUXvv6VF77+lRe+/pUXvv6VF77+lRe+/pUXvv6VF77+lRe+/pUXvv6VF77+lRe+/pUXvv6VF77+lRe+/pUXvv6VF77+lRe+/pUX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a26rvea22mtuq73mttprbqu95rbaa26rvea22mtuq73mttprbqu95rbaa26rvea22mtuq73mttprbqu95rbaa26rvea22mtuq73mttprbqu95rbaa26rvea22mtuq73mttprbqu95rbaa26rvea22mtuq73mttprbqu95rbaa26rvea22mtuq73mttprbqu95rbaa26rvea22mtuq73mttprbqu95rbaa26rvea22mtuq73mttprbqu95rbaa26rveZ0soxK2T9MdzZ8anbwAvt2ivR4XYX8x+/7i3+fLv79cPHvx4t/P138+/ni3y/X/n42F/++vfj3L75+88XXb774+s0XX7/54us3X3z95ouv33zx9Vsuvn7LxdfvSZX99rz3o427mZIv03Y5LoRa77f3O61/Wh8mH706Sv7xZdLTCCh/nMFefgZ3+Rn85Wegy88QLj9D/PEZQtjW3Q3x6Azp8jPkn58hme0MqRycoVx9BvfzazqUTelo/MEZ7OVncJxneFrb5nEGf/kZ6PIz/PyajmnbCyZmc3CGePkZfn5Nx7x93BsLHZwhX36Gn1/TaV/BLdn89QzeXH4Gy3kGFw/O4C4/g7/8DD+/ph+fot8e6B+cIVx+hp9f03mnlA9jKV1+hp9f07dnYtsZnjbBepyhXH0GMpxnCAf3VrKXn8FdfoafX9O3vPHj2HJ0TRNdfoafX9Nl37PtpurBGeLlZ/j5NV323LvEI0r58jMUzjOkg3trMJefwV5+hp9f09aEzaJYEw+u6uA7nOP4uia3zY6WUnx9Dm/zdg5vn9aNcZGOjjZx+2lvnpyZ//XA5OvRyWzJvU9PV9yvo+/9D8L7H4X3Pwnvfxbe/yK7/8eP6QX13wrvvxPefy+8/8Ln3yh8/o3C598ofP6NwuffKHz+TcLn3yR8/k3C598kfP5NwuffJHz+TcLn3yR8/k3C598kfP7NwuffLHz+zcLn39x//nX7S+72eRu1w/6/uwL5vtcSJft16dySSdVog6rRRlWjTapGm1WNtmgabTGqRmtVjdapGq2qXKqoyqWKqlyqqMqliqpcqqjKpYqiXCoboyiXuo12rfn25e5pt9EudU9+vbnFbbST35Nn2TTQlu2FYudM+XT0nePkd3sxHCefR6RwtJPPUGI4Tl5HEMNx8gqFGI6T52JiOBI4snCcvF4jhuPkrkMM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TbGRmmIjNcVGaoqN1BQbqSk2UlNspKbYSE2xkZtiIzfFRm6KjdwUG7kpNnJTbOSm2MhNsZGbYiM3xUZpio3SFBulKTZKU2yUptgoTbFRmmKjNMVGaYqN0hIbJ9voVVvZplauqZVvakVNrUJTq9jUKjW1yk2tmmLDNsWGbYoN2xQbtik2bFNs2KbYsE2xYZtiwzbFhm2KDdcUG64pNlxTbLim2HBNseGaYsM1xYZrig3XFBuuKTZ8U2z4ptjwTbHhm2LDN8WGb4oN3xQbvik2mqpzJ3uw1FpRU2xQU2xQU2xQU2xQU2xQU2w01UV9U13UN9VFfVNd1DfVRX1TXdQ31UV9U13UN9VFfVNd1DfVRX1TXdQ31UV9U13UN9VFfVNd1DfVRX1TXdQ31UV9U13UN9VFfVNd1DfVRX1TXdQ31UV9U13UN9VFfVNd1DfVRX1TXdQ31UV9U13UN9VFfVNd1DfVRX1TXdQ31UV9U13UN9VFfVNd1DfVRX1TXdQ31UV9U13UN9VFfVNd1DfVRX1TXdQ31UV9U13UN9VFfVNd1DfVRX1TXZSa6qLUVBelprooNdVFqakuSk11UWqqi1JTXZSa6qLUVBelprooNdVFqakuSsd10VsZeFue5VaJC59afX2lZ1+TPT0+6CN//3m69ufDtT8fr/35dO3P52t/vlz688dlY76ft9f+vLv256+9at21V6279qp111617tqr1l171bprr1p/7VXrr71q/bVX7UkdPMX80cSl5w/of83Qt39yv449Lv8G/1gO+mkNLLpP7fH9Jun9Jvn9JuXNJrd/8r+OPJ5xaCce3TO9cmt4+8f/75/+/S//9M9//bf/uDX59V//79/+5T//8ve/ffzjf/7//2f7L//873/561//8r//8f/8+9//5d/+9f/++7/941///i+//tufzMf//M90K5n8Od2czD/83lbpf+abZfhzvs3j//C7h7f/Hu3tvyf767//akApmT/f/if8+he/WqRbmvbn2//QY2emX4eF21HRbK3cDYXzcRf/1yHe/ZncdkCwfw7xgeV3m1uT27/679ug/x8=",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "add_lock_public_user",
      "is_unconstrained": true,
      "custom_attributes": [
        "internal",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "2722406262643068352": {
            "error_kind": "string",
            "string": "HashlockAlreadySet"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16870384257694633552": {
            "error_kind": "string",
            "string": "Function add_lock_public_user can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "add_lock_public_user"
      ]
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [
        "aztec::macros::functions::utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7f3druy6dp6N3ouP14H4J5K5lQ8bQRL7CwwYduA4G9gIfO+75qwuVfXVVcUxNFlqjWxPDpyx1pK6yOdtktr7SkX933/4x3/67//nf/7Xf/7X//ff/vc//Jf/5//+w7/82//4b//xz//2r7f/9H//82//8N///Z//5V/++X/+1+f/+h+WP/6Pc/XPHf73//pv//rHf/7f//Hf/v0//uG/uCW68Ld/+Kd//cc//5397Y/8v//8L//0D/+llv/824/Nc1m/Ni5L3Ddd08GmyaevTVNa9k1dXP7z//O3f3B+6TCaEvI2mlTfjyaG+rVpXMvP0bgeoylxG00t70ezLhub1a8/R+M7jKZ6/7VxDakxmrJ8bZqXA6XC4WhCWTb4LtR1fT8aXxf3tXVYnjZ2y9dB4hUHSVccZL3iIPmKg5QrDlIvOEhYrjiIu+Ig/oqDXHHGhyvO+HDFGR+uOOPDFWd8uOKMD1ec8fGKMz5eccbHK874eMUZH6844+MVZ3y84oyPV5zx8YozPl5xxqcrzvh0xRmfrjjj0xVnfLrijE9XnPHpijM+XXHGpyvO+HTFGb9eccavV5zx6xVn/HrFGb9eccavV5zx6xVn/HrFGb9eccavV5zx+YozPl9xxucrzvh8xRmfrzjj8xVnfL7ijM9XnPH5ijM+X3HGlyvO+HLFGV+uOOPLFWd8ueKMLz3O+LCkdT9IzU8HCfeDrFccJF9xkHLFQeoFB6nLFQfpccaH21O47SDe128H+bn1zUJuQ7qZCv+0dT56XFm2R30pPJ0c6X5yVH/98Mv+yPJ2vSyN4ac17w9/1xL2rVO8jz8MPv44+PjT4ONfBx9/Hnz8ZfDx16HH75dl8PG7wcc/9v3XL+rvvzluzVLKKT6P/8BKpP29KJ+ye79xSdswSn5qrMKhR3H7+2X+9uhn3zr6o43Lw8982/RP4BHg1wJX3+HMBlx9SzYbcPU95GzA1Te9swFX36VPBtyptxWzAVfvg2YDrt64zQYcp3kx8Ajwa4HjNC8GjtO8GDhO82LgOM2LgeM0rwXucZoXA8dpXgwcp3kxcJzmxcAjwK8FjtO8GDhO82LgOM2LgeM0LwaO07wWeMBpXgx8AKfpHsDLe4au7D8kcdWHxp92sW6rzLn0tEDb12uXYQBPKIVmAPcmhSaC5hWaARyRFJoBvIsUmgFchhSaAfyAFJoBOnchNHGAHlsKDd3wSzR0wy/R0A2/RBNB8woN3fBLNHTDL9HQDb9EQzf8Eg3d8Cs0iW74JRq64Zdo6IZfoqEbfokmguYVGrrhl2johl+ioRt+iYZu+CUauuFXaFa64Zdo6IZfoqEbfomGbvglmgiaV2johl+ioRt+iYZu+CUauuGXaOiGX6HJdMMv0dANv0RDN/wSDd3wSzQRNK/Q0A2/REM3/BIN3fBLNHTDL9HQDb9CU+iGX6KhG36Jhm74JRq64ZdoImheoaEbfomGbvglGrrhl2johl+ioRt+habSDb9EY7gb9nXd0ITFLU2QOe4g3dPfLkcjWZfytfHqn1YIKeFO3XCjLUjdcA8vSD1CXYC6YechSN2wqRGkbtgvCVI3bMUEqRt2eWLUg/6vQk9JHW8qQR1vKkEdbypBPUJdgLphb3o70fNOvbYG4lz2+x93dXn6638o9lmVDHvZgVQy7H0HUsmwVx5IJcPeehyVRviUOiqN8P11VBrho+2oNMKX3lFphM/Do9II35RHpRE+RI9KI3y9HpVG+OQ9Kjmyh19VyS9pG4nztxk3VPI3Vb829648QSnr0dZ52bfO/vG69PqnSp7sYQSVyB5GUInsYQSVyB5GUCmi0gAqkT2MoBLZwwgqkT2MoBLZwwgqkT0MoFIgexhBJbKHEVQiexhBJbKHX1YplLKrFGPryYVf97H4dU2Pras7ROi3P357fv609R/6/tw65H3koYZvW/+pakTVCVUl25hRVbKQGVUlO5lRVbKWGVUlm5lQ1UiWM6OqZD8zqkpWNKOqZEszqhpRdUJVyZZmVJVsaUZVyZZmVJVsaUZVyZYmVDWRLc2oKtnSjKqSLc2oKtnSjKpGVJ1QVbKlGVUlW5pRVbKlGVUlW5pRVbKlCVVdyZZmVJVsaUZVyZZmVJVsaUZVI6pOqCrZ0oyqki3NqCrZ0oyqki3NqCrZ0oSqZrKlGVUlW5pRVbKlGVUlW5pR1YiqE6pKtjSjqmRLM6pKtjSjqmRLM6pKtjShqoVsaUZVyZZmVJVsaUZVyZZmVDWi6oSqki3NqCrZ0oyqki3NqCrZ0oyqki1NqGolW5pRVbKlGVUlW5pRVbKlGVWNqDqhqmRLM6pKtjSjqmRLM6pKtjSjqmRL86kaF7KlGVUlW5pRVbKlGVUlW5pR1YiqE6pKtjSjqmRLM6pKtjSjqmRLM6pKtjShqo5saUZVyZZmVJVsaUZVyZZmVDWi6oSqki3NqCrZ0oyqki3NqCrZ0oyqki1NqKonW5pRVbKlGVUlW5pRVbKlGVWNqDqhqmRLM6pKtjSjqmRLM6pKtjSjqmRLE6oayJZmVJVsaUZVyZZmVJVsaUZVI6pOqCrZ0oyqki3pUNXHtCMsLVVj3VVNy1J/qkq2NKOqZEszqkq2NKGqkWxpRlXJlmZUlWxpRlXJlmZUNaLqhKqSLc2oKtnSjKqSLc2oKtnSjKqSLU2oaiJbmlFVsqUZVSVbmlFVsqUZVY2oOqGqZEszqkq2NKOqZEszqkq2NKOqZEsTqrqSLc2oKtnSjKqSLc2oKtnSjKpGVJ1QVbKlGVUlW5pRVbKlGVUlW5pRVbKlCVXNZEszqkq2NKOqZEszqkq2NKOqEVUnVJVsaUZVyZZmVJVsaUZVyZZmVJVsaUJVC9nSjKqSLc2oKtnSjKqSLc2oakTVCVUlW5pRVbKlGVUlW5pRVbKlGVUlW5pQ1Uq2NKOqZEszqkq2NKOqZEszqhpRdUJVyZZmVJVsaUZVyZZmVJVsaUZVyZbmU/X236HqhKqSLc2oKtnSjKqSLc2oakTVCVUlW5pRVbKlGVUlW5pRVbKlGVUlW5pQVUe2NKOqZEszqkq2NKOqZEszqhpRdUJVyZZmVJVsaUZVyZZmVJVsaUZVyZYmVNWTLc2oKtnSjKqSLc2oKtnSjKpGVJ1QVbKlGVUlW5pRVbKlGVUlW5pRVbKlCVUNZEszqkq2NKOqZEszqkq2NKOqEVUnVJVsaUZVyZZmVJVsaUZVyZZmVJVsaUJVI9nSjKqSLc2oKtnSjKqSLc2oakTVCVUlW5pRVbKlGVUlW5pRVbKlGVUlW5pQ1US2NKOqZEszqkq2NKOqZEszqhpRdUJVyZZmVJVsaUZVyZZmVJVsaUZVyZYmVHUlW5pRVbKlGVUlW5pRVbKlX1Z1Xdyuan4e+KGqtz/pdijPqr6ogbJsNZBdbW3tl7pt7X3+tvWfqkZUnVBVsqUZVSVbmlFVsqUZVSVbmlFVsqUJVc1kSzOqSrY0o6pkSzOqSrY0o6oRVSdUlWxpRlXJlmZUlWxpRFVjCNvWsbSeCa7Rf228ro8KCOvRLOvjaePyNIzjjVe3b736tDS2dtmte1Hd5hhaf73uvNfqnkr3qATL7dno18bFr/554z/LnLCNMjdQ5qSPlPn8ZV6IYylzA2VOPk2ZGyhzAnvK3ECZ8wSDMjdQ5pEyp8znL3OecVHmBsqch36UuYEy5ykoZW6gzHkKSpkbKHOeglLm85d55SkoZW6gzHkKSpkbKHOeglLmBsqcp6CUuYEyj5Q5ZT5/mfMUlDI3UOY8BaXMDZQ5T0EpcwNlzlNQytxAmfMUlDI/XeY+5b3MS+tPu7Luo/7j3/Hb9rdiXBeeVVKMaoqRJ4oUo5pi5LkfxaimGHk6RzGqKcZIMVKMWoqRJ10Uo5pi5HkUxaimGHlqRDGqKUae7VCMaoqRJzAUo5ZidDyBoRjVFCNPYChGNcXIExiKUU0x8gRGRzHm/eWq2z+/b/2nThGdhtCJ3H4MnYi0x9CJtHcMnQhCx9CJjHAInTzx2Rg6kSyNoROhyxg6kUeMoVNEpyF0Io8YQyfyiDF0Io/4VZ1CyH5nEpNvkHe3wezPKlzJj986r4c6LX7Xyfunbf9UiTRiBJXIIgZQKZBE/KpKccn7uKOLuaHSujyWdnjwc7eHy39yJ1mQ4U5SIMMd5y/DPcJdhDvOXIY7TluGO85ZhjteWIY77laEe8SvynDHr8pwx6/KcMevynCPcP9V7musO/e1+aMVH/IG3of69Oyr5N9OjSPudgSV8MIjqIRzHkElfPYIKuHKB1Ap4eFHUAnHP4JK5AMjqESaMIJKEZUGUInsYQSVyB5GUInsYQSVyB4+pVJ0+yJRMS7fVPqTPHmCEPmVjECKPL5fijxeXoo8/lyKfIS8EHl8tBR5vLEUefyuFHk8rBR5PKwQ+YyHlSKPh5Uij4eVIo+HlSIfIS9EHg8rRR4PK0UeDytFHg8rRR4PK0S+4GGlyONhpcjjYaXI42GlyEfIC5HHw0qRx8NKkcfDSpHHw0qRx8MKka94WCnyeFgp8nhYKfJ4WCnyEfJC5PGwUuTxsFLk8bBS5PGwUuTxsDLk84KHlSKPh5Uij4eVIo+HlSIfIS9EHg8rRR4PK0UeDytFHg8rRR4PK0Te4WGlyONhpcjjYaXI42GlyEfIC5HHw0qRx8NKkcfDSpHHw0qRx8MKkfd4WCnyeFgp8nhYKfJ4WCnyEfJC5PGwUuTxsFLk8bBS5PGwUuTxsELkAx5WijweVoo8HlaKPB5WinyEvBB5PKwUeTysFHk8rBR5PKwUeTysEPmIh5Uij4eVIo+HlSKPh5UiHyEvRB4PK0UeDytFHg8rRR4PK0UeDytEPuFhpcjjYaXIW/awIe7kQ15bW69lAx9uD5Setq53kpY9aV+SEZKdSFr2jH1JWvaAfUla9nR9SVr2aH1JWvZcXUmulj1UX5KWPVFfknicXiTxOL1IRkh2IonH6UUSj9OLJB6nF0k8Ti+SeJxOJDMepxdJPE4vknicXiTxOL1IRkh2IonH6UUSj9OLJB6nF0k8Ti+SeJxOJAsepxdJPE4vknicXiTxOL1IRkh2IonH6UUSj9OLJB6nF0k8Ti+SeJxOJCsepxdJPE4vknicXiTxOL1IRkh2IonH6UUSj9OLJB6nF0k8Ti+SeJw+JMuCx+lFEo/TiyQepxdJPE4vkhGSnUjicXqRxOP0IonH6UUSj9OLJB6nE0mHx+lFEo/TiyQepxdJPE4vkhGSnUjicXqRxOP0IonH6UUSj9OLJB6nE0mPx+lFEo/TiyQepxdJPE4vkhGSnUjicXqRxOP0IonH6UUSj9OLJB6nE8mAx+lFEo/TiyQepxdJPE4vkhGSnUjicXqRxOP0IonH6UUSj9OLJB6nE8mIx+lFEo/TiyQepxdJPE4vkhGSnUjicXqRxOP0IonH6UUSj9OLJB6nE8mEx+lFEo/TiyQepxdJPE4vkhGSnUjicXqRxOP0IonH6UUSj9OLJB6nE8kVj9OLJB6nF0k8Ti+SeJxeJCMkO5HE4/QiicfpRRKP04skHqcXSTxOJ5IZj9OLJB6nF0k8Ti+SeJxeJCMkO5HE4/QiicfpRRKP04skHqcXSTxOJ5IFj9OLJB6nF0k8Ti+SeJxeJCMkO5HE4/QiicfpRRKP04skHqcXSTxOJ5IVj9OLJB6nF0k8Ti+SeJxeJCMkO5HE4/QiicfpRRKP04skHqcXSTxOH5J1weP0IonH6UUSj9OLJB6nF8kIyU4k8Ti9SOJxepHE4/QiicfpRRKP04mkw+P0IonH6UUSj9OLJB6nF8kIyU4k8Ti9SOJxepHE4/wiyRgW/7V1DGn9RvJgJDFvSFxyTyMpR+Nel/K18eqf/nIJd41wT/o1wpep18jj+PRrhJfUrxEuVb9G+F/9GkU0Uq8Rnl2/RqQB+jUiZ9CvETmDfo3IGdRrFMgZ9GtkOmco29Yh+vRt6z/ZmPb3DTamfXWDTYTNSzamfWSDjWn/1mBj2jc12Jj2Kw02pn3CezbRdH/eYENf/JoNffFrNvTFr9lE2LxkQ1/8mg198Ws29MWv2dAXv2ZDX/ySTaIvfs2Gvvg1G/ri12zoi1+zibB5yYa++DUb+uLXbOiLX7OhL37Nhr74JZuVvvg1G/ri12zoi1+zoS9+zSbC5iUb+uLXbOiLX7OhL37Nhr74NRv64pdsbH/RvsGGvvg1G/ri12zoi1+zibB5yYa++DUb+uLXbOiLX7OhL37Nhr74JRvbX0FvsKEvfs2Gvvg1G/ri12wibF6yoS9+zYa++DUb+uLXbOiLX7OhL37JxvSXs2N4sGmui+HytnaFXx5/2Rd3sG3ZeZRQG9vWXaBav2/7pz6We/MR9LHsD0bQx7JHGUGfiD6q9bHs1UbQx7JfHEEfy551BH0s++YR9LHs3fXr4xbTn6UfQiASBOUCmY4Qyr40bYmuJZAv+2KzIcSnrQ+RJLeLn8rybes7eNPZgCT4CHgZ8KbdvCR40zZdErxp/y0J3rSxlgRv2jELgnemnbAkeNMOVxI8zlUIPM5VCHwEvAx4nKsQeJyrEHicqxB4nKsQeJyrDHiPcxUCj3MVAo9zFQKPcxUCHwEvAx7nKgQe5yoEHucqBB7nKgQe5yoDPuBchcDjXIXA41yFwONchcBHwMuAx7kKgce5CoHHuQqBx7kKgce5yoCPOFch8DhXIfA4VyHwOFch8BHwMuBxrkLgca5C4HGuQuBxrkLgca4y4BPOVQg8zlUIPM5VCDzOVQh8BLwMeJyrEHicqxB4nKsQeJyrEHicqwz4FecqBB7nKgQe5yoEHucqBD4CXgY8zlUIPM5VCDzOVQg8zlUIPM5VBnzGuQqBx7kKgce5CoHHuQqBj4CXAY9zFQKPcxUCj3MVAo9zFQKPc5UBX3CuQuBxrkLgca5C4HGuQuAj4GXA41yFwONchcDjXIXA41yFwONcZcBXnKsQeJyrEHicqxB4nKsQ+Ah4GfA4VyHwOFch8DhXIfA4VyHwOFcR8G7BuQqBx7kKgce5CoHHuQqBj4CXAY9zFQKPcxUCj3MVAo9zFQKPc5UB73CuQuBxrkLgca5C4HGuQuAj4GXA41yFwONchcDjXIXA41yFwONcZcB7nKsQeJyrEHicqxB4nKsQ+Ah4GfA4VyHwOFch8DhXIfA4VyHwOFcZ8AHnKgQe5yoEHucqBB7nKgQ+Al4GPM5VCDzOVQg8zlUIPM5VCDzOVQZ8xLkKgce5CoHHuQqBx7kKgY+AlwGPcxUCj3MVAo9zFQKPcxUCj3OVAZ9wrkLgca5C4HGuQuBxrkLgI+BlwONchcDjXIXA41yFwONchcDjXGXArzhXIfA4VyHwOFch8DhXIfAR8DLgca5C4HGuQuBxrkLgca5C4HGuMuAzzlUIPM5VCDzOVQg8zlUIfAS8DHicqxB4nKsQeJyrEHicqxB4nKsM+IJzFQKPcxUCj3MVAo9zFQIfAS8DHucqBB7nKgQe5yoEHucqBB7nKgO+4lyFwONchcDjXIXA41yFwEfAy4DHuQqBx7kKgce5CoHHuQqBx7mKgPcLzlUIPM5VCDzOVQg8zlUIfAS8DHicqxB4nKsQeJyrEHicqxB4nKsMeIdzFQKPcxUCj3MVAo9zFQIfAS8DHucqBB7nKgQe5yoEHucqBB7nKgPe41yFwONchcDjXIXA41yFwEfAy4DHuQqBx7kKgce5CoHHuQqBx7nKgA84VyHwOFch8DhXIfA4VyHwEfAy4HGuQuBxrkLgca5C4HGuQuBxrjLgI85VCDzOVQg8zlUIPM5VCHwEvAx4nKsQeJyrEHicqxB4nKsQeJyrDPiEcxUCj3MVAo9zFQKPcxUCHwEvAx7nKgQe5yoEHucqBB7nKgQe5yoDfsW5CoHHuQqBx7kKgce5CoGPgJcBj3MVAo9z/Qj46HP92jqG5Btbu5j3v53c07jL0SzXpXxtvPr1advwJSmeeDpJcdvTSYqPn03STEIwnaRkD9NJSqoxnaTkJdNJGpF0NknJeKaTlPRoOklJj6aTlPRoOklJj2aTtJAe/aqkYR+IW5fQEMn7Zfna2sfwXdI7eDIeIfAkMULgyUuEwEfAy4AnexACT0IgBB4fLwQety0EHk8sA77iXIXA41yFwONchcDjXIXAR8DLgMe5CoHHuQqBx7kKgce5CoHHuYqADwvOVQg8zlUIPM5VCDzOVQh8BLwMeJyrEHicqxB4nKsQeJyrEHicqwx4h3MVAo9zFQKPcxUCj3MVAh8BLwMe5yoEHucqBB7nKgQe5yoEHucqA97jXIXA41yFwONchcDjXIXAR8DLgMe5CoHHuQqBx7kKgce5CoHHucqADzhXIfA4VyHwOFch8DhXIfAR8DLgca5C4HGuQuBxrkLgca5C4HGuMuAjzlUIPM5VCDzOVQg8zlUIfAS8DHicqxB4nKsQeJyrEHicqxB4nKsM+IRzFQKPcxUCj3MVAo9zFQIfAS8DHucqBB7nKgQe5yoEHucqBB7nKgN+xbkKgce5CoHHuQqBx7kKgY+AlwGPcxUCj3MVAo9zFQKPcxUCj3OVAZ9xrkLgLTvXknbwdYnftr7Dsewum3AsO8AmnAic13AsO6kmHMtupwnHsiNpwrHsGppwLHf2LTjFcvfdhEOH/AYOHfIbOHTIb+BE4LyGQ4f8Bg4d8hs4dMhv4NAhv4FDh/waTqVDfgOHDvkNHDrkN3DokN/AicB5DYcO+Q0cOuQ3cOiQ38ChQ34Dhw75JZy40CG/gUOH/AYOHfIbOHTIb+BE4LyGQ4f8Bg4d8hs4dMhv4NAhv4FDh/wajqNDfgOHDvkNHDrkN3DokN/AicB5DYcO+Q0cOuQ3cOiQ38ChQ34Dhw75NRxPh/wGDh3yGzh0yG/g0CG/gROB8xoOHfIbOHTIb+DQIb+BQ4f8Bg4d8ms4pr8H34RDh/wGDh3yGzh0yG/gROC8hkOH/AYOHfIbOHTIb+DQIb+BQ4f8Go7p70434dAhv4FDh/wGDh3yGzgROK/h0CG/gWO5Q64u7XDW1tYul6+N/dOqp764g23LzqOE2ti2lm3ItX7f9i6Q5S59CIEsO4UhBLLsVmrehh1dXBpb+xz8plCuz1unI4luaDeNvFu/bf0neNPfMRYFb9lliYK37OBEwVt2h6LgI+BlwFt2taLgTTtmSfCmnbAkeNMOVxI8zlUGvOnvGIuCx7kKgce5CoHHuQqBj4CXAY9zFQKPcxUCj3MVAo9zFQKPc5UBb/o7xqLgca5C4HGuQuBxrkLgI+BlwONchcDjXIXA41yFwONchcDjXGXAm/4GuCh4nKsQeJyrEHicqxD4CHgZ8DhXIfA4VyHwOFch8DhXIfA4VxnwFecqBB7nKgQe5yoEHucqBD4CXgY8zlUIPM5VCDzOVQg8zlUIPM5VBHxacK5C4HGuQuBxrkLgca5C4CPgZcDjXIXA41yFwONchcDjXIXA41xlwDucqxB4nKsQeJyrEHicqxD4CHgZ8DhXIfA4VyHwOFch8DhXIfA4VxnwHucqBB7nKgQe5yoEHucqBD4CXgY8zlUIPM5VCDzOVQg8zlUIPM5VBnzAuQqBx7kKgce5CoHHuQqBj4CXAY9zFQKPcxUCj3MVAo9zFQKPc5UBH3GuQuBxrkLgca5C4HGuQuAj4GXA41yFwONchcDjXIXA41yFwONcZcAnnKsQeJyrEHicqxB4nKsQ+Ah4GfA4VyHwOFch8DhXIfA4VyHwOFcZ8CvOVQg8zlUIPM5VCDzOVQh8BLwMeJyrEHicqxB4nKsQeJyrEHicqwz4jHMVAo9zFQKPcxUCj3MVAh8BLwMe5yoEHucqBB7nKgQe5yoEHucqA77gXIXA41yFwONchcDjXIXAR8DLgMe5CoHHuQqBx7kKgce5CoHHucqArzhXIfA4VyHwOFch8DhXIfAR8DLgca5C4HGuQuBxrkLgca5C4HGuIuDXBecqBB7nKgQe5yoEHucqBD4CXgY8zlUIPM5VCDzOVQg8zlUIPM5VBrzDuQqBx7kKgce5CoHHuQqBj4CXAY9zFQKPcxUCj3MVAo9zFQKPc5UB73GuQuBxrkLgca5C4HGuQuAj4GXA41yFwONchcDjXIXA41yFwONcZcAHnKsQeJyrEHicqxB4nKsQ+Ah4GfA4VyHwOFch8DhXIfA4VyHwOFcZ8BHnKgQe5yoEHucqBB7nKgQ+Al4GPM5VCDzOVQg8zlUIPM5VCDzOVQZ8wrkKgce5CoHHuQqBx7kKgY+AlwGPcxUCj3MVAo9zFQKPcxUCj3OVAb/iXIXA41yFwONchcDjXIXAR8DLgMe5CoHHuQqBx7kKgce5CoHHucqAzzhXIfA4VyHwOFch8DhXIfAR8DLgca5C4HGuQuBxrkLgca5C4HGuMuALzlUIPM5VCDzOVQg8zlUIfAS8DHicqxB4nKsQeJyrEHicqxB4nKsM+IpzFQKPcxUCj3MVAo9zFQIfAS8DHucqBB7nKgQe5yoEHucqBB7nKgI+LzhXIfA4VyHwOFch8DhXIfAR8DLgca5C4HGuQuBxrkLgca5C4HGuMuAdzlUIPM5VCDzOVQg8zlUIfAS8DHicqxB4nKsQeJyrEHicqxB4nKsMeI9zFQKPcxUCj3MVAo9zFQIfAS8DHucqBB7nKgQe5yoEHucqBB7nKgM+4FyFwONchcDjXIXA41yFwEfAy4DHuQqBx7kKgce5CoHHuQqBx7nKgI84VyHwOFch8Iada3T71tHV9dvWdziG3WUbTgTOaziGXVobjmEn1YZj2O204Rh2JG04hl1DE04y3Nm34Rjuvttw6JDfwKFDfgMnAuc1HDrkN3DokN/AoUN+A4cO+Q0cOuTXcFY65Ddw6JDfwKFDfgOHDvkNnAic13DokN/AoUN+A4cO+Q0cOuQ3cOiQX8PJdMhv4NAhv4FDh/wGDh3yGzgROK/h0CG/gUOH/AYOHfIbOHTIb+DQIb+GU+iQ38ChQ34Dhw75DRw65DdwInBew6FDfgOHDvkNHDrkN3DokN/AoUN+DafSIb+BQ4f8Bg4d8hs4dMhv4ETgvIZDh/wGDh3yGzh0yG/g0CG/gUOH/BJOsfyt+TYcOuQ3cOiQ38Cx3CFHFzY42S0HcCJwXsOx3CE34VjukJtwLHfITTiWO+QmHMsdcguO5W9at+FY7pCbcCx3yE04dMhv4ETgvIZDh/wGDh3yGzh0yG/g0CG/gUOH/BqO5W/ntuHQIb+BQ4f8Bg4d8hs4ETiv4dAhv4FDh/wGDh3yGzh0yG/g0CG/hmP5G51tOHTIb+DQIb+BQ4f8Bk4Ezms4dMhv4NAhv4FDh/wGDh3yGzh0yK/hWP4WYBsOHfIbOHTIb+DQIb+BE4HzGg4d8hs4dMhv4NAhv4FDh/wGDh3yazimv6nXhEOH/AYOHfIbOHTIb+BE4LyCU/UH7Gvetk5rCc9w7hPQ3+IvD3WX9ecEujRTPmxVEUIujQmEtS7b1mV5/uVv+hpT1TemPuFa5zE5hWPyCscUFI4pKhxTUjimVeGYssIxKbyOR4XX8aTwOp4UXseTwut4UngdTwqv40nhdTwpvI4nhdfxpPA6nhRex1eF1/FV4XV8VXgdXxVex1eF1/FV4XV8VXgdXxVex1eF1/FV4XU8K7yOZ4XX8azwOp4VXsezwut4Vngdzwqv41nhdTwrvI5nhdfxovA6XhRex4vC63hReB0vCq/jReF1vCi8jheF1/Gi8DpeFF7Hq8LreBW4jpe8b10XdzAmr3BMQeGYosIxJYVjWhWOKSscU1E4pio7Juf/fkx+WQSu42V/2ytUv3wb08+ty/7OUwmPV558cQfb3rqcr21vrL9te5+rMzRXb2iuwdBco6G5JkNzXQ3NNRuaazE012pnrs5Q3+QM9U3OUN/kDPVNfZb51zLXddvW3Rr9g8lO1Ti1JjtV59Sa7FStU2uyU/VOrclO1Tw1JusFuqfq8z7ZlBuTff97vtsE3OgT8KNPIIw+gTj6BNLoE1hHn0AefQJl9AnUwScQRr8Th9FvZEH9jezt0gC3Cai/CrUmoP4qlP1jAj7/nID6q1BjAlH9Vag1AfV+oDUB9ZfR1gT0X0bjuk/gj0VzHhP4ubGP+0B8jPHnbKOp2ap3Gl1nq96WdJ2t/u6h52z1txo9Z6u/L+k426S/iek5W/0dz2/N1pfHbH9ahKS/Peo528l6qcZs41SzTWnrk31aw/uN12XZflKx3h6R/0QzV+P1O2hSzfUtmrm6tLQ/CvQpu/cbl2X7wyU+rUIZyheZuTq6nmTm6v56kpmrU+xIZp2rq+xJZq4OtCeZaJdM2h62lLx+I3Pwh13Yxuxdevzh6I82LlvvEJZvm96JT9YoDUDccP8lRNxwXydE3HC/KETccB8qQzwb7m+FiBvum4WIz5Uej0B8rgR7BOIR4hcTx3NeTRzPeTVxPOfFxAs1/kvEl+p34k/vFB8SL2UbxLc1mA7/sLsde/vLt3/np1/P1fVLIk4K9RKR3KiXiKhHu0SVbEi9RIRJ6iUifVIvEXGVeokiEmmXiEBMvUSkC+olIl1QLxHpgnqJSBeUS+QW0gX1EpEuqJeIdEG9RKQL6iWKSKRdItIF9RKRLqiXiHRBvUSkC+olIl3QLpEjXVAvEemCeolIF9RLRLqgXqKIRNolIl1QLxHpgnqJSBfUS0S6oF4i0gXtEun/gBoSkS6ol4h0Qb1EpAvqJYpIpF0i0gX1EpEuqJeIdEG9RKQL6iUiXdAukf6PwiIR6YJ6iUgX1EtEuqBeoohE2iUiXVAvEemCeolIF9RLRLqgXiLSBe0SRdIF9RKRLqiXiHRBvUSkC+olikikXSLSBfUSkS6ol4h0QbtEaeKzqLzfOK/btjl/g34HM3Ht/jUwE+dRfw3MACmQe4BpzPXdn/5zuusAiUrP6Q6QTvSc7gBOv+d0B3DNPacbbU13ADf369ONS6hfG8el1safDnFvAUMsT8NOyxecATpAOTgDdIFycAboBOXgTNUNdoaTp+ode8OZqtPsDWeqvrQ3nKm62N5wInBew6FDfgPHTId8n66Znvc+XTNd7H26ZvrSP6dbzHSa9+ma6R3v052rG3T7g4sYXGz86bLEr41LeKDxxR1sW8v2h2v9vu0d41x9oxjGCMYeGOfqRcUwztW1imGcqxsWwzhXly2Gca7uXQpjncsViGGcy22IYcTFdMGIi+mCMYKxB0ZcTBeMk/WNbnvUEJ0/CLRG+IJ7v+n6Eb6G3nO6k/VLrelO1te0pjtZ/9GabrQ13cnu563pTpYetqY7WcrXmq6prsqP8OXajtMd4SuwPadrq6sa4eukPadrq6sa4auZPadrq6sa4WuOPadrq6sa4SuDPadrq6sa4et3Padrq6sa4atsPadrq6sa4WthPadrq6sa4StWPadrq6sa4etKPadrq6sa4as/Padrq6sa4Ws0Padrq6sa4SspPadrq6sa4esdPadrq6sa4asSPadrq6sa4WsHPadrq6saYRX+ntO11VWNsDp8z+na6qpGWLW853RtdVXRVlcVbXVVyVZXlWx1VclWV5VsdVUp2pqura5qhK9Y9Jyura5qhC9O9Jyura5qru9ItKdrq6ua6zsS7ena6qrm+o5Ee7q2uqrJvgzRnK6trmqyrzc0p2urq5rsCwvN6drqqib7CkJzura6qsm+VNCcrq2uarKvCTSna6urmuxrAs3p2uqqJvuaQHO6trqq2b4m0Jqura5qttX5W9O11VXNttp9a7q2uqrZVo9vTddWVzXbauyt6drqqmZb3bw1XVtd1Wyrhbema6urqra6qmqrq7K1trq3tbZ6sLW2erC1tnqwtbZ6sLW2eliirema6qqCrbXVg6211YOttdXDbGurf+w7R+u2rVsW/23jPznOtmi7GEe+SdiHIx8l7MORrxL24Rjh2IWjmc+C36dr5vPd9+ma+cz2fbpmms8/pzvbEvSt6Zpp5e7TNdNx3adrpjG6Tzfamq6Zzx/fp2urq5ptCfrWdG11VbMtQd+Y7mxL0Lema6urmm0J+tZ0bXVVsy1B35qura5qtiXoW9O11VXNtgR9a7q2uqrZlqBvTddWVzXbEvSt6drqqmZbgr41XVtd1WxL0Lema6urmm0J+tZ0bXVVsy1B35qura5qtiXoW9O11VXNtgR9a7q2uqrZlqBvTddWVzXbEvSt6drqqmZbgr41XVtd1WxL0Lema6urmm0J+tZ0bXVVsy1B35qura5qtiXoW9O11VXNtgR9a7q2uqrZlqBvTddWVzXbEvSt6drqqmZbgr41XVtd1WxL0Lema6urmm0J+tZ0bXVVsy1B35qura5qtiXoW9O11VXNtgR9a7q2uqrZlqBvTddWVzXbEvSt6drqqmZbgr41XVtd1WxL0Lema6urmm0J+tZ0bXVVsy1B35quqa4qzrYEfWu6prqqONsS9K3pmuqq4hJtTddUVxVnW4K+NV1TXVWcbQn61nRtdVV2Voq/T9dWV2Vn3fX7dG11VXZWMb9P11ZXZWtt9WhrbfVoa231ONna6muo23TLHwd/+6d/64MLZZthrd+3/RPjZGu2i2GcqwsUwzhXd/k5jO+/ohInW7xejmOEYxeOczXachzn6uDlOM5lDeQ4zuU5yv6nY4ktjnkNXxvn/Jhh9F9k5rInHclM9j2DnmTmMhFvyNynO1ez35zuXD15c7pxpukmF9O2sVsP4qi5Pn3Qnu5UjWh7ulP1i+3pTtXWtac7Va/WnO5cnz5oT3eqrqo93am6qvZ0p+qqnqfrnT+YbrQ13Wm7quPpTttVHU932q7qeLrTdlXH052rq8ou7xuX+nO6c336oD3dubqq5nTn6qqa052rq2pON9qa7lxdVXO6c3VVzenO1VU1pztXV9Wcrq2uaq5PH7Sna6urmuvTB6mEZdu4rqXxp2Pd2Ty/3lyWg219XvzXxj77h9davzDO1a2JYYxg7IFxru6yE8Y7mrk60a5o5upau6KZq8Ptimaubrgnmrk+b9EXzVxd9m+huWX128axHKAx3JG30BjusltoImheoTHcDbfQGO6GW2gMd8MtNIa74RYaw91wA81cnyX5TTRp74bLQTc81ydM+qKx3A030FjuhhtoImheobHcDTfQWO6GG2gsd8MNNJa74QYay93wezRzfU6mLxoz3fB9umY63Pt0zXSt9+lGW9M1013ep2umY7xPd6oucF2WbSBrWN3BdKfq7NrTnapba003zfXpmfZ0p+qq2tOdqqtqT3eqrqo93WhrulN1Ve3pTtVVtadrqqtKc316pj1dW13VXJ+eaU/XVlc116dn2tO11VXN9emZ9nRtdVVzfXqmPV1bXdVcn55pT9dWVzXXJ2La07XVVc31yZX2dG11VXN9wKQ9XVtd1VyfA2lP11ZXNdfHNdrTtdVVzfUZjPZ0bXVVc33boj1dW13VXN+2aE/XVlc117ct2tO11VXN9W2L9nRtdVVzfduiPV1bXdVc37ZoT9dWVzXXty3a07XVVc31bYv2dG11VXN926I9XVtd1VzftmhP11ZXNde3LdrTtdVVzfVti/Z0bXVVc33boj1dW13VXN+2aE/XVlc117ct2tO11VXN9W2L9nRtdVVzfSuiPV1bXdVc32loT9dWVzXX9xTa07XVVc313YP2dG11VXN9n6A9XVtd1VzfEWhP11ZXNdd6/+3p2uqq5lqXvz1dW13VXOvnt6drq6uaa5379nRtdVVzrUffnq6trmqudePb07XVVc21vnt7ura6qrnWYW9P11ZXNdfa6u3p2uqq5lpbvT1dW13VXGurt6drq6uytbZ6srW2+mprbfXV1trqq6211Vdba6uvS7Q1XVNd1WprbfXV1trqq6211Vdba6uvttZWX22trb7aWlt9tbW2+mprbfXV1trqq6211Vdba6uvk62tHsu28ZqcP5juXF1VyLu6tx0bf7os8WvjEuq+rS/uYNtatj9c6/dt/8Q42ZrtYhjn6gLFMM7VXYphnKtrFcMYwdgD41xdthjGubp3MYxzuQIxjHO5DTGMuJgeGCf7RoIYRlxMF4y4mC4YcTFdMEYw9sCIi/k1jOu2rVsWf8ARG9OHIz6mD0eMTB+OOJkuHCf7MIkcx7m6x1TqxnF1LY4u1SVss0zVhX379QvOXDfhN3Du053rXtmc7lS3tJzztnHOT5358Z/2eU1fW/ucw/OfvrOZ6jbVl81cX2/ozGaqaKwzm6nyrs5spmpDOrOJsHnJZqq4qTObqbrX32VT/camPDV/O5upWt3ObEz3xQ02hvvi4JfNUAXv8w82c31/ozMbw31xk43hvrjJxnBffGOzvGVjuL8J0W1bh+iXn2wM9zdNNob7myYby/1Ng81cX8L4TTahlp2NW97/6VTzdlNLtf68cM/1jY0PglyX/Q64LgduZK6vd1xTkccgLbdZMewtaEzuL57aEZC/C/K4Ig0HmyHub0OEWMtPNqYb/wYb041/g43pxr/BxnTj/2CTnl6S2tjM9bGWzmws9/ItNpbb8xYbyx13eAwkufz+T7vb5WcjkuPTCi+hfJG03CnmffmbkGv4a95lri+/fBBkK5aY65sy11TkMUjLDevjT4e/exJ/cJFc6v4itwvLwUXScntbfNxJ1safjjuQ6L/fbA6oPyI4d8vO963DRn2u7/EMQ91ySy5H3XKzL0fdso2Qox6hLkDdstGTo27ZFf4W9bCZwvg8w52jZVPYk+NcPyDv+oPdPNmnqjrDmWvZqs5w5lqMqjMcFgl4AycC5zWcuZaD6gzHzPISZ+CYWYziDJy5VmP6XTghPuAk/wTneGv/tPX6A6Xtfronysk+aSaK0nav/hsoo9sDnOifXqbYQNru6zuCtO0BOoKMgOwD0ra36AjStg/pCNK2Z+kIEn/TCSTupg/IyT4AKAgSZ9MJJM6mE0jjzuZVEHHwt8v+W4Qcnn5z/eJv17JN8kb96VO8afkCHwEvA964c+oD/o7SuHfqidK4e3obCPf5dJvbvxwQvK8NOK4s2/qirrhnlPkQzvKAs6zPcO4TcOon4B8T+LncWO7zuTLJCYTRJxBHn0AafQKr+gnE9XGJbvxqzMf9XuFjjD9nm03NtpiabbU026i/e+g5W/2tRs/Z6u9Les5WfxPTc7Zxrtn68pjtT4sQ9bdHPWc7WS/VmO1cvVRKW5/s0/rXlsvIca7G63fQNBbAyHGuLi25sKPJjQUiy7L94RKfxvz1M7Cc5uroepKZq/vrSWauTrEnmbm6yp5kImRekJmso/kdMmkbRsnrNzIHf9iFx8PIp1WR/1jK7ufGj8Wzlm+b3olP1igNQNxw/yVDfDXc1wkRN9wvChE33IfKEO/zWYb5iS+Prz+6p3cYDomXsg2iuuYqQ7dj7693lJwf2/v69YJHniv8nFKiuRLbKSXClKmXCBenXiJsn3aJCj5RvUQYS/US4UTVS2T40cwoEkUk0i4R6YJ6iUgX1EtEuqBeItIF9RKRLmiXqJIuqJeIdEG9RKQL6iUiXVAvUUQi7RKRLqiXiHRBvUSkC+olIl1QLxHpgnKJykK6oF4i0gX1EpEuqJeIdEG9RBGJtEtEuqBeItIF9RKRLqiXiHRBvUSkC9olcqQL6iUiXVAvEemCeolIF9RLFJFIu0SkC+olIl1QLxHpgnqJSBfUS0S6oF0iT7qgXiLSBfUSkS6ol4h0Qb1EEYm0S0S6oF4i0gX1EpEuqJeIdEG9RKQL2iUa4Cvf5iUiXVAvEemCeolIF9RLFJFIu0SkC+olIl1QLxHpgnqJSBfUS0S6oF2iSLqgXiLSBfUSkS6ol4h0Qb1EEYm0S0S6oF4i0gX1EpEuqJeIdEG9RKQL2iVKpAvqJSJdUC8R6YJ6iUgX1EsUkUi7RKQL6iUiXVAvEemCeolIF9RLRLqgXaKVdEG9RKQL6iUiXVAvEemCeokiEmmXiHRBvUSkC+olIl1QLxHpgnqJSBe0S5RJF9RLRLqgXiLSBfUSkS6olygikXaJSBfUS0S6oF4i0gX1EpEuqJeIdEG7RIV0Qb1EpAvqJSJdUC8R6YJ6iSISaZeIdEG9RKQL6iUiXVAvEemCeolIF7RLVEkX1EtEuqBeItIF9RKRLqiXKCKRdolIF9RLRLqgXiLSBfUSkS6ol4h0QblEdSFdUC8R6YJ6iUgX1EtEuqBeoohE2iUiXVAvEemCeolIF9RLRLqgXiLSBe0SOdIF9RKRLqiXiHRBvUSkC+olikikXSLSBfUSkS6ol4h0Qb1EpAvqJSJd0C6RJ11QLxHpgnqJSBfUS0S6oF6iiETaJSJdUC8R6YJ6iUgX1EtEuqBeItIF7RIF0gX1EpEuqJeIdEG9RKQL6iWKSKRdItIF9RKRLqiXiHRBvUSkC+olIl3QLlEkXVAvEemCeolIF9RLRLqgXqKIRNolIl1QLxHpgnqJSBfUS0S6oF4i0gXtEiXSBfUSkS6ol4h0Qb1EpAvqJYpIpF0i0gX1EpEuqJeIdEG9RKQL6iUiXdAu0Uq6oF4i0gX1EpEuqJeIdEG9RBGJtEtEuqBeItIF9RKRLqiXiHRBvUSkC9olyqQL6iUiXVAvEemCeolIF9RLFJFIu0SkC+olIl1QLxHpgnqJSBfUS0S6oF2iQrqgXiLSBfUSkS6ol4h0Qb1EEYm0S0S6oF4i0gX1EpEuqJeIdEG9RKQL2iWqpAvqJSJdUC8R6YJ6iUgX1EsUkUi7RKQL6iUiXVAvEemCeolIF9RLRLqgW6KwLKQL6iUiXVAvEemCeolIF9RLFJFIu0SkC+olIl1QLxHpgnqJSBfUS0S6oF0iR7qgXiLSBfUSkS6ol4h0Qb1EEYm0S0S6oF4i0gX1EpEuqJeIdEG9RKQL2iXypAvqJSJdUC8R6YJ6iUgX1EsUkUi7RKQL6iUiXVAvEemCeolIF9RLRLqgXaJAuqBeItIF9RKRLqiXiHRBvUQRibRLRLqgXiLSBfUSkS6ol4h0Qb1EpAvaJYqkC+olIl1QLxHpgnqJSBfUSxSRSLtEpAvqJSJdUC8R6YJ6iUgX1EtEuqBdokS6oF4i0gX1EpEuqJeIdEG9RBGJtEtEuqBeItIF9RKRLqiXiHRBvUSkC9olWkkX1EtEuqBeItIF9RKRLqiXKCKRdolIF9RLRLqgXiLSBfUSkS6ol4h0QbtEmXRBvUSkC+olIl1QLxHpgnqJIhJpl4h0Qb1EpAvqJSJdUC8R6YJ6iUgXtEtUSBfUS0S6oF4i0gX1EpEuqJcoIpF2iUgX1EtEuqBeItIF9RKRLqiXiHRBu0SVdEG9RKQL6iUiXVAvEemCeokiEmmXiHRBvUSkC+olIl1QLxHpgnqJSBeUS+QW0gX1EpEuqJeIdEG9RKQL6iWKSKRdItIF9RKRLqiXiHRBvUSkC+olIl3QLpEjXVAvEemCeolIF9RLRLqgXqKIRNolIl1QLxHpgnqJSBfUS0S6oF4i0gXtEnnSBfUSkS6ol4h0Qb1EpAvqJYpIpF0i0gX1EpEuqJeIdEG9RKQL6iUiXdAuUSBdUC8R6YJ2ieLE1rW83ziv27Y5f4N+BxMBcwxmYpv218AMYI7cA0xjru/+9H26AxiNntMdoGnvOd0BGuCO000DNJM9pztAY9ZzugM8Qvmd6abt/uaqD40/fTuT67Z1euoAb3/6zmaABlCMTYTNSzYDtIGfYuNL3pvGUmtj6+Br2SZ5u7HuW385sDRZ2ygHcrKGVA7kZK3uB0GGte4gS34C+XPb6Hbo0bv8A/pkDfcQ0NfJ2v7fg75P0le3NLYu+xxLeEzRF3ewbS3bMGr9vu0d+mTmYwzohi2QHHTD3koOegT69dBNu0Ep6KadoxR00y5TCrppRyoF3bQjFYKecaQC0HGkAtBxpALQcaQC0CPQPwB93bZ1y+IPqGNJJajjSSWoY0olqONKJahjSwWoF8u+tD4eOC9N6i7mHWVyT3+7HI1kXbbn06t/+p1ICV/YLTtTQeyWvakgdsvuVBB7BLsEdssGVRC75a79k9jjtvGa3E/sI3yDfUjs+y9817UcYKeT+VXsye3DTiF+w35HSXfSDWUEZS+UdBHdUFrOrn/zFrUP5IYyNW5Rt8OX+BhK/fEa/ghf854TPL2wEHjLIbYgeD/C97TnBG/Y/4Ul5B18bQ3k/W/W/Ajfsh4DpGE/1xdkBOSvgXRuTTsTtz4tIuf+uB7//Otvf6jtR/ja85zgDTtFWfCGneKHwXf7Vb0f4dvMiGTYgf6uSNnvf9zVJTRE8jnvL2nlpyUlv8CP8M3lOcHjQIXA41g/BL7nixF+hG8kI5Mf4TvJyORH+FYyMvkRvpeMTH6EbyYjkx/hi68mZHr7LqYf4XuVJmR6++6mH+GblYPK1HgVzI/wLcpZ0dORiaGnyxJDzzOTj92Su77HNMKXIRHqJtQI34dEqD+E4rnMIELxHGcQofD3vyqUX9JO/vZoPjaEugWRj0+1lico5egVDJ+Xfevs/Q+ZIjKNIBNZwBAykRsIyHRHT24ghp7cQAw9SYAU+oi3F0OPWxdDj//+FHq/v9fgb/8+QI+jFkMfQS+Fnr5eCn2iw/kU+hSXDX1KR+jpcMTQ0+F0QX+HSc/SEWYEZj+YJOq/DNO7usP0z9fMMz+fT2TkQuDppIXAk49/Cny/tQgSSbp+kVYc6TmRVvezA1rxmB1h4ho7wsQ1/jLMUMoOM8bmKhmr3zO/NTxtXd0X+gj6K9DnA/Q40ivQR3+AHk/6MfT7WG6U0zf0R2NZl30s6/Pj53o4z7yHPKWExtbFb9Ms0X3b9l4CuGPzJYBPN18CpADWSyCTMZgvAZIR8yVAnmO+BEihzJdApASmL4G0vfFeUj4oAVK5+Usg7leBJ4CPEiAdtFQCazgoAXKBAUvAp7BB8Sn5n7IWvP6Qsj6W+l9dOpAV/z6lrHjyKWXFZ08pa0TWGWXFD08pKx53RlkrBmfE6KI+3pCtR7l0xeBMKSsGZ0pZMThTyhqRdUZZMThTyorBmVDWsNAy6ZDVx7QjLKkha1hL2LZeSz2QlZZpSlkjss4oKy3TlLLSMg0oawz7Fz1jKOFAVn7pOKKsdY/6Yy3lQFZ+vTi2rGlZji7CvHk4o6yOB3NTysqDuSllJWWaUlZSpilljcg6o6ykTFPKSso0paykTFPKSso0paykTDPK6kmZppSVlGlKWUmZppSVlGlKWSOyzigrKdOUspIyTSkrKdOUspIyTSkrKdOMsgZSpillJWWaUlYMjg5Z3f5RquBS88caYZc1hKPXvwMGZ3RZ68GPNQIGZ0pZMThTyorBmVHWiMGZUlYMzpSy8hh9Sll5jD6lrBFZZ5SVlGlKWUmZppSVlGlKWUmZppSVlGlGWRMp05SykjJNKSsp05SykjJNKWtE1hllJWWaUlZSpillJWWaUlZSpillJWWaUdYVg3OFrNk3ZM3rtvh+zg/a0X+pFFFpAJWwHyOohJv4lEo5b5v7soSGSjWUDWGNfxx/vzUd3sdKfdzHnjY+Grevxe2zXPz7jW9Tybs47huU8lUw+BSBgrmjx0t8Cn3xdUeflp/oM8+pPoZ+jTv6J4IP9Nyhfhl9Cvu4fcqugb7m7VtIbnFPN4bbwO/kudT/Mvl1cTv5/DzwQ/K3P7nfk/2zyX3R75Xtq6C3v11bWzu330ZczI2tS92gVHd03eOWY74EiLqsl0Dh5avpS6DWsDcDS/lWAz83Xus+y7W6hlstty7wa+PiV//DURZ6a6rrc9XFq2hU1+eqiwdGVNfnqitSXVTXx6qLB3RU1+eqi9iW6vpcdRFNU12fqy5Sb8vVda8BYm/zNVDJvakB0unpa8AtftmLIC6NVsPVdX/BpdZpXuyrkUKfvtBvgfVDTH9wtSMToggq0Y2xIqgHRUDCQhFUghCKoJKEmC+CuBCFmG8M40IWQhEsvFBHESy890YRLJEioAhIDCmChcSQIlhIDCmChbCIInCERSMWgV/2RVC8/14Ed1mJf6aUlUBnSlmJaKaUNSLrjLISo0wpK8HIkLLGtMualwNZiTqmlJXXnWaU1eNbp5Q1IuuIsu6/WvHh70Zyl5VOeERZQ9rP1m+f1thlpROeUlY64SllpROeUlaezs4oa+B565Sy4lunlJXnrVPKyvPWEWW96bZtHUtobL3G7Ysp6/p42hPWo1mWtCEppX7b9l4ukXKhXH69XEjFKJffKBfSNsrladv6+Cbb4mpj43SrjU0bV2Jj63UNyz6O4A5qkYiQWtRSi+Sa1KKWWiSMpRaV1GIkQaYWtdQisTe1qKUWyeqpRS21yAMGalFLLUZqkVpUUos8GqEWtdQiz12oRS21yHMXalFLLfLchVrUUos8d6EWldRi4rkLtailFnnuQi1qqUWeu1CLWmqR5y7U4jW1mMNeJflG5KAWI7VILSqpRZ67UItaapF8kVq8qhZL2mvxCfdeiyuZDrV4US1Gv18Xb+M/qEW8C7WopRZ5N4JavKgWS9qA5LIe1SLvRlCLp2sx7qu+p/jHoX9UF26E6vpcdfH+AtX1serKuFeq63R15T0bSWU5eJaWeceA6vpcdfHWANV1vrrWZa8u33KYLix+Vycsf+cxj4A/pL/9e3Wt7VPaGbq0Lkd3ajws1a622vdZ/lHtrdG4WNI++FjywVOVQnpItV9V7c7vfzy4dHDtLVx7qUY91UjeSDXqqUbySapRTTVW8kyq8Xw1PmuTD6qLPJPq+lx1kWdSXZ+rLt4NpLo+V12R6qK6PlZd/PaI6vpcdfGsger6XHWRj1Fdp6ur7h/+SrWkH9WVFvIuqutz1UXeRXV9rrrIu6ius9W1Lvvboatz+aC6yLuors9VV6S6qK6PVRd5F9X1ueoi76K6PlddvCtLdX2uunj3ler6XHWR1VNdH6suR99FdZ2uLhfzXl0HaxwlR99FdX2uuui7qK7PVRd9F9X1seryvCNBdX2uunhHgur6XHXxjgTVdb669q1X/3e/lv25dfFxq5LiV/8YdPkqRV6ooBSVlGKkFClFHaXIqxqUopJS5PkCpaikFHkYQSkqKUWeXFCK15SiW9P+2Zrbv5+K8ZHn8KSDalRTjYEnI1SjnmrkSQrVqKcaefJCNV5Wjdk9qrEcVSMxI9V4VTWuJe7VmJeDN5kDSSPVeFU1Zv+4U+e4HlQjYSPVqKcayRupRj3VSN5INaqpxkjeSDXqqUbyRqpRTzWSN1KNeqqRl72pxsuqsayPanwC/qjGSDVSjWqqkWcxVKOeauRZDNV4VTWWZdmrsTh3UI08i6Ea9VQjz2KoRj3VyLMYqvGyvvHpjbLifGt7/5D+9u/VtbZPqewJUkq1/qz2xLMeqt1OtfMsiWq3U+08q6La7VQ7z8KodjvVHql2qt1MtfMsj2q3U+08K6Ta7VQ7zyKp9nmqfX+6lNZlOah2nnVS7WqrfZ/lH9XeGo2L5SFQ/Pu//2e1r2QyVPs01Z7Ko9rzwTt+a6TaqXYz1U4mQ7XbqXYyGardTrXzDiTVflm1p6ffzqwH1Zh5R5Fq1FONvENINeqpRt7xoxr1VCN5L9Wopxoj1Ug1qqlG8lKqUU81kmdSjXqqkXfAqMarqrHsvG//TvmgGnlHi2rUU408i6Ea1VRj4VkM1ainGnkWQzXqqUbSb6rxqmqsj1+mrHWNB9UYqUaqUU01kvBQjZdV4/q4U9d88JvTylsTVONF1Zi927/Tevt3OqhGngxSjZdVYwqPaiwHv1CuPBmkGk9Xo095r8aS/8LW91qka6QWtdQiTwWpxWtq0ZX18Yuu278P/HTlqSDVqKUa14WnglSjnmrkqSDVqKcayRqpRj3VyDNqqlFPNUaqkWpUU408h6Ea9VQjz2GoRj3VyJMYqvGqaszuIXxO7qAaeRZDNeqpRp7FUI1qqtHxLIZq1FONPIuhGvVUI89iqEY91cizGKpRTzVGqpFqVFONPIuhGvVUI3kj1XhVNZZl/2JqKe7nL7RWj6emGq+qxvp0bazh4Nro8dQ6qjHHuFdj/L71XSjs5iBCRYQaQyhMyiBC8S7VIELxmtEgQuGIlQiVHx4kuwOheDllDKEC720MIhTxyyBCkUwMIhTJxCBC4aOUCFUf7XldD4Si69MhVIlbNu9LCj+FinR9gwhF19dFqDtMOrOOMOmeOsKMwOwHk+cjHWHSe3eEyXOGX4ZZ/f4+kq81NxqpdXksR/1kTEr4As9zAyHwOEIZ8AmHJwQexyYEHncnBJ5++1Pg99ch1qffBzzA09V8Cvz6eA+6HICnq/lV8CFkvzOJyTfAu9tg9jWhXMmP3yGshw8klu2P++z907Z/yrTSAw0hEx3TEDLRXwnIdEdP1i6GPoJeCj2+Qgw9qb8Yep4RiKHHT38O/f6jZefq4t42otXlbeTVPf1YeJMJ9z2CTBn3PYRMeIshZKIj0yGT30OS6n35IRPd2xAy0ekNIROdXheZ/oRZ6Mc6wuSZRUeYPFnoCJN+viPMCMx+MMnzfxlmcg+Y6SmpfMDED3aEiWvrCBNv1REmDqgfzIoD6ggTB9QRJg6oI0wcUEeYEZj9YOKAOsLEAXWEiQP6ZZi3PnJnkt13mAd/3dft11MhuMc3rr8ecVTckhB4nJUI+Lzgwj4F/rb9Dv7bKyQ/t41uFyl6l3+IhLsbQCRc4zmR/M8OKC+4xl+HWeoTzPUAZgTmr8LMwT1gJvcXb644TCHwuFEh8DjXT4Hv2KngcgcQCUd8TqT155rlNx8AzF9vJ8sTTH8AEzf6qzDjkvdxRxdz4/Lxfmmn7HCYQuBxo0LgI+BlwONchcDjXIXA029/CvzbdRMz3w7/GPi36yZmvgX+6+BD2B9YxPB3H1v6ub3Pefvrt3+Wv7f2fNtbCjxdjRB4upoPgXd5Dfs88xp/oieRF0NPzi6Gnm5eCj3fsJZDT0f/MfT5sVrh7d/1B3o6nM+hz+WBvqw/0NPh/DL6+EAZk4/f0N9h0rN0hEkX0g8mX0nuCZNn+B1hkmB3hEkP2xFmBGY/mKTHHWHil34Z5hr3H3jEtYT/bPilt9vf4eOYBOHjsATh48g+BP8GYhu4D8vTqwkl39HzDWQ59Lg9MfR4QzH0OMkr0Dt/gD6CXgo9LlUMPZ72U+jDnif4UNM39Adbv/10bk643yFkwicPIROOWkCmP9GvOGox9DhqMfQ4ajH0OGox9BH0Uuhx1J9Cn+I2TZ+e123Z0eOoxdDjksXQ43yl0Gf6ejH0EfSfQX97Oub3v/689Y6eDkcMveUOJ8Qd/e2u19i6rtsc3bI8Ykhf3BdJyw1LX5KW+4++JC2H479F8mkV85DDkwtf6h2l6Q+md0ZpucntjNJyGN0ZpeVwuTPKCMpeKC1bo84osTrdUOJ1uqHE7HRDidvphdL0x9E7o8TtdEOJ2+mGErfTDWUEZS+UuJ1uKHE73VDidrqhxO10Q4nb6YSymP4IeWeUuJ1uKHE7v4gyLm5bHDe6GA9Q4na6oYyg7IUSt/OrKF2uO8q6fEN58LfffiO6mP44tyB2XJQIdhzXZ7B3+9R2Mf2p7TEkMv0B79+TyIe96/G5NCSKpW5/O9anxR2Ot055+9OpPuErXxphPfVrhKfVrxFmWb9GEY3Ua4S9/4xGNT00WuvPXMX0N8xFwWPxPwS+7heaxR8kiQ6T/ynwfgcfywF4rPunwO/DXtL6E7zHkAuBx2ULgcc6/yr4sK8YGsPfofy9re/g8cNC4CPgZcDjXD8C3sW8r9eQ3PNqLEfjXpfticTqn/5yCV8i4XIHEAlHPIBIuOcBRMJp6xcp4MoHEAk/o0GkuG28JncgEt2dBpHW7U+vazkQie7uMyIlt08yhfhNpDt4OjYh8HRhMuAjnZUQeJ53fOhGvA/7Bj41bsS3wZb4GHj98YJu5OnIEDLhPYaQKSLTCDLxnGYImUx7+bJtHaJP37a+w7HsKMr+QmWoS/wJJxnuaqLbt46urgdwDF/9bheo/d2i7JYDOIavOW04hnO7NhzD2VrMj1f2yrI0ti77HG+52L7tHx/f+Llt3W+DtX7f9g7d8F1QDLrl71fLQTecp8lBt9xHikE3nHXJQY9Avx66ZScmBt2ywxODbtk5ikHHkQpAx5FeDz3jSAWg40gFoONIPwH9/feAS8aSSlCPUBegjimVoI4rlaCOLZWgbtkitd7OKJatTBOOZcvRhGPZGvh9ktHHcgDHcgffhBOB8xqO5X64Ccdy29qEY7m7bMKx/HAipG3YMS6+sfW67ssSlEeb7t3XolOWv97eFaTlb7f3BWm5S3/zmvCBU95XTXeuPv3puJG03NL3JRn5ucw/vvq5jOnPhzfhWP4VWhOO5ZVc6r4Ewm2Ora1d3u6ZfnlsexygdnxebPrD4UMIZPl3nAMIVE1/5FyHQO+fJ1XT304fQyHLq8yMoZDlBWbGUCiikHKFLNvoMRSy7OXrvoJrdLGVp/kctoV/fP72xeh0qFHasrobyvht6zt40zmBJHjT/l8SvGlf/0Hwbl8AvHi3/gRv+pPzouBN23BJ8KbdtSR406ZZEnwEvAx40xZXEjzOVQg8zlUIPM5VCDzOVQa86W+zi4LHuQqBx7kKgce5CoGPgJcBj3MVAo9zFQKPcxUCj3MVAo9zlQFv+vvlouBxrp8Bv+6TLLn4A/A4VyHwOFch8BHwHwF/g7aBr3+81foDPM5VCDzOVQg8zlUIPM5VCDzOVQZ8xLkKgce5CoHHuQqBx7kKgY+AlwGPcxUCj3P9CPi6+OVr67qEdAAe5yoEHucqBB7nKgM+4VyFwONchcDjXIXA41yFwEfAy4DHuX4IfK4beLfUA/A4VyHwOFch8DhXIfA4VxnwK85VCDzOVQg8zlUIPM5VCHwEvAx4nOsvgg+PD+oGX9YGeJcfI8lrfB72nTvGVYY7vlWGO7ZVhjuuVYR7xrTKcMezynDHsspwx7F+hnut29Z+WRrDXpdlez64Lu5ApIhI4iKlulvhY5Fwwh8Saf8orF+Cfz/suMOO/ulH5aEcXhqre1wbq38M29f1S1Nc9nya4uDn05R0YD5NSR6m07SQasynKYnJfJqSxsynKUnPfJpGNJ1OU3Kk+TQlR5pPU3Kk+TQlR5pPU3Kk6TSt5EjzaUqONJ+m5EjzaUqONJ+mEU2n05QcaT5NyZHm05QcaT5NyZHm05QcaTJN47KQI82nKTnSfJqSI82nKTnSfJpGNJ1OU3Kk+TQlR5pPU3Kk+TQlR5pPU3Kk6TR15EjzaUqONJ+m5EjzaUqONJ+mEU2n05QcaT5NyZHm05QcaT5NyZHm05QcaTpNPTnSfJqSI82nKTnSfJqSI82naUTT6TQlR5pPU3Kk+TQlR5pPU3Kk+TQlR5pO00CONJ+m5EjzaUqONJ+m5EjzaRrRdDpNyZEUaBq2Dx/GXL5peteIXEi/RuQ8H9HIu32S3j2N5P69yRt3shgZ7uQlItwjmYYMd3KHD3EPYedea8feN9SyTTE6t28dtjt2JHWYTVEyh9kUjSg6maLkDbMpSjoxm6JkGbMpSkoym6LkLwoUfZ8JJ7Ia/RpZTgFC2alHn75tfYdj2VA34UTgvIZj2ebF8ICT18bWLm83er88/rIv7mDbsvMooTa2rbtCtX7f9i6QZdc2hECWTdgQAln2VDoEWrdt3bL4A4Use6QhFFotO6QxFLL83HsMhSw72DEUsmyjx1AootCRQnc4ePk3cPDRb+CY9rBlm2Qo0bUufL7sV6gQ4tPWh0humdsOPq7ftr6DN+1NJcGbtpyC4LNpJ/lB8Gn/BVlIZTkAb9ogSoI37fskwZu2c5LgI+BlwJt2gJLgTbtLSfA4VyHwOFch8DhXGfAF5yoEHucqBB7nKgQe5yoEPgJeBjzOVQg8zlUIPM5VCDzOVQg8zlUGfMW5CoHHuQqBx7l+BnwN+2/jl1oOwONchcBHwMuAx7l+BHz0D/A++QPwOFch8DhXIfA4VyHwOFcR8G7BuQqBx7kKgce5CoHHuQqBj4D/DPhcN/Dh78D/3tZ3mfC5Q8iEKx5CJjy0Aplc3Be/dMk9jbsczXJdtkUPVv/0y8YSviTFnU8nKb5/NkkdicJ0kpJVTCcpKch0kuIfx5M0bhuvyR1ISsc7nqSr3yRdy4GkdLwaJE1uR5Ke/3a5f+XSebrYIWSiMx1CJrrNIWTiCZ2KdmOf5E2m1Gg3blN7DKX6mvft1y9RI6LOJypeb0JRebI4oag8h5xQVHKZXxU1PMCvS2jJ9GbrO3jSExnwgTxECDwJx0fAe79sn0P1MRy8QBTILITAk0IIgY+AlwGPmxcCj+MWAo8rFgKPcxUCj3OVAR9xrkLgca5C4HGuQuBxrkLgI+BlwONchcDjXIXA41yFwONchcDjXGXAJ5zrZ8Anv23t09HaAQnn+hnwMdQd/Lo0ti47vxIe+HxxB9vWsk2x1u/b3gXFEU8mKE57MkEjgs4lKMnAZIKSOEwmKEnGZIKSkEwmKMnLXIKuJDqTCUpSNJmgJEWTCUpSNJmgEUHnEpSkaDRB1/3X0cviDxQlKppNUbKi2RQlLJpNUdKiyRTNxEWzKYob/Yyiac27orW9EGJdwvbHU31a0vdrfZ9spt25T9dML3Cf7lw3yhr2Wq4xNv60z+s2EJ9zeP7Tf7Ipc91y+rKZK+zvy2au3Lwvm7lu+n3ZRNi8ZDNXMNqXzVwRY182c3Wvv8mmbp/fuJmu+JPNXK1uXzam++L3bKrhvjj4pT6GnX+yMdwXN9kY7oubbAz3xU020TSb5S0bw/3NLRXd/nSIfvnJxnB/02RjuL9psLmdcbB5ycZyfxNq2dm45f2fTnX/JkOqNf8EabkZ+h2Q67LfAdflpxvxi+XO6WRFHoOMli97+1PwEJ++Pnvu1DacVZ4FeVyRhoPNEPO6g6zlJxvTjX+DjenGv8HGdOP/no0z3fg/2KSn17V2NpYb/xYby718i43l9rzFJlq2Ln5/AzK53PjTa9k8oMvx6ZXGUL5IWu4Uc9kjm1zDX/MuznJb+TsgW7GEs9yDnqzIY5CWG9bHnw5/9yT+4E8vdf/TLiw/L5Lecntb/D7sUht/Ou5AbtC+cTwYxiOCc7fsfN867NQtN85y1C235HLULTf7ctQj1AWoW0755ahbNnpy1C27wt+iHjZTGHM56MAtm8KOHAM/Br9zVP3TYR9YEXAImVjnbwiZWC9Bh0whPmR6+mTO+mJr/7T1+kPUiKjzicoqfhOKykJ+w4n6x29Adhf89JB5k5SV/KaTlKX8ppOUtfxmkzSS30wnKVnPdJKSC00nKRnSdJJGJJ1NUvKj6SQlPZpOUtKj6SQlPVIi6aso/uBvl7D/yMo9afPib9d9ljf9n2aZlq8SIG2yXgKJdGqqEriLSj41oagkVMpFvcuEn/1VmXzZm9kQYgN89PtPJ2NITZlifjTKT6+XuXL4+9a4bbw+LePjSviSFD87nqR547eWdCApfnY6SfGz00mKP51N0hW/OaCkbpd0PZAUtzmdpHjN6STlbYjxJF23qGFdy4GkEUlnk5T0aDpJSY+mk5T0aDpJSY+mk5T0aDZJM+nRdJJa9qUh7pKGvDa2jmHxD5Get65/XaT3T0BzRCQFIr2P1rNl7ziMSJbd4DAiWfZ3w4hk2bEpEuntU4ds2YONIlKx7KqGEcnyU3Y9Ir03s8Xyc/NhRCJxGECkiEj6RSJxGEAkEocBRCJxGEAkEgf9IlXLPmkJu0hLbQ3ExTVuT/1u/y5Pf90tB9v7VLb1JG7/fIJS8hd6y+5HGL1lTyOMPoJeCr1l/yGM3rKrEEZv2St8Fn3el9fyOS4H6C07AGH0lp8kiqIPi+Xng8LocbNi6CPoP4R+rdvAb/8MB+jpcD6FvpRtc1+XdICeDudD6G+R6OOv+3qAng5HCr2jwxFDT4fzMfTZ73+9fL/N/t7Wd6FI9wcRimcBKoRaS9p/VFWe1l5ev2SKyDSCTDxjGEImnkfokKnuUNbq8w+ZcPZDyEQKMIRMJAYjyORJF4aQiSRiCJnIIYaQiRRCiUyPpV1q+ilTRKYRZCKFGEImUoghZCKFGEImUoghZCKFEJDpT/QBL/Qh9M131AL+Rgx9BL0UenzIp9B/ex85HqDHW4ihxy+IoccDiKGnr/8Yev9AH1r262awth+EhuDi39uvyNPFIWTi6eIQMuGodcgU1rrLVJ4zp9/Z9i4pTn06SSOSziYpycJwkka330ujdz8lJbGYTlKSkOkkJWERkPSOnoTlY+jXvKPP5Sf6RGryMfRlf4aU68EvvhNJyBVVf4iedEMMPSmEGHp8yKfQl7RN8/bPI/T4BTH09PVi6OnrpdCv9PUfQx/9e/R0OB9D31i1b42gl0LPcwsx9PT1YuhpLqXQZ+KzX0YfwrKjv0FpoHc5p7Btf/v3A8vXo5JMfCaGnuZSDH0E/cfQ5/JA//TZ7w09zaUYeppLMfSExmLo6evF0BMaS6EvhMZi6HGzYuhxs2Lo6et/Gf2S93FHF3MD/fpYqia5p/AsfIGnq/8U+H3rtaQD8PT0QuDp6IXA08/LgK908x8D73bw6wF4enkh8HTyQuB5KvUp8Ov2stm6lgPwEfAy4HGuQuBxrkLgca5C4HGuQuBxriLg44JzFQKPcxUCHwH/i+BD2BeDdyEm3wDvXCn7MytXl+cvpv7curq8jby6H4szxYWufwiZ8Ag6ZPJug1K9/ykTjmIImfAfQ8iEWxlBJoe3USJTcLtMof6QCSc0hEw88RtCJp4PDiFTRKYRZCKFGEImUgglMi3+0ZCXHzKRQgwhEynEEDKRQowgkyeFGEImUoghZCKFGEImUoghZIrINIJMpBBDyIRv+lWZfPX7CoW+1uYrXW9/Yh09TuhT4N/+7jEGvI0QeNyKEHj8hxB4HMXHwL/7wWkMEfAy4On6hcDzNPFT4N//NCPwfFAIPM5VCDzOVQZ8xLkKgce5CoHHuQqBx7kKgaeP/2Xw6+J28Pl54Ifgb3/S7VDW1Nja5/r4KP3frWR7F4q+X4dQxW8Pw3wJ5UAofMIgQuErxhAq4UOUCLUD98XlA6HwLYMIhc8ZRCh80SBCRYQaQyieGA4iFMnEIEKRTAwiFMnEIEKRTIwh1EoyoUSo/RcNt38eREgrycQgQpFMDCIUycQgQkWE0iHUPvKbUPVAKJKJQYQimRhEKJIJJULFsguVwoFQJBODCEUyMYZQmWRiEKFIJgYRimRiEKFIJgYRKiLUGELho3QIte4LMd3+dm1tHUPYto4lNLZe4+N3Io8nXWE9mmUtW7245WkYxxuvPm0AV19af/qPtab2n7eU8sdQn7a/VyNmkWq8rBrjQ/jna+OjGnHEVKOaaizYfqpRTzWSbVCNItW4+oNqJMChGq+rxvioxpxaf73uvNf6/KLhUQkWv//t4p8K/bbxvc7Jv6hzC3UeqXPq3ECd814YdW6hznmtjjq3UOc8TaPOLdQ5z+mocwt1zhNA6txAnVeeLVLnV9V59TvA27/Xb9vfq5GUm2q87KpbH++k1eXgnbRKdkE1XnZtdA/ha3AH1UhHSjVquTamhb6RahTpG8NRNfJOGtWopxp5J41q1FONeGqqUU81RqqRaryqGsMjV68xHlQjb2FRjXqqkbyRatRTjbzRRDXqqUbeO6Ia9VQjz2KoRjXV6HgWQzVeVo2N59TJ8SyGatRTjTyLoRr1VCPPYqhGPdUYqUaqUU018iyGatRTjTyLoRr1VCPPYqhGPdXIsxiqUU01evJGqvF0Nbp961thLq1qzD7sfzzfpnBQjeSNVKOeaiRvpBovq8Y1PKox14NqjFQj1aimGskbqUY91UjeSDXqqUbyRqrxqmoMy65OvhXKQTWSN1KNeqqRd7+pRjXVGHj3m2q8rBrjUzWmdFCNPIuhGvVUI89iqEY91cizGKpRTzVGqpFqVFONPIuhGvVUI89iqEY91cizGKrxsmoMz9W4HlQjz2KoRj3VyLMYqlFNNUaexVCNl1XjPsc//n3wDk/kWQzVqKcaeRZDNeqpRp7FUI16qjFSjVSjmmrkWQzVqKcaeRZDNeqpRp7FUI2XVWN+qsa6HFQjz2KoRj3VyLMYqlFNNSaexVCNV1VjdPsXOnL0B+vwJJ7FUI16qpFnMVSjnmrkWQzVqKcaI9VINaqpRp7FUI16qpFnMVSjnmrkWQzVeFk1Ls/VePAN1sSzGKpRTzXyLIZqVFONK89iqMarqtGXx9q2MaTW9jG4fft4uMLeyrMbqldt9Yb0qN7kmtuXtA8+llwOqp1nQ1S72mpP8VHt60EmsPIsieod4lp9WL2R6qV6h61enlVRveNWL8+2qN5xq5dnYVSv2urN66N6q++QUfCsjWpXW+31ca2+PRk5qF6ezVG9I1yrD6s38yyP6h23enmWR/WOW708m6N6x61ens1RvVqrN7r8qN4Q/npGkSPVTrVrrfbwdK2OB98cyTzLo3qHuFYfVi/P8qjecauXZ3lU77jVy7M5qnfc6uXZHNWroXr/rMbCszaqUU818uyMatRTjTwLoxovq8b0qEZfloNq5NkW1ainGiPVSDWqqUaeJVGNeqqRZ0NUo55q5FkP1ainGnl2QzXqqUaexVCNaqqx8iyGatRTjeSNVONF1bjWdS+qteZ6UI2RaqQaL7o2Lg/hb/9eD6qRvJFq1FON5I1Uo55qJG+kGi/rG+vyVI0HK6tX8kaqUU81kjdSjVqqcV3IG6lGPdXIu99Uo55q5N1vqlFPNfIshmrUU42RaqQa1VQjz2KoRj3VSN5INZ6txnSrjU0bV2Jj6xzX7W/f/lkPapG0kVpUUouOrJFa1FKLJI3U4kW1uLpN97z6fFCL5IzUopZaJGWkFrXUYqQWqUUltUjCSC1qqUXyRWrxolpMZauSnOpB1u3x0dTiRbWY6zboXII7qEV8NLWopRbx0dSillqM1CK1qKQW8dHUopZa5DfT1OJFtViS22txDQe1yC+mqUUttUi+SC1qqUXeX6QWldRi4P1FalFLLfLchVrUUos8d6EWtdQiz12oRS21GKlFalFJLZIvUosX1eLz+4tHz10C+SK1qKUWyRepRSW1GMkXqUUttUi+SC1eVYvr/p7OmstBLfKeDrV4US3mnV/OLh7UIj6aWtRSi/hoalFLLeKjqcWr+sWaH7WYftZiwkdTi1pqER9NLWqpxUgtUosX9Yv7p6Vv/zzoFxO/A6QWr6rFp98ButDY2sWS9qHEcpRHJvJIavei2i1u3Wv36DlNIo+kFgWuo4e1SB5JLWqpRfJIalFJLa7kkdSillokj6QWtdQivxukFrXUInnkiLXo44bQ+7x82/ouK1HdiLIGv/1tH2I4kJXUa0pZCZCmlJUsZsh7a3nI+ncj+VPWTKwxpawkBFPKitmeUlbWu5lS1oisM8pKyjSlrKRMU8pKyjSjrAXf+suyLukh623GTfRL2eN4/xTHl/ULPd5SDD3+Tww9Hu1j6OP+LNqn8A39wVh83YQK4elHzJtMEZlGkAkPpUOmsNZdppKfZPqdbe+S4p+mkxTvNJ2kPJ0fTtLo9ntp9O6npDyZn03SSroxnaSkJp+SNDzeHw15aUia8qZ/qk8Ay5dKBCwjqEQWM4JKEZUGUIkkZgSVCFc+pVJ8PGmMz3/9UKVbZ75tfevo8rNOPzcuPm68i1/9T1GJVyYUlYBlQlGJWKYTNS+ELBOKSswyoaikMhOKSogzoaj41E+Jmvz+4CL59E3UO3p61I+hj/uryyn9fDcwO+5PH0O/b+7TWg7QcxcRQx9BL4We0F7gWn/mzkA/NIhQZPEqhFpL2hCuJT/WeNtkIl0fQia8yAgyeRJwHTLVHcpaff4hE5n2EDKRAgwhE4nBEDJFZBpBJpKIIWQihxhCJlIIJTLtjznXmn7KRAoxhEykECPIFEghhpCJFGIImUghhpCJFEJApjt6vNCvonc347j9cVeX0EDvYt6guOSef1x/NPL1cYIk97Rt+JIJL6RDprw71pIOZMILDSETXmgEmSJeaAiZ8EJKZNp/ulDWA5nwQkPIhBcaQqaITCpkWh9f4y0HMvFEdgiZSCGGkIkUYgiZSCGGkIkUYgSZEinEEDKRQgwhU7Qrk6+PBZQXt7Rk6vn8KBn2QR/F/j4aTYZ9jSR2wz5FErth3yGJ3bCP+Cz2twnwatgXSGI33OdLYjf89PCj2N/bpdXw00BJ7BHsEthxqSLYcaki2HGpIthxqSLYcakS2PMx9rx/3/0p/vfFHRyg7MhLqI1ta9mo1Pp92z8HUxZNg3GaBuM1DSZoGkzUNJikaTCrpsFkTYMpmgaj6QpcNV2B67VX4HW/qy6LPxiNVzWaoGo0UdVokqrRrKpGc3y1ibXuLWXy73vbsmxnbYlPLXa4f9WivPhSVM8juI8fwX/8COHjR4gfP0L660dImwMref12hAOXtNTNyni3PLaO/ugPl+0DINX51h++GcvtD8fl8QQ17BNdrUw0W5losTLR9vU+f5von3u55dRe7tRe6dPXKbd+/Aj540coHz/CxzsD//HOwDsjp7X3ViYarEw0WploOnOX8OupvfKZvY4X0wm+bpYtBPdYWGn92qmc2ame2Ol42YsQHs8QQnleQutvv7Ht/QDu0wfwnz5A+KsHiG7XIHr38wDx0wdIHz5AOtTA57w9brv9s/zYKZzZKZ7Z6cVV4ncefd22+No4PT8L/Hr0VV68fN/1EPnzhyifP0Tteoi4/DzEi5dlux7Cff4Q/vOHCH/9EOuyXRhWvx4cIn7+EOnzh1g/f4j8+UOUzx+ifvwQefn8IdznD+E/f4jPn93582d3/vzZnT9/dufPn93582d3/vzZXXqcF29/nlpKj4p6+yJUefG2RHL7K2IpxG+HuO+Wz+1Wzu1WT+324ql+3F9ou+2WGvhc9WWnXX39YShePK3vfBB/xUHCFQeJVxwkf/zUrD2uYW9/wFhq/fQh6rJ8/hDu84fwnz9E+Pwh4ucP0eN+8vYHcXVZP3+I/PlDlE/feOtSP34It3z+EO7zh/CfP0T4/CHi5w+RPn+I9eOHOH5amtKWmqby3OktXzu5Mzv5Mzsdl8qS91n98e/6dx1JffGYa8l1b2GX2wP7H7ulc7ut53bL53Y7vlguJYTHbk8f2dh2q6d2e/ElqOZu7txuL3Srj8+NLHV1P3Z7QbKW7bMjzi3LD5IvvpPQ3K2e2u3FAuWtub1YMLu524sTp9bwNMj0Y7d4brd0brf13G753G7l3G711G4vFuy7bVofu/nnKvnb79fUi+XmOh/EX3GQ8NcP8v5ZZH2x6FvXQ6TPH2L93UPcd8vndivndjt3iXzxfK65mzu3mz+3Wzi3Wzy3Wzq323put3M30vXcjfTFo46c9gtrzs8/Uz1qb31e9jeMsvc/DhE+f4j4+UOkzx9i/fwh8ucPUT5/iPrxQ7z6gXLPQ7jPH+LzZ3f5/NldPn92l8+f3eXzZ3f5/NldPn92l8+f3fXzZ3f9/Nldf/vsvu8Wzu0Wz+2Wzu22ntstn9utnNutntgtLctybjd3bjd/brdwbrd4brd0brf13G753G7l3G7nqsSdqxJ3rkrcuSpx56rEnasSd65K3LkqceeqxJ2rEneuSvy5KvHnqsSfqxJ/rkr8uSrx56rEn6sSf65K/Lkq8eeqJJyrknCuSsK5KgnnqiScq5JwrkrCuSoJ56oknKuScK5K4rkqieeqJJ6rkniuSuK5KonnqiSeq5J4rkriuSqJ56oknauSdK5K0rkqSeeqJJ2rknSuStK5KknnqiSdq5J0rkrWc1WynquS9VyVrOeqZD1XJeu5KlnPVcl6rkrWc1WynquSfK5K8rkqyeeqJJ+rknyuSvK5KsnnqiSfq5J8rkryuSop56qknKuScq5KyrkqKeeqpJyrknKuSsq5KinnqqScq5J6rkrquSqp56qknquSeq5K6rkqqeeqpJ6rknquSs5lr+5c9urOZa/uXPbqzmWvt///3G7p3G7rud3yud3Kud3OVcm57NWdy17duezVncte3bns1Z3LXt257NWdy17duezVncte3bns1Z3LXt257NWdy17duezVncte3bns1Z3LXt257NWdy17duezVncte3bns1Z3LXt257NWdy17duezVncte3bns1Z3LXt257NWdy17duezVncte3bns1Z3LXt257NWdy17duezVncte3bns1Z3LXt257NWdy17duezVncte3bns1Z3LXt257NWdy17duezVncte3bns1Z3LXt257NWdy17duezVncte3bns1Z3LXt257NWdy17duezVncte3bns1Z3LXt257NWdy17duezVvche6/6GoavR/dztVfa6L+nnavXfdjtayrfTh0Juw3G6huN1DSfoGk7UNZykazirruFkXcMpuoZTVQ2n6roqV11X5arrqlx1XZWrrqty1XVVrrquylXXVblefVV++42r23iqqvH4ZVE2HqdsPF7ZeIKy8Rxem/3N9nzt5r1LjfHc0ofHh5TX/PerF9wOkq44yHrFQXKXg4T1cZA1PB3k4Bd5JWwLA4Xled2n5Xg51WVfc20JT1+0Xr7GX5SPP+381xTCz/HXscd//Jh/oPG7wcfvBx9/GHz8cfDxp8HHvw4+fu3339b4B7//usHvv37w+68f/P7rB7//+sHvv37w+68f/P7rB7//+sHvv37w+68f/P4bBr//hsHvv2Hw+28Y/P4bBr//hsHvv2Hw+28Y/P4bBr//hsHvv3Hw+28c/P4bB7//xsHvv3Hw+28c/P4bB7//xsHvv3Hw+28c/P6bBr//psHvv2nw+28a/P6bBr//psHvv2nw+28a/P6bBr//psHvv+vg99918PvvOvj9dx38/rsOfv9dB7//roPff9fB77/r4PffdfD7bx78/psHv//mwe+/efD7bx78/psHv//mwe+/efD7bx78/psHv/+Wwe+/ZfD7bxn8/lsGv/+Wwe+/ZfD7bxn8/lsGv/+Wwe+/ZfD7bx38/lsHv//Wwe+/dfD7bx38/lsHv//Wwe+/dfD7bx38/lvHvv+GZez7b1jGvv+GZez7b1jGvv+GZez7b1jGvv+GZez7b1C//lVr/GPff8Pg61+Fwde/CoOvfxUGX/8qDL7+VRh8/asw+PpXYfD1r8Lg61+Fwde/CoOvfxUGX/8qDL7+VRh8/asw+PpXYfD1r8Lg61+Fwde/CoOvfxUGX/8qDL7+VRh8/asw+PpXYfD1r8Lg61+Fwde/CoOvfxUGX/8qDL7+VRh8/asw+PpXYfD1r8Lg61+Fwde/CoOvfxUGX/8q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xRlfrjjjyxVnfLnijK9XnPH1ijO+XnHG1yvO+HrFGV+vOOPrFWd8veKMr1ec8fWCM74syxUHcVccxF9xkHDFQeIVB0lXHGS94iD5ioOUKw5yxRnvrjjj3RVnvLvijL/i1avirjjj3RVnvLvijHdXnPHuijP+infuyhXv3JUr3rkrV7xzV654565c8c5dueKdu3LFO3flinfuyhXv3JUr3rkrV7xzV654565c8c5dueKdu3LFO3flinfuyhXv3JUr3rkrV7xzV654565c8c5dueKdu3LFO3flinfuyhXv3JUr3rkrV7xzV654565c8c5dueKdu3LFO3flinfuyhXv3JUr3rkrV7xzV654565c8c5dueKdu3LFO3flinfuyhXv3JUr3rkrV7xzV654565c8c5dueKdu3LFO3flinfuyhXv3JUr3rkrV7xzV654565c8c5dueKdu3LFO3flinfuSo937sJS96WyvWttnbcB5ccP6GP4Gk1WNZqiajRV02h6vBfYcTRO1Wi8qtEEVaOJqkaTVI1G1bW4qLoWF1XX4qLqWlxVXYurqmtxVXUtrqquxVXVtbhquhbX45f8XAjbIk0uPH3kpRyt/xTDY3nRp6HE8nWE+PEjpI8fYf34EfLHj1A+foT6l4+QHmfBenCE4/f5uh7B/fUj5GU/k+vBEfzHj/DXz+lUN6XXJRwcIX78CKnnEZ4+UPM4wvrxI+SPH+Gvn9NrdtsRynJwhPrpI/i/fk6vZVuhe63x4Aju40f46+d03j/Dll05OEL4+BFizyP49eAI6eNHWD9+hL9+Tj/Wky/LUS2Vjx/hr5/TZadUjmopLB8/wl8/p0vYFqQu0R8cwX/8CKHnEdLBtTXEjx8hffwIf/2cvt2Jv7atR+d0yB8/wl8/p28Vvx0hHnQCoX76CPGvn9N1773rekApuo8fwfc8Qj64tsbw8SPEjx/hr5/TbkmbRXHLenBWx/WCYxyf19Fvd0cX8/r+GMGV7RjBPX38xa/xMJZZtz8dlidnFv54Ivlz67xszX3IT2fcH1vfx18GH38de/zHbx0ONH43+Pj94OMPg48/Dj7+NPj418HHP/j9Nw1+/02D33/Xwe+/6+D333Xw++86+P13Hfz+uw5+/10Hv/+ug99/18Hvv+vg9988+P03D37/zYPff/Pg9988+P03D37/zdfff/3+K5I/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",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "redeem_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "ownership_key",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7L3dkuywcqX3LrrWBX4Sf/MqDodjbI0dilBIjpnx1YTe3bV3NVns02SBxU4CSOTShc4+J8hm4stFIleSBfyvf/qX//Z//n//z//xr//+f//H//in//K//a9/+rf/+L/+6//81//498d/+1//lNLf/+1//L//9d///Nf/8T//63//n//0X1yg9M//9N/+/V8e/4zW/ec//9P//a//9t/+6b+U/J///PNgR2Y52MXXwbHsHOxNCV8Hexvz+4NtKHY5+vFv9zrcZbd3fAx5OTym9Dq67P51H/1yNFnz7ej//Z//KWWQOSBTQGafTDYgc0DGgswBGQcyB2Q8yByQIZA5IBNA5oBMBJkDMqiBj8igBj4igxr4gExBDXxEBjXwERnUwEdkUAMfkSGQOSCDGviIDGrgIzKogY/IoAY+IoMa+ICMNSiCD9GgCj5EgzL4EA3q4EM0BDRHaFAJH6JBKXyIBrXwIRoUw4doUA0fobGohg/RoBo+RINq+BANquFDNAQ0R2hQDR+iQTV8iAbV8CEaVMOHaFANH6FxqIYP0aAaPkSDavgQDarhQzQENEdoUA0fokE1fIgG1fAhGlTDh2hQDR+h8aiGD9GgGj5Eg2r4EA2q4UM0BDRHaFANH6JBNXyIBtXwIRpUw4doUA0foSFUw4doUA0fokE1fIgG1fAhGgKaIzSohg/RoBo+RINq+BANquFDNKiGj9AEVMOHaFANH6JBNXyIBtXwIRoCmiM0qIYP0aAaPkSDavgQDarhQzSoho/QRFTDh2hQDR+iQTV8iAbV8CEaGhtNcC80MVbQOOviEsmjtftbNINXwz3R7FfDlO0LjX+Phqylr4Pp0f95jdY9r5Buv8JubWa9o/Vu9D6b99d4HG7Xo8MrCSXsHFxKWaRjjbG0jWgvYxQ2KcvhxwCK8AEksz+AbNar+K2yHwP4e9puDWBNTutz0ZT4Gnewe+O2OZTlcJvz694MeyN/3A/L3eaTtSM/0ZMDnnd4PPC8w0PA8w5PAJ53eCLwvMOTgOcdngw87/AU4HmDZ39LLuBZ8KBqfosHVfNbPKia3+Ih4HmHB1XzWzyomt/iQdX8Fg+q5rd4UDW/w1NQNb/Fg6r5LR5UzW/xoGp+i4eA5x0eVM1v8aBqfosHVfNbPKia3+JB1fwGjzOomt/iQdX8Fg+q5rd4UDW/xUPA8w4Pqua3eFA1v8WDqvktHlTNb/Ggan6Hx6JqfosHVfNbPKia3+JB1fwWDwHPOzyomt/iQdX8Fg+q5rd4UDW/xYOq+R0eh6r5LR5UzW/xoGp+iwdV81s8BDzv8KBqfosHVfNbPKia3+JB1fwWD6rmd3g8qua3eFA1v8WDqvktHlTNb/EQ8LzDg6r5LR5UzW/xoGp+iwdV81s8qJrf4SFUzW/xoGp+iwdV81s8qJrf4iHgeYcHVfNbPKia3+JB1fwWD6rmt3hQNb/DE1A1v8WDqvktHlTNb/Ggan6Lh4DnHR5UzW/xoGp+iwdV81s8AqrmfpukuCCgau6IJzJVzWUdgi2+VPCsf5v8C84jvGdEPIVqoVfCSonvI7IllPWvl2i/bZKyl4L3e6q46CYYg+8xhuTMOoac/PsxlLA+du3mqWv9l7ZpdwTWrDfQ49/BV0ZgXjeQ3Wx2ZEPavZlXpub1kPB279ZMZd0iKJXiKre9Xx8SZDePCLOb22TXMJI3laNtSusI0zaO/aONW291E8O3o/9CD4DeHnoE9PbQE6C3h545oD9KuOVotymh9qGHUJY5KWb32m7NGrs/Da+T0mM2ex0d83MARfgADvaL+z6AFN4PIPm0pDmR/X6RnXnepGUvumKd+RmSHS8kN15IfryQaLyQwnghxfFCSuOFlMcLqQwXUh7v6Z07PL3tuslvecwelaOdT8sWto/JdnN0Cc8BOOkD8NIHQNIHEKQPIEofQJI+gCx9AEX4AIqRPgDpM3GRPhMX6TNxkT4TF+kzcZE+ExfpM3GRPhMX4TOxN8JnYm+Ez8TeCJ+JvRE+E3sjfCb2RvhM7M3wM7FzeR1Ait8GsPdqzi/Dfbyhqh194+vHh1Ncovam+kLRm/UDFL/9NO/K60dvhq9NkNJPUzp8tYaUfprS4etXpPTDlNrhK3qk9NOUDu9xkNJPUzq860NKP03p8D4YKf00pYSUzpbS4XslSOmnKUX3aLqUons0XUrRPZoupegezZZSh+7RdClF92i6lKJ7NF1K0T2aLqWElM6WUnSPpkspukfTpRTdo+lSiu7RdClF92i2lHp0j6ZLKbpH06UU3aPpUoru0S0p7bd+m/foHk2XUnSPpkvp8N0jWtc6dsGHSpKKTa/RvgLJe1FnZ5f0Z7f5Ud9+QidN//CdJqT/zvQP35VC+u9M//AdLKT/xvTT8N2uj9JvXV7LOXJ2m/+/ox2+EcQ62uF7JJ+Ntvj13i7Rv7+3H7focmtvgnap7DoGu9xRD/OQvh39l+PwjQkhHAkcWTgOb8FH4bhuzOQerYCfHOfyvf04zmUg+3Gcy4ndyDG8OG6CXjnOZWm6cQyTeYNuHCdzHTfWPRuO7idH+JmTHNPaT3CbTfhWjvAzPBwJHFk4ws98/nwsP+vHoNjP5LjuJGo2f3kf5JzfzwTFNgzp90Gxexwl/R1f5ATFphfp91GxV2dL/1+Qs5n19R23LSVUilFaoKe4mY7KrthzXIJ2OW+Czk+Ms3n1Thhns+qdMBIwcmCczah3wjibT++EcTa/2wnjbL6xE8bZ/FcfjGk2H9MJI1wMC0a4GBaMcDEsGAkYOTDCxbBghIthwQgXw4IRLoYFI1wMB8YMF8OCES6GBSNcDAtGuBgWjASMHBjhYlgwwsWwYISLYcEIF8OCES6GA2OBi2HBCBfDghEuhgUjXAwLRgJGDoxwMSwY4WJYMMLFsGCEi2HBCBfDgJEMXAwLRrgYFoxwMSwYFbuYF5mczTeMf8kQyByQUew1Snwti2ts5d4L3i2/S3+EsblT9ayLS0axo4JYPhWLYt8IsXwqFsXuGGL5VCyKewAQy4disYo7HRDLp2JR3M+BWD4Vi+KuFcTyqVgU9+Yglk/FQhALxHJWLOjgQiynxYIOLsRyWizo4EIsp8WCDi7Eclos6OBCLGfF4tDBhVhOiwUdXIjltFjQwYVYTosFHVyI5bRYCGKBWM6KBR1ciOW0WNDBhVhOiwUdXIjltFjQwYVYTosFHVyI5axYPDq4EMtpsaCDC7GcFgs6uBDLabGggwuxnBYLQSwQy1mxoIMLsZwWCzq4EMtpsaCDC7GcFgs6uBDLabGggwuxnBULoYMLsZwWCzq4EMtpsaCDC7GcFgs6uBDLabEQxAKxnBULOrgQy2mxoIMLsZwWCzq4EMtpsaCDC7GcFgs6uBDLWbEEdHAhltNiQQcXYjktFnRwIZbTYkEHF2I5LRaCWCCWs2JBBxdiOS0WdHAhltNiQQcXYjktFnRwIZbTYkEHF2I5K5aIDi7Eclos6OBCLKfFgg4uxHJaLOjgQiynxUIQC8RyVizo4EIsp8WCDi7Eclos6OBCLKfFgg4uxHJaLOjgQixnxZLQwYVYTosFHVyI5bRY0MGFWE6LBR1ciOW0WAhigVjOigUdXIjltFjQwYVYTosFHVyI5bRY0MGFWE6LBR1ciOWsWDI6uBDLabGggwuxnBYLOrgQy2mxoIMLsZwWC0EsEMtZsaCDC7GcFgs6uBDLabGggwuxnBYLOrgQy2mxoIMLsZwVS0EHF2I5LRZ0cCGW02JBBxdiOS0WdHAhltNiIYgFYjkrFnRwIZbTYkEHF2I5LRZ0cCGW02JBBxdiOS0WdHAhlpNiCQYdXIjltFjQwYVYTosFHVyI5bRY0MGFWE6LhSAWiOWsWNDBhVhOiwUdXIjltFjQwYVYTosFHVyI5bRY0MGFWM6KxaKDC7GcFgs6uBDLabGggwuxnBYLOrgQy2mxEMQCsZwVCzq4EMtpsaCDC7GcFgs6uBDLabGggwuxnBYLOrgQy1mxOHRwIZbTYkEHF2I5LRZ0cCGW02JBBxdiOS0WglgglrNiQQcXYjktFnRwIZbTYkEHF2I5LRZ0cCGW02JBBxdiOSsWjw4uxHJaLOjgQiynxYIOLsRyWizo4EIsp8VCEAvEclYs6OBCLKfFgg4uxHJaLOjgQiynxYIOLsRyWizo4EIsZ8VC6OBCLKfFgg4uxHJaLOjgQiynxYIOLsRyWiwEsUAsZ8WCDi7Eclos6OBCLKfFgg4uxHJaLOjgQiynxYIOLsRyViwBHVyI5bRY0MGFWE6LBR1ciOW0WNDBhVhOi4UgFojlrFjQwYVYTosFHVyI5bRY0MGFWE6LBR1ciOW0WNDBhVjOiiWigwuxnBYLOrgQy2mxoIMLsZwWCzq4EMtpsRDEArGcFQs6uBDLabGggwuxnBYLOrgQy2mxoIMLsZwWCzq4EMtZsSR0cCGW02JBBxdiOS0WdHAhltNiQQcXYjktFoJYIJazYkEHF2I5LRZ0cCGW02JBBxdiOS0WdHAhltNiQQcXYjkrlowOLsRyWizo4EIsp8WCDi7Eclos6OBCLKfFQhALxHJWLOjgQiynxYIOLsRyWizo4EIsp8WCDi7Eclos6OBCLGfFUtDBhVhOiwUdXIjltFjQwYVYTosFHVyI5bRYCGKBWM6KBR1ciOW0WNDBhVhOiwUdXIjltFjQwYVYTosFHVyI5aRYokEHF2I5LRZ0cCGW02JBBxdiOS2WyTq4OZoDsfwdLU01WhfWv+1ioPe3hnVuvY/cRmU+7P3p4vNydCGTXoHsRe19Xm4k78vm4LR3sHHLPeqN99uD/6ZorsbflCmaq902ZYrmanJNmaK5WksyU2TDMkT/KKZ+pGiuhs6MKbJztVGEpmgdonfWvz/YRWfXEfrKwbZ4u5bzlH8kf662CJL//WBjFi/3cKuVg8Nqih9t+O3w/upkro4IdHKXTuZqhkAnd+mEoJOZdUJrO9bE8hudoJcFnZzRCRpqM+vk5WCdzfTDxKBVpzj5aAIqTj7aizMn361hOO9ypdHlXy/1fbH/qBSHLieUck4paIlCKV84gl0OtoHcL/yJQ/8UomIXFZqtEBW7qAiigqi+RBXXd8fhu/n6VFRo40JU7KJCz1eaqEJaR1hr91c+XHHo+U6cfL4XzQ7tYejkjE7QSZ5aJ1wvmj36yNDJGZ2gizyzTt6/lvTo9ipOPrqyipNPSP7EyWd8zezREoVSzikFfU4o5QsH22s+j/4pRMUuKjRbISp2UaEzC1EtouJ6d0xo40JU7KJCz1eYqJJfR5ji71waoeerOPno+c6cfLZalgg6gU5O6ATNYejkjE7QGp5aJ2zOBN1e6OSMTtDA7a8Tl2jVSa51OhjXgiQ0WidOPt+n0gG9U+jkjE7QDoVOzugEndOpdcL1SX1AkxU6OaMTgk4m1sn7D7ADOqeKk492qOLko8c5c/IZP6gP6HJCKeeUgpYolPKFg+2lbUT/FKJiFxWarRAVu6jQmYWoFlFxfWMQ0caFqNhFRRCVMFHxrQUZ0fOdOPl8L5oj2sPQyRmdoJM8tU64XjRH9JGhkzM6QRd5Zp28fy2Z0O1VnHx0ZRUnH93TmZPP+Jo5oSUKpZxTCkEpUMoTB9trvoT+KUTFLio0WyEqdlGhMwtRLaLienec0MaFqNhFhZ6vMFExLgeY0fNVnHz0fGdOPlstm9Eehk7O6ATNYejkjE4IOplZJ1zOJKPbC52c0clkDdxY1l8xpBCE6MS4pdPhzfefXvxN0WTt0BlTNFlzccYUTdaqmzBFZbKGmsgUvb528zaVHymarO01Y4om6zjJTNFHm57xre5dJmsjIfnfDmb78Vsh6AQ6OaGTydpI0MlNOkEbaWqdcP1IsqCXBZ2c0QkaajPr5P1P6gpadWqTnwyagIqTj/bizMnn+4lkMuhyQinnlIKWKJTyhYPrM7xkCKKCqLhFhWYrRMUuKnRmIapFVExfjSaDNi5ExS4q9HyliYptde9k0POdOPlsL5qTRXsYOjmjE3SSp9YJ04vmZNFHhk7O6ARd5Jl18v61pCUkX2/y0ZVVnHx0T2dOPuNrZouWKJRyTinoc0IpXzjYXvNZ9E8hKm5ROTRbISp2UaEzC1EtouJ6d+zQxoWo2EWFnq8wUfEt8JwcIfl6k4+e78zJ56tl0R6GTs7oBM1h6OSMTtAanlonbM4E3V7o5IROPBq4/XXy2aZnbGtBJo9G68TJ5/tU2qN3Cp2c0QnaodDJGZ0QdDKzTrg+qfdoskInZ3SCJuvMOnn/AbZH51Rx8tEOVZx89DhnTj7jB/WELieUck4paIlCKV842F7aEvqnEBW7qNBshajYRUUQFUT1JSqubwwIbVyIil1U6PlKExXfWpCEnu/Eyed70UxoD0MnZ3SCTvLUOuF60RzQR4ZOzugEXeSZdfL+tWRAt1dx8tGVVZx8QvInTj7ja+aAliiUck4p6HNCKV842F7zBfRPISp2UaHZClGxiwqdWYhqERXXu+OINi5ExS4q9HyFiYpxOcCInq/i5KPnO3Py2WrZSNAJdHJCJ2gOQydndILW8NQ6YXMm6PZCJ2d0MlkDN+dlsK5sInno5O9oJ+ss5uheo/X/ONo0V8vLG7fk1psUf4x2rl5MbbTDNx9CXp9nodC30f4dwPAGujYAkj6A4S1HbQDD18JxLftdJPNzAMMXabUBDF891AYwfEHg1xrSUbA/BpCHn+Mfhclao2zmsYNZj5Y//YjjdfDeodnZJejsNj9Y9X8G8LMIdmURQvCbv0x7B1vjVwNhKG3C+It8+EJjPuTDVzvzIR++PpsPOQF5a+TD18C1+X/4Gvg+zQSzaia11MzwVft8yIf3GfMhH94ZTYe8KPZyvZBL9nJ/ByDZGf0dgGSf8XcAJH0Aw9fAtQFIroH/DkByRfl3AJLrs78DkFztPAaQjeTa4e8AhM/E2QifibMRPhNnI3wmzkb4TJyN8Jk4G+EzcTbCZ+JspM/EVvpMbKXPxFb6TGylz8RW+kxspc/EVvpMbKXPxFb6TGw5ZuLsTFg7u9tFvXdDCmlday08quH/3PaB/4TkzHgh2fFCcuOFNPyM9v49+wNBc6aPt55LSI/3FPYn0zBeSLFDSNG8QnI/Q0rjhTT8zFC7GYR/NZt9+3nk0WJeXlo+HpA/n5DejheSGy8kP15IHWaGxy2whpTMt5D23oCn9YdH1mxn571X8YHcclsG8rQ59u9gg6bBRk2DTZoGmzUNtigaLBlNg7WTDXZ1F4FK/MfBOk2D9ZoGS5oGO1sF9Xaws1VQbwcruaj4OwDJhcKfAQTJk//fAUie0P8OYLyWQRivZcCyZwxzSMJ/CJfH3zOjNgAWA+7tKgpPoRISkVmWkSLaSMhbeoaUxwupDBcSy8rizCHZ5iEFWn/C8yiTys+Q3Hgh+fFCovFCCuOFFJuHlPK6AOHjnV74GVIaL6T2T+9UvF9DSu5nSGW4kJIZLyQ7Xkiug7zT6y16Tt9CuretmrymwZKmwQZNg42TDfZd8y0lTYPNmgZbFA02G02DtZoGK7mo+DsAkj4AyZP/3wFIntD/DiANZ2zyeCY5j2eSixmuB3S4cs/aFLHW+m8h/T3NXTvNXzuNrp128KSygV6nbXafWE6L105L107L104T/u14GX+ljdoADu4cZ18DcLkygGDX4Qa/2Z2z7M0Lj3t2uZcfz4DNX94ro7xZB+v/DvDr4D8X+Rl1KOtD5fHvzc6fLu++vw72tXHKxjG7Up5sHNgcsvFgc8iGwOaQTVDMJq6/i7QxpW9sdo52tB7tYvpJMoIkE8kEkkwkM0gykSwgyUPyaAkekPyYpGavwEtSs7PgJanZh/CSJJBkIgmPw0USHoeLJDwOF0l4HC6S8DhMJB08zmmSeUXyiOUnSXgcLpLwOFx3NzwOF0kCSSaS8DhcJOFxuEjC43CRhMfhIgmPw0TSw+NwkYTH4SIJj8NFEh7nLEkfl8+zLVnzkySBJBNJeBwukhwex2azfkyebd6S/HsNzdV/onWQiXaerprr+RobzRV6hQ1prrlrbDRX0TU2muviGhvNlW6NDYHNIRvN1WiNjeYeeo5lLYvLz/ewpLkurrHRXBfX2Giuiytsgua6uMZGc11cY6O5Lq6x0VwXF7t22x7Nmp9sCGwO2Wiui2tsNNfFNTaa6+IaG811cY2N5rq4wiZqrotrbDTXxTU2c9XFwb3YxFhh415hO7tZCe3adxRxriq6J0kCSSaSc1XoPUnOVc/3JDlX9d+T5Fxe4VaS738xF+dyFh1Jprl8SE+Sc7mWniThcbhIwuNwkSSQ5KmCEjwOF0l4HC6S8DhcJOFxuEjC4zCRzPA4XCThcZjqyQyPw0USHoeLJIEkE0l4HC6S8DhcJOFxuKogeBwukvA4TCQLPA4XSXgcLpLwOExzd4HH4SJJIMlEEh6HiyQ8zlmSldWTCjwOF0l4HC6S8Dg8JK0xMDlsKE+4HB/Se5Teu5XOFuU+nbSYBfKb3bXJfgXkWAJKyy+nPfn4PiAbXVohRcqv+KP7iskPGBM1jyltVjhMcXN/rTGFAWOKA8Z0UJ4Y94rJpMrzK/m0PDcSWfe6k3Z3tS92fSYVl2zlaOfTsnCko7A5uoSvEWRmqtHY91RdWf6yN5tHKn3FczC50iYeylbKjMC5gbg1R/u5As4fOBZwjuE4xXA4V+t+oPRAyYWSgJILZQBKLpQRKLlQJqDkQpmBkgulZo/Bi9JpdiTMKDX7F2aUcDtsKOF22FASUHKhhNthQwm3w4YSbuc0yrcf0DxQwu2woYTb4brBPdwOG0q4HTaUcDtsKOF22FASUHKhhNthQwm3w4YSbocNJdwOG0q4HS6UBLdzFmXt42yC22FDCbfDhlKz23m/reoDDgHOMRzNjqQKR7PHqMLR7BqqcDT7gCoczZV9DU7QXKtX4WiuvqtwNNfT7/flfcDRXCFX4RDgHMPRXCFX4WiukKtwNFfIVTiaK+QqHM0V8vttVq2JmivkKhzNFXIVjuYKuQpHc4VchUOAcwxHc4VchaO5Qq7CmatC7reg7wPlXPV0V5RzVd89Uaa5avWuKOeq7LuinMsHdEU5l2vot9T0AyUBJRfKuRxJV5Rz+ZeuKOF22FDC7bChhNvhKoYy3A4bSrgdNpRwO2wo4XbYUBJQcqGE22FDCbfDVVdmuB02lHA7bCjhdrhQFrgdNpRwO2wo4Xa4iqECt8OGkoCSCyXcDhtKuB02lHA7bDM43A4bSrgdJpTWwO2woYTbOYuysvCPNXA7bCjhdthQElByoYTbYUN5wu2EzWXu3lfdmsQSEOce5tbkAWMqzWOq7Rduz2zg3DwmO2BMXvi+6nay/Vg/ewK7uBzuXAo/n6k2jve4ONiq9PFCepXqo/Nl3sdkbaF1jQZbSi2qEsrrp47RfrsR9mY2Cpupbe++GfA5bLmfw9HY9zG5svxlbzbSpv/83x//5f/87//6b//2r//P//Fv//F//df/+a//8e//48+J5s//s/u7irli7PrnNtp/ePu/A9zfQKt6Vrp0Vr50Vrly1v5mN9Wz7KWz3KWz/KWz6NJZl7ThL2nDX9KGv6QNf0kbdEkbdEkbdEkbdEkbdEkbdEkbdEkbdEkbdEkbdEkb4ZI2wiVthEvaCJe0ES5pI1zSRrikjXBJG+GSNsIlbcRL2oiXtBEvaSNe0ka8pI14SRvxkjbiJW3ES9qIl7SRLmkjXdJGuqSNdEkb6ZI20iVtpEvaSJe0kS5pI13SRr6kjXxJG/mSNvIlbeRL2siXtJEvaWP/e2xvwstilbQ5yz/PypfOKlfO2v+gtHqWvXSWu3TWrjb844XHcpZz5dtZez2YuNrluG1mmbRzNGX/6hu9jg3PnO5/VvZhPNmsazplmyvxhJiWo0PMfj060DOgMFpAcbSA0mgB5dECKmMF5PY//egZkB0tIDdaQH60gAZ7UjvT/kn92sAgpEcUm4B2Or/BLhOfC5uXOLsH57CEkdNmkvS773seTbm1875530O7ffr8Kqm+HfqXYATBXxJMIPhLghkEf0mwgODvCFoDgr8kaEHwlwQdCP6SoAfBXxIkEPwlQXiS3xKEJ/ktQXiS3xKEJ/ktQXiSXxJ08CS/JQhP8luC8CS/JQhP8luCBIK/JAhP8luC8CS/JQhP8luC8CS/JQhP8kuCHp7ktwThSX5LEJ7ktwR7eBL7IpjfQ7F5/YLVFucrf9pSWX/kGpLb/um/YyVFYw2KxhoVjTUpGmtWNNaiZ6xkFI3VKhqrUzRWRXUTKaqbSFHdRIrqJlJUN5GiuokU1U1BUd0UFNVNQVHdFBTVTUFR3RQU1U1BUd0UFNVNQVHdFBTVTVFR3RQV1U1RUd0UFdVNUVHdFBXVTVFR3RQV1U1RUd0UFdVNSVHdlBTVTUlR3ZQU1U1JUd2UFNVNSVHdlBTVTUlR3ZQU1U1ZUd2UFdVNWVHdlBXVTVlR3ZQV1U1ZUd2UFdVNWVHdlBXVTUVR3VQU1U1FUd1UZqqbXInr5oZmswfxEZl161Eb7OZv571Iolk2mIxu83PH7J8YCRg5MM5U7XXEOFMh2RHjTDVqR4wzlb8dMc5UWXfD6M1MRXtHjDP5gY4YZ7IaHTHCxbBgJGDkwAgXw4IRLoYF40wu5vGkTyvGUgvE2uTWP26L2fz1Pym4F/tMrkcQ9plckhzsdiZXJQj7TC5MEPaZXJsg7DO5PEHYCdh7YJ/JRQrCPpPrFIQdLrULdrjULtjhUntgd3CpXbArdqnOhCUS6x4jrmB3jzR9He5s3kDJce/oZNajk3t92xef2BW71J7YFbvUntgJ2HtgV+xSe2JX7FJ7YlfsUntiV+xSe2JX7FI7YveKXWpP7HCpXbDDpXbBDpfaBTsBew/sml2qz3nFTlRr/Lq4xuJiDK+ji92Lxbrljz9eWG+O/pOwn0f7tEbui/929N80aXa1gtKk2QULSpNm1ywoTZpdtpw0TbUJ6MRp0uziBaVJs+sXlCbNXQJBaSKkSUKa0IUQkSZ0IUSkCV0IEWlCF0JEmtCFkJCmqbbUnjhN6EKISBO6ECLShC6EiDQR0iQhTehCiEgTuhAi0oQuhIg0oQshIk3oQkhIU0QXQkSa0IUQkSZ0IUSkCV0IEWkipElCmtCFEJEmdCFEpAldCBFpQhdCRJrQhZCQpoQuhIg0oQshIk3oQohIE7oQItJESJOENKELISJN6EKISBO6ECLShC6EiDShCyEhTRldCBFpQhdCRJrQhRCRJnQhRKSJkCYJaUIXQkSa0IUQkSZ0IUSkCV0IEWlCF0JCmgq6ECLShC6EiDShCyEiTehCiEgTIU0S0oQuhIg0oQshIk3oQohIE7oQItKELoSANJFBF0JEmtCFEJEmdCFEpAldCBFpIqRJQprQhRCRJnQhRKQJXQgRaUIXQkSa0IWQkCaLLoSINKELISJN6EKISBO6ECLSREiThDShCyEiTehCiEgTuhAi0oQuhIg0oQshIU0OXQgRaUIXQkSa0IUQkSZ0IUSkiZAmCWlCF0JEmtCFEJEmdCFEpAldCBFpQhdCQpo8uhAi0oQuhIg0oQshIk3oQohIEyFNEtKELoSINKELISJN6EKISBO6EDelyVFYEeZamqisaQrGlJ9pQhdCQpoIXQgRaUIXQkSa0IUQkSZ0IUSkiZAmCWlCF0JEmtCFEJEmdCFEpAldCBFpQhdCQpoCuhAi0oQuhIg0oQshIk3oQohIEyFNEtKELoSINKELISJN6EKISBO6ECLShC6EhDRFdCFEpAldCBFpQhdCRJrQhRCRJkKaJKQJXQgRaUIXQkSa0IUQkSZ0IUSkCV0ICWlK6EKISBO6ECLShC6EiDShCyEiTYQ0SUgTuhAi0oQuhIg0oQshIk3oQohIE7oQEtKU0YUQkSZ0IUSkCV0IEWlCF0JEmghpkpAmdCFEpAldCBFpQhdCRJrQhRCRJnQhJKSpoAshIk3oQohIE7oQItKELoSINBHSJCFN6EKISBO6ECLShC6EiDShCyEiTehCCEjT439DmiSkCV0IEWlCF0JEmtCFEJEmQpokpAldCBFpQhdCRJrQhRCRJnQhRKQJXQgJabLoQohIE7oQItKELoSINKELISJNhDRJSBO6ECLShC6EiDShCyEiTehCiEgTuhAS0uTQhRCRJnQhRKQJXQgRaUIXQkSaCGmSkCZ0IUSkCV0IEWlCF0JEmtCFEJEmdCEkpMmjCyEiTehCiEgTuhAi0oQuhIg0EdIkIU3oQohIE7oQItKELoSINKELISJN6EJISBOhCyEiTehCiEgTuhAi0oQuhIg0EdIkIU3oQohIE7oQItKELoSINKELISJN6EJISFNAF0JEmtCFEJEmdCFEpAldCBFpIqRJQprQhRCRJnQhRKQJXQgRaUIXQkSa0IWQkKaILoSINKELISJN6EKISBO6ECLSREiThDRp7kJEY9c0pW3gu2l6/Em7Qtmm6SCp2SxJTbbUjnamLEc7l74d/TdNmrsQgtKkuQshKE2auxCC0qS5CyEnTUlzF0JQmjR3IQSlSXMXQlCaNHchBKWJkCYJaUIXQkSa0IUQkSZ0IUSkCV0IEWlCF2KINJH3y9GUa69UIrmvg2N8pdTHvVGW18saswlj/+Bo16OjC6ZytE02Lrwf/y6+9tfLyjsWu9Fi3jk4P14tfR2cXXTbg//oNqMtA91K1C36VNCtRN2icQfdStQtOpnQrUTdEnQL3QrULXrd0K1E3aL5D91K1C3ehkC3EnWL10PQrUTd4n0ZdCtQtwXvy6BbibrF+zLoVqJu8b4MupWoW7wvg24l6pagW+hWoG7xvgy6lahbvC+DbiXqFu/LoFuJusX7MuhWom7xvgy6lafbaPC+DLqVqFu8L4NuX3/YhbTqNtf+tM1xjfrPv+nb8X/VhbdaUNd96sK7J6jrPnUR1AV13aYuvMeBuu5TF962QF33qQvvRKCu+9SFNxdQ133qwvsFqOs2dVm8BYC67lMXevVQ133qQq8e6rpPXejVQ133qYugLqjrNnWhV3+TutL6bcrjn9+P/gsebexO4NHh7QQezc9O4NEX7APeoWXWCTy6SZ3Ao9HSCTx6EJ3AE8D3AQ/n2gk8nGsn8HCuncDDuXYCr9i5ep+WHrL1FFwFpX0Es7Z6bU6vH+bFXfDGreCd2xz7B7tX7Ft7YlfsWntiV+xZyaQ1brKUKtijef30N76OfbwO+wtSsQflBUkAyQNSsUfkBanY8/GCVOzheEEq9mS8IBV7LFaQpNg18YJU7IN4QcLZMIGEs2ECSQDJAxLOhgmkZmcTqawgY/WjZufTQtL5sunW5/Rx0400+6CO2DW7po7YNXusftiDZkfWEbtm/9YRu2a31xG7Zm/YETsBew/smn1nR+xwqV2ww6V2wQ6X2gU7XGoP7BEu9TR2suuSDUTmG/a/KOE82VDCTbKhhENkQ0lAyYUSTo4NJdwZG0o4LjaUcFFsKOGMuFAmuB02lHA7bCjhdthQwu2woSSg5EIJt8OGEm6HDSXcDhtKuB02lHA7XCgz3A4bSrgdNpRwO2wo4XbYUBJQcqGE22FDCbfDhhJuhw0l3A4bSrgdLpQFbocNJdwOG0q4HTaUcDtsKAkouVDC7bChhNthQwm3w4YSbocNJdwOE8pk4HbYUMLtsKGE22FDCbfDhpKAkgsl3A4bSrgdNpRwO2wo4XbYUMLtcKG0cDtsKOF22FDC7bChhNthQ0lAyYUSbocNJdwOG0q4HTaUcDtsKOF2uFA6uB02lHA7bCjhdthQwu2woSSg5EIJt8OGEm6HDSXcDhtKuB02lHA7XCg93A4bSrgdNpRwO2wo4XbYUBJQcqGE22FDCbfDhhJuhw0l3A4bSrgdLpQEt8OGEm6HDSXcDhtKuB02lASUXCjhdthQwu2woYTbYUMJt8OGEm6HC2WA22FDCbfDhhJuhw0l3A4bSpoJpacVpU+xdnTMC0n/eDGzObo80UzlXnjRTOVGeNFM5S540UzlFnjRTFX9s6KJU1XzvGimqs550UxVbfOimap65kVDQHOEBtXwIRpUw4doUA0fokE1fIgG1fARmrn2kudFg2r4EA2q4UM0qIYP0RDQHKFBNXyIBtXwIRpUw4doUA0fokE1fIRmrr3GedGgGj5Eg2r4EA2q4UM0BDRHaFANH6JBNXyIBtXwIRpUw4doUA0foZlrL2peNKiGD9GgGj5Eg2r4EA0BzREaVMOHaFANH6JBNXyIBtXwIRpUwwdo8lx7FfOiQTV8iAbV8CEaVMOHaAhojtCgGj5Eg2r4EA2q4UM0qIYP0aAaPkIz1162vGhQDR+iQTV8iAbV8CEaApojNKiGD9GgGj5Eg2r4EA2q4UM0qIaP0My11ykvGlTDh2hQDR+iQTV8iIaA5ggNquFDNKiGD9GgGj5Eg2r4EA2q4SM0c+2FyYsG1fAhGlTDh2hQDR+iIaA5QoNq+BANquFDNKiGD9GgGj5Eg2r4CM1ceyXyokE1fIgG1fAhGlTDh2gIaI7QoBo+RINq+BANquFDNKiGD9GgGj5CM9deerxoUA0fokE1fIgG1fAhGgKaIzSohg/RoBo+RINq+BANquFDNKiGj9BgL7pjNKiGD9GgGj5Eg2r4EA0BzREaVMOHaFANH6JBNXyIBtXwIRpUw0dosBfdMRpUw4doUA0fokE1fIiGgOYIDarhQzSohg/RoBo+RINq+BANquEjNNiL7hgNquFDNKiGD9GgGj5EQ0BzhAbV8CEaVMOHaFANH6JBNXyIBtXwERrsRXeMBtXwIRpUw4doUA0foiGgOUKDavgQDarhQzSohg/RoBo+RINq+ABNwV50x2hQDR+iQTV8iAbV8CEaApojNKiGD9GgGj5Eg2r4EA2q4UM0qIaP0GAvumM0qIYP0aAaPkSDavgQDQHNERpUw4doUA0fokE1fIgG1fAhGr3VMHnjvo4mH+I3NDuRUFqQ2GA3keS9uKPJXwdHt/nL2f+FrniXu47Q9VbwHaHr9QYdoet1HR2hE6C3h67XKXWErteDdYSu1911hK7XN3aEDkfaHrrinSY7Qocj7QAdjrQD9LkcaV6O9uTCt6P/DpY0DXYuB1YZ7FzOpzLYuRxHZbBzVfqVwc5VYb8f7GS7RlYGO1dFWRnsXJVcZbCaKqjJdl+sDFZTBTXZDomVwWqqoCbbxbAyWE0V1GQ7DVYGq6mCmmw3wMpgNVVQk+3YVxmspgpqsl31KoPVVEFNtvNdZbCaKqjJdqerDFZTBTXZDnKVwWqqoCbb5a0yWE0V1GQ7sVUGq6mCmmy3tMpgNVVQk+1oVhmspgpqsl3HKoPVVEFNtjNYZbCaKqjJdu+qDFZTBTXZDluVwWqqoCbbBasyWE0V1GQ7VVUGq6mCmmw3qcpgNVVQk+34VBmspgpqsl2ZKoPVVEFNtnNSZbCaKqi5djci/xps9TeBNi2/23Pm9ZddtjvH5pVH9qVybFmJl/L92L/Ap6riJAAnAG8LfKpqVgLwqSpqCcCnquolAJ/KWUgAPpW7GR+4NXNtxyWC+FQ+TwRxmM3WxOE2WxOnqYjndZGlTLZG3OV12STvaXN03vvbwa7ZDNl8O/pJci4f2ZPkXAaxJ8m5nF9PknNZup4k5/JqHUnOtQlcV5JzeaueJOfyTD1JzuWFepIkkGQiCY/DRRIeh4skPA4XSXgcLpLwOEwk59qArytJeBwukvA4XCThcbhIEkgykYTH4SIJj8NFEh6HiyQ8DhdJeBwmknNt6daVJDwOF0l4HC6S8DhcJAkkmUjC43CRhMfhIgmPw0USHoeLJDwOE8m5NvfrShIeh4skPA4XSXgcLpIEkkwk4XG4SMLjcJGEx+EiCY/DRRIeh4nkXNtvdiUJj8NFEh6HiyQ8DhdJAkkmkvA4XCThcbhIwuNwkYTH4SIJj8NEcq4NcruShMfhIgmPw0USHoeLJIEkE0l4HC6S8DhcJOFxuEjC43CRhMdhIjnXFtZdScLjcJGEx+EiCY/DRZJAkokkPA4XSXgcLpLwOFwk4XG4SMLjMJGca5P5riThcbhIwuNwkYTH4SJJIMlEEh6HiyQ8DhdJeBwukvA4XCThcZhIFngcLpLwOFwk4XG4SMLjcJEkkGQiCY/DRRIeh4skPA4XSXgcLpLwODwkrYHH4SIJj8NFEh6HiyQ8DhdJAkkmkvA4XCThcbhIwuNwkYTH4SIJj8NE0sLjcJGEx+EiCY/DRRIeh4skgSQTSXgcLpLwOFwk4XG4SMLjcJGEx2Ei6eBxuEjC43CRhMfhIgmPw0WSQJKJJDwOF0l4HC6S8DhcJOFxuEjC4zCR9PA4XCThcbhIwuNwkYTH4SJJIMlEEh6HiyQ8DhdJeBwukvA4XCThcZhIEjwOF0l4HC6S8DhcJOFxuEgSSDKRhMfhIgmPw0USHoeLJDwOF0l4HCaSAR6HiyQ8DhdJeBwukvA4XCQJJJlIwuNwkYTH4SIJj8NFEh6HiyQ8DhPJCI/DRRIeh4skPA4XSXgcLpIEkkwk4XG4SMLjcJGEx+EiCY/DRRIeh4lkgsfhIgmPw0USHoeLJDwOF0kCSSaS8DhcJOFxuEjC43CRhMfhIgmPw0Qyw+NwkYTH4SIJj8NFEh6HiySBJBNJeBwukvA4XCThcbhIwuNwkYTHYSJZ4HG4SMLjcJGEx+EiCY/DRZJAkokkPA4XSXgcLpLwOFwk4XG4SMLj8JB0Bh6HiyQ8DhdJeBwukvA4XCQJJJlIwuNwkYTH4SIJj8NFEh6HiyQ8DhNJC4/DRRIeh4skPA4XSXgcLpIEkkwk4XG4SMLjcJGEx+EiCY/DRRIeh4mkg8fhIgmPw0USHoeLJDwOF0kCSSaS8DhcJOFxuEjC43CRhMfhIgmPw0TSw+NwkYTH4SIJj8NFEh6HiySBJBNJeBwukvA4XCThcbhIwuNwkYTHYSJJ8DhcJOFxuEjC43CRhMfhIkkgyUQSHoeLJDwOF0l4HC6S8DhcJOFxmEgGeBwukvA4XCThcbhIwuNwkSSQZCIJj8NFEh6HiyQ8DhdJeBwukvA4TCQjPA4XSXgcLpLwOFwk4XG4SBJIMpGEx+EiCY/DRRIeh4skPM45kuRS+TqafHCVoy2l9W8Hu4k7740ymvx1cHRxc6z/yhHc0/A5SvBl4+cIjm/8HMFLjp8juNTxc0TI0fA5grMeP0fw7OPnCN2A8XOEPsP4OUKfYfgcZfQZxs8R+gzj50hxn8GvgdhofIW6c8Z8He3If8/Rk6TibgAzSQJJJpKKnTUzScX+l5mkYpfKTFKxl2Qmqdjx8ZIsin0ZM0nF7omZJDwOF0l4HC6SBJJMJOFxuEjC43CRhMfhIgmPw0USHoeHpDfwOFwk4XG4SMLjcJGEx+EiSSDJRBIeh4skPA4XSXgcLpLwOFwk4XGYSFp4HC6S8DhcJOFxuEjC43CRJJBkIgmPw0USHoeLJDwOF0l4HC6S8DhMJB08DhdJeBwukvA4XCThcbhIEkgykYTH4SIJj8NFEh6HiyQ8DhdJeBwmkh4eh4skPA4XSXgcLpLwOFwkCSSZSMLjcJGEx+EiCY/DRRIeh4skPA4TSYLH4SIJj8NFEh6HiyQ8DhdJAkkmkvA4XCThcbhIwuNwkYTH4SIJj8NEMsDjcJGEx+EiCY/DRRIeh4skgSQTSXgcLpLwOFwk4XG4SMLjcJGEx2EiGeFxuEjC43CRhMfhIgmPw0WSQJKJJDwOF0l4HC6S8DhcJOFxuEjC4zCRTPA4XCThcbhIwuNwkZzK4+SwkiyGvh39HC2pGu1UXqE62qnq+epop6q5q6Odqi6ujnaq2rU22jxVfVkd7VQ1YHW0U9Vp1dGqqqXm2vO8OlpVtdRce4dXR6uqlpprD+7qaFXVUnPtZV0drapaaq49oaujVVVLzbW3cnW0qmqpufYoro5WVS01116/1dFqqqVorj1zq6PVVEvRXHvPVkerqZYiQ6pGq6mWorn2Qq2OVlMtRXPtKVodrapaaq69OaujVVVLzbXHZXW0qmqpufaKrI5WVS01156L1dGqqqXm2ruwOlpVtdRcewBWR6uqlpprL73qaFXVUnPtSVcdrapaaq693aqjVVVLzbVHWnW0qmqpufYaq45WVS01155d1dGqqqXm2vuqOlpVtdRce0hVR6uqlpprL6bqaFXVUnPtaVQdrapaaq69gaqjVVVLzbXHTnW0qmqpufaqqY5WVS01154vxYZ1tLF2tE3562C3WQHHZbtzbF55ZF8qx5a8hFzK92OfxKeq5yQQn2sPGRHEp6prS1rCJkumcrRL3i3IU9keHfaYP54HC3Rn47ejnySnqpm7kpyqHu9KkkCSieRUPqIryak8SleSU/mfriTn8lY9Sc7lmTqSnGuvma4k4XG4SMLjcJGEx+EiSSDJRBIeh4skPA4XSXgcLpLwOFwk4XGYSM6110xXkvA4XCThcbhIwuNwkSSQZCIJj8NFEh6HiyQ8DhdJeBwukvA4TCTn2u+oK0l4HC6S8DhcJOFxuEgSSDKRhMfhIgmPw0USHoeLJDwOF0l4HCaSc+1D1pUkPA4XSXgcLpLwOFwkCSSZSMLjcJGEx+EiCY/DRRIeh4skPA4PyTDX/oBdScLjcJGEx+EiCY/DRZJAkokkPA4XSXgcLpLwOFwk4XG4SMLjMJGca9/OriThcbhIwuNwkYTH4SJJIMlEEh6HiyQ8DhdJeBwukvA4XCThcZhIzrWfbleS8DhcJOFxuEjC43CRJJBkIgmPw0USHoeLJDwOF0l4HC6S8DhMJOfa57orSXgcLpLwOFwk4XG4SBJIMpGEx+EiCY/DRRIeh4skPA4XSXgcJpJz7T/flSQ8DhdJeBwukvA4XCQJJJlIwuNwkYTH4SIJj8NFEh6HiyQ8DhPJAI/DRRIeh4skPA4XSXgcLpIEkkwk4XG4SMLjcJGEx+EiCY/DRRIeh4lkhMfhIgmPw0USHoeLJDwOF0kCSSaS8DhcJOFxuEjC43CRhMfhIgmPw0QyweNwkYTH4SIJj8NFEh6HiySBJBNJeBwukvA4XCThcbhIwuNwkYTHYSKZ4XG4SMLjcJGEx+EiCY/DRZJAkokkPA4XSXgcLpLwOFwk4XG4SMLjMJEs8DhcJOFxuEjC43CRhMfhIkkgyUQSHoeLJDwOF0l4HC6S8DhcJOFxeEhGA4/DRRIeh4skPA4XSXgcLpIEkkwk4XG4SMLjcJGEx+EiCY/DRRIeh4mkhcfhIgmPw0USHoeLJDwOF0kCSSaS8DhcJOFxuEjC43CRhMfhIgmPw0TSweNwkYTH4SIJj8NFEh6HiySBJBNJeBwukvA4XCThcbhIwuNwkYTHYSLp4XG4SMLjcJGEx+EiCY/DRZJAkokkPA4XSXgcLpLwOFwk4XG4SMLjMJEkeBwukvA4XCThcbhIwuNwkSSQZCIJj8NFEh6HiyQ8DhdJeBwukvA4TCQDPA4XSXgcLpLwOFwk4XG4SBJIMpGEx+EiCY/DRRIeh4skPA4XSXgcJpIRHoeLJDwOF0l4HC6S8DhcJAkkmUjC43CRhMfhIgmPw0USHoeLJDwOE8kEj8NFEh6HiyQ8DhdJeBwukgSSTCThcbhIwuNwkYTH4SIJj8NFEh6HiWSGx+EiCY/DRRIeh4skPA4XSQJJJpLwOFwk4XG4SMLjcJGEx+EiCY/DRLLA43CRhMfhIgmPw0USHoeLJIEkE0l4HC6S8DhcJOFxuEjC43CRhMfhIZkMPA4XSXgcLpLwOFwk4XG4SBJIMpGEx+EiCY/DRRIeh4skPA4XSXgcJpIWHoeLJDwOF0l4HC6S8DhcJAkkmUjC43CRhMfhIgmPw0USHoeLJDwOE0kHj8NFEh6HiyQ8DhdJeBwukgSSTCThcbhIwuNwkYTH4SIJj8NFEh6HiaSHx+EiCY/DRRIeh4skPA4XSQJJJpLwOFwk4XG4SMLjcJGEx+EiCY/DRJLgcbhIwuNwkYTH4SIJj8NFkiYiSXY9mmyJ345+jnYmH1If7UxeoT7amer5+mhnqrnro52pLq6Odqr96+ujnam+rI92phqwPtqZ6rT6aEnVaFXVUlPtS14frapaaqr9veujVVVLTbVPdn20qmqpqfabro9WVS011b7N9dGqqqWm2v+4PlpVtdRU+wjXR6uqlppqP976aFXVUlPta1sfrapaaqr9YeujVVVLTbXPan20qmqpqfYrrY9WVS011b6f9dGqqqWm2j+zPlpVtdRU+1DWR6uqlppqP8f6aFXVUlPti1gfrapaaqr9BeujVVVLTbVPX320qmqpqfa7q49WVS011b5x9dGqqqWm2n+tPlpNtVSeah+z+mg11VJ5qv3A6qPVVEtlQ6pGO1UtRdYvo03W7Ix2qlqqOtqpaqnqaKeqpaqjnaqWqo12qv2S6qOdqpaqjnaqWqo62qlqqepoSdVoVdVSU+2DUx+tqlpqqv1k6qNVVUtNtS9LfbSqaqmp9jepj1ZVLTXVPiH10aqqpabab6M+WlW11FT7VtRHq6qWmmr/h/poVdVSU+2jUB+tqlpqqv0I6qNVVUtNta5/fbSqaqmp1sevj1ZVLTXVOvP10aqqpaZar70+WlW11FzrnldHq6qWmmvd8+poVdVSc617Xh2tqlpqrnXPq6NVVUvNte55dbSqaqm51j2vjlZVLTXXuueV0ZYO3fOYlqNDzH472mdEHZ4k5sXfxJ8R7SvC+SUR3qdcicjHYpajs/m5LVU5aBAyXyS3uEhpcJGDLhTzRWyLi7gWF/EtLkItLhJaXKTFHU8t7nhqccdTizs+tLjjQ4s7PrS440OLOz60uONDizs+tLjjQ4s7PrS440OLOz62uONjizs+trjjY4s7Pra442OLOz62uONjizs+trjjY4s7PrW441OLOz61uONTizs+tbjjU4s7PrW441OLOz61uONTizs+t7jjc4s7Pre443OLOz63uONzizs+t7jjc4s7Pre44zPHHZ/TenQx9udFimlxEdviIq7FRXyLi1CLi4QWF4ktLpKYL2LdzkU47vi8vv7xxZlvF/l5dF5fsWT/esPist059vFo/Tq2lO/HPoMvYoN3xhjJwVvJwTvJwXvJwZPk4IPk4KPk4JPk4OXOsI/gJc+wVvIMayXPsHbsGTYux9pHLbAT/dhTbC36sefYWvRjT7K16MeeZWvRjz3N1qLnmGeLS2v0IVWif/+N4SOiMlpEzgwXkR0uIjdcRH64iGi4iMJwEcXhIkrDRTTcM9sP94T07Z+Qb79Uf0QUhouo/b2W3Csil35GlIaLKA8XURktIjLDRdTh7qe4RvTnx0GviH4e7GgNxBHRz/Cd7PC97PBJdvhBdvhRdvhJdvhZdvhl8PBdfoX/syALRnb4o8+6lfAHn3VDWGoeF6J/f3A0ZvmcLD562z/HOvgU/clYQ0nl7VgHn8/D2vt1Idn3B2ez/OFMmx9a+/w11MHnfs6hDl4ncA518JqCc6iD1x+cQx28VmEcahx9Zv1kqGHpO+YUvw115w9bv8TsbHj9YXJ7B+dlyvPm26FPhKNP2AIQEhD+FuFM9UUnhDPVLZ0QzlQPdUI4U53VCeFM9VsfhGnwfpcEhIP33CQghDv5NUK4k18jJCD8LUK4k98izFpVaIpbEW4+ldpFmPMSxLcfB+/+Yfu49vKXH/9Om0+wS/xirlW2PZlrdeE9mWu17T2Za/X5PZlrbQx0ZF60dhJ6MtfaeujJXGuvoidzrc2NnswJzJszhw9tzxw+tD1z+ND2zOFD2zOHD23N3Br40PbM4UPbM4cPbc8cPrQ9cwLz5szhQ9szhw9tzxw+tD1z+ND2zOFDmzO38KHtmcOHtmcOH9qeOXxoe+YE5s2Zw4e2Zw4f2p45fGh75vCh7ZnDhzZn7uBD2zOHD23PHD60PXP40PbMCcybM4cPbc8cPrQ9c/jQ9szhQ9szhw9tztzDh7ZnDh/anjl8aHvm8KHtmROYN2cOH9qeOXxoe+bwoe2Zw4e2Zw4f2pw5wYe2Zw4f2p45fGh75vCh7ZkTmDdnDh/anLmoPRTz+4NTXI5N6RvF50glqet3I5XUW/jdSHs4+tcG9aES/Ls//Yw/C4+/yI4/GuHxW+HxO+Hx+6HjJ+OXDZTJlFL5057WYsFT3oQdzNdoSdVog6rRRlWjHbtu4B7t2FUG92jHrkmYR5vGrmC4Rzt2vcM92rGrI+7RqqqluuwKxzPaZ/xyq6Nn/HLrnWf8ciuYZ/xya5Jn/HKrjL/x58HrBrs2FMlbqvzpbGhptvvXWF22O8eWvPzhUr4f++QyeIXRjcvgtUg3LoNXLd24ELjschm8burGZfB6rBuXweu8blwGrx+7cRm8Lu3FpaDe3eeCenefC+rdfS6od/e5jF6/2KUfSdbt9APK6HVGLf7R64Fa/KPP2+/jd2b0+bUW/+jzYC3+0eerWvyjzyu1+El4/KP3JWrxy55/nZE9/zoje/51Rvj8a4XPv1b4/GuFz79W+PzbZR8FzviFz79W+Pxrhc+/Vvj8a4XPv074/OuEz79O+PzrhM+/XdaP5oxf+PzrhM+/Tvj864TPv074/OuFz79e+Pzrhc+/Xvj822XdTM74hc+/Xvj864XPv174/OuFz78kfP4l4fMvCZ9/Sfj822W9MM74hc+/JHz+JeHzLwmff0n4/BuEz79B+PwbhM+/Qfj822UdQ874hc+/Qfj8O/hKgvX4hc+/g68kWI1/8JUE6/ELn38HX0mwHr/w+Xf0tQGr8Quff0dfv68av/D5d/Q19qrxC59/R18Hrxq/8Pl39LXqqvELn39HX0+uGr/w+Xf09eSq8Quff0dfT64av/D5d/j15GrxC59/h1+frRa/8Pl3+PXOavELn3+HXz+sFr/w+Xf49bhq8Quff4df36oWv/D5d/j1omrxC59/i/D5twiff4Wvf+WEr3/lhK9/5YSvf+WFr3/lha9/5YWvf+WFr3/ljez51wtf/8oLX//KD7/+1W3risblWGuM+3bwE4zaha5rYNSudF0BM/xSYN3AqF3rugZG7WLXNTAkFswzfrm7jTzjl7sryDN+uVXNM365xcczfrk1wt/4h19VrBa/3Bn3Gb/cifEZv9zdGp7xC59/h19VrBa/8Pl3+FXFavELn3+HX1WsEv/wq4rV4hc+/w6/qlgtfuHz7/CritXiFz7/Dr+qWC1+4fPv8KuK1eIXPv8Ov6pYLX7h8+/wq4rV4hc+/w6/qlgtfuHz7/CritXiFz7/Dr+qWC1+4fPv8KuK1eIXPv8Ov6pYLX7h8+/wq4rV4hc+/w6/qlgtfuHz7/CritXiFz7/Dr+qWC1+4fPv8KuK1eIXPv8Ov6pYLX7h8+/wq4rV4hc+/w6/qlgtfuHz7/CritXiFz7/Dr+qWC1+4fPv8KuK1eIXPv8Ov6pYLX7h8+/wq4rV4hc+/w6/qlgtfuHz7/CritXiFz7/Dr+qWC1+4fPv8KuK1eIXPv8Ov6pYLX7h8+/wq4rV4hc+/w6/qlgtfuHz7/CritXiFz7/Dr+qWC1+4fPv8KuK1eKXPf/S8KuK1eKXPf/S8KuK1eKXPf+SkT3/0vCritXilz3/kuBVxZ7xy55/SfAaXX/jF7yU1jN+4fOv4IWpnvELn3+Fr39Fwte/IuHrX9Ho619FX5b485+Lv/3THy0sl5cRlvL92CeXwef1blwGrxd6cRl9HbD7uLxfoJFGX2CsH5jBK6d+YAYvyfqBIYDZBzN4EdkPzODVaV7/NGWqgUnRfx2cUlyPJfc11MELWc6hDl6bcg518HLzzVD/xj/68nTV+Aev3qrxj11kBUthOdjGHXs++PJ09fhJePxjVxb1+McuAOrxjz2r1+Mfe6quxz/2/FuNf/Dl6erxjz3/buN31u3EL2f+3Y9fzvy7H7+c+Xc/fjnz7378cubf/fgHn3+TTevBuezEP/j8W41/8Pm3Fv/gy9PV4x98/q3GP/j8W41/8Pm3Gv/g8281/sHn32r8g8+/1fiFz7+DL09Xj1/4/Dv48nQhe7McXGKu/Gkq62C3nzJls3OsS2bZztgl96ps4xeXwef1blwGrxe6cRm8DmHi8hwrKRrr4PUN61gHr4VYxzp43cQ61sFrLNaxDl6PfTTWR8ttOZjyz7EOvrQh71hnqsdqY52pxqqNdaa6qTZWUjTWmeqm2lhnqptqY52pbqqNdaa6KYS1bso7ddPgy0yyjnXwJSl5xzpV3VQZ61R1U2WsU9VNlbGSorFOVTdVxjpV3VQZ61R1U2WsiuqmwZcHfTfWv/EPvjxoPX659c0zfrk1yzN+uXXIM34SHv/Y9UI0Zgkk+mh34h+7BqjHP/a8Xo9/7Lm6Hv/Y828t/jD48qD1+Meef+vxjz3/1uMfe/6txz/2/FuPX/b8GwZfHrQev+z5Nwy+PGg9fuHz7+DLg9bjFz7/Dr48aD1+4fPv4MuD1uMXPv8OvjxoPX7h8+/gy3jW4xc+/w6+LGY9fuHz7+CLTNbjFz7/Dr5kYz1+4fPv4Asg1uMXPv8OvlRhPX7h8+/g6w/W4xc+/w6+/mA9fuHz7+DrD9bjFz7/Dr7+YD1+4fPv4OsP1uMXPv8Ovv5gPX7h8+/g6w/W4xc+/w6+/mA9fuHz7+DrD9bjFz7/Dr7+YD1+4fPv4OsP1uMXPv8Ovv5gPX7h8+/g6w/W4xc+/w6+/mA9fuHz7+DrD9bjFz7/Dr7+YD1+4fPv4Ov51eMXPv8OvpZePX7h8+/ga97V4xc+/w6+Nl09fuHz7+BryNXjFz7/Dr7WWz1+4fPv4Guy1eMXPv8OvnZaPX7h8+/ga5zV4xc+/w6+Flk9fuHz7+BrhtXjFz7/Dr62Vz1+4fPv4Gtw1eMXPv8OvlZWPX7h8+/g61/V4xc+/w6+/lU9fuHz7+DrX9XjFz7/Cl//Kghf/yoIX/8qCF//Kgpf/yoKX/8qCl//Kgpf/yoa2fNvFL7+VRS+/lUUvv5VFL7+VRS+/lUUvv5VFL7+VRS+/lUUvv5VFL7+VRS+/lUcff0rysvBMVi3E//g869PK//HiZU/nQ19HZz9a69wl+3OsSUvf7iU78c+uQw+r3fjMni90IvL6OuAdeMyeH3TjcvgdVM3LoPXY924ELjschm8fuzGZfC6tBsX1Lv7XFDv7nNBvbvLZfR197pxQb27zwX17j4XtfVuXI61xrgdMAQw+2DUVrw1MGpL3hoYtTVvDYzaorcCZvRVEUMuC5jHG7DKn7ahGL8MNxTr1+Pj12gHn2rejPYZ/+AzQjX+sR/cKaXl4JQ2Ndz+n3Yphq+jXUp++6efgx37Ycw82LEfsMyDHbtVwDvYwdcdZB7s2NMh82DHdurMgx3bfjMPlqYabHHLYPOmqlgHO3ZRxDzYuSqoymBnqqC8M0tx7J1LPwc7UwVVHexMFVRtsIOvHMk82JkqqMdgzdvBzjTPerLL0Z6c+TnYmebZ6mBnmmerg51qnq0Ndqp51pe8Dtaa9386lLQ8ukMpO0+zqSblT8hEsz7no9kpRAdfe7KNZvbJTDXdk19rGwr2d3fT4OtltiGzr5mZWjGe1ld3nkr+OVjSNNi5SsTKYOcqESuDnatEfA02bN6Kr4OdqkSsDXaqqq8y2MEXMWUe7FS1mX8FEmx6/6ftI9FfB9tEmx/D+vyFZqoSJK0//fWp+N+VrYMvc3ojmZoJHHwB1Taa2SczVSX0+tP+H15K7TxoTFk/OLPe7DxopqqbsqMVTan8aTJL0OS+P4F3ML5aEvbRvluP9ivGqSqyfhinqvW6YRx8KV4xGKeqT/thnKrR2A/jVJagH0ZSi9Ev9oG2I1zBTGUfOMEM/qMl3p+gjL6MM/NoB/9RPeto0+hLRDOPVtNPx9Loy08zj3bwH6szj5ZUjVbujwivjHbw34p/OlpPr9EGtxnt/tFuc3T8wWayyouVzWR1Giubyaq6D9iQXf0vuc1ryC8yoy9S3pHMZNUiI5nJKktGMpNVoYxkCGQOyExW3TKS0VsJ18jorYNrZPRWwTUyqIEPyIy+QH5HMrPVwEcucedv5/WLzOQ3Pzo6+NslL4N8YNxsxhLMF8nZauZ+JGersXlIPtkQ2Byyma3OftvxOlg03a4rMXrnSmW0Nptl0R6b7ZZN2h2teY3WxO1onxGV9hG5V0Q/F0NIBwuF94zIDheRGy4iP1xE1D4iiq8nS+WTb0frI84R0c/wg+zwo+zwk+zws+zwi+jwycgO38oO3w0evsuv8H8WZORlhz/6rFsJf/BZN4Sl5nEh/u6HiIkGn6I/GWvlp4WJBp/Pg/XrWFNlXZS87jCcaRPz13fQiQaf+zmHOnidwDjUMHhNwTnUwesPzqEOXqtwDnX0mfWToYYljJzit6Hu/GHrX53zzZJXf5aT+Hnw69f05tuhT4SjT9gCEM5UB3RCOFN90QnhTHVLH4RxpnqoD8I0U/HxCULz2i7Abl6J7SLMeQmi2OqPmh/XXl//5Qff9XhXvl4ApsG7O1MyJzBvzlxrtd+TuVZ70JO5Vj/Rk7lWA9KTuVbH0pF51mpxejKfqfcshTl8aHvm8KHtmROYN2cOH9qeOXxoe+bwoe2Zw4e2Zw4f2px5gQ9tzxw+tD1z+ND2zOFD2zMnMG/OHD60PXP40PbM4UPbM4cPbc8cPrQ182zgQ9szhw9tzxw+tD1z+ND2zAnMmzOHD23PHD60PXP40PbM4UPbM4cPbc7cwoe2Zw4f2p45fGh75vCh7ZkTmDdnDh/anjl8aHvm8KHtmcOHtmcOH9qcuYMPbc8cPrQ9c/jQ9szhQ9szJzBvzhw+tD1z+ND2zOFD2zOHD23PHD60OXMPH9qeOXxoe+bwoe2Zw4e2Z05g3pw5fGh75vCh7ZnDh7ZnDh/anjl8aHPmo2+7OiVz+ND2zOFD2zOHD23PnMC8OXP40PbM4UPbM4cPbc8cPrQ9c/jQ5syn2qpbCnP40PbM4UPbM4cPbc+cwLw5c/jQ9szhQ9szhw9tzxw+tD1z+NDmzCN8aHvm8KHtmcOHtmcOH9qeOYF5c+bwoe2Zw4e2Zw4f2p45fGh75vChzZkn+ND2zOFD2zOHD23PHD60PXMC8+bM4UPbM4cPbc8cPrQ9c/jQ9szhQ5szz/Ch7ZnDh7ZnDh/anjl8aHvmBObNmcOHtmcOH9qeOXxoe+bwoe2Zw4c2Z17gQ9szhw9tzxw+tD1z+ND2zAnMmzOHD23PHD60PXP40PbM4UPbM4cPbc28GPjQ9szhQ9szhw9tzxw+tD1zAvPmzOFD2zOHD23PHD60PXP40PbM4UObM7fwoe2Zw4e2Zw4f2p45fGh75gTmzZnDh7ZnDh/anjl8aHvm8KHtmcOHNmfu4EPbM4cPbc8cPrQ9c/jQ9swJzJszhw9tzxw+tD1z+ND2zOFD2zOHD23O3MOHtmcOH9qeOXxoe+bwoe2ZE5g3Zw4f2p45fGh75vCh7ZnDh7ZnDh/anDnBh7ZnDh/anjl8aHvm8KHtmROYN2cOH9qeOXxoe+bwoe2Zw4e2Zw4f2px5gA9tzxw+tD1z+ND2zOFD2zMnMG/OHD60PXP40PbM4UPbM4cPbc8cPrQ58wgf2p45fGh75vCh7ZnDh7ZnTmDenDl8aHvm8KHtmcOHtmcOH9qeOXxoc+YJPrQ9c/jQ9szhQ9szhw9tz5zAvDlz+ND2zOFD2zOHD23PHD60PXP40ObMM3xoe+bwoe2Zw4e2Zw4f2p45gXlz5vCh7ZnDh7ZnDh/anjl8aHvm8KHNmRf40PbM4UPbM4cPbc8cPrQ9cwLz5szhQ9szhw9tzxw+tD1z+ND2zOFDGzP3xsCHtmcOH9qeOXxoe+bwoe2ZE5g3Zw4f2p45fGh75vCh7ZnDh7ZnDh/anLmFD23PHD60PXP40PbM4UPbMycwb84cPrQ9c/jQ9szhQ9szhw9tzxw+tDlzBx/anjl8aHvm8KHtmcOHtmdOYN6cOXxoe+bwoe2Zw4e2Zw4f2p45fGhz5h4+tD1z+ND2zOFD2zOHD23PnMC8OXP40PbM4UPbM4cPbc8cPrQ9c/jQ5swJPrQ9c/jQ9szhQ9szhw9tz5zAvDlz+ND2zOFD2zOHD23PHD60PXP40ObMA3xoe+bwoe2Zw4e2Zw4f2p45gXlz5vCh7ZnDh7ZnDh/anjl8aHvm8KHNmUf40PbM4UPbM4cPbc8cPrQ9cwLz5szhQ9szhw9tzxw+tD1z+ND2zOFDmzNP8KHtmcOHtmcOH9qeOXxoe+YE5s2Zw4e2Zw4f2p45fGh75vCh7ZnDhzZnnuFD2zOHD23PHD60PXP40PbMCcybM4cPbc8cPrQ9c/jQ9szhQ9szhw9tzrzAh7ZnDh/anjl8aHvm8KHtmROYN2cOH9qeOXxoe+bwoe2Zw4e2Zw4f2pq5NfCh7ZnDh7ZnDh/anjl8aHvmBObNmcOHtmcOH9qeOXxoe+bwoe2Zw4c2Z27hQ9szhw9tzxw+tD1z+ND2zAnMmzOHD23PHD60PXP40PbM4UPbM4cPbc7cwYe2Zw4f2p45fGh75vCh7ZkTmDdnDh/anjl8aHvm8KHtmcOHtmcOH9qcOUnyRPn9wSkux6b0jeJzpJKcyO9GKqn+/91IqcNI7WukleDf/eln/EF4/FF4/El4/Fl4/EV2/F123/4k/rA8lm1xvvKnH9koy9FhUys8/vRzsFbTYJ2mwfqJButyWsuLXErlaO9KXgb5eB6tR3+Vx122Y5ZBZvTSpR+Z0YuiG8n4WFYyOW3I/DyW7EqRnE0/KI5emsmgOHqB+BlFkxaKxZrK0XkdY/avIbpsd44teQmjlO/HPimOXqaKoBhnKpb7UZypCu9Hcabyvh/FuXxDL4oEigwU5/IjvSjO5V16UZzLu/SiCO/CQRHehYFignfhoAjvwkER3uUUxbgca41xOxhhXlgwEjByYIR9YcEI/8KCEQaGBeNUDqa83kqZKkZLaWUT7OZv571IolleYkW3+Vo2+y+OU3mYfhzzVC6mI8epfExHjlM5mY4cp7IyHTlOVT3eyZGWg2OwOxwxX5/kuP48J8b8k2NRPF8Hu4YdPH3j+GSjeA6uslE8r1bZKJ4rq2xI8XN7DeTBJlSe24/LZ3qFUn58d1mmaud1Jam5JuMlOVVTrytJzX09XpIzOQVvfFpJllog77/cd2am2p+XzEyVPy+Zmer+z8hYG8Ny+OPfm+U57J9n2s+//vY3XM7M5BL6kiSQZCI5k6e4mSTbL+icmcl/yKE+k1f5lHpy6x9/tIB9hbpLaf28IW2W01lIzuRV+pLU61WYSVq93uZTkpzvN53V65z6ctfsy3py1+zienIncO/CXbND7MkdNfZN3N9+Z+Qc6pmbuL/9Lsk51DOnuVe+uXAONQofSwJLNpaoJfhYau4hfzpPcX5f4Bz6yL3IoybuRR596k7kPfravcgrdoLOhBXl49UKVcg/3ra+dpvJGyg57r7JMevRybkf3BU7wa7cFbvGrtwJ3Bm4P1kqdpjsLBU7THaWij0jO0vFLpCdpWJfx82SFDu1T1m69eXn48WP2WEJ78XHEn6KjyXqSz6WmMdPswxkFpYh7LHEPM7GcqoNGDlZPulgZn5HB3PtOzqaO4zOrvtlOrd97lz53d5Ue0j2Jam5ouMlqblf+CFJvl81TrWnpRzqmr3LN+rR7szzmt1Ilc5Ue1by09HsL3zOKx2i6i9io1s7LNFvji72i6VmN/IblmmHpWbv8guW5HZYElieZrnG4mIM31juxRLNGkvcvqMqu+NMq2HP2VeOzm4ZZib77dhnTjX7qFlzqtnRzZpTzX5x1pxqdqOz5lSzh540p1Pt+IqcPnOKfsV8OUXfRGBOw/J5Zg5pJ6fo3wjMKa336QbgK6eEnErOafQ7OYU/HSGnLvgFigvB7eQJnnOMPL1WRY027OQJPlJEnqbaR3fmPMHvycgTPJyMPMGXycgTIU8i8oS6fAhPXF4fupW9HuNU+1lPnKep9sueOU+oy2XkCXW5jDyhLpeRJ0KeBOTJK9579+Y8OQorwhwqefIx++XomMtOnlBHyMgT6ggZeUIdISNPhDwNkCfy6zY55LPfyRN+ZzNEnsrah6WS806e8NuZwfIUjNl77uF7Ixl5wnsNGXnCew0RedK8X7aoPKEfISNP6EfIyBP6ETLyRMiTiDyhHyEjT+hHyMgT+hEy8oR+hIw8oR8hIk8O/QgZeUI/Qkae0I+QkSf0I2TkiZAnEXlCP0JGntCPkJEn9CNk5An9CBl5Qj9CRJ486vKb8mTX3QEeL4+q3y37NU/e731n6Ql5Gi1PZee7ZY+6XEaeUJfLyBPqchl5Ql0uI0+oy0XkifCeUEae8J5QRp7wnlBGntCPkJEnQp5E5An9CBl5Qj9CRp7Qj5CRJ/QjZOQJ/QgReQroR8jIE/oRMvKEfoSMPKEfISNPhDyJyBP6ETLyhH6EjDyhHyEiTxF1+aU8JVfJU4rLgq8pxfVYcl/YUWZ3wY6quQt2Avaz2FNaDnfZ+Ar24vOCsNCf66+P9925IJfXXLA5eC9uV7JdR2nc+4MfQ0lrcuw3KPlLASivORTwZIkS+DTL7MrKMpgdlmjzn2cZaWUZ40+WSfNTPvg1bheSrbAsaVll3hq7ebg+An+i1Py4jMauKNM28F2Ujz+5TlRu654Oqpq87Cr0+NuldrS166PYUqocncsCpdidR03S/NieNaeauxyz5lTzFxpSc1qKXydUk78l9efBsayjjMVWXFN+lEZfB2cX3Q9nkzRXkJDLp3LJmr9XgVw+lovm9jzk8rFcNL9WgFw+lovm1yGQy8dyIcgFcjkvFzQxIZcP5IL+6FRyeSYVDdIJk4oO6YRJRR9TXlKtcWbNKpnKdG1LXF/4lzLNt0UFTQ+Byn00H5bAHxn8+Twq6E3MmFVCVoVntexkFU5/xqzCkM+YVTjyGbMKSz5jtQRPPl9WyeAToBmzii91ZswqekszZhW9pRmzSsjqhFlFb2nGrKILMWNW0YUYIqvOrL96d+57Vp95Ql9BRJ4sOgUy8gTvLyNPcPMy8gR/LiNPhDwNkad16+1HmsxOnuChZeQJX1zIyBP8k4g8OdR7Y+Rp/d7b+X+I5Jkn1HtD5MmH9X76tlj0midCnkTkCfWejDyh3pORJ7ytkpEnvH+SkSf4JxF58nj/JCNPeP80RJ7IL99HOMq+cnSkZQ3wGF+9dR/3RpnDgiTn8u3YZ/7R59Cdf/RPdOefkP+p819eO3UYWyoHB+uX17bBZqocHaM3axze7ogLzSSI6zZxoQMGcd0mLrTtIK7bxIVeI8R1m7jQIIW47hIXoasLcd0mLrSiIa7bxIU+N8R1m7jQRIe4bhMXQVwQ113iQoce4rpNXOjQQ1y3iQsdeojrNnGhQw9x3SYudOghrrvEFdChh7huExc69BDXRXElv6okPYjsiAsdeojrNnGhQw9x3SYu9LkgrsviymEV1wb3S1xoRUBcV8VFbn1yPeL/Ka6Igh7iuk1cBHFBXBfFlcMCJOW4Jy68uIa4XrmhdbnZQH8u/UMuKNEhlw/kgpfLkMsHcoFHg1w2uVktfchm5zVKxAtgyOW8XBJe6UIum9xEs8rF1XyU9cat2fHmH5zUHvBX6h//jrZ2fAgrQxui2ZkcE5wa5NtOvuso/8i3Fo2lHNbgKaed/nsmyBfyvSpf69Y/7m3YeTpmPB0hrxvlhb4X5HWjvNAng7xulBf6apDXQW7SjlzQV4NczsuloK8GuXwgF3wrBbl8IBf8nAFy+UAu+IEC5PKBXAhygVzOywV9GsjllZuy7gkSSg47ckHfBXL5QC7ou0Aup+USDPoukMvrD5v187dobdqRC/oukMsHckHfBXL5QC7ou0AuH8iFIBfI5bxc8HUf5PKBXPC1HuTygVzQ1YVczsvFEuQCuax/2FJa5bKzwkawqF0glw/kgtoFcvlALqhdIJcP5II30pDLB3LBG2nI5bxcHN5IQy4buaxHR/cPP0v7eXR2tKgku+heQecvbeH1NbR1l7bwrhvauktbeDEObd2lLYK2oK2btIW2NbR1l7bQ44a2LmrLxrAugP/490ZdrzYEeuKQ143yQg8d8rpRXui5Q173ycujRw95XZdXsi955T15od0FeV2WV8y0yiuZnW8vPUFekNdVeSX3mhwTxR15oekFed0oL/S9IK8b5YW+F+R1o7zQ94K8bpQX+l6Q133yIvS9IK8b5YXPUyGv6/LK8SWvDfCXvPCFKuR1o7zQtYe8bpQXQV6Q11V5ZbPujBuztTvyQtce8rpRXujaQ143ygtde8jreu21+SAnW1c7/sK29GvjI4RSduSLtwKQr2D54q0D5CtXvgFvNSBfwfLFWxPIV7B88VYG8hUsX7z1gXwFy5cgX8hXrnzx1gryHVi+62uLEI3ZkS/eikG+7eS7jvKPfGvRWMqvBNE//v2/8o3oPEC+48o35Jd8084XVRGdB8hXsHzReYB8BcuXIF/IV6588cUZ5HtdvmHztX/ckxe+CIO8bpQXvtiCvO6TV8IXVZDXjfJC3xHyulFe6AtCXjfKC307yOtGeRHkBXndJy98cQN5XZZXXnk//h3SjrzwRQzkdaO80LWHvG6UF7r2kNeN8kLXHvK6T14ZbVXI67K8yuvj+Fgi7cgLbVXI60Z5oTEBeV2XV3xNjiXt/NKs4JU25HVVXsnZdU+2x7/DjrzwUgjyui6v4F/yyjs/NCwEeUFe6x92Ia3yyukXRz/FhcoL4rpNXHghBHFdFJfN8fWzj8e/d1xjwQshyOtGeeGFEOR1o7zwQgjyuk1e0aDnBXndKC+8b4S8bpQX3jdCXjfKCx17yOtGeRHkBXndJy/07CGvy/JK9pX4FOyOvNC1h7xulBe69pDXjfJC1x7yulFe6NpDXvfJy6JrD3ndKC907SGvG+WFrj3kdaO80LWHvG6UF/pekNdleWWzbneWszU78oJzhLwuy6tsnl7F7zy9HJzjTfJKRKu86PvRT/IwVb3Iw2/0Io9SvBd5AvlO5PHZRS/ycGZ3kU+v0jnZHfJ4Wd+LPN5j9yIPo96JvIeH7UUeHrYXeQL5m8iXV1VZ4g551DY3kc+0dEJdDn6HPGqbXuRR2+yT/0uHUH+8o4Ma4R0d9KLf0UG/+B0dAp03dDT3XYtbPytwpaTK/B/Na+nJTcX7eM39JKm5j8pLUrN34CWp2QvwktRc27OSDJp9AC9JzXXfhyTXl6Bx83XqiyTm7tMk4+ujvbxDUvHc7X1a2FhPwVVI2kcw62IUNqfXZ61xt+Nq3NpxdW5z7JO74pm+K3fFdUFP7lFxFcHI/clSce+RnaXiTiU7S8X1LTtLAks2lop7puwsFTuvz1muv8Wythj7tn4qNi2RF7v5DdTCHT6tD3f4tC7cE2rcPtwJ3O/h7lZ/XJzLP7ijRunDHfVMH+6oZ/a5P+mg6nhHBz3cN3QyOq3v6KCufEcH3dB3dDT3N4N90QmbvtCLDoHOGzqa6/s6Hc1VeJ2O5lq5TkdzrVyno7lWrtIpmmvlOh3NtXKdjuZauU4HtfI7OgQ6b+horpUfc9JKJ9nvdHb+uivLJ+fe29f2aF9d1qK5ruYlqbkG5yWpuV7/kOTj+JXkt3e1P48lu1InZ3+81y2afUAv6knzvvPfqbuf83zSvG36H2e+oRN36Gj2F8nbF51gfzXjJM0bXDOTJJBkIqnZ43xIknE+1uyH+lHX7J2+UY92Z55X7Yde24Q86LgdOop9C5m0xk2WUuWOfb/6QNK8myYzScW+hZmkYo/DTFKxx2EmSSDJRFJx3fcpybfr3STN+5l9SvLtejdJ8/5k5P3akSX/D6uA/zzepbT89cc///EXHEnzfmPMJDXP3bwkNc/dn5G0Kfp1nCnST5aKO5TsLBX3HdlZaq4quVkq7j1ys9S8a9DHLNNrlZnHv8sPlpjHP2CZ8otljj9Yap7H6cWGgqNvLJ90NM/MdTqa59o6Hc2zZ52O5jd3VTqad1c6QUdzLVWno7nzVqejuZtWp0OK6URav7mlmH2tsn57/JOm5tqan6bmWpyfpuba/TOaDxBL4M6bzRvGnL5Yaq70uVlq9gXMLDXvzcTOUrPn+AVL63ZYanYo3Cw1+xlulgSWZ1n61Uo6X8I3ljtHv939JwX4pD7c4aj6cIf34uD+ZAnvxccS3ouNpeYd7dhZwnvxsYT34mMJ73WaZaBlmC5sf+e8siSwZGMJP8XHEh6JjyXqSzaWCfP4WZaPfr5b//r26JUl5nE+llPN455Wlo/HV+XoEpcxWmNeTR+X7ReaqaZlXjRTzbK8aKZqFn6EZrMK4p8fKmyOLl9spmr+MbOZqtjiZTPXJmjMbKZqtjGzmaroZmYzVRHNzIbA5pCN3qq4zkZvWVxng7r4mA3q4mM2qIsP2cy14RkzG9TFx2xQFx+zQV18zIbA5pAN6uJjNqiLj9mgLj5mg7r4mA3q4iM2ea6Nuj5iQ8Yua3GRJdpho7currPRWxfX2eiti8mmsrIp5hubnb/9dquobAgcWTjqrbd5OeqtzT/kyLaFVp5rCy0hzPV6CXJ+ndtdyhXmlMvyt6lsfgy5f3RIy58OZYMvf0HXa1L6QZ9razAp0BXbqn7QFfu1ftAVG8HPoJfwgh7LT0s9195kXUkqNoMfkizrvW3cTpvHKraDn5J0K0nKOyQVm7xPSa5hmxB3SMK6cZGEH2MiOdcejp+R9OtqSeT/gc1nRz9JKnZOzCQV2yFmkoo9zkckLaX155DBbn9fvBf3+x2G81z7PYqhrtg7daSu2Gd1pK7Yk3Wkrti/9aM+1w6W41Cn5eAY7A51AvU7qMflT8eYd6ijhjlJPdh1kMHTN+pPkqhLuEii1uAiifqBi6Ti/u+Hs9Ma9oNkqMxOj2AzvQIvPz4+m2t/UEHcUQP34Y5OdB/u6Fv34U5Tcc/L0Z5c+Hb0c7RTVbZ5/bbIF0M/RzvVrnxk16PJlrgz2pmeII+bfH3nn6zZGe1M9219tDN1SeqjnamTQen19Uo2pnJ0Xsf4cHzrsX+WqP15bFkf9qV8P/ZJcaZnfT+KM3Uw+lGcqXvRjeJUO131ozhTZ6EfxZn6BP0oTlWzd6NIoMhAcSqP0Y0ivAsHRXgXDorwLhwU4V0YKCZ4l1MU3+9RlBPMCwtGuBcWjLAvLBgJGDkwwsCwYJyq9q69NZ1qY7v6aKeqZWujnWrzOXJmXUnFUd4Z7VSlYXW0U1Vw1dFOVWhVR0uqRjtV2VId7VT9UR+WsImMqxwd4/qrv/wq6Jz9Wrlgqm3WeMlMVaOxkpmqnnvzXdiOjVnXRbS2bP40faGZaoc1ZjRTfeNf+wp4rm3BqqMlVaOd6tfDZf0NoC+xdrRNy8zgjK+0fBjf48y1IZgI4lP9ZkME8al+tTwG8UrTea490SQgL3NttSYD+VQ/apaBfCqvIwP5VIZLBnKaCvm6vhRZqjU7XPLLr8dd+rYtVdiFHpZGSjaJvh39JDmXo+xJci6n2JPkXA7wRpJ2XeIvOxt3SM7l7HqSnMuwdSQ516ZvXUnOZa96kpzLNfUkOZcZ6kmSQJKJJDwOF0l4HC6S8DhcJOFxuEjC4zCRnGvPta4k4XG4SMLjcJGEx+EiSSDJRBIeh4skPA4XSXgcLpLwOFwk4XFOkozrIHPK7idJD4/DRRIeh4skPM5JkiUukeSS7Q5JeBwukgSSTCThcbhIwuNwkYTH4SIJj8NFEh6HieRcuyF2JQmPw0USHoeLJDwOF0kCyVMki3Hm6+hitrs5riThcbhIwuNwkYTH4SIJj8NFEh6HieRUu8b2JQmPw0USHoeLJDzOWZKpLCT/7sT+gySBJBNJeBwukvA4XCThcbhIwuNwkYTHYSI51U7SfUnC43CRhMfhIqnX4/jXnkDe5VghadMrkhRpG/YTJAEkD0i9DocZpF6DwwxSr79hBqnX3jCD1OtueEFOtdV0V5B6vc2HIEtZjnbGVMKOxiyvKKKxO9T1+qAbqYeymqZ96vBMZ6mve/I44937sGmzG+Dm52k+7z6Nin09jop7he1K/EoSIUnjJwleT0CS4CMFJAkeVUCS4H8FJAneevwkZfh2AUlCT0BAktBCEJAkdBwEJImQpPGThI6DgCSh4yAgSeg4CEgSOg4CkoSOw/hJKug4CEgSOg4CkoSOg4AkoeMgIEmEJI2fJHQcBCQJHQcBSULHQUCS0HEQkCR0HEZPEhmDjoOAJKHjICBJ6DgISBI6DgKSREjS+ElCx0FAktBxEJAkdBwEJAkdBwFJQsdh/CRZdBwEJAkdBwFJQsdBQJLQcRCQJEKSxk8SOg4CkoSOg4AkoeMgIEnoOAhIEjoO4yfJoeMgIEnoOAhIEjoOApKEjoOAJBGSNH6S0HEQkCR0HAQkCR0HAUlCx0FAktBxGD9JHh0HAUlCx0FAktBxEJAkdBzuSJJftmWhlL8l6QmdAL09dHQEzkF3dh2ks5tIntvbPEDCtTOBhLNmAgn3ywQSDvUsSO9XkKUwlmy+5GWIZO16tF+mMYI/HT5FcKfDpwjedPgUwZkOnyJCikZPEVzv8CmCnx4+RXDqd6TofcOO4OrbQw9T2UufV4zkwrejn6OdyqlVRzuV6amOdir/QP412hQrR9u0TGfOvP6yy3bn2LzyyL5Uji0r8lK+H/skTiDemPhU1b0I4lMV62MQj8ux1hi3g3yq4lsG8qlKbxnIp3r1JgJ5nMrryEA+leGSgXwq1/cG+XO0Wlzfc7SkarRzuZ28NKh9Jlt7eLi83uXe0+bovPu3XVhJUvx29JPkXC6mJ8m5zElPknN5jhtJhvWjfh+y2SE5l5XoSDLN5RB6kpyr8O9Jcq56vifJubxCT5IEkkwk4XG4SMLjcJGEx+EiCY/DRRIeh4lkhsfhIgmPw0USHoeLJDwOF0kCSSaS8DhcJOFxuEjC43CRhMfhIgmPw0SywOOcJFn8+rM5U/IOSXgcLpLwOFwk4XHOkST3IumC2yFJIMlEEh6HiyQ8DhdJeBwukvA4XCThcXhIWgOPw0USHoeLJDzOWZKpLCT9P5D87OgndziiPtwJ3Ltwh9u6g7ulddEiG+wm7rw3ymiWHzhGt/l9R/ZfOYKPGz9HcIjj5wjec/wcwdUOnyMLvzx+juBjBsgRLQfHYHdyhLpugBxFt+Qo5p0coa67JUfBrkjC9m9n+uKOWq0Pd9RfXbg71FR9uOONxT1z8DrIB/dQmYMfQ3uFUlxJ6/HxK0t4GyIhS/AcErJEyJKALOG9jIQsKXbw/kUyGl/j/uboJ0nFPpuZpGLnzExSsRf+iKRzZtkax5Hf+crAK3a3zCQV+1Vmkoo9JTNJxb6PmSSBJBNJxf6JmSQ8DhdJeBwukvA4XCThcZhIEjwOF0l4HC6S8DhcJOFxuEgSSDKRhMfhIgmPw0USHoeLJDzOSZLBLUe7sPcbR4LHOUmSfFlJRlM5mm9vaBvgnUbPEDzZ6BmC1xs9Q/CQo2eIkKHBMwTPO3qG4KVHzxA8+ugZgvcfPUPoKQyeoYiewugZQk9h9AyhpzB6htBT6J6huP5GzBi3kyJCikZPEboKw6cIbYXhU4S+wvApQmNh9BQluKKTKQoxrSkq9ZWAivHLHw9lsy7c12/5k9wa4Bm/3AnyGf/gs0fxq3wKUeVPuxSXQFxKfvunn4Md/DnMO9jBe6Wsg82Dtx15Bzv4XMU72MGbYbyDHbyvxDtY0jTYweucDwdbluV7HwU0/Rzs4EUR72DnqqAqg52pgvLOlFfY6edgZ6qgaoMdfctx3sHOVEFVBztTBeVfP+DZH+xM8+yjMbP8aU/O/BzsTPNsdbAzzbPVwU41z9YGO9U860teB2vN+z8dyrqMaijlx9PMjb5H7n1kolmf89H8LETd6HveNtHMPpmppvvXCyFPm918rt1NM3VXrpLZ1wxNRSbFlUzJPwc7V4lYGexcJWJlsHOViJXBzlUivgYbNu/n18FOVSJWBjv6To+8g52qkKsNdqrazLv1K5NgU+VPx7zU8zbR5rMRn7/Q0ExoUl4dbyr+d2Wrnape+YRMzQSOvpVnE83sk5mqEnr9af8PL6V2/rQp65+23uw8aKaqm7Jbw86l8qfJLM9rct+fwDthvFoS9tG+W4/2K8apKrJuGEffgVIKxqmqyH4Yp6pP+2GcqtHYDyMBIwfGqfzDRxj9Yh8o5Z+V4Oj7CPYDg98r/fnbrX8M47D1XR/u2CivE3f86O4m7p5e3DeLM8eDo93m6PgjS1iOREKWsCSJhCwRstQ9S38+r1zt1ebF1ZIjLEsyfo6wLsn4OcLCJOPnCE5//ByhKzB8jrANpYAcodswfo7Qaxg/R+g0jJ8jQo6GzxH6DOPnCH2Gu3J01Cfd+dvZr1/V2xhrf7uso3wkdDPKYL5yir7EfDlFH2PsnD6zhE6GgCxhW9jmWXpyV+yrXF5LNu+pQpLc+uMX8qHKndKrHNx8g2Lz7k+OaDk4bn5Ub7P/yhEhR/1zlBZ+MYedHCn2VWJypNhXicmRYp8kJkeKfc9AObJrjuJOjhS7Hik50rxtpZgcKX5/O06O4uJhY8w7OVL8/lZMjtBnGD9HhBwNnyP0GcbPEfoM4+cIfYbxc4Q+w/A5mmsLS09rjnyKlaPJG/eivj26/J76+zdCaSrHMw71933PNJWHEUOdQL0D9al8hhjqUzmHgai/7fGOvh3xpNSnqu7FUJ/qveA41N+7pNF3ip6UOrxpD+rwpj2ow5v2oE6g3oE6vGkP6vCmPahPVa8bv1I3pRaIpUjLa43Hv/Pmr//ZrvLH8S7k5Ve1j39uoOT0ZDn6buOiWE5VW3dmOVXF3JnlVHVwZ5YElmwsp6pZ72WZ1qU0Hi//zA7LqSrRziynevfRmeVUbzQ6s4Tv4WL5MK9geZZlLEvgj3/6HZaYx0+zzHk5/GG9ww5LzONnWT7u4ddfd2WHJeZxPpaYx/lYYh4/zzK59a/n73PPZ0f/JW/R7exFHr3Re8jHHNbP4vNmRb74xR11bh/u6Ln24U7gfg/3skKJxaUf3OEB+3CHX+zDHd6yD3f40D7c4Vm7cHdwrH24w6/exf31M+4SfnKHX+3DHX61D3cC9y7c4Vf7cIdf7cMdfpWD+1+WHjX5WZbVb0c86mw+lqid+ViiHj7N8tu3drTDksCSjSXqVj6WqEX5WKK+PM/SvVj6Wl3v3bov6qNYon+s6z3eh/ThjvchXbgTvNdN3H0sK/e87R98cuwzR/B04+cIXnH8HMGD9s/R+33pPRFyNHyO4JnHzxG8OEeOnizhxc+zfO0cnlLeYQl/fZ5lXnvqqez87o3gmS/pco9lgA/mYwm/yseSwPIsyxyWYT7+uccSdSsfS9SXfCxRX/KxRH15niW5tyzn2pe67zo0c+0f3Zkl+rh8LAks2ViiJuJjqbm34b1ZWfoSKyxtSsEvxz/+/cLy1QtOmnsb3Cw110TcLDXXRB+zTPnFcrPr2sJSc03EzZLAko2l5p4bN0vN9SU3S809N26Wmntu3Czhe9hYzrUjameWmutLs+6obslSqrCMrx+OB7vpbPgvkgSSZ0m+3cnez7VHY1eSmitLXpKa60pekpqryk9J2pVk3CGpuaZkJal6d09ekpr76B+SfLt7r1e9sycvSXgcLpIEkkwk4XG4SMLjcJGEx+EiCY/DRRIeh4ckad7J0/t1qUrrKbgKSWtzXrvstpjt7jk/jy42LZEX+2N1AjKKq8+u3Anc7+Hu7AKlOPeTu+LKtit3xXVwV+6Kq+au3BXX2Ddz93bl7ssP7oor8p7cNe/J25W74jcaXbnDr/bhDr/ahzuB+03cjXvVkfkHd/jVPtzhV/twh1/twx1+tQ93+NUu3DXvyNuVO/xqH+7wq324w6/24a64fnfFraviuFKqX2a8/eUYad5z9FOSb39bQk5xjc1MUnHVzEtS8y64zCQVV7Yfk3z3Kx3SvAMuM0nF1SczSQLJsyTff+mree9bZpLwOFwk4XG4SMLjcJGEx2EiqXm3WWaS8DhcJEkxyWjsSjJtA98l+fiTdoUSQ+Vol8prX71/WIHsSV5z/Xkr+eyW9r3LPu+Q11yv9iWvub7tS15zPXwvebPuYZdt2iGvuX7uSl7zrpadyWuuz/uS1/zOoi95ze84+pInkO9EHh62F3l42F7k4WF7kYeHvYt8eu2Fm3a6BwEethP5CA/bizw8bC/y8LB3kV8jf5AvO+ThYXuRJ5DvRB4e9i7ylFfywe+Qh4ftRR4ethd5eNhe5OFhO5FP8LC9yMPD9iIPD9uLPOr5m8jHdVmEx98utaPJ++Voyr5ydKTXV8qvzr+Pe6Msed2r12zC2D84urAAjC7X/vSflR/Wj6tz/hPq5vinvGBaIK/r8qJX4rdPr5e84MwgrxvlBfsJed0oL3hsyItHXtH9lFdGIwHy+oW86CWvFGp/vay8Y9l+jZR3Ds5u/dvZbZT7OPgpXPRhIFyRwkUbC8IVKVx8yQLhihQuQbgQrkTh4r0LhCtSuHijA+GKFC7eFUG4IoWLt1AQ7mXhFrcCfPw7fjv+r7wKuq2Q1/XnYnl9AVTMzhdAhSAvyOvy08u+El+83ZEXqjrI68anF2ovyIun9vJ78sIXQJDXbfIKBl8AQV43ygvOEfK6UV74mgbyui4v/2rYFqIdeeGbF8jrRnkR5AV53ScvfD8Ced0oL3zlAXndKC907SGvG+WFrj3kdV1elXeOwaBrD3ndJy+Lrj3kdaO80LWHvG6UF7r2kNeN8kLXHvK6UV4EeUFe98kLXXvI60Z5oWsPed0oL/S9IK/XH7br0Q+lmZq8kvPrH0+PIfyUl0PfC/K6UV7oe0Fe1+UV/UteqezIC30vyOtGeaHvBXndKC+CvCCv++SFvhfkdVle3qzZSQ+h7MgLfS/I60Z54WtVyOtGeeFrVcjrurxoI68QduSFrj3kdZ+8PLr2kNeN8kLXHvK6UV7o2kNeN8oLXXvI60Z5EeQFed0nL3TtIa/r8vJbecUdeaFrD3ndKC907SGvG+WFrj3kdV1e6xj//HvniwmPrj3kdZ+8CF17yOtGeaFrD3ndKC907SGvG+WFrj3kdaO8CPKCvO6TF7r2kNd1eaWNvIrZkRe69pDXjfJC1x7yulFe6NpDXpflRXZdeDyR21ljgtC1h7zuk1dA1x7yulFe6NpDXjfKC117yOtGeaFrD3ndKC+CvCCv++SFrj3kdV1eZiuvnR3RArr2kNeN8kLXHvK6UV7o2kNel+Xl8mt1QvKhdjx5ux5Puws2BXT5Icd2cvThJcdgq8fnsAZPOeWf8o14iwD5tpNvoJd8447zjXjrADn2eZruyhFvKSDHgeSItxqQ40ByJMgRchxHjnhrAjm2k2OKLzkWx+DE8VYG8m0n3/J6mj5a7jtyxFscyLHL03RfjnjrAzkOJEe89YEcx5FjwlscyHEgOeItDuTYTI5k00uO3v/eiSe89YF828nXb56mtLPyesJbH8ixz9N0V44EOUKO48gRb30gx4HkiLc4kONAcsRbHMjxFjk+5YW3MpDXjfLCWxbI6z55Zbw1gbyuyyu85OWy2ZEX3oJAXjfKC28pIK8b5YW3DpDXjfIiyAvyuk9eeCsAed0oL3T5Ia8b5YWuPeR1o7zQtYe87pNXQd8L8roqr1ji+ko7llR25IW+F+R1+ellXol//DvuyAt9L8jrRnkR5AV53Scv9L0gr+u1VzEbee0sdlvQ94K8bpQX+l6Q143yQt8L8rpRXvhaFfK6TV7R4GtVyOtGeaFrD3ndKC907SGvG+WFrj3kdaO80PeCvF65sb4subGZKkcnisvffvyz7IgLXS+I6zZxoecFcd0mLnS8IK6r4op2yXuKLv0Ul0W/C+K6TVzodkFct4kLvS6I6zZxodMFcd0mLvS5IK6r4gp5UUkKZaeJauEWIa6r4kplCTplb3+Ky8EtQly3iQtuEeK6TVxwixDXbeKCW4S4bhMXQVwQ10Vx5WBXce3s5h4dfskIcd0mLvS5IK7bxIXvuSCu28SF77kgrtvEhQ49xHWXuDw69BDXbeJChx7iuk1c6NBDXLeJC30uiOuquLbfc+116D36XBDXbeJCnwviuk1c6HNBXLeJC30uiOuyuOL6VURM+ae4iCAuiOuiuNLKLyVLO+KCW4S4bhMX3CLEdZu44BYhrss1V0kvcYUdccEtQly3iQtuEeK6S1wB7xYhrss117oV4+OfOzVXwK9/IK7L4tr8+sf6ytGWclhDobzXFwsEMUKMF8WYbVzFuNfRD+iLQVwcT7pdcaEvBnHdJi70xSCu28SFvhjEdZu40BeDuO4SV8SvhSCu28SFvtgQ4nK0IHQumW9HP/NEyNMIefJu+dvOk9/JE7ovMvKERoaMPKEnMMb8lF95+odInnmCvZaRJzhVEXlKMH0y8oTVFmTkCR8XycgT+hEy8kTIk4g8oR8hI0+a/ZMJrzw9RlxlafLaK3WbXmmOXyw1exxmllmzD+FmqdkrfMqS1pdtLvhvLHdicWUh7/3mF3cLd821f0/ummv5W7n7WFbuOW24f3LsM0eEHA2fI801vJQcaX6fOEqOyK7zETn7M0ea3yVKyRF88Pg5gr8+nSP/+q7LJ1PJUUhLQkPZAMxP7AVWvAt2uPYu2GHau2CHZ++CnYD9LHZ6vUqh7V/fxf6YNZejH0/ytAX/8+DsaOGdXXQ/swQjLiFLsOISsgQzLiFLsOMSsgRDPn6WkoF/l5Al2H0JWSJk6WyWglvbxMGFb1l6skQldp4lrR/9hfDzE59k8Yw/z3I93IWYd1jiSczHEt1UPpZokXI8L688XQnkO5FH5/Me8jGHBWHM6bVAy8Idvcw+3FET9+GOfuNN3MsK5fFqPf3gjg5iF+4OfrEPd3jLPtzhQ/twh2ftw53AvQt3+NW7uK8vZmIJP7nDr/bhDr/ahzv8ah/u8KtduHv41T7c4Vc5uD9Zkl6W9lGhLX/cFuMrLC2lBYoNdvsTw73I40vCwW6O9V/cFdfk93JPqxXKYYe74pq8K3fFNXlX7opr8q7cFdfkN3NfP5z9Uzv+I3dSXJN35a64Ju/KXfE7pHu5x9eeVXmHu+J3SF25E7h34Q6/2oc7/Gof7vCrfbjDr/bhDr/ahXuYqX535bWsnrGmxp2znx5mqsdv5fi+bxUIHFk4zlQv9+Q4U/3bk+NM9ey9HN/228JM9WlPjjPVmx05xpned9zK8X0dHmd6f9GTI/wMD0f4GR6OBI4sHOFneDjCz/BwhJ9h4Zh2Odq0bt63aYe6bHcukFfk2ZfKsSUvVEr5fuwzmDxSMGWgYPZ3nuwVjB0pGDdSMH6kYGikYMJIwcSRghnpCZxHegLntk/guM6qxrif0RQzVDR2qGjcUNH4oaKhoaLZf9pQKWtJGdz72jab5a7NtCmx/ddqxPur5LNeodx8hby/OjnrFeztV3C3X8H//gphcWA5xW9X2HFJpixWxlnzOprc3h/OyzrPxbraH/ZlGacj83p55teBkpaBBi0DjVoGWn/ep28DfZ6VL51Vrpxl/d3PKUu3XyHcfoV4+xXS7VfIt1+hKLmtndEyUKtloE7LQP2VWcLRpbPClbMO1mZw6z7Q3tvXwhvx66R45aR05aT9T5A+2NL6+NjnBcrNFzj4kS7jBexvL/B+1+988LNLxgv4my8QdnPgHi+Elrv38Trmx0n2yknuykkHT4lPXn09jvg6OGzfBX69+sqB7r9EuP8S8f5LJNZLkNm5RL7/EuX2S0Rz/yXs7y8RzfJgiC7uXMLdfwl//yXo/kuE+y8R779Euv8S+f5LlNsvkcz9l7j/7k73393p/rs73X93p/vv7nT/3Z3uv7szx33x9td9OXMo6u2HUPnga4lg10/Egqdvl3ieFq6dFq+dlq6ddvD8XT9oe5wWKvhscXmlXVz5YSgO3tbzXuTgJTzzRWyLi7gWFwm335qF4xn29rdruaT7L5Hvv0S5+xLFmPsvYe+/hLv/EhzzydsfZhVD918i3H+JePfEW0y6/xL5/kuU2y9hzf2XsPdfwt1/CX//Jej+S+yKNoSlaxryttIzXyeVCyftv0ysnbQvFZPWUf35d/mHiqQcvOYyqawlrHm87P5xmr92Gl07LVw7bf9habL3r9M2i7Avp6Vrp+Vrp5VLp/mDvJXXcvSmRPvjtAOSJS/L0ltrzA+SPl47LV07rVwa2/5brPppBzdOKX4TZPhxmrt2mr92Gl07LVw7LV47LV07bf/GeRxaXqe5rUr++XNN7a+nxXyR/Xd43Bexv7/I+3eRZf8NIe8l/P2XoE8v8TwtXDstXjvt2iPy4P1c9bRy6bRorp1mr53mrp3mr51G1067NpHGaxPpwauOFNYHa0rbn6nulbcumfULo+Tcj0vY+y/h7r+Ev/8SdP8lwv2XiPdfIt1/iXz/Jcrtl8j33935/rs733935/vv7nz/3Z3vv7vz/Xd3vv/uzvff3fn+u7t8fHc/T7PXTnPXTvPXTqNrp4Vrp8Vrp6Vrp+Vrp5ULpwVjzLXT7LXT3LXT/LXT6Npp4dpp8dpp6dpp+dpp11Rir6nEXlOJvaYSe00l9ppK7DWV2GsqsddUYq+pxF5TibumEndNJe6aStw1lbhrKnHXVOKuqcRdU4m7phJ3TSX+mkr8NZX4ayrx11Tir6nEX1OJv6YSf00l/ppK/DWV0DWV0DWV0DWV0DWV0DWV0DWV0DWV0DWV0DWV0DWVhGsqCddUEq6pJFxTSbimknBNJeGaSsI1lYRrKgnXVBKvqSReU0m8ppJ4TSXxmkriNZXEayqJ11QSr6kkXlNJuqaSdE0l6ZpK0jWVpGsqSddUkq6pJF1TSbqmknRNJfmaSvI1leRrKsnXVJKvqSRfU0m+ppJ8TSX5mkryNZWUayop11RSrqmkXFNJuaaSck0l5ZpKyjWVlGsqudZ7tdd6r/Za79Ve673aa73Xx39eOy1cOy1eOy1dOy1fO+2aSq71Xu213qu91nu113qv9lrv1V7rvdprvVd7rfdqr/Ve7bXeq73We7XXeq/2Wu/VXuu92mu9V3ut92qv9V7ttd6rvdZ7tdd6r/Za79Ve673aa71Xe633aq/1Xu213qu91nu113qv9lrv1V7rvdprvVd7rfdqr/Ve7bXeq73We7XXeq/2Wu/VXuu92mu9V3ut92qv9V7ttd6rvdZ7tdd6r/Za79Ve673aa71Xe633aq/1Xu213qu91nu113qv9lrv1V7rvdprvVd7rfdqr/Ve7bXeq73We7XXeq/2Wu/VXuu92mu9V3ut92qv9V7ttd6rvdZ7tQe917J+YWgL2Z3TDlSyLulnS3HfTttbypdpo5BHOGWocI56xb3CsWOF48YKx48VDo0VThgrnDhWOGmscMZ6KuexnsplrKdyGeupXMZ6KpexnsplrKdyGeupXFo/ld/ucfWIJw0WTx4snjJUPM6YweKxg8Wzv4D6o7D/Os05GyrxPPoBZg0/pn9cveBxEd/iItTiIoHlIj6+LhL95iI7v8jLflkYyJvtuk9mfzlVs665Zvzrt/fFfMUfB48/rPxj8P5n/El4/Fl4/EV2/PsfPgiK3wqP3wmP3wuPn4THP/r8W4tf+Pxrhc+/Vvj8a4XPv074/OuEz79O+PzrhM+/Tvj864TPv074/OuEz79O+PzrhM+/Xvj864XPv174/OuFz79e+Pzrhc+/Xvj864XPv174/OuFz78kfP4l4fMvCZ9/Sfj8S8LnXxI+/5Lw+ZeEz78kfP4l4fNvED7/BuHzbxA+/wbh828QPv8G4fNvED7/BuHzbxA+/wbh828UPv9G4fNvFD7/RuHzbxQ+/0bh828UPv9G4fNvFD7/RuHzbxI+/ybh828SPv8m4fNvEj7/JuHzbxI+/ybh828SPv8m4fNvFj7/ZuHzbxY+/2bh828WPv9m4fNvFj7/ZuHzbxY+/2bh828RPv8W4fNvET7/FuHzbxE+/xbh828RPv8W4fNvET7/Ftnzrzey519vZM+/3sief72RPf96I3v+9cOvf1WLX/b864Wvf+WFr3/lha9/5YWvf+WFr3/lha9/5YWvf+WFr3/lha9/5YWvf+WFr3/lha9/5YWvf+WFr3/lha9/5YWvf+WFr3/lha9/5YWvf+WFr3/lha9/5YWvf+WFr3/lha9/5YWvf+WFr3/lha9/5YWvf+WFr3/lha9/5YWvf+WFr3/lha9/5YWvf+WFr3/lha9/5YWvf+WFr3/lha9/5YWvf+WFr3/lha9/5YWvf+WFr3/lha9/5YWvf+WFr3/lha9/5YWvf+WFr3/lha9/5YWvf+WFr3/lha9/5YWvf+WFr3/lha9/5YWvf+WFr3/lha9/5YWvf+WFr3/lha9/5YWvf+WFr3/lha9/5YWvf+WFr3/lha9/5YWvf+WFr3/lha9/5YWvf+WFr3/lha9/5YWvf+WFr3/lha9/5YWvf+WFr3/lha9/5YWvf+WFr3/lha9/5YWvf+WFr3/lha9/5YWvf+WFr3/lha9/5YWvf+WFr3/lha9/RcLXvyLh61+R8PWvSPj6V2Rkz78kfP0rEr7+FQ2//tXrT8dU7Db+vYOXqGOOrz+c/ddYR5+rOcc6+rzOONbh1+DiHOvo9cJHY41uOTbmnbGOXltwjnX0OoRzrKRorKPXN5xjHb0W4hzrVHVTZaxT1U2VsU5VN70f6+hrp4US8loLJf9+rI83SX7504Vo86f3jrbeu+VvW78F6Ur8ojN4pdWZzuC1WWc6g1dzbHSeoyVVox28omMe7eA1HfNoB6/qmEc7eF3HPNrBKzve0Y6+Ll9yefnTKZnyfrQ2meVP2xRfB1u/C9IsaB5t0Mqx7DP/6OsJTst98Hp0Wu6DV7oCuD85EjiycBy8OhfDcfRerjHrezLj45bjM345lXzKtqKDEGl5iR+2peH+UzvbtPzpx19+oXHZfbGRU/e3ZyPHJTRnM/pao13ZyOkWt2cjp1fcno2cTnF7NgQ2h2yGqnOfIQ1VMj5DGqoKfIY0VPH1DGmomudvSGMtq/oMaagZ/hnSUBPrM6Sh5rNnSENNI8+Qxnt6j7WQ6DOk8Z7eYy33+QxpvKf3WItyPkMa7+k91tKZz5DGe3qPtcDlM6Txnt5jLUP5DGm8p/dYi0U+Qxrv6T3Wko7PkMZ7eo+18OIzpPGe3mMtj/gMabyn91iLGD5DGu/pPdZSg8+Qxnt6j7Ug4DOk8Z7eYy3b9wxpvKf3WIvrPUMa7+k91hJ4z5DGe3qPtVDdM6Txnt5jLSf3DGm8p/dYi749Qxrv6T3W0mzPkMZ7eo+1gNozpPGe3mMtc/YMabindxhrMbJnSMM9vcNYS4Y9Qxru6R3McE/vMNZaXc+Qhnt6h7FW1HqGNNzTO4y1PtXfkMZaRuoZ0nhP77EWZXqGNN7Te6wljp4hjff0HmvBoGdI4z29x1p+5xnSeE/vsRazeYY03tN7rGVbniGN9/Qea0GTZ0jjPb3HWhrkGdJ4T++xFtl4hjTe03us5SqeIY339B5rkYNnSOM9vcf6Kf0zpPGe3mP9wPsZ0nhP77F+Kv0Mabyn91g/DH6GNN7Te6yfwT5DGu/pPdaPPp8hjff0Hu+3lmG831qG8X5rGcb7rWUY77eWYbzfWobxfmsZxvutZRjvt5ZhvN9ahvF+axnG+61lGO+3lmG831qG8X5rGcb7rWUY77eWYbzfWobxfmsZxvutZRjrt5Y/j9786d9uNxXG+hHnzWMVtBx2Ku79WG0priyBlOJfgS9Lt4axfnp6/3jH+l1rg/EK2sCEZbyCtiRhGa+gTUZYxku6xsv0S851/9fHv23ajPd5kY9F9DyNrp0Wrp0Wr52Wrp2Wr51WLp32+S++nqfZa6e5a6ddU0m5ppJyTSXlmkrKNZWUayopl1QSjbl2mr12mrt2mr92Gl07LVw7LV47LV07LV877ZpK7DWV2GsqsddUYq+pxF5Tib2mEntNJfaaSuw1ldhrKnHXVOKuqcRdU4m7phJ3TSXumkrcNZW4aypx11TirqnEX1OJv6YSf00l/ppK/DWV+Gsq8ddU4q+pxF9Tib+mErqmErqmErqmErqmErqmErqmErqmErqmErqmErqmknBNJeGaSsI1lYRrKgnXVLL/Vpriehol63ZOi/un2ddpzvzn+55ANvR1cPavRetdtjvHlnW3olK+H/sMJ40VTh4rnDJUOPtvivuFY8cKx40Vjh8rHBornDBWOGM9leNYT+U41lM5jvVUTq2fynE51hrjduKxg8XjBovHDxYPDRZPGCyej5/Nz9PStdPypdOYliN9+6ovMi0wWrkItbhIaHGR2OIiqcVFeD5sIvu6SCibi3z2mv0ZUhkuJKalN1lDsq1DIluWbxjI/VQS08KbjAH50QLief598pFKMGb524FK7W+XsP7pkjcbun9tLBg7LNHJPIAofQBJ+gCy9AEU2QNIHRYiZR6AlT4AJ30AXvoARp+Jc/HL0cZ/H8COJa5sCJzM6PM283BHn+WZhzt6TcA83NErCObhjl5v8A7Xjl6dMA939Frmw+GuDdfsTN4Z7uiVD/NwR6+TmIdLuoY7WVVVG+5kVVVtuJNVVbXhTlZV1YY7V1Xl7Gu4oXZ0KrT8cjGV4ipH++CWlrbdFDBm71hny4ufKd+O/ovdzVXdicE+V5UpBvtc1a4Y7HNV3WKwE7D3wD6XCxGDfS43JAb7XK5MDPa53KEY7HCpPbB7uNQu2OFSu2CHS+2CHS61C3YC9h7Y4VK7YIdL7YIdLrULdrjULtjhUntgJ7jULtjhUu/A7vyLH7kd7HCpXbDDpXbBjrq9C3ZUMndgT3YB4h699Z/YAyqZLthRyXTBjkqmC3ZUMl2wE7D3wI5+exfsqNu7YEe/vQt29Nu7YG/uUr31C3ZvS22FRufdgsYR/fon0u03Me47XKtruE7XcL2u4ZKu4QZdw21e7fpHC3cZ7t+g3w/XxnW4zqdfDzfpGm7WNdyiarjtN7zuO1yra7hO13AH3+06uXWfh8eN97Kt+7s/R7euWp/Sa7TW7/1pb4xdA8m1o5kLgNF33Z6WewD3LtyjXu4vNo9HfapxZ36+J3Dvwj2Dew/ueXC9hxLWAZjit9yf8Q+um2r8RXb8xYwdfwzrpjQx+J34rfD4nfD4B/dT1fhJePyD1/fV+Aevk6vxDz7/VuMffP6txj/4/FuJPxvZ8282suffbGTPv9nInn+zkT3/ZiN7/s1G9vybjez5NxvZ8282wudfK3z+tcLnXyt8/rXC598OG3Hwxi98/rWDz7+b/mFMm4+X9/vmpbiyBFKKfwXuSvwar5x+Nc945fS3ecYrpx9eHy892lNfB1P2+edo3eDVA/NoB681mEc7eGXCPNrB6xjm0ZKq0Q5eIzGPVlBFldPPitAJqpB24xdU8ezGL6iC2YvfC6pJduMXVGXsxi+obtiNX1AlsBu/oLl9N35Bs/Vu/KN/+Rpo+YV1iia+rza8X471tAnafQ119I9NGYc6+vedjEMdvABgHCoNXitwDnXwsoJzqINXIJxDHf3nXIxDpZm+sE9m+dM2xc3qLLvfzAez/GAwkPl27JPMVL9xYiUz1a+QWMlM9TshVjJT/ZKHlczohWE3MmH0OrIfmdHLzn5kRq9S+5GZao0CVjKkl0xcfpIaSq4cSy4sGMll2hxtvzhiVYB/6bAqQA6KVwXoyl3xqgBduWNVgH/psCpADlM5FTnc41Q+SBB3vR3AvB68fRl79HR/Ufcp7XDU2y/k5ai3u8jLUW8vkpej3s4lK8ekt8/Jy1FvV5SXo94eKi9HvR1XXo4Ejqc4snZZ5lrjVQx1eKUe1OGs7qAeX/tZmbxDHT6sB3W4tg7UMzxeD+pwhD2owz/2oA632YM6gXoH6vCmN1AfZf9ZW15p3MBb9p/NGR5Zc/bh1TVnHz0DzdlH70Jx9kffVQbZvzX76OVozj56Spqzj96W5uwTsq84++j1ac4+en2as49en+bso9enOfvo9enNfhl9B0tk/9bso9enOfvo9WnOPnp9mrNPyL7i7KPXpzn76PVpzj56fRNn3/lXGsntZB+9Ps3ZR69PcfZH360d2b81+6j5J85+sgs8l7zZyT5qfs3ZR82vOfuo+TVnHzW/4uw7vN/XnH2839ecffh9zdnH+33N2SdkX3H29fb6HjXP18ElhMqxwaR1WzZrtlqxXxz1ds14OertP/Fy1NvJ4eWouCeSl80lrTG1baGCtS+QIf4E6RW3F3hBKnbqvCAVm15ekIr9Iy9IAkgekIq/YOAFqfhjAF6Qit+r84JU/Ir6E5C8O68WDx/UAzvBNXXBDo91C/b3i8gXgiPrgh3+rQt2AvYe2OENu2CHk+yCHb6zC3a41C7Y4VLvwC7lB+sBbll1+uHaVacf3QPV6UcXQ3X6CenXnH50dVSnH90l1elHl0t1+tFtU51+dP00pz+i66c6/ej6qU4/un6q04+un+r0E9KvOf3o+qlOP7p+qtOPrp/q9KPrpzr96PppTn9C1091+tH1mzn9tS0qErp+qtOPrp/q9MP3q04/Kv+Z019bsjaj8ledflT+qtOPyl91+lH5q04/If2a04/3/arTD9+vOv143686/Xjfrzn9ZSrfHx2t6U/VjBazHO1KqO1URcYsaiFDW2l9LaFcpppGPyLpjbFrILnK3b/uJJ++30lPklPNSF1JTvVw70pyqrcj/UhGY6Z60dCVpN65m5vkVO3vriSn6iR3JUkgyURyqv7mrSQ/2o33/bqxD+5wRH24wz/14Q631Yc7vFkX7hZOrg93+L4+3OES+3CHp7yFu4xfpT3yT8i/6vzDv+vOP/oIuvOPfobu/KOvojv/6O+ozr9Dn0l3/tHv0p1/9N105x/9P935J+Rfdf7R/9Odf/T/dOcf/T/d+Uf/T3f+0f9TnX+P/p/u/KP/pzv/6P/pzj/6f7rzT8i/6vyj/zd1/t+vTP3IP/p/uvOP/p/q/BP8v+78o/6fOv/v16h75J+Qf9X5R/2vO/+o/3XnH/W/7vzj/b/u/OP9v+r8B/h/3fnH+3/d+cf7f935V9z/syYvgdiQKkdTKksglMlsjrZfJAkkmUgq7kkxk1Tc3WEmqbhPYtNK0rkayWDXmS/YEHdIKu44MJNU7N15SUbFLpiZpGI/yUxSsTNjJqnZ4/CSJJBkIqnZ4/CS1OxxPiH54S6btZWjIxxRH+7wT324w2114Z7gzfpwh5Prwx2+rw93uMQ+3Anc7+Au5ReoCU5Yd/7h33XnH30E3flHP0N3/tFXUZ3/jP6O7vyjz6Q7/+h36c4/+m6680/Iv+r8o/+nO//o/+nOP/p/uvOP/p/u/KP/pzr/Bf0/3flH/093/tH/051/9P9055+Qf9X5R/9Pd/7R/5s6/7UV6Av6f7rzj/6f5vxbA/+vO/+E/M+c/8oKlNag/tedf9T/uvOP+l93/lH/684/3v+rzr/F+3/d+Yf/151/vP/XnX+8/9ed/8H9fyhhSVLKtpJ/n/Ka0bwJ25f4NdrB3S7zaAf3dsyjHdzJ8I7WDV63M4928CqVebSD12TMox28AmEeLaka7eBvl5hHq6qWcqpqKaeqlnKqaimvqpbyqmopr6qW8qpqKU8zjTYHWkebzLfR7oRtjVmitls2Jn+xmaryYmYzVZ3GzGaqqo6ZzVQ1IDObqSpGXjY0VX3JzGaqapSZzVS1KzObqSrdXNY/XRxV2Pj1L9MmjHz+UEvpCyIpgfgc7VwlcW20cxW5tdHOVbbWRjtXIVob7VylZWW0Ya5isTbaucq/2mjnKuhqo52qRCt+KV/JxFqJll+flj3+8uYjra9t12wgsDlkM1WdxsxmqqruQzbvtzK0YaoakJnNVBUjM5up6kteNnGqapSZzVS1KzObqSpdZjaa6+IaG9LLRsiScTYqrs/F5EixTxCTI8V+RUyOFPsmMTlS7N+k5Cgp9pFicqTYz4rJkWJfLSZHiv29mBwRcjR8jtBnGD9H6DOMnyP0GcbPEfoM4+cIfYbhc5TRZxg/R+gzjJ8j9BnGzxH6DOPniJCj4XOEPsP4OUKfoXuOaltJZfQZxs8R+gzD56jAH42fI0KORl/afPStrZGjR45Q142fI9R14+cIdd34OcL7o9Fz5AzeH42fI/ij8XOE90fj5wjvj4bPkSXkqHeOvPELbG/tTo7QZxg/R+gzjJ8j9Bn6971zWXNk3E6O0GcYP0foMwyfo7m2b5w0R+gzjJ8j9BnGzxH6DOPniJCj4XOEPsP4OUKfYfwcwcMOn6PRN7JMLi9/OiVTyZGNbqFuU3qxsX7vT/vXGuDeuVQ5+tHZDCsSnyo5EtMLHH1rT+T/5vwPXusg/zfnf/A6Cvm/ef4f/F0Q8n9z/gev0ZH/m/M/+Dss5P/e/I++ZTLyf3P+B3/3hvzfnP/B3+sh/zfnH/0/3fkn5F91/tH/051/9H9U53/0nbLvzL8xdg0k14523q35J7JS8l/r/4++dzjyf3P+CflXnX/F9Z+G/Ffnf8Xvf5H/R/4V1//I/yP/it//Iv+P/Ct+/4v8RxcVv/9F/h/5V/z+F/l/5B/9P935R/9Pd/4J+Vedf/R/VOd/9L3oP8t/MmHNfyyVjOa8tMatMdX0z/nzn9G3uUf6703/VNUf0v9p+gnpnzj91bl/qne/SP+n6Z+q9Ef6P03/VG9+kf5P0z/Vi1+k/9P0T/XeF+n/MP15qte+SP+n6UfXT3X60fVTnX50/VSnH20fzekviku/9eCcfC37c/7eZ/Q975H9W7OvuPBD9ovium/+7FfnfUL2FWdfcdGP7BfFr3qR/aL4TS+yXxS/6EX2i+L3vOqz7w16fZqzj16f5uyj16c5+4TsK87+4I5vs/NiNsVvs/+MX87OkfvxD1511+K3g9eNMZj0dXQMfif+wSufavyDz93V+Ad/01SNf/DZsxr/4N3+avyD96ur8Q8+/1bjH3z+rcY/+Pxbi98Jn3+d8PnXCZ9/nfD51wmff53w+dcJn3+d8PnXCZ9/nfD51wuff73w+dcLn3+98PnXC59/vfD51wuff0ffVb4av/D5d/RdvTf957h9SbP79sfnsnzX7gvR5k/vvit6TB7L37Y+lc1bmhKfdEbf87ozncFrh850Bq9M2Og8Rzt4HcM8WlI12sFrpA9HS24dbbQ7ox28omIerZz3/xyjlfO1AMdo56rtKqMNc9VqtdHOVXvVRjtXLVUb7VS1VEnLF2hkTarU1dnG13dzJr+q6t0v4Sitv2OmZF9ft/lAXyQJJJlITlUDdiU5VX3ZleRUtWtXklPVxV1JTlVz9yQ5+n6TgkhO5RW6kpzKh3QlCY/DRZJAkokkPA4XSXgcLpLwOFwk4XGYSI6+E+RAJEtYSZa4QxJz90mSef2MiR6H75BUPHeP8ltzW16wNz/UX39rPvo2YsjRI0eK6w0xOVJcyYjJkeI+sJQcjb61FXL0yJFiryEmR4q74mJypLjfLiZHhBwNnyP0GcbPEfoM4+cIfYbxc4Q+w/g5Qp9h+ByNvo8icvTIEfoM4+cIfYbxc4Q+w/g5IuRo+ByhzzB+jtBnGD9H6DN0z5HzL9jkdnKEPsP4OUKfYfQc0ej7OCFHjxyhruueo2QXei55s5Mj1HXj5wh13fg5Ql03fo5Q1w2fo9H3WEOOHjnC+6PxcwR/NH6O8P5o/BwRcjR8jgbvM6SwLoKZoomVHPl1wUzaBL0MdXC7zjnUwV0v51AHN4+cQx3cgzEOdfTtKjmHOrgj4Bzq4IU151AHr0+Ty8ufTmnzQnx3qDaZ5U/bFF8HW79bVq3LwgQylWO5d1Oh0ff5nJb76HXkrNxHL2rH5/7kOHrFLIXj6OW4FI6j1/qjcHy/RwaNvu+uGI6juxQpHEe3QFI4wl/xcCRwZOEI/8PDEX6GhyP8zCmOHddHptH3BEeOHjmCDxs+R6Pvvo4cPXIE/zh+juBNx88RfO/4OSLkaPgcwa+PnyP0AsbPEfoM4+cIfYbxc4Q+w/A5CugzjJ8j9BnGzxH6DOPnCP6of47e7wpJAXVd9xxV9pukgLruhhwJWVWQIipGzdlHLao5+6hyNWcf7+k0Z5+QfcXZh3fWnH28tdScfbwP1Zx9dOQ0Zx+9PsXZT+j1ac4+en2as49en+bso9enOfuE7CvOPnp9mrOPXp/m7KPXpzn76PVpzj56fYqzn9Hr05x99Pomzn5tZ9aMXp/m7KPXpzn78Puas4+af+Ls13ZKK6j5NWcfNb/m7KPm15x91Pyas0/IvuLs4/2+5uzD72vOPt7va84+3u9rzr7iXt+6AFIouXIsubCuI+YybY62fzkGQ2o55vXgnHzlWOfjcrDzKX1T+pOj3jqUl6Peio6Xo97aiJej3iqDl6Pe+ZqVo9X7louXo973Rbwc9b554eWo9x3GZxzdypGo5k/frRX7pE6g3oE6vFIP6nBWPajDh/WgDtfWgzo8XgfqDo6wB3X4xxuoC/mFWXBwvZqzD6+uOfuE7CvOPnoXmrOPHorm7KOXozn76Clpzj56W4qz79Fj05x99Po0Zx+9Ps3ZR69Pc/YJ2VecffT6NGcfvT7N2UevT3P20evTnH30+hRnn9Dr05x99Po0Zx+9Ps3ZR69v4uxXVo8ORMi+4uyj16c5+/D7irMfUPNPnP3KSnIhoObXnH3U/JqzT8i+4uyj5tecfbzf15x9vN/XnH34fc3Zx/t9xdmPeL+vOft6e33FLWMsIVSODSatmwxYs9XK174BUW/XjJej3v4TL0cCRxaOinsiedkqxRoTayCtfYEMcQek4vYCL0jFTp0XpGLTywtSsX9kBZkUWzFekIq/YOAFqfhjAF6Qit+r84IkgDwD0tnXDivOf99hZedP19Z3TvBBXbDDNXXBDo/VBTscWRfs8G89sGe4vS7Y4Q27YIeTvAO7lN+SZvhf1eknpF9z+tE9UJ1+dDFUpx/dFNXpR1dHdfrRXdKc/oIul+r0o9umOv3o+qlOP7p+qtNPSL/m9KPrpzr96PqpTj+6fqrTj66f6vSj66c4/dGg66c6/ej6qU4/un6q04+un+r0E9I/cforq8dHg66f6vSj66c6/fD9mtNvUfnPnP7KapLRovJXnX5C+jWnH5W/6vSj8ledfrzvV51+vO9XnX74fs3pd3jfrzr9eN+vOv00U/ofw1nTn6oZLWY52pVQ20SGjFnUQoa20rJfJKeaRj8i6Y2xayC5yt2/7iSfvt9Jf0n6qWakriSnerh3JTnV25GuJKd60dCVpN65m5vkVO3vriSn6iR3JTlVU7Yryan6m7eS/GijzMq6sdHDEXXhTvBPfbjDbfXhDm/WhzucXB/uBO5duMMl9uEOT3kLdym/SiM4Yd35h3/XnX/0EVTnP6CfoTv/6Kvozj/6O7rzjz6T7vwT8q86/+i76c4/+n+684/+n+78o/+nO//o/6nOf0T/T3f+0f/TnX/0/3TnH/0/3fkn5F91/tH/051/9P905x/9P935R/9v6vzXVqaO6P+pzn9C/093/uH/decf9f/U+a+tUZdQ/+vOP+p/3flH/a86/xn1v+784/2/7vzj/b/u/MP/684/If+q84/3/7rzr7j/Z01eArEhVY6mVJZAKJPZHP21R0FW3EljJqm4J8VMUnF3h5dkUdwnsWkl6VyNZLDrzBdsiDskFXccmEkq9u7MJBW7YGaSBJJMJBU7M2aSmj0OL0nNHoeXpGaPw0tSs8f5hOSHu2xWVo5OBo6oD3f4pz7c4bb6cIc368OdwL0Ld/i+PtzhEvtwh6e8hbuQX6AmAyesO//w76rzb9FH0J1/9DN05x99Fd35R39Hd/4J+Vedf/S7dOcffTfd+Uf/T3f+0f/TnX/0/1Tn36H/pzv/6P/pzj/6f7rzj/6f7vwT8q86/+j/6c4/+n+684/+n+78o/+nO//o/02d/8oK9Mmj/6c7/+j/6c4/If+q84/6f+r8V1agTB71v+78o/5XnX9C/a87/6j/decf7/915x/v/3Xnn5B/1fnH+3/d+cf7f935H9z/hxKWJKVsK/kPzqSvg4PbrlZqzHO0YXC3yzzawb0d82gHdzLMox28bmceLaka7eA1GfNoB69AmEc7+Ps25tEO/naJebSqaqmoqpaKqmqpqKqWiqpqqUiqRquqloqqaqk4VS1FxS+jDZS+jXYn7Mf/vERtN4P0Jn+xmaryYmYzVZ3GyyZNVdUxs5mqBmRmM1XFyMxmqvqSmQ2BzSGbqWpXZjZTVbphfRMZoisVNn79y7QJI8fTh9oH/ifEqQroNxCfo52qJK6OdqoitzbaPFXZWh3tVIVodbRTlZbV0U5VLFZHS6pGO1VBVx3tVCVapLUZmZOvlGj59WnZ4y9vPtJatl3LU1VezGymqtOY2UxV1X3IprKVYZmqBmRmM1XFyMxmqvqSmc1U1SgzGwKbQzZTVbrMbDTXxTU2iutiKUvGFcX1uZgcKfYJQnKUjWK/IiZHin2TmBwp9m9icqTYR4rJESFHw+dIsa8WkyPF/l5MjtBnGD9H6DOMnyP0GYbPkUWfYfwcoc8wfo7QZxg/R+gzjJ8jQo6GzxH6DOPnCH2G8XOEPsP4OUKfYfwcoc/QPUeVraSyQ59h/ByhzzB+jgg5Gj5HqOu656iytHkefWtr5OiRI9R1w+do9C2ikaNHjlDXjZ8jvD8aP0d4fzR+jgg5Gj5HeH80fo7w/mj4HHXentfXcmQfT+PlT2d6/aCXlvid8Pi98PhJePxBePxRePxJePxZePxFdvydN1z8ffzC598gfP4NwuffzhsX/j5+4fNvED7/BuHzbxA+/wbh828UPv9G4fNv+430vPXLzgneFlP5286/djX36fuu5s8BeOkDIOkDCNIHEKUPIEkfQJY+gCJ8AO23VeMegB19AG4dAFGto19bhzKn4edt3uEOP8vzDpd0DXf4CoJ3uMPXG7zDHb464R3u8LUM73CHr3w+Gq6U35vl4eu1ObHPVWWKwT5XtSsG+1xVtxjsBOw9sM/lQsRgn8sNicE+lysTg30udygGO1xqD+wFLrULdrjULtjhUrtgh0vtgp2AvQd2uNQu2OFSu2CHS+2CHS61C3a41A7Yi4FL7YIdLvUO7JWVAYuBS+2CHS61C3bU7V2wo5K5A3tlNZZiUcl0wY5Kpgt2VDJdsKOS6YKdgL0HdvTbu2BH3d4FO/rtXbCj394Fe3uX+nDOC/a/A3z7t4NdQQYbXsO13j4H0H5HI+4BWOkDcNIH4KUPgKQPIEgfQJQ+gCR9AHnsATj7Wr3D+VSrHyq/OS5u8Hmbebh+8Fmee7iD1wTcwx28guAe7uD1BvdwSddwB69luIc7eOXz4XClfDnkB6/XZsU+V5UpBvtc1a4U7DRX1S0G+1zVvxjsc7kQMdjnckNisBOw98A+lzsUgx0utQt2uNQu2OFSu2CHS+2BPcCldsEOl9oFO1xqF+xwqV2wE7D3wA6X2gU7XGoX7HCpXbDDpd6Bvfa79ACX2gN7hEvtgh11exfsqGTuwF77NVdEJdMFOyqZLthRyfTAnlDJdMGOfnsX7Oi3d8GOur0LdgL2HtjRb++CvYNLLcvB3m9WEfnzt58hNa9pyaxenkyoKeHd0X8H0H5XXu4B2LEHEHNY7q6Yk9385Wf4Tnb4Xnb4NHj4xSwP2z9rPvwIP8gOP8oOP8kOP8sOf/CZtxJ+GXzerYU/+qxbCX/0WbcS/uizbiV82bNukT3rFtmzbpE96xbZs26RPOsmYyTPuo/wJc+6j/Alz7qP8CXPuo/wJc+6j/Alz7qP8CXPuo/wJc+6j/CHn3VpbVOV8DP84Wfdt+Hb4Wfd9+EPP+u+D3/4Wfd9+MPPuu/Dv3na+nuR0RdVF/o+0ptljM5b++3oJ3Z84tMFOz7x6YIdn/jcgd3lsmI3bgc7AXsP7PjEpwt2/BClC3b8EKULdvwQpQt2/BClB/bJNgURgx0utQt2uNQu2AnYe2BvP6Vq2A601pPpsOI/sD+wW2Dvgd0Be4dne4cV/4H9gZ2AvQf2AOw9sEdg74E9AXsP7BnYe2CHS+2BPcCldsEOl9oFO+xSF+zNp1SX/TJYb6yv/O1QQl7QZPtaX/lPvn4eHCl9HRxy2v5pI7mB034tY+To0xy1X/gYOfo4RxY5Gn0+ig45Gj5HHjkaPkeEHA2fo4AcDZ+jiBwNn6OEHA2fI/QZxs8R+gzD5yihzzB+juBhx8/R4DVDcnn50ymZSo5sdAt1m9KLjfW0+94jLen3brPoy/7Rk/4sOw1ejyD/N+d/8FoH+b83/3nwOgr5v3f+z4O/C0L+b87/4DU68n9z/gd/h4X835x/Qv5V53/wd2/I/835H/y9HvJ/c/7R/9Odf/T/dOcf/T/V+S/o/+jOv+L6zxi7BpJrR0+6KEpRXP8h/w+iius/5P9BVHH9pyH/lfnfGsXvf5H/R/4V1//I/yP/it//Iv+P/Ct+/4v8P/JPyL/q/Ct+/4v8P/KP/p/u/KP/pzv/6P+pzr9F/0d3/qeq/9K6jbtNsVQymvPSGn90Qavpn/LnP9ZOVf4h/Z+mf6rqD+n/NP1TFX9I/6dz/1TvfpH+D9Pvpir9kf5P0z/Vm1+k/9P0T/XiF+n/NP1TvfdF+j9NPyH9mtOPrp/q9KPrpzr96PqpTj/aPprT70lv+teDv63gquj3PtYrrvyQfa+48EP2veK6b/7sV+d9xS97kX2vuOhH9knxq15knxS/6UX2SfGLXmSfFL/nRfaJkH3F2UevT3P20evTnH10exRnP+h1fGFtggcylWN9SWWFbjYrwI69p2Otzx/0Oj5k3wa9jg/Zt4GQ/XmzX5339To+ZN8GvY4P2bdB79cdyL4Nev0+sm+D3q87kH0b9X7dgezbiF6f5uyj16c5++j1ac4+IfuKsw+/f0P2HzfVmn2TK/mkVJaoH/98ZdQH+soRXHn3HOX1fn78s+zkCN65f46cX3Pk3c8cJTjc8XMEHzp+juAWx88RPN34OSLkaPgc4VuI/jkyac2RMzs5whcL4+cIfYbxc4Q+w/g5Qp9h+Bxl9BnGzxH6DOPnCH2G8XM0uD8KJeSvo+P2h3y7OZr01xx5cH+EHD1yNLg/Qo4eORrcH2nIUe17hjy4P0KOki2D+yPk6JGjwf0RcvTI0eD+CDl65Gjw97DI0SNHhBwNnyP0GcbPEfoM4+cIfYbxc4Q+w+g5ckaxP2L9dcODKEiy/AbBGcVeg/WrP2cIJJlIKq7bmUkqrq6ZSSqugZlJKq5UmUkqfm/F+kWKs4rfLjGThMfhIgmPw0USHoeLJIEkE0l4HC6S8DhMJF37uTsYs/ztQKX2t3NZP7YzfpbNkZ1zwN4Duwf2HtgJ2P+l/bsnF4C9B/YI7D2wJ2DvgT0Dew/sBdg7YPcG2Htgh0vtgh0utQt2uNQu2GGXemDf30OQUlz7lq9LPBB8nRSunBSvnLRrK4JdRBGc/3bSXus4LmxdznZz9NcV8u1XKHdfYX9TGNYr2Nuv4G6/gr/9CnT7FcLtV4i3X+H2ezrefk/H2+/p/WVHAy3TSqD083G5v35fSMtJcbtMzXpSuXCl/dWzwvriLUTaOWn/KZKX+SwUv3OSu3KSv3ISXTkpXDkpXjkpXTlp/1bIZj1pL0/lwkn76wXUTrLvT4pmZ0z7v6gO63vcuHkx+zppVxHRLvSiLzsnUeVKe/fT/o8gKzfh/q/yaidduN39/m9i7KNMWSpnF8vOae7aaf7aaXTttHDttHjttHTttHzttHLptP0PLeunHagkp/W0jVF5nebqp8Wd0/y10+jaaeHaafsqedwZy2l+58Hjbbp2Wr52Wrl0mjPXTrPXTnPXTvPXTjvIW1zT7ZPfOW2f5KvGs4F27gB/gKSs9xuZsHOaq5+2c5t6f+00unZauHZavnQa7ZMkt67QSN7unOaunbZPkqJZT4s7DwWKB6e9xpZ2JuFwMLa1tWMp72gyuGun+Wun7auECq13gNkbW7h2Wrx2Wrp2Wj64u9e8Bbdzm4Zy6bT9Bk01yGivneauneavnUaXnpP7nYz6afHaaenSaclcenKla0+udO3JlfyV04jMfj92/ZqMkv35EyjafyrXT9sdW+0HV7T/VK6fRtdOC9dO2+9sVz7+JUrXTsvXTiuXTgvm2mn22mnu2mn+2ml07bRw7bRrKjno7bvlCRT866TlrQ4dtOsrJ7krJ/krJ9GVk8KVk+KVk9KVk/KVk8qFk9IVRexPSaEs4oubl6uvk9yVk/yVk+jKSeHKSfHKSenKSfnKSeXCSQfN+MpJVxSRrygiX1HEwfKzyS7vi13a0/l+Q9nGl42LKe+c5q6d5q+dRtdO2y+ZU1rKE5uK2zktXjstXTstXzutXDntYUiunWavneauneavnUbXTgvXTovXTkvXTsvXTrumEntNJQc98GJW91fc3mnu2mn7eYt2bVNGt1mYy6ev0+K101L1NE87p+Vrp5VLpx38YCzb5S3z40XqpmQue1955Uf78evo7DdvsvePto9GbH61hcvmy63H8c+gaMSgwohBxRGDSiMGlUcMqgwY1MFPADoHZUcMyt0b1PMivsVFqMVFQouLxBYXSS0ukltchOUJtPbBs9+8wVsvQqbFRWyLi7gWF/EtLkItLhJaXCS2uAjHHe/WDwkz2dr8k21ab127+Vjmzy8WniHl8UIqw4UUzHgh2fFCcuOF5McLidqH9NkS4+9fEYcQpA8gSh9Akj6ALH0ARfgAopE+ACt9AE76ALz0AUifiaP0mThKn4mj9Jk4Sp+Jo/SZOA0/D7zfciik0Z9ClU/3Qmr/FBpl2QlbXst2bL6QXl92pwQ0R2gy0ByhKUBzgCYboDlCY4HmCI0DmiM0HmiO0BDQHKEJQHOEBtXwIRpUw4doUA0fokE1fISmoBo+RINq+BANquFDNKiGD9EQ0ByhQTV8iAbV8CEaVMOHaPRWw86/0NDOz+eK3mq4giYavdVwFY3euqaKRu8MVVlkIBq9M1QVjd4ZqopG7wxVQ2P1zlBVNHr7NVU0evs1VTR665oqGgKaIzR6+zVVNLvVsDfroi7eUK4M1trHffl1+OPfrgbHPf5vLdH9a40s7/1XUOnuoJ6XyW0uU5pcZn+pc/7L2DaXcW0u49tchtpcJrS5DMszI7xW6bZxs1HQ0SfM738mGl0aMag8YlClR1DHX6D/DcqbEYOyIwblRgzKjxgUjRhUGDGoOGJQPZ7oQt6YRZ8B5xhOAZxDOGQA5xiOBZxjOA5wjuF4wDmGQ4BzDCcAzjGcCDjHcFAhv4GDCvkNHFTIx3ACKuQ3cFAhv4GDCvkNHFTIb+AQ4BzDQYX8Bg4q5DdwUCG/gYMK+Q0czRVy7Rv6qLlCrsLRXCFX4RDgHMPRPFvVvlSMmmerKhzNs1UNTtI8W1XhaJ6tqnA093OqcDT3c6pwCHCO4Wju51ThaO7n1OBkzbOVX1dGfxgJuwNH82xVhaN5tqrC0TxbuVxWOGbHlWfNs1UVjubZqgpHcz+nCkdzP6cKR/XbhwqcovrtQw2O6rcPNTiaK+QqHM0VchUOisA3cPQujlVzVoqXb6ygSYqXb6yi0bs4VuVZk4zexbGqaBQv+llDQ0BzhEbv4lhVNHqXiq2i0btUbBWN4sXMa2gUL2ZeQaN4qdgqGlTDh2hI9mbYyQ6/GfaqhMc/y84A4ugDcOt+6tm7nQEk6QPI0gdQhA/AGekDsNIH4EYfgEnrAJzZGYCXPoDRZ+LqAIafiWsDGH4mrg1g+Jm4NoDhZ+LaAIafiSsD2F+HNcSwfFYbHv2+9TTr7Z7peHiYr6Mf7zfzt6OfFykNLrK/TCH3RWyLi7gWF2mR+P1l3LgvElpcJLa4SGpxkdziIi3u+NDijg8t7vjQ4o4PLe740OKODy3u+NDijg8t7vjQ4o4PLe742OKOjy3u+Njijo8t7vjY4o6PLe742OKOjy3u+Njijo8t7vjU4o5PLe741OKOTy3u+NTijk8t7vjU4o5PLe741OKOTy3u+Nzijs8t7vjc4o7PLe743OKOzy3u+Nzijs8t7vjc4o7PLe740uKOLy3u+NLiji8t7vjS4o4vLe740uKOLy3u+NLiji8N7vhsTIuL2BYXcS0u4ltchFpcJLS4SGxxkdTiIrnFRVrc8bbFHW9b3PG2xR1vW9zxtsUdb1vc8bbFHW9b3PG2xR1vW9zxrsUd71rc8a7FHe9a3PGuxR3vWtzxrsUd71rc8a7FHe9a3PG+xR3vW9zxvsUd3+LTq+xb3PG+xR3vW9zxvsUd71vc8S2+ucstvrnLLb65yy2+ucstvrnLLb65yy2+ucstvrnLLb65yy2+ucstvrnLLb65yy2+ucstvrnLLb65yy2+ucstvrnLLb65yy2+ucstvrnLLb65yy2+ucstvrnLLb65yy2+ucstvrnLLb65yy2+ucstvrnLLb65yy2+ucstvrnLLb65yy2+ucstvrnLLb65yy2+ucstvrnLLb65yy2+ucstvrnLLb65yy2+ucstvrnLLb65yy2+ucstvrnLLb65yy2+ucstvrnLLb65yy2+ucstvrnLLb65yy2+ucstvrnLLb65yxzf3HlT1qWyna0dnZaA0usH9OS/oklDRZOHiqYMFE3h+C6QMRo7VDRuqGj8UNHQUNGEoaIZ6VlczEjP4mJGehYXM9Sz2A71LLZDPYvtUM9iO9Sz2A71LLZDPYv3P/Kz3i+LNFm/2eQl763/RP61vOgmFMpfV6DbrxBuv0K8/Qrp9ivk269Qfn2F8LoL4s4V9r/nY72C/f0Vklnv5LJzBXf7FX5/T4eyZDoav3MFuv0KgfMKmw1qXleIt18h3X6F39/TMdnlCtnsXKHcfQX6/T0d87JCdyy0cwV7+xV+f0+ndRu2ZPPOFfztVyDOK7i4c4Vw+xXi7Vf4/T39Wk8+mz0t5duv8Pt7Oq+U8p6Wgrn9Cr+/p7NfFqTO5Hau4G6/gue8Qth5tga6/Qrh9iv8/p4udjm27N3TId1+hd/f04/KdLkC7VQCodx9hfj7e7qstXeJO5Sivf0KjvMKaefZGv3tV6Dbr/D7e9qasFgUa+LOXR1jg2vs39fkltnRUorvr+FtXq7h7WbzFxdpty0Tlz/tzcaZ+T9vJH8encxS3Pu0ueP+HP2MPwuPv8iOf/+rQ0HxW+HxO+Hxe+Hxk/D4g/D4o/D4hc+/Sfj8m4TPv1n4/JuFz79Z+Pybhc+/Wfj8m4XPv1n4/JuFz79Z+Pybhc+/Rfj8W4TPv0X4/FuEz79F+PxbhM+/pf3869ZfkfzpIr+P/9NtxM26/22yP/e/LSWpGm1WNdqiZ7TZGKNqtFbVaJ2q0XpVoyVVow2qRquolnqMVlEt9RitolrqMVpVtZRVVUtZVbWUVVVLWVW1lJ1rvl0/KH/8M+6MdqpncjbLR4j0OPznaN3gz2RnX6MNtjLaPz/L+Dr6T8e5crQPSyBkN1GbvWOdLcsHxc6Z8u3oJ8fBn/ZiOA4+j4jhOPgMJYYjgSMLx8E7FGI4Dl6LieE4eFdFDMfB+zViOA7uOqRw9PAzPBzhZ3g4ws/wcISf4eFI4MjCEX6GhyP8DA9H+BkejvAzPBzhZ1g4EvwMD0f4GR6O8DM8HOFnTnF0/sVxs+7YiyOBIwtH+BkejqgfWTgGzNenOCa7LH/mkjc7HDFf83DEfM3DEfM1D0fM1zwc0X/k4Yj+Iw9H1I88HNF/ZOEY0X/k4cjgZ7xZOXpH3zg+r+EaXMM3uAY1uEZocI3Y4BqpwTVyg2uU+6/BsQayc2m9Rs6VZ1m2KS9Pp29Pvvz1VOBY1Zg5IjdcRH64iGi4iMJwEcXhIkrDRZSbR3T828FnRGW0iLIZLiI7XERuuIj8cBHRcBGF4SJq/syW8rY+J5A5IJNB5oBMAZl9MsWAzAEZCzIHZBzIHJDxIHNAhkDmgEwAmQMyqIGPyKAGPiKDGviIDGrgfTLWoAY+IoMa+IgMauAjMqiBj8gQyByQQQ18RAY18BEZ1MBHZNTWwJVfslijtgaukbFqa+AqGbX1TJWM2rmp8oWptWrnpioZtXNTlYzaualGxqmdm6pk1PZnqmTU9meqZNTWM1UyBDIHZNT2Z6pkGGpg8isZyrZCxtt1FxFvKaxH270/bRMtJbxNcXNw2jk40oI8Br899DnQpGWgeZ6B5uXYuLnj1oGWiQa6/NoomZ8Z5ViHWsZAGcpBsuU1UFcZaDDr4zEYStuBPgNyowXkRwuIRgsojBZQHC2gNFpAebSAymABcazcyRvQaE9qGu1JTaM9qWm0JzWN9qSm0Z7UNNqTmkZ7UtNoT+ow2pM6jPakDq2f1FRKXgMK5T/fuhkKZTHXFMn8jN6Ljp5ERx9ERx9FR59ER59FR18kRx+N6Oit6OgFzbX+Z/SC5tqd6AXNtTvRC5prd6IXNNfuRC9orv0ZfeJ+5sRK9I/uWFr/tM/vo4+Glj8dTTHvD7aPI5ajH/8O8edgvabBkqbBBk2DjZoGmzQNNk872PJzsEXRYLPRNFirabDzVlA7g523gvoxWHf0S32TDwb7PMteOstdOUvv7xu88V8HO2/tt6OfZNT+vqFGRu/vG6pk1P6+weWykjFuh4za3zdUyej9vWaNDIHMARm1v2+oklH7G98qGbW/8a2S0bv+RI2M3vUnKmS83vUnamRQ6R2Rwb6bLC7LY99NHo7Yd5OHI/bd5Hk+Yt9NFo6EfTd5OFpwZOHowJGFowdHFo4Ejiwc4Wd4OMLP8HCEn+HhCD/DwjEMXj++2dPx59GUyhL245+vSHygr9EOXuV9Ntq8auzxz7Iz2sFrsQ9H6/w6Wu92RkuqRjt4XcM82sGrD+bRDl4j/P/lndGO27YSht/lXPtCwxlyZp6lKIo2JzgIEDRFTlugF3n3yrsryokoM/q7VobpTRCv9VG/rPE/5JgUX/lqg2fyV77a4PXDg1dbp63OFz5tr7YEr/K98tV+V32p7tV+X32p3tV+X32p3tXKv+pqv6++VO9qv6++VOdqtZmBpM7dELkZnLs1L3Z9Smn67NjnEzRNX6iO0UU6J/h2uxql9rroUcTzyOJlZPF5ZPFlZPE6sngbWbwPLL69LncU8SNnWBs5w9rIGdZGzrA2coa1kTOsjZxhbeQMayNnWB85w/rIGdZHzrAeOcP25g545AzbFR85w3bFR86wXfGRM2xXfOQM2xUfOcN2xPMUOcN2xUfOsF3xkTNsV/zAGZangTMsTwNnWJ4GzrA8DZxh518FRxY/coalkTMsjZxhaeQMSyNnWBo5w9LIGZZGzrA0coalkTMsjZxh08gZNo2cYdPIGTZFzrBat9ZLylNDfOQM2xUfOcN2xUfOsF3xkTNsV3zkDNsVHznD9sRz5AzbFR85w3bFR86wXfHtJQDrzHWaSm5gBcPaC/yIl1n1dDtPfsUMwxzCdp7Q1MXai6Co1I+ErPGR7DzvhL3ui8DeOlvGsIJhimGGYQ5hO7s9d7H2fcup3u58s3HyiiUMYwwTDMsYVjBMMawdJbnU7TuyeQNzCNtZmdnFCMMShjGGCYZlDNsxhXXblbk72MAMwxzCdMIwwrCEYYxhgmEZwwqGYVGiWJTsbDo2Z9mK5YYF7Wzf1cUIwxKGMYYJhmUMwzoYhnUwDOtgGNbB2JmzqPUJtKK0dt6XlZi8M1uwi7UrMFr7k6JKDaxgWLvq0HmqA+/MCuti7ZF2Z02r7MyE6mKEYQnDGMMEwzKGFQxTDDMMw6KEm5+kyvIFUCmb77a0R6bruNyzNSBDIAeg9pi0BxECJQRiBBKkhiCSMaxgmGKYYZhD2M7It4sRhiUMYwzDoiRjUdIewna8oz2A9WpTnloQYgPt4WTnTO3BZA8SBMoIVJAPArHrgth1e9zptTvl2gij9qizBxEC9ey6CSF23R5t9qCMQEhEKBIRikSEIt9cQxK4IQnckARuRyNifkXXI9vZOPOy+ivfPFKHhK5na2fi+4geR+w44geR+VW6HrkzNUeXb25J6y9A89DyCeTrke1UqlR/DSrrx045N37gkTqDItP02bHzBbVT7qHmaandZtZN8/LY5vNjmy+PbV4f27w9tnl/aPPtIrxOa/Pea76szwAucvMM4OZm4MmW7zBPa/FDnsyvXdn/RlpSIC18rhYqXPvmJX9+9FWOxJKTY8kpseRoLDkWS46HkqNTLDkUS06KJSeWK+vprmz1Nxol28jJseSUWHI0lhyLJcdDybEplhyKJSfFknO2K2uu8yDUZCNHYsnJseSUWHI0lhyLJcdDyfEplhyKJSfFkhPLlT2WK3ssV/ZYruyxXNljubLHcmWaTrdlr9MgP5uDtOihYHpSMD0cTI8E05OD6SnB9GgwPRZMj8fSQ8H8mYL5MwXzZwrmzxTMnymYP1Mwf6az/dnWxbnGvtVjwfT4N9RzM4V10ZOmYHoomJ5X8Oe6mlKUSkdPSmQvR6eU81YPn65Hq56yjeckwfTkk/XwVB93z0RbPSWYHg2mx87WUzd9TJwb8eOn65GqR3mjh6eT9ci0/OqfhBp6KJieFEzP2f687uuZJNtWj5yupz52RnT7feccTM/Z/ixe83ueGvdLg+mxYHrO9udc143N3bFt/Mh0up6aT3PZ9g/lbH/Oviz4TmXa1uclBdPDwfSc7c9lHV8U2X6/JJ+up+avUhrfr7P9eZ3uMw8vdKtHg+mxYHo8lp48BdNDsfJpTrH0tOe1kNeleOQ3TxJ7efIDtaefdCmGKIGo3KVue+8LVSBKIcogygEqtX+1T9OamyYuW4ogKkEUQ5RAVIaoAlEKUQZRjlAExQZBsUFQbBAUGwTFBkGxQVBspJ3PMNcK1VRoS+1cV10DPf936wCpQOfaiV6rNb3J85YyiHKE4gmiCKISRDFE7dzluox0prYRxRmiCkQpEodsEOUIJRNEEUQliGKIghxAMkTt9Dc81WmC7nzz5BN/6lemnQcl9TkCuQRyDHICchnkCsgpyBnIgfHSfk6BqC/VZDG2LUUQlSCKIUogKkNUgSgwQgoYIQWMEAUdRUFHUdBRFHQUBR1FQUdR0FEUjJf2ItRedKojlEFuYpCbGOQmBrmJQW5iYIQYGCEGRoiBjmKgozjoKA46ioOO4qCjOOgoDmUfh7LPztOQexTkJY54yd6m8D2KIAqLkJ0dyL+CE5DLIFdATkHOQA5zlJ3tjb+CI5BDcs/ebro9SiAqQ1SBKIUogygwQhIYIQmMkAQ6SgIdJYGOkkBHSaCjJNBREugoCco9DOUehnIPQ17CkJcw5CUMeQmDEcJghDAYIQw6ioCOIqCjCOgoAjqKgI4ioKMIlHsEyj0C5R6BvCRDXpIhL8mQl4C1WAZrsQzWYhmsxTJYi2WwFstgLXZv47Y+BzpKAR0FqsgyVJFlqCLLUEV2Z7u3LgV5SYG8BKzFMliLZbAWu7Pd272ra6xYk6muwJTbFZisz+eQE86RTzgH6GpgPZiP14O316S6TLBQ5+0V+aPPcLzOfPAMsjMuWmfxUrnZ6qNSBaK0S7FsKYMoP0zNr+R6bPuEuc5kKWndB43kpfR3GGkPve4jdBxJxxE+iMyv8vXIdlGFaNJlJsr8/5vd+Mie2LLPWl2bZTfhRNqI8lJ3MyyZbw+dr6hdt3mtxu2fNl6nwRSzLxv3f9z4shpapy+Vt0tFr9L4/ELv3Na6hMLcv+qKnRfD85utKpuiuvFm14P/7Zud+JPRNT+EwktetWnNqvTsq23jv4/occSOI34YaTvwfaTpwFZ7InazAmdB0nGEjyNyHMnHkXIc0eNI21FNWqbBLQ+YR1Mvx8695zXJ5+fm/aHNt8tlr9c8Pbb59Njm+bHNy2Obz49tvrxi88ab5vWxzdtjm2/3C+picL/dmujZR9oFyfsIHUfScYSPI3IcyceRchjZ2b7xLmLHkeN3X4/ffT1+9/X43W/XjFLdoC8V/TL42yWg+0g+jrSn6Wtd/+ibb2W7NnMfseOIH0bahZP7CB1EPs0v//z547uff3n/9v8zcn33j1/f/P7uw68vL3//67flnV8+vnv//t3/fvrt44c3b//7x8e3P73/8Ob63n+ml39+UJ7HRSokPz7tyPiDCaWLCU8/Pu0xOL+vflE2v75/BUR1usz/5OsfroTOB88tcKqbOl45ThdJC5Ppksu63eH1T4kuqdSNDJ8anq4ILwzNJk7Pp72ehefqE7vVesn1HDI3S/Uc6ZJ1LQs8NeGXJOto/+m0ckm+jhSf/qSXZ+12X7tXokyXUi/f9DKr/PRpvjV/Aw==",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "commit_private_user",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "src_receiver",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 48
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6652550611004701521": {
            "error_kind": "string",
            "string": "Funds Not Sent"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "notify_created_nullifier_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "random",
        "decompose_hint",
        "lte_hint",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "lock_public_solver",
      "is_unconstrained": true,
      "custom_attributes": [
        "internal",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "ownership_hash",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 48
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "15001264570739363109": {
            "error_kind": "string",
            "string": "Function lock_public_solver can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "lock_public_solver"
      ]
    },
    {
      "name": "redeem_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "ownership_key",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "772057049813214347": {
            "error_kind": "string",
            "string": "HTLCNotExists"
          },
          "2570651705007895968": {
            "error_kind": "string",
            "string": "HashlockNotMatch"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6012086182631426650": {
            "error_kind": "string",
            "string": "NotAnOwner"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17814817983036354427": {
            "error_kind": "string",
            "string": "Function redeem_public can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "redeem_public"
      ]
    },
    {
      "name": "lock_private_solver",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "ownership_hash",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 48
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6418028854678020178": {
            "error_kind": "string",
            "string": "FundsNotSent"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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TXtFjD35gYoYBYwaGHExKhhxMSoYcTEqGHExKhh7cjEffce2Y8xnAwlhi/uLhzw9vPo/ErwVe+jJ9TSEvSeX1BD2nlxVQ9h7cmENYRew18Dek8trCHtPrrAh7D25yIaw9+Q6G8KOS62BPeJSq2DHpVbBjkutgn1glxqn5TaSED9mfII9fsj0dXkM6QFKWo+u3qb96i3ev9u3fmIXsNfAPrBLrYl9YJdaE/vALrUm9oFdak3sA7vUitjngV1qTewDu9Sa2Ad2qTWx41KrYBew18COS62CHZdaBfvILnVOaccuchb8xnUfS1zX5X51DkdjCfH24nNYHq7+R7CfV8/bPvI5z9+u/iPTyK62IZlGdsHtyNTV4yg7lmlkl92QTCO78oZkGtnFNySTIFMLMo2cEjQk08ipQkMykUI0IRMpRBMykUK0IFNXD3fuWCZSiCZkIoVoQiZSiCZkEmRqQSZSiCZkIoVoQiZSiCZkIoVoQiZSiBZkWkkhmpCJFKIJmUghmpCJFKIJmQSZWpCJFKIJmUghmpCJFKIJmUghmpCJFKIFmTZSiCZkIoVoQiZSiCZkIoVoQiZBphZkIoVoQiZSiCZkIoVoQiZSiCZkIoVoQaZECtGETKQQTchECtGETKQQTcgkyNSCTKQQTchECtGETKQQTchECtGETKQQLciUSSGakIkUogmZSCGakIkUogmZBJlakIkUogmZSCGakIkUogmZSCGakIkUogGZZCKFaEImUogmZCKFaEImUogmZBJkakEmUogmZCKFaEImUogmZCKFaEImUogWZAqkEE3IRArRhEykEE3IRArRhEyCTC3IRArRhEykEE3IRArRhEykEE3IRArRgkyRFKIJmUghmpCJFKIJmUghmpBJkKkFmUghmpCJFKIJmUghmpCJFKIJmUghWpBpJoVoQiZSiCZkIoVoQiZSiCZkEmRqQSZSiCZkIoVoQiZSiCZkIoVoQiZSiBZkElKIN8kUZdkRpjOZJO8yLdOUf8pECtGETKQQTchECtGETIJMLchECtGETKQQTchECtGETKQQTchECtGCTAspRBMykUI0IRMpRBMykUI0IZMgUwsykUI0IRMpRBMykUI0IRMpRBMykUK0INNKCtGETKQQTchECtGETKQQTcgkyNSCTKQQTchECtGETKQQTchECtGETKQQLci0kUI0IRMpRBMy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wzc2fD1cn+3C9vFQSLtz88l+WVovmL+HpPOQfB5STkK+WIhfj9bjvOjXVCib3dHm/nHRbTwPSech+TyknIYcnAr7FlKdTfK2v5x31dkV4s5D/HkInYeE85B4HpLOQ6rq50zPcf0LpPJqSVynD797weUrvfxfR4e7dfv5enDY7+ftZ3/effbn/Wd/nj778+GzPx87/nz2Lz+fPvvz+bM/X48T3PoCRPHpb+eRg7ThLcSeh7jzEH8eQuch4TwknoYcxIlvIfk85Lz66bz66bz66bz6B/e2bBHvEnr/bec/uLflLSSch9Rv7UlryuzKy6is70m+h+TzkHIaUt+KfA+xJyF/Lf/5f//+P//l7//hX//5/yyQr//1v//tH//rX/79377/87/+33+s/8s//Oe//Ou//sv//rv/+M9//8d//qf//s9//rt//fd//Prf/of5/n//M3lLP5L3YTHmy5YcYvqRQ/76768+k75egk2ulK///QtAIZkfy//7CfhCpBjyjxSj+Rnjf/3uF867H+RWTLA/Qvz6n39eN/jzn5z94X7+k9/+ycYfzn79E60/4vIPn7eG6QeVr/85vCLi83fph/v5VHr+U/rh3dc/5Sew/HD09U9l5eHrbqWl3vHtdVw82hp2X80s7Xz7u1Sql/9MP73daPy6zsgV+oYH82OhY4WH5fnHf/6Exy/P/U+4XeF2Ka3Z5R8fcGvtD/to8Of/uBTr7NLg9w8slf0fS0r1vL7xT37APx1YnCxphZT8wxq/2bz8pzdmlwb//Nm08PBMb49Vt0954sLM1nPy0tMWrf5aevX/Bw==",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "notify_created_nullifier_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "random",
        "decompose_hint",
        "lte_hint",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "is_contract_initialized",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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oOd0bXVVI6zC33O6trqqEVaH7zldW13VCKuW95yura5qtdVVrba6qjXamq6trmq11VWttrqq1VZXtdrqqkb4ikXP6drqqkb44kTP6drqqub6jkR7ura6qrm+I9Gerq2uaq7vSLSna6urmuzLEM3p2uqqJvt6Q3O6trqqyb6w0Jyura5qsq8gNKdrq6ua7EsFzena6qom+5pAc7q2uqrJvibQnK6trmqyrwk0p2urq5rtawKt6drqqmZbnb81XVNdVZxttfvWdE11VXG21eNb0zXVVcUl2pquqa4qzra6eWu6prqqONtq4a3p2uqqnK2uytnqqmytrR5tra0eba2tHm2trR5tra0eba2tHm2trR5tra0eba2tHm2trR5tra0eZ1tb/WPfOVq3bd2y+G8b3zlGOHbhyDcJ+3Dko4R9OPJVwj4c+SxhF46zLUH/muN9umY+332frpnPbN+na6b5vE832pqumVbuPl0zHdd9umYao/t0zfQv9+ma+fzxX9OdbQn61nRtdVWzLUHfmq6trmq2Jehb07XVVc22BH1rura6qtmWoG9N11ZXNdsS9K3p2uqqZluCvjVdW13VbEvQt6Zrq6uabQn61nRtdVWzLUHfmq6trmq2Jehb07XVVc22BH1rura6qtmWoG9N11ZXNdsS9K3p2uqqZluCvjVdW13VbEvQt6Zrq6uabQn61nRtdVWzLUHfmq6trmq2Jehb07XVVc22BH1rura6qtmWoG9N11ZXNdsS9K3p2uqqZluCvjVdW13VbEvQt6Zrq6uabQn61nRtdVWzLUHfmq6trmq2Jehb07XVVc22BH1rura6qtmWoG9N11ZXNdsS9K3pmuqq0mxL0Lema6qrSrMtQd+arqmuKi3R1nRNdVVptiXoW9M11VWl2Zagb03XVlc12xL0rena6qpmW4K+NV1bXdVsS9C3pmurq5ptCfrWdG11VbMtQd+arq2uarYl6FvTtdVVzbYEfWu6troqOyvF36drq6uys+76fbq2uio7q5jfp2urq7K1tnqytbZ6srW2eppsbfU11G265dfB3/7pP/rgQtlmWOv3be8YIxh7YJyrCxTDOFd3+TmM77+ikiZbvF6O41z9sBzHuRptMY6TreMvx3EuayDHcS7PUfY/HUtsccxr+No458cMo/8iM5c96UkmQuYFmblMxBsy9+nO1ew3pztX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",
      "brillig_names": [
        "is_contract_initialized"
      ]
    },
    {
      "name": "get_htlc_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "view",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "key",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "Train::HTLC_Public",
            "fields": [
              {
                "name": "src_receiver",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "amount",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "token",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "hashlock_high",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "hashlock_low",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "secret_high",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "secret_low",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "ownership_hash_high",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "ownership_hash_low",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "timelock",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "claimed",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 8
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "9174444391250494040": {
            "error_kind": "string",
            "string": "Function get_htlc_public can only be called statically"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBYJwAABAMnAgIEAScCAwQAHxgAAwACgEwuCIBMAAElAAAAhyUAAADHLgQAAYBNLgQAAoBOLgQAA4BPLgQABIBQLgQABYBRLgQABoBSLgQAB4BTLgQACIBULgQACYBVLgQACoBWLgQAC4BXKAIADASATScCDQQLOw0ADAANKACAQwQAAygAgEQBAAAoAIBFBAAAKACARgAAACgAgEcBAAEoAIBIBAABKACASQQABCgAgEoEAAsoAIBLBAAXJiUAAAbFHgIAAwAeAgAEADM4AAMABAAFJAIABQAAAOslAAAG7h4CAAMJJwIEAAEKOAMEBSQCAAUAAAEHJQAABwAtCAEDJwIEBAQAEAEEAScDAwQBACgDAgQtDAQFLgqARgAFACgFAgUuCoBGAAUAKAUCBS4KgEYABSsCAAQAAAAAAAAAAAIAAAAAAAAAAC0IAQUnAgYEBQAQAQYBJwMFBAEAKAUCBi0MBgcuCoBGAAcAKAcCBy4KgEYABwAoBwIHLgqARgAHACgHAgctDgQHLQgBBAAAAQIBLQ4DBC0IAQMAAAECAS0OBQMtCAEFAAABAgEuCoBFAAUtCAEGAAABAgEuCoBEAAYnAgcAAicCCAQJLQgACS0MBAotDAMLLQwFDC0MBg0tDAcOABAACAAlAAAHEi0EAAAnAgcECC0IAAgtDAQJLQwDCi0MBQstDAYMLQwBDQAQAAcAJQAABxItBAAALQ0GAQsoAAGARAAHJAIABwAAAkUnAggEADwJAQgnAgEEBy0IAActDAQILQwDCS0MBQotDAYLABAAAQAlAAAIOy0EAAAtDQQBLQ0DBy0NBQgtDgEELQ4HAy0OCAUuCoBHAAYBKAAHgEgAAy0NAwELKAABgEYAAwsoAAOARAAEJAIABAAAArMlAAAJSR4CAAMFHAwDBQQcDAUEABwMBAMELQgBBCcCBQQYABABBQEnAwQEAQAoBAIFJwIGBBcAOAYFBi0MBQcMOAcGCBYMCAgkAgAIAAADDi4KgEYABwAoBwIHIwAAAu0tCAEFAAABAgEtDgQFLgiARQACIwAAAyYNKAACgEsABCQCAAQAAAZ2IwAAAzstDQUCLQgBBAAAAQIBLQ4CBC0IAQIAAAECAS4KgEUAAi0IAQUnAgYEGAAQAQYBJwMFBAEAKAUCBicCBwQXADgHBgctDAYIDDgIBwkWDAkJJAIACQAAA6IuCoBGAAgAKAgCCCMAAAOBLQgBBgAAAQIBLQ4FBi4IgEUAASMAAAO6DSgAAYBLAAUkAgAFAAAF6iMAAAPPLQ0GAS0NAQIAKAICAi0OAgEnAgQEBS0IAAUtDAEGLgiASAAHABAABAAlAAAJWy0EAAAtDAYCLQ0BBAAoBAIELQ4EAScCBAQMJwIGBActCAAHLQwBCC0MBAkAEAAGACUAAAlbLQQAAC0MCAUnAhAEES0IABEtDAISABAAEAAlAAAKiS0EAAAtDBIELQwTBi0MFActDBUILQwWCS0MFwotDBgLLQwZDC0MGg0tDBsOLQwcDycCGgQbLQgAGy0MBRwAEAAaACUAAAqJLQQAAC0MHAItDB0QLQweES0MHxItDCATLQwhFC0MIhUtDCMWLQwkFy0MJRgtDCYZASgAAYBIABotDRoFHAwFGgQcDBoBABwMAQUEDDgDBQEWDAEDHAwBBQAcDAMaAAQ4BQQbBDgaAgQAOBsEAhwMAQQGHAwDGwYEOAQGHAQ4GxAGADgcBhAEOAUHBgQ4GhEFADgGBQcEOAQIBQQ4GxIGADgFBggEOAQJBQQ4GxMGADgFBgkEOAQKBQQ4GxQGADgFBgoEOAQLBQQ4GxUGADgFBgsEOAQMBQQ4GxYGADgFBgwEOAQNBQQ4GxcEADgFBAYcDAEEBRwMAwUFBDgEDg0EOAUYBAA4DQQFHAwBBAIcDAMBAgQ4BA8DBDgBGQQAOAMEAS0MBQ0tDAcDLQwLBy0MAQstDAIBLQwQAi0MCQUtDAYJLQwKBi0MDQotDAgELQwMCCYtDQYFLQ0EBy0NAggNKAAIgEsACSQCAAkAAAYLJQAADSAAKAcCCgA4CggLLQ0LCQEoAAiASAAKDjgICgskAgALAAAGMyUAAA0yLQ4HBC0OCgIuBAAFgAMoAIAEBAAYJQAADUQuCIAFAAcAKAcCCAA4CAEKLQ4JCi0OBwYBKAABgEgABS0MBQEjAAADui0NBQQcDAIGAAA4AQYHLwwABwAGLgQABIADKACABAQAGCUAAA1ELgiABQAHACgHAggAOAgCCS0OBgktDgcFASgAAoBIAAQtDAQCIwAAAyYoAIAEBHgADQAAAIAEgAMkAIADAAAG7SoBAAEF96Hzr6Wt1Mo8AQECJioBAAEFvh4//z6k9vo8AQECJioBAAEFf1IskMgPglg8AQECJiUAAAbFLQ0DBi0NBAcLKAAHgEQACCQCAAgAAAc4JwIJBAA8CQEJCygABoBDAAckAgAHAAAHxyMAAAdNLQ0BBi0NAgctDQMILQ0ECQ0oAAiAQwAKJAIACgAAB3IlAAANIC4EAAaAAygAgAQEAAQlAAANRC4IgAUACgAoCgILADgLCAwtDgUMASgACIBIAAUOOAgFBiQCAAYAAAeyJQAADTItDgoBLQ4HAi0OBQMtDgkEIwAACDonAgYEBy0IAActDAEILQwCCS0MAwotDAQLABAABgAlAAAIOy0EAAAtDQEGLQ0CBy0NBAguBAAGgAMoAIAEBAAEJQAADUQuCIAFAAkAKAkCCgEoAAqARQALLQ4FCy0OCQEtDgcCLgqASAADLQ4IBCMAAAg6JiUAAAbFLgiARQAFIwAACEsNKAAFgEMABiQCAAYAAAi2IwAACGAtDQEFLQ0CBi0NAwctDQQILQ0GCQAoCQIJLQ4JBi0IAQknAgoEBQAQAQoBJwMJBAEAKAYCCicCCwQEACgJAgw/DwAKAAwtDgUBLQ4JAi0OBwMtDggEJi0NAwYMOAUGBwEoAAWASAAGJAIABwAACNQjAAAJQC0NAQctDQIILQ0DCS0NBAoAKAgCDAA4DAUNLQ0NCwAoBwINADgNBQ4tDQ4MADgLDA0uBAAIgAMoAIAEBAAFJQAADUQuCIAFAAsAKAsCDAA4DAUOLQ4NDi0OBwEtDgsCLQ4JAy0OCgQjAAAJQC0MBgUjAAAISyoBAAEFAtxuJ4B2Ep08AQECJiUAAAbFASgAAoBKAAQOOAIEBSQCAAUAAAl6JQAADTINMIBLAAQABQsoAAWARAAEJAIABAAACZclAAAN0i0IAQQnAgUEDAAQAQUBJwMEBAEAKAQCBScCBgQLADgGBQYtDAUHDDgHBggWDAgIJAIACAAACd4uCoBGAAcAKAcCByMAAAm9LQgBBQAAAQIBLQ4EBS4IgEUAAyMAAAn2DSgAA4BKAAQkAgAEAAAKECMAAAoLLQ0FASYtDQUEADgDAgYOOAMGByQCAAcAAAorJQAADTINKAAGgEsAByQCAAcAAApAJQAADSAAKAECCAA4CAYJLQ0JBy4EAASAAygAgAQEAAwlAAANRC4IgAUABgAoBgIIADgIAwktDgcJASgAA4BIAAQtDgYFLQwEAyMAAAn2JQAABsUBKAABgEgAAy0NAwInAgMEAgA4AQMFLQ0FBC0IAQMnAgUEAgAQAQUBJwMDBAEAKAMCBS0MBQYtDgQGJwIFBAYtCAAGLQwDBwAQAAUAJQAADeQtBAAALQwHBAEoAAGAQwAFLQ0FAwEoAAGASQAGLQ0GBS0IAQYnAgcEAgAQAQcBJwMGBAEAKAYCBy0MBwgtDgUIJwIHBAgtCAAILQwGCQAQAAcAJQAADeQtBAAALQwJBScCBgQFADgBBggtDQgHLQgBBicCCAQCABABCAEnAwYEAQAoBgIILQwICS0OBwknAggECS0IAAktDAYKABAACAAlAAAN5C0EAAAtDAoHJwIGBAYAOAEGCS0NCQgtCAEGJwIJBAIAEAEJAScDBgQBACgGAgktDAkKLQ4ICicCCQQKLQgACi0MBgsAEAAJACUAAA3kLQQAAC0MCwgnAgYEBwA4AQYKLQ0KCS0IAQYnAgoEAgAQAQoBJwMGBAEAKAYCCi0MCgstDgkLJwIKBAstCAALLQwGDAAQAAoAJQAADeQtBAAALQwMCScCBgQIADgBBgstDQsKLQgBBicCCwQCABABCwEnAwYEAQAoBgILLQwLDC0OCgwnAgsEDC0IAAwtDAYNABAACwAlAAAN5C0EAAAtDA0KJwIGBAkAOAEGDC0NDAstCAEGJwIMBAIAEAEMAScDBgQBACgGAgwtDAwNLQ4LDScCDAQNLQgADS0MBg4AEAAMACUAAA3kLQQAAC0MDgsnAgYECgA4AQYNLQ0NDBwMDA0FHAwNBgAcDAYMBQEoAAGASgANLQ0NBhwMBg0CHAwNAQAcDAEGAi0MAgEtDAQCLQwFBC0MBwUtDAkHLQwLCS0MBgstDAgGLQwKCC0MDAomKgEAAQXFa8RaDhAAAjwBAQImKgEAAQVFp8pxGUHkFTwBAQImLgGAA4AGCwCABgACgAckAIAHAAANXyMAAA1qLgCAA4AFIwAADdEuAAABgAUBAAABgAQAAQEAgAOABIAJLgCAA4AKLgCABYALCwCACoAJgAwkAIAMAAANvS4BgAqACC4CgAiACwEAgAoAAoAKAQCACwACgAsjAAANjCgBgAUEAAEDAIAGAAKABiMAAA3RJioBAAEF9C7lhLv0IdE8AQECJiUAAAbFASgAAYBIAAMtDQMCHAwCAwYcDAMBABwMAQIGLQwCASY=",
      "debug_symbols": "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",
      "brillig_names": [
        "get_htlc_public"
      ]
    },
    {
      "name": "commit_public_user",
      "is_unconstrained": true,
      "custom_attributes": [
        "internal",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 48
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "src_receiver",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3559210201980528457": {
            "error_kind": "string",
            "string": "Function commit_public_user can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "commit_public_user"
      ]
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "constructor"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000001"
            },
            {
              "kind": "string",
              "value": "HTLC_Private"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Train"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "contracts_private",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "contracts_public",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::add_lock_public_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::add_lock_public_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::add_lock_private_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::add_lock_private_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "key",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::get_htlc_public_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "src_receiver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "hashlock_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "hashlock_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "secret_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "secret_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "ownership_hash_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "ownership_hash_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "claimed",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::HTLC_Public"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::get_htlc_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "secret",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "ownership_key",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::redeem_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::redeem_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::refund_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::refund_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "ownership_hash",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 48
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::lock_private_solver_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::lock_private_solver_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "secret",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "ownership_key",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::redeem_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::redeem_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "ownership_hash",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 48
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::lock_public_solver_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::lock_public_solver_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 48
                    }
                  },
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "src_receiver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::commit_public_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::commit_public_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::refund_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::refund_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "src_receiver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 48
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::commit_private_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::commit_private_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "Train::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::constructor_abi"
        }
      ]
    }
  },
  "file_map": {
    "100": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "101": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\nuse super::utils::is_note;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract. Only a single struct in the entire contract\n/// should have this macro (or `storage_no_init`) applied to it.\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot }, false);\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n/// Only a single struct in the entire contract should have this macro (or `storage`) applied to it.\npub comptime fn storage_no_init(_s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(\n    typ: Type,\n    slot: Quoted,\n    parent_is_map: bool,\n) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot }, true);\n        (quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }, 1)\n    } else {\n        let storage_size = if parent_is_map {\n            // Variables inside a map do not require contiguous slots since the map slot derivation is assumed to result\n            // in slots very far away from one another.\n            1\n        } else {\n            let (_, container_struct_generics) = typ.as_data_type().unwrap();\n            let stored_struct = container_struct_generics[0];\n\n            if is_note(stored_struct) {\n                // Private notes always occupy a single slot, since the slot is only used as a state variable\n                // identifier.\n                1\n            } else {\n                get_storage_size(typ)\n            }\n        };\n\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        (quote { $struct_name::new(context, $slot)}, storage_size)\n    }\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "103": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "104": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash =\n            compute_unique_note_hash(nonce, compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash));\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.nonce, note_and_data.nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == first_note_and_data.nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == second_note_and_data.nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "105": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    pending_partial_notes.for_each(|i, pending_partial_note: DeliveredPendingPartialNote| {\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log sans the extra\n            // fields) to get the complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                // temporary node connectivity issue - is simply throwing good enough here?\n                assert(\n                    deliver_note(\n                        contract_address,\n                        pending_partial_note.storage_slot,\n                        discovered_note.nonce,\n                        complete_packed_note,\n                        discovered_note.note_hash,\n                        discovered_note.inner_nullifier,\n                        log.tx_hash,\n                        pending_partial_note.recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "107": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/private_logs.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{\n            ComputeNoteHashAndNullifier,\n            partial_notes::process_partial_note_private_msg,\n            pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n            private_notes::process_private_note_msg,\n        },\n        encoding::decode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        msg_type::{\n            PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n        },\n    },\n    oracle::{logs::store_private_event_log, message_discovery::sync_notes},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `syncNotes` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    sync_notes(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get the logs from the capsule array and process them one by one\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    logs.for_each(|i, log: PendingTaggedLog| {\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n        logs.remove(i);\n    });\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(log_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            pending_tagged_log.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        // In the case of events, the msg metadata is the event selector.\n        let event_selector = EventSelector::from_field(msg_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            msg_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n            pending_tagged_log.tx_index_in_block,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "108": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n        // issue, and we should perhaps not have marked the tag index as taken.\n        assert(\n            oracle::message_discovery::deliver_note(\n                contract_address,\n                storage_slot,\n                discovered_note.nonce,\n                packed_note,\n                discovered_note.note_hash,\n                discovered_note.inner_nullifier,\n                tx_hash,\n                recipient,\n            ),\n            \"Failed to deliver note\",\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "109": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\nglobal MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "110": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "117": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/logs/note.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    messages::{\n        encoding::encode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        logs::utils::prefix_with_tag,\n        msg_type::{PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID},\n    },\n    note::{note_emission::NoteEmission, note_interface::NoteType},\n};\nuse protocol_types::{\n    abis::note_hash::NoteHash, address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS,\n    traits::Packable,\n};\n\n// TODO: it feels like this existence check is in the wrong place. In fact, why is it needed at all? Under what circumstances have we found a non-existent note being emitted accidentally?\nfn assert_note_exists<let N: u32>(context: PrivateContext, note_hash_counter: u32) {\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists =\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n}\n\npub fn compute_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PRIVATE_NOTE_MSG_TYPE_ID,\n    )\n}\n\npub fn compute_partial_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID,\n    )\n}\n\nfn compute_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    msg_type: u64,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let packed_note = note.pack();\n\n    // A note message's content is the storage slot followed by the packed note representation\n    let mut msg_content: [Field; N + 1] = std::mem::zeroed();\n    msg_content[0] = storage_slot;\n    for i in 0..packed_note.len() {\n        msg_content[1 + i] = packed_note[i];\n    }\n\n    // Notes use the note type id for metadata\n    let plaintext = encode_message(msg_type, Note::get_id() as u64, msg_content);\n\n    let ciphertext = AES128::encrypt_log(plaintext, recipient);\n\n    let log = prefix_with_tag(ciphertext, sender, recipient);\n\n    log\n}\n\npub unconstrained fn compute_note_log_unconstrained<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_note_log(note, storage_slot, recipient, sender)\n}\n\n/// Sends an encrypted message to `recipient` with the content of the note, which they will discover when processing\n/// private logs.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n        assert_note_exists(*context, note_hash_counter);\n\n        let encrypted_log = compute_note_log(note, storage_slot, recipient, sender);\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n\n/// Same as `encode_and_encrypt_note`, except encryption is unconstrained. This means that the sender is free to make\n/// the log contents be whatever they wish, potentially resulting in scenarios in which the recipient is unable to\n/// decrypt and process the payload, **leading to the note being lost**.\n///\n/// Only use this function in scenarios where the recipient not receiving the note is an acceptable outcome.\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n\n        assert_note_exists(*context, note_hash_counter);\n\n        // Safety: this function does not constrain the encryption of the log, as explained on its description.\n        let encrypted_log =\n            unsafe { compute_note_log_unconstrained(note, storage_slot, recipient, sender) };\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n"
    },
    "118": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/logs/utils.nr",
      "source": "use crate::{\n    oracle::notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n    prelude::AztecAddress,\n};\n\npub(crate) fn prefix_with_tag<let L: u32>(\n    log_without_tag: [Field; L],\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> [Field; L + 1] {\n    // Safety: we assume that the sender wants for the recipient to find the tagged note, and therefore that they will\n    // cooperate and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the\n    // note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    let mut log_with_tag = [0; L + 1];\n\n    log_with_tag[0] = tag;\n    for i in 0..log_without_tag.len() {\n        log_with_tag[i + 1] = log_without_tag[i];\n    }\n\n    log_with_tag\n}\n\nmod test {\n    use super::prefix_with_tag;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn prefixing_with_tag() {\n        let sender = AztecAddress::from_field(1);\n        let recipient = AztecAddress::from_field(2);\n\n        let app_tagging_secret = 42;\n        let index = 5;\n\n        // I am using the deserialize trait instead of directly instantiating the IndexedTaggingSecret struct because\n        // direct instantiation functionality is not exposed.\n        let indexed_tagging_secret = IndexedTaggingSecret::deserialize([app_tagging_secret, index]);\n\n        // Mock the tagging oracles\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(indexed_tagging_secret);\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        let log_without_tag = [1, 2, 3];\n        let log_with_tag = prefix_with_tag(log_without_tag, sender, recipient);\n\n        let expected_result = [indexed_tagging_secret.compute_tag(recipient), 1, 2, 3];\n\n        // Check tag was prefixed correctly\n        assert_eq(log_with_tag, expected_result, \"Tag was not prefixed correctly\");\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "123": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_interface::{NoteHash, NoteType},\n    retrieved_note::RetrievedNote,\n    utils::{compute_note_hash_for_nullify_from_read_request, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::notify_created_note;\nuse protocol_types::traits::Packable;\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    let note_hash_counter = context.side_effect_counter;\n\n    let note_hash = note.compute_note_hash(storage_slot);\n\n    let packed_note = Note::pack(note);\n    notify_created_note(\n        storage_slot,\n        Note::get_id(),\n        packed_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(note, storage_slot, note_hash_counter)\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n\n    destroy_note_unsafe(context, retrieved_note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_from_read_request(retrieved_note, note_hash_for_read_request);\n    let nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash = if retrieved_note.metadata.is_settled() {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifying so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, note_hash)\n}\n"
    },
    "125": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub note: Note,\n    pub storage_slot: Field,\n    pub note_hash_counter: u32, // a note_hash_counter of 0 means settled\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note, storage_slot: Field, note_hash_counter: u32) -> Self {\n        Self { note, storage_slot, note_hash_counter }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "128": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/note/note_getter.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n    retrieved_note::RetrievedNote,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::oracle;\nuse crate::utils::{array, comparison::compare};\nuse dep::protocol_types::{\n    constants::{GET_NOTES_ORACLE_RETURN_LENGTH, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL},\n    traits::{Packable, ToField},\n};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    packed_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the packed note.\n    // This allows easier packing and custom (un)packing schemas. A note property is located\n    // inside the packed note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = packed_note[selector.index as u32].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[(31 + offset - i) as u32] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_packed_note<let N: u32>(packed_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(packed_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (RetrievedNote<Note>, Field)\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    // Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do\n    // is check that the metadata is correct, and that the note exists.\n    let retrieved_note = unsafe { get_note_internal::<Note, N>(storage_slot) };\n\n    // For settled notes, the contract address is implicitly checked since the hash returned from\n    // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n    // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the contract\n    // address returned from the oracle matches. Since branching in circuits is expensive, we perform this check on all\n    // note types.\n    assert(\n        retrieved_note.contract_address.eq(context.this_address()),\n        \"Note contract address mismatch.\",\n    );\n\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (retrieved_note, note_hash_for_read_request)\n}\n\n/// Returns a BoundedVec of notes that have been proven to have been created by this contract, either in the current or\n/// past transactions (i.e. pending or settled notes). A second BoundedVec contains the note hashes used for the read\n/// requests, which can save constraints when computing the note's nullifiers.\n///\n/// WARNING: recall that notes are never destroyed! Note existence therefore does not imply that the note is _current_\n/// or _valid_ - this typically requires also emitting the note's nullifier to prove that it had not been emitted\n/// before. Because of this, calling this function directly from end-user applications should be discouraged, and safe\n/// abstractions such as aztec-nr's state variables should be used instead.\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // Safety: The notes are constrained below.\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the notes (as opposed to simply removing some), the private\n    // kernel will later validate that these note actually exist, so transformations would cause for that check\n    // to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = array::collapse(filtered_notes);\n    let mut note_hashes = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_packed_note = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let retrieved_note = notes.get_unchecked(i);\n\n            // For settled notes, the contract address is implicitly checked since the hash returned from\n            // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n            // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the\n            // contract address returned from the oracle matches. Since branching in circuits is expensive, we perform\n            // this check on all note types.\n            assert(\n                retrieved_note.contract_address.eq(context.this_address()),\n                \"Note contract address mismatch.\",\n            );\n\n            let packed_note = retrieved_note.note.pack();\n            check_packed_note(packed_note, options.selects);\n            if i != 0 {\n                check_notes_order(prev_packed_note, packed_note, options.sorts);\n            }\n            prev_packed_note = packed_note;\n\n            let note_hash_for_read_request =\n                compute_note_hash_for_read_request(retrieved_note, storage_slot);\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> RetrievedNote<Note>\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let opt_notes: [_; 1] = oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_fields,\n    );\n\n    opt_notes[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_fields,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\n/// Unconstrained variant of `get_notes`, meant to be used in unconstrained execution contexts. Notably only the note\n/// content is returned, and not any of the information used when proving its existence (e.g. nonce, note hash, etc.).\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteType + Packable<N> + Eq,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n\n    // We fetch the notes from the same oracle we use in the constrained case, except we don't bother inspecting the\n    // metadata in order to prove existence.\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_fields,\n    );\n\n    // Even though we don't expect for the opt_notes array to be sparse, collapse is still useful in this case to\n    // convert it into a BoundedVec.\n    array::collapse(opt_notes).map(\n        // view_notes just returns the actual note, so we drop the metadata\n        |retrieved_note| retrieved_note.note,\n    )\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects as u32] = select.unwrap_unchecked().value;\n            select_comparators[num_selects as u32] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
    },
    "131": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "134": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "137": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "138": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "139": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "140": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "141": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "142": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "146": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "147": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "148": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "149": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use crate::messages::encoding::MAX_MESSAGE_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        msg_content,\n        tx_hash,\n        log_index_in_tx,\n        tx_index_in_block,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {}\n"
    },
    "150": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr",
      "source": "use crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn sync_notes(pending_tagged_log_array_base_slot: Field) {\n    sync_notes_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "152": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::{\n    note::{note_interface::NoteType, note_metadata::NoteMetadata, retrieved_note::RetrievedNote},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::IndexedTaggingSecret,\n    traits::{FromField, Packable},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {\n    // This wrapper exists to extract the ORACLE_RETURN_FIELD_LENGTH generic numeric param into a value and pass it to\n    // the oracle, so that it knows how big the return array must be.\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        ORACLE_RETURN_FIELD_LENGTH,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let MAX_NOTES: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    _placeholder_fields: [Field; ORACLE_RETURN_FIELD_LENGTH], // TODO: Compute this value automatically from MAX_NOTES\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let fields: [_; ORACLE_RETURN_FIELD_LENGTH] = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n\n    let mut opt_notes = [Option::none(); MAX_NOTES];\n    for i in 0..opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let maybe_nonce = fields[read_offset];\n            let maybe_note_hash_counter = fields[read_offset + 1] as u32;\n            let packed_note = array::subarray(fields, read_offset + 2);\n\n            let note = Note::unpack(packed_note);\n            let retrieved_note = RetrievedNote {\n                note,\n                contract_address,\n                metadata: NoteMetadata::from_raw_data(maybe_note_hash_counter != 0, maybe_nonce),\n            };\n\n            opt_notes[i] = Option::some(retrieved_note);\n        };\n    }\n    opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "153": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "154": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "155": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "157": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "159": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/state_vars/private_immutable.nr",
      "source": "use dep::protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\nuse crate::context::{PrivateContext, UtilityContext};\nuse crate::note::{\n    lifecycle::create_note,\n    note_emission::NoteEmission,\n    note_getter::{get_note, view_notes},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateImmutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context, let N: u32> Storage<N> for PrivateImmutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateImmutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateImmutable>` type (for example), because the storage slot often also identifies an actor.\n    // e.g. the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<Note> PrivateImmutable<Note, &mut PrivateContext> {\n    // docs:start:initialize\n    pub fn initialize<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: NoteType + NoteHash + Packable<N>,\n    {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:get_note\n    pub fn get_note<let N: u32>(self) -> Note\n    where\n        Note: NoteType + NoteHash + Packable<N>,\n    {\n        let storage_slot = self.storage_slot;\n        let retrieved_note = get_note(self.context, storage_slot).0;\n\n        // Because the notes obtained from PrivateImmutable are not meant to be nullified and get_note(...) function\n        // has already constrained the note (by pushing a read request to the context), we can return just the note\n        // and skip the additional data in RetrievedNote.\n        retrieved_note.note\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateImmutable<Note, UtilityContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    // docs:start:is_initialized\n    pub unconstrained fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // view_note does not actually use the context, but it calls oracles that are only available in private\n    // docs:start:view_note\n    pub unconstrained fn view_note<let N: u32>(self) -> Note\n    where\n        Note: Packable<N>,\n    {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: x_coordinates_match,\n        };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "168": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable.nr",
      "source": "use dep::protocol_types::{\n    shared_mutable::{\n        ScheduledDelayChange,\n        ScheduledValueChange,\n        shared_mutable_values::{unpack_delay_change, unpack_value_change},\n        SharedMutableValues,\n    },\n    traits::Packable,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\n\nmod test;\n\npub struct SharedMutable<T, let INITIAL_DELAY: u32, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// This will make the Aztec macros require that T implements the Packable and Eq traits, and allocate `M` storage\n// slots to this state variable.\nimpl<T, let INITIAL_DELAY: u32, Context, let M: u32> Storage<M> for SharedMutable<T, INITIAL_DELAY, Context>\nwhere\n    WithHash<SharedMutableValues<T, INITIAL_DELAY>, _>: Packable<M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in blocks. Reads in private are only valid as long as they are included in a block not too far into the\n// future, so that they can guarantee the value will not have possibly changed by then (because of the delay).\n// The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, let INITIAL_DELAY: u32, Context> SharedMutable<T, INITIAL_DELAY, Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PublicContext>\nwhere\n    T: Eq,\n{\n\n    pub fn schedule_value_change<let N: u32>(self, new_value: T)\n    where\n        T: Packable<N>,\n    {\n        let _value_change = self.schedule_and_return_value_change(new_value);\n    }\n\n    pub fn schedule_and_return_value_change<let N: u32>(\n        self,\n        new_value: T,\n    ) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n        let current_delay = delay_change.get_current(block_number);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let block_of_change = block_number + current_delay;\n        value_change.schedule_change(new_value, block_number, current_delay, block_of_change);\n\n        self.write(value_change, delay_change);\n\n        value_change\n    }\n\n    pub fn schedule_delay_change<let N: u32>(self, new_delay: u32)\n    where\n        T: Packable<N>,\n    {\n        let mut delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n\n        delay_change.schedule_change(new_delay, block_number);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    pub fn get_current_delay<let N: u32>(self) -> u32\n    where\n        T: Packable<N>,\n    {\n        let block_number = self.context.block_number() as u32;\n        self.read_delay_change().get_current(block_number)\n    }\n\n    pub fn get_scheduled_value<let N: u32>(self) -> (T, u32)\n    where\n        T: Packable<N>,\n    {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay<let N: u32>(self) -> (u32, u32)\n    where\n        T: Packable<N>,\n    {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change<let N: u32>(self) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        // We don't read ScheduledValueChange directly by having it implement Packable because ScheduledValueChange\n        // and ScheduledDelayChange are packed together (sdc and svc.block_of_change are stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_value_change::<T, N>(packed)\n    }\n\n    fn read_delay_change<let N: u32>(self) -> ScheduledDelayChange<INITIAL_DELAY>\n    where\n        T: Packable<N>,\n    {\n        // Since all ScheduledDelayChange member are packed into a single field, we can read a single storage slot\n        // here and skip the ones that correspond to ScheduledValueChange members. We are abusing the fact that\n        // the field containing the ScheduledDelayChange data is the first one in the storage layout - otherwise we'd\n        // need to offset the storage slot to get the position where it'd land.\n        // We don't read ScheduledDelayChange directly by having it implement Packable because\n        // ScheduledValueChange and ScheduledDelayChange are packed together (sdc and svc.block_of_change are\n        // stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_delay_change::<INITIAL_DELAY>(packed)\n    }\n\n    fn write<let N: u32>(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>,\n    )\n    where\n        T: Packable<N>,\n    {\n        // Whenever we write to public storage, we write both the value change and delay change to storage at once.\n        // We do so by wrapping them in a single struct (`SharedMutableValues`). Then we wrap the resulting struct in\n        // `WithHash`.\n        // Wrapping in `WithHash` makes for more costly writes but it also makes private proofs much simpler because\n        // they only need to produce a historical proof for the hash, which results in a single inclusion proof (as\n        // opposed to 4 in the best case scenario in which T is a single field). Private shared mutable reads are\n        // assumed to be much more frequent than public writes, so this tradeoff makes sense.\n        let values = WithHash::new(SharedMutableValues::new(value_change, delay_change));\n\n        self.context.storage_write(self.storage_slot, values);\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext>\nwhere\n    T: Eq,\n{\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction block number as this proof\n        // will only be valid for however many blocks we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n        let (value_change, delay_change, historical_block_number) =\n            self.historical_read_from_public_storage();\n\n        // We use the effective minimum delay as opposed to the current delay at the historical block as this one also\n        // takes into consideration any scheduled delay changes.\n        // For example, consider a scenario in which at block 200 the current delay was 50. We may naively think that\n        // the earliest we could change the value would be at block 251 by scheduling immediately after the historical\n        // block, i.e. at block 201. But if there was a delay change scheduled for block 210 to reduce the delay to 20\n        // blocks, then if a value change was scheduled at block 210 it would go into effect at block 230, which is\n        // earlier than what we'd expect if we only considered the current delay.\n        let effective_minimum_delay =\n            delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon =\n            value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any block after the block horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_tx_max_block_number(block_horizon);\n        value_change.get_current_at(historical_block_number)\n    }\n\n    fn historical_read_from_public_storage<let N: u32>(\n        self,\n    ) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u32)\n    where\n        T: Packable<N>,\n    {\n        let header = self.context.get_block_header();\n        let address = self.context.this_address();\n\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        let values: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::historical_public_storage_read(header, address, self.storage_slot);\n\n        (values.svc, values.sdc, historical_block_number)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, UtilityContext>\nwhere\n    T: Eq,\n{\n    pub unconstrained fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let smv: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::utility_public_storage_read(self.context, self.storage_slot);\n\n        let block_number = self.context.block_number() as u32;\n        smv.svc.get_current_at(block_number)\n    }\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "180": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "183": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "184": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "186": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "187": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "189": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "191": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "192": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/random.nr",
      "source": "use crate::oracle::random::random;\n\n/// Returns as many random bytes as specified through N.\npub unconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n"
    },
    "195": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "202": {
      "path": "/home/nerses/nargo/github.com/noir-lang/poseidon/v0.1.0/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "219": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "221": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "264": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "279": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "281": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "282": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "283": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr",
      "source": "use crate::traits::{Deserialize, Serialize, ToField};\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\nuse std::meta::derive;\n\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\n\n#[derive(Serialize, Deserialize)]\npub struct IndexedTaggingSecret {\n    app_tagging_secret: Field,\n    index: u32,\n}\n\nimpl IndexedTaggingSecret {\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\n        poseidon2_hash(\n            [self.app_tagging_secret, recipient.to_field(), self.index as Field],\n        )\n    }\n}\n"
    },
    "292": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "296": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint =\n        quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_pack & typ.implements(packable_constraint)) {\n        // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n        let name_at_one_token = collapse_to_one_token(name);\n        let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n        // We add the individual fields to the fields array\n        let pack_method = get_trait_impl_method(\n            typ,\n            quote { crate::traits::Packable<$packed_len> },\n            quote { pack },\n        );\n        let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n        for i in 0..packed_len {\n            fields = fields.push_back(quote { $packed_struct_name[$i] });\n        }\n\n        // We add the new auxiliary variable to the aux_vars array\n        aux_vars = aux_vars.push_back(packed_struct);\n    } else if typ.is_field() {\n        // For field we just add the value to fields\n        fields = fields.push_back(name);\n    } else if typ.as_integer().is_some() | typ.is_bool() {\n        // For integer and bool we just cast to Field and add the value to fields\n        fields = fields.push_back(quote { $name as Field });\n    } else if typ.as_data_type().is_some() {\n        // For struct we pref\n        let nested_struct = typ.as_data_type().unwrap();\n        let params = nested_struct.0.fields(nested_struct.1);\n        let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n            let maybe_prefixed_name = if name == quote {} {\n                // Triggered when the param name is of a value available in the current scope (e.g. a function\n                // argument) --> then we don't prefix the name with anything.\n                param_name\n            } else {\n                // Triggered when we want to prefix the param name with the `name` from function input. This\n                // can typically be `self` when implementing a method on a struct.\n                quote { $name.$param_name }\n            };\n            generate_serialize_to_fields(quote {$maybe_prefixed_name}, param_type, should_pack)\n        });\n        let struct_flattened_fields = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n        );\n        let struct_flattened_aux_vars = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n        );\n        fields = fields.append(struct_flattened_fields);\n        aux_vars = aux_vars.append(struct_flattened_aux_vars);\n    } else if typ.as_array().is_some() {\n        // For array we recursively call `generate_serialize_to_fields(...)` for each element\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        for i in 0..array_len {\n            let (element_fields, element_aux_vars) =\n                generate_serialize_to_fields(quote { $name[$i] }, element_type, should_pack);\n            fields = fields.append(element_fields);\n            aux_vars = aux_vars.append(element_aux_vars);\n        }\n    } else if typ.as_str().is_some() {\n        // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n        // then we add each byte to fields as a Field\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let as_member = name.as_expr().unwrap().as_member_access();\n        let var_name = if as_member.is_some() {\n            as_member.unwrap().1\n        } else {\n            name\n        };\n        let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n        let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n        for i in 0..str_len {\n            fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n        }\n        aux_vars = aux_vars.push_back(as_bytes);\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "298": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "299": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "308": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "312": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_delay_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initially equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation\n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the\n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a\n// reduced delay, invalidating prior private reads.\npub struct ScheduledDelayChange<let INITIAL_DELAY: u32> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option,\n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pub(crate) pre: Option<u32>,\n    pub(crate) post: Option<u32>,\n    // Block at which `post` value is used instead of `pre`\n    pub(crate) block_of_change: u32,\n}\n\nimpl<let INITIAL_DELAY: u32> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u32>, post: Option<u32>, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current block number - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_block_number: u32) -> u32 {\n        // The post value becomes the current one at the block of change, so any transaction that is included in the\n        // block of change will use the post value.\n        if current_block_number < self.block_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the block at which it will become the current\n    /// delay. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u32, u32) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.block_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current block number. This function is only meaningful\n    /// when called in public with the current block number.\n    /// The block at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u32, current_block_number: u32) {\n        let current = self.get_current(current_block_number);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let blocks_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior constraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value block of change\n            //       block                 block of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   blocks until change               new delay            |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.block_of_change = current_block_number + blocks_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical block number. It only returns a meaningful value when called in private with historical blocks. This\n    /// function can be used alongside `ScheduledValueChange.get_block_horizon` to properly constrain the\n    /// `max_block_number` transaction property when reading mutable shared state.\n    /// This value typically equals the current delay at the block following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is\n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_block_number: u32) -> u32 {\n        if self.block_of_change <= historical_block_number {\n            // If no delay changes were scheduled, then the delay value at the historical block (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // block of change the current delay will be the scheduled one, with an overall delay from the historical\n            // block number equal to the number of blocks until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //         block                  delay                  actual earliest value\n            //           v                block of change              block of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest block in            |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |         blocks                  new delay                      |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest block in\n            //                             which to scheduled value change\n            let blocks_until_change = self.block_of_change - (historical_block_number + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                blocks_until_change + self.post.unwrap_or(INITIAL_DELAY),\n            )\n        }\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Empty for ScheduledDelayChange<INITIAL_DELAY> {\n    fn empty() -> Self {\n        Self { pre: Option::none(), post: Option::none(), block_of_change: 0 }\n    }\n}\n"
    },
    "314": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_value_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some block\n// called the `block_of_change`. The value can only be made to change by scheduling a change event at some future block\n// of change after some minimum delay measured in blocks has elapsed. This means that at any given block number we know\n// both the current value and the smallest block number at which the value might change - this is called the\n// 'block horizon'.\npub struct ScheduledValueChange<T> {\n    pub(crate) pre: T,\n    pub(crate) post: T,\n    // Block at which `post` value is used instead of `pre`\n    pub(crate) block_of_change: u32,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given block. This function can be called both in public\n    /// (where `block_number` is simply the current block number, i.e. the number of the block in which the current\n    /// transaction will be included) and in private (where `block_number` is the historical block number that is used\n    /// to construct the proof).\n    /// Reading in private is only safe if the transaction's `max_block_number` property is set to a value lower or\n    /// equal to the block horizon (see `get_block_horizon()`).\n    pub fn get_current_at(self, block_number: u32) -> T {\n        // The post value becomes the current one at the block of change. This means different things in each realm:\n        // - in public, any transaction that is included in the block of change will use the post value\n        // - in private, any transaction that includes the block of change as part of the historical state will use the\n        //   post value (barring any follow-up changes)\n        if block_number < self.block_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the block at which it will become the current\n    /// value. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u32) {\n        (self.post, self.block_of_change)\n    }\n\n    // Returns the previous value. This is the value that is current up until the block of change. Note that this value\n    // might not be the current anymore since block of change might have already passed.\n    pub fn get_previous(self) -> (T, u32) {\n        (self.pre, self.block_of_change)\n    }\n\n    /// Returns the largest block number at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_block_number`,\n    /// since due to its asynchronous nature private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum number of blocks that need to\n    /// elapse from the next block until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical block number is only safe to use\n    /// if the transaction's `max_block_number` property is set to a value lower or equal to the block horizon computed\n    /// using the same historical block number.\n    pub fn get_block_horizon(self, historical_block_number: u32, minimum_delay: u32) -> u32 {\n        // The block horizon is the very last block in which the current value is known. Any block past the horizon\n        // (i.e. with a block number larger than the block horizon) may have a different current value. Reading the\n        // current value in private typically requires constraining the maximum valid block number to be equal to the\n        // block horizon.\n        if historical_block_number >= self.block_of_change {\n            // Once the block of change has been mined, the current value (post) will not change unless a new value\n            // change is scheduled. This did not happen at the historical block number (or else it would not be\n            // greater or equal to the block of change), and therefore could only happen after the historical block\n            // number. The earliest would be the immediate next block, and so the smallest possible next block of change\n            // equals `historical_block_number + 1 + minimum_delay`. Our block horizon is simply the previous block to\n            // that one.\n            //\n            //      block of      historical\n            //       change         block            block horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n            historical_block_number + minimum_delay\n        } else {\n            // If the block of change has not yet been mined however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the block horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the block of change is in the past: the time horizon is the\n            //      block prior to the earliest one in which a new block of change might land.\n            //\n            //         historical\n            //           block                        block horizon      block of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` blocks away from the historical block number, in which case\n            //      the block of change would become the limiting factor for the time horizon, which would equal the\n            //      block right before the block of change (since by definition the value changes at the block of\n            //      change).\n            //\n            //           historical                         block horizon\n            //             block     block of change       if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the block of change to an arbitrary\n            // value, and therefore scenario a) is not currently possible. However implementing #5501 would allow for\n            // this to happen.\n            // Because historical_block_number < self.block_of_change, then block_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.block_of_change - 1,\n                historical_block_number + minimum_delay,\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current block number. This function is only meaningful when\n    /// called in public with the current block number.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_block_number: u32,\n        minimum_delay: u32,\n        block_of_change: u32,\n    ) {\n        assert(block_of_change >= current_block_number + minimum_delay);\n\n        self.pre = self.get_current_at(current_block_number);\n        self.post = new_value;\n        self.block_of_change = block_of_change;\n    }\n}\n\nimpl<T> Eq for ScheduledValueChange<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n\nimpl<T> Empty for ScheduledValueChange<T>\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        Self { pre: T::empty(), post: T::empty(), block_of_change: 0 }\n    }\n}\n"
    },
    "316": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/shared_mutable_values.nr",
      "source": "use crate::{\n    hash::poseidon2_hash,\n    shared_mutable::{\n        scheduled_delay_change::ScheduledDelayChange, scheduled_value_change::ScheduledValueChange,\n    },\n    traits::{Hash, Packable},\n    utils::arrays,\n};\nuse std::meta::derive;\n\nmod test;\n\n/// SharedMutableValues is just a wrapper around ScheduledValueChange and ScheduledDelayChange that then allows us\n/// to wrap both of these values in WithHash. WithHash allows for efficient read of values in private.\n///\n/// Note that the WithHash optimization does not work in public (due to there being no unconstrained). But we also want\n/// to be able to read the values efficiently in public and we want to be able to read each value separately. Reading\n/// the values separately is tricky because ScheduledValueChange and ScheduledDelayChange are packed together (sdc and\n/// svc.block_of_change are stored in the same slot). For that reason we expose `unpack_value_change` and\n/// `unpack_delay_change` functions that can be used to extract the values from the packed representation. This\n/// is \"hacky\" but there is no way around it.\n#[derive(Eq)]\npub struct SharedMutableValues<T, let INITIAL_DELAY: u32> {\n    pub svc: ScheduledValueChange<T>,\n    pub sdc: ScheduledDelayChange<INITIAL_DELAY>,\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutableValues<T, INITIAL_DELAY> {\n    pub fn new(svc: ScheduledValueChange<T>, sdc: ScheduledDelayChange<INITIAL_DELAY>) -> Self {\n        SharedMutableValues { svc, sdc }\n    }\n}\n\npub fn unpack_value_change<T, let N: u32>(packed: [Field; 2 * N + 1]) -> ScheduledValueChange<T>\nwhere\n    T: Packable<N>,\n{\n    let svc_pre_packed = arrays::subarray(packed, 1);\n    let svc_post_packed = arrays::subarray(packed, N + 1);\n    ScheduledValueChange::new(\n        T::unpack(svc_pre_packed),\n        T::unpack(svc_post_packed),\n        packed[0] as u32,\n    )\n}\n\npub fn unpack_delay_change<let INITIAL_DELAY: u32>(\n    packed: Field,\n) -> ScheduledDelayChange<INITIAL_DELAY> {\n    // This function expects to be called with just the first field of the packed representation, which contains sdc\n    // and svc block_of_change. We'll discard the svc component.\n    let svc_block_of_change = packed as u32;\n\n    let mut tmp = (packed - svc_block_of_change as Field) / TWO_POW_32;\n    let sdc_block_of_change = tmp as u32;\n\n    tmp = (tmp - sdc_block_of_change as Field) / TWO_POW_32;\n    let sdc_post_is_some = tmp as bool;\n\n    tmp = (tmp - sdc_post_is_some as Field) / TWO_POW_8;\n    let sdc_post_inner = tmp as u32;\n\n    tmp = (tmp - sdc_post_inner as Field) / TWO_POW_32;\n    let sdc_pre_is_some = tmp as bool;\n\n    tmp = (tmp - sdc_pre_is_some as Field) / TWO_POW_8;\n    let sdc_pre_inner = tmp as u32;\n\n    ScheduledDelayChange {\n        pre: if sdc_pre_is_some {\n            Option::some(sdc_pre_inner)\n        } else {\n            Option::none()\n        },\n        post: if sdc_post_is_some {\n            Option::some(sdc_post_inner)\n        } else {\n            Option::none()\n        },\n        block_of_change: sdc_block_of_change,\n    }\n}\n\nglobal TWO_POW_32: Field = 2.pow_32(32);\nglobal TWO_POW_8: Field = 2.pow_32(8);\n\n// We pack to `2 * N + 1` fields because ScheduledValueChange contains T twice (hence `2 * N`) and we need one extra\n// field to store ScheduledDelayChange and the block_of_change of ScheduledValueChange.\nimpl<T, let INITIAL_DELAY: u32, let N: u32> Packable<2 * N + 1> for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; 2 * N + 1] {\n        let mut result = [0; 2 * N + 1];\n\n        // We pack sdc.pre, sdc.post, sdc.block_of_change and svc.block_of_change into a single field as follows:\n        // [ sdc.pre_inner: u32 | sdc.pre_is_some: u8 | sdc.post_inner: u32 | sdc.post_is_some: u8 | sdc.block_of_change: u32 | svc.block_of_change: u32 ]\n        result[0] = self.svc.block_of_change as Field\n            + ((self.sdc.block_of_change as Field) * 2.pow_32(32))\n            + ((self.sdc.post.is_some() as Field) * 2.pow_32(64))\n            + ((self.sdc.post.unwrap_unchecked() as Field) * 2.pow_32(72))\n            + ((self.sdc.pre.is_some() as Field) * 2.pow_32(104))\n            + ((self.sdc.pre.unwrap_unchecked() as Field) * 2.pow_32(112));\n\n        // Pack the pre and post values from ScheduledValueChange\n        let svc_pre_packed = self.svc.pre.pack();\n        let svc_post_packed = self.svc.post.pack();\n        for i in 0..N {\n            result[i + 1] = svc_pre_packed[i];\n            result[i + 1 + N] = svc_post_packed[i];\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; 2 * N + 1]) -> Self {\n        let svc = unpack_value_change::<T, N>(fields);\n        let sdc = unpack_delay_change::<INITIAL_DELAY>(fields[0]);\n        Self::new(svc, sdc)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32, let N: u32> Hash for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn hash(self) -> Field {\n        poseidon2_hash(self.pack())\n    }\n}\n"
    },
    "319": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "333": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n"
    },
    "337": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "338": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "354": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "355": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "357": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "367": {
      "path": "/home/nerses/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "396": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER},\n        hash::poseidon2_hash_with_separator,\n        traits::{Deserialize, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// The returned `PartialUintNote` value must be sent to public execution via a secure channel, since it is not\n    /// possible to verify the integrity of its contents due to it hiding information. The recommended ways to do this\n    /// are to retrieve it from public storage, or to receive it in an internal public function call.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient, sender);\n        context.emit_private_log(encrypted_log);\n\n        PartialUintNote { commitment }\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nimpl PartialUintNote {\n    pub fn commitment(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, value: u128, context: &mut PublicContext) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; 2] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "50": {
      "path": "/home/nerses/contracts/chains/aztec/contracts/train/src/lib.nr",
      "source": "pub fn bytes_to_u128_limbs(bytes: [u8; 32]) -> (u128, u128) {\n    let mut high: u128 = 0;\n    let mut low: u128 = 0;\n    for i in 0..16 {\n        high = (high << 8) + (bytes[i] as u128);\n    }\n    for i in 16..32 {\n        low = (low << 8) + (bytes[i] as u128);\n    }\n    (high, low)\n}\n\npub fn u128_limbs_to_bytes(high: u128, low: u128) -> [u8; 32] {\n    let mut bytes: [u8; 32] = [0; 32];\n\n    let mut temp = high;\n    for i in 0..16 {\n        bytes[15 - i] = (temp & 0xff) as u8;\n        temp >>= 8;\n    }\n\n    temp = low;\n    for i in 0..16 {\n        bytes[31 - i] = (temp & 0xff) as u8;\n        temp >>= 8;\n    }\n\n    bytes\n}\n"
    },
    "51": {
      "path": "/home/nerses/contracts/chains/aztec/contracts/train/src/main.nr",
      "source": "//     @@                                    @@@\n//    @@@\n//    @@@        @@   @@@@      @@@@@         @     @    @@@@@\n//  @@@@@@@@@   @@@@@@      @@@@    @@@@@    @@@   @@@@@@    @@@@\n//    @@@       @@@       @@@           @@@  @@@   @@@          @@@\n//    @@@       @@@       @@@           @@@  @@@   @@@          @@@\n//    @@@       @@@       @@@           @@@  @@@   @@@          @@@\n//     @@@      @@@        @@@@       @@@@@  @@@   @@@          @@@\n//       @@@@@  @@@           @@@@@@@@@ @@@  @@@   @@@          @@@\n\nmod lib;\nmod types;\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract Train {\n    use crate::lib::{bytes_to_u128_limbs, u128_limbs_to_bytes};\n    use crate::types::events::{\n        TokenCommitted, TokenLockAdded, TokenLocked, TokenRedeemed, TokenRefunded,\n    };\n    use dep::aztec::messages::logs::note::encode_and_encrypt_note;\n    use dep::aztec::protocol_types::traits::{Packable, Serialize};\n    use dep::aztec::state_vars::{private_immutable::PrivateImmutable, SharedMutable};\n    use dep::sha256;\n    use dep::token::Token;\n    use aztec::macros::{\n        functions::{initializer, internal, private, public, utility, view},\n        notes::note,\n        storage::storage,\n    };\n    use aztec::prelude::{AztecAddress, Map};\n    use std::meta::derive;\n\n    #[note]\n    #[derive(Eq)]\n    struct HTLC_Private {\n        owner: AztecAddress,\n        randomness: Field,\n    }\n    #[derive(Eq, Packable, Serialize)]\n    pub struct HTLC_Public {\n        src_receiver: AztecAddress,\n        amount: u128,\n        token: AztecAddress,\n        hashlock_high: u128,\n        hashlock_low: u128,\n        secret_high: u128,\n        secret_low: u128,\n        ownership_hash_high: u128,\n        ownership_hash_low: u128,\n        timelock: u64,\n        claimed: u8,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor() {}\n\n    #[storage]\n    struct Storage<Context> {\n        contracts_private: Map<Field, PrivateImmutable<HTLC_Private, Context>, Context>,\n        contracts_public: Map<Field, SharedMutable<HTLC_Public, 3, Context>, Context>,\n    }\n\n    #[private]\n    fn commit_private_user(\n        Id: Field,\n        src_receiver: AztecAddress,\n        timelock: u64,\n        token: AztecAddress,\n        amount: u128,\n        dst_chain: str<8>,\n        dst_asset: str<8>,\n        dst_address: str<48>,\n        randomness: Field,\n    ) {\n        assert(amount > 0, \"Funds Not Sent\");\n\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address())\n            .commit_public_user(\n                dst_chain,\n                dst_asset,\n                dst_address,\n                Id,\n                src_receiver,\n                timelock,\n                token,\n                amount,\n            )\n            .enqueue(&mut context);\n\n        let htlc_note = HTLC_Private { owner: context.msg_sender(), randomness: randomness };\n        storage.contracts_private.at(Id).initialize(htlc_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n\n        Token::at(token)\n            .transfer_to_public(context.msg_sender(), context.this_address(), amount, randomness)\n            .call(&mut context);\n    }\n\n    #[internal]\n    #[public]\n    fn commit_public_user(\n        dst_chain: str<8>,\n        dst_asset: str<8>,\n        dst_address: str<48>,\n        Id: Field,\n        src_receiver: AztecAddress,\n        timelock: u64,\n        token: AztecAddress,\n        amount: u128,\n    ) {\n        assert(context.timestamp() + 900 < timelock, \"InvalidTimelock\");\n        let htlc_public = HTLC_Public {\n            src_receiver: src_receiver,\n            amount: amount,\n            token: token,\n            hashlock_high: 0 as u128,\n            hashlock_low: 0 as u128,\n            secret_high: 0 as u128,\n            secret_low: 0 as u128,\n            ownership_hash_high: 0 as u128,\n            ownership_hash_low: 0 as u128,\n            timelock: timelock,\n            claimed: 1 as u8,\n        };\n        storage.contracts_public.at(Id).schedule_value_change(htlc_public);\n        let log_msg = TokenCommitted {\n            Id: Id,\n            amount: amount,\n            token: token,\n            timelock: timelock,\n            dst_chain: dst_chain,\n            dst_asset: dst_asset,\n            dst_address: dst_address,\n            src_receiver: src_receiver,\n        };\n        context.emit_public_log(log_msg.pack());\n    }\n\n    #[private]\n    fn add_lock_private_user(Id: Field, hashlock: [u8; 32], timelock: u64) {\n        let htlc_private = storage.contracts_private.at(Id).get_note();\n        assert(htlc_private.owner == context.msg_sender(), \"NoAllowance\");\n\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address()).add_lock_public_user(Id, hashlock, timelock).enqueue(\n            &mut context,\n        );\n    }\n\n    #[internal]\n    #[public]\n    fn add_lock_public_user(Id: Field, hashlock: [u8; 32], timelock: u64) {\n        assert(context.timestamp() + 900 < timelock, \"InvalidTimelock\");\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n        assert(htlc_public.hashlock_high == (0 as u128), \"HashlockAlreadySet\");\n        assert(htlc_public.hashlock_low == (0 as u128), \"HashlockAlreadySet\");\n\n        let hashlock_tuple = bytes_to_u128_limbs(hashlock);\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: hashlock_tuple.0,\n            hashlock_low: hashlock_tuple.1,\n            secret_high: htlc_public.secret_high,\n            secret_low: htlc_public.secret_low,\n            ownership_hash_high: htlc_public.ownership_hash_high,\n            ownership_hash_low: htlc_public.ownership_hash_low,\n            timelock: timelock,\n            claimed: htlc_public.claimed,\n        };\n        storage.contracts_public.at(Id).schedule_value_change(modified_htlc_public);\n        let log_msg = TokenLockAdded { Id, hashlock, timelock };\n        context.emit_public_log(log_msg.pack());\n    }\n\n    #[private]\n    fn refund_private(Id: Field, randomness: Field) {\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address()).refund_public(Id).enqueue(&mut context);\n\n        let htlc_private = storage.contracts_private.at(Id).get_note();\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n\n        Token::at(htlc_public.token)\n            .transfer_to_private(htlc_private.owner, htlc_public.amount)\n            .call(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn refund_public(Id: Field) {\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n        assert(htlc_public.timelock < context.timestamp(), \"NotPassedTimelock\");\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: htlc_public.hashlock_high,\n            hashlock_low: htlc_public.hashlock_low,\n            secret_high: htlc_public.secret_high,\n            secret_low: htlc_public.secret_low,\n            ownership_hash_high: htlc_public.ownership_hash_high,\n            ownership_hash_low: htlc_public.ownership_hash_low,\n            timelock: htlc_public.timelock,\n            claimed: 2 as u8,\n        };\n\n        storage.contracts_public.at(Id).schedule_value_change(modified_htlc_public);\n        let log_msg = TokenRefunded { Id };\n        context.emit_public_log(log_msg);\n    }\n\n    #[private]\n    fn lock_private_solver(\n        Id: Field,\n        hashlock: [u8; 32],\n        amount: u128,\n        ownership_hash: [u8; 32],\n        timelock: u64,\n        token: AztecAddress,\n        randomness: Field,\n        dst_chain: str<8>,\n        dst_asset: str<8>,\n        dst_address: str<48>,\n    ) {\n        assert(amount > 0, \"FundsNotSent\");\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address())\n            .lock_public_solver(\n                Id,\n                hashlock,\n                ownership_hash,\n                amount,\n                token,\n                timelock,\n                dst_chain,\n                dst_asset,\n                dst_address,\n            )\n            .enqueue(&mut context);\n\n        let htlc_note = HTLC_Private { owner: context.msg_sender(), randomness: randomness };\n        storage.contracts_private.at(Id).initialize(htlc_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n\n        Token::at(token)\n            .transfer_to_public(context.msg_sender(), context.this_address(), amount, randomness)\n            .call(&mut context);\n    }\n\n    #[internal]\n    #[public]\n    fn lock_public_solver(\n        Id: Field,\n        hashlock: [u8; 32],\n        ownership_hash: [u8; 32],\n        amount: u128,\n        token: AztecAddress,\n        timelock: u64,\n        dst_chain: str<8>,\n        dst_asset: str<8>,\n        dst_address: str<48>,\n    ) {\n        assert(context.timestamp() + 2700 < timelock, \"InvalidTimelock\");\n        let hashlock_tuple = bytes_to_u128_limbs(hashlock);\n        let ownership_hash_tuple = bytes_to_u128_limbs(ownership_hash);\n        let htlc_public = HTLC_Public {\n            src_receiver: AztecAddress::zero(),\n            amount: amount,\n            token: token,\n            hashlock_high: hashlock_tuple.0,\n            hashlock_low: hashlock_tuple.1,\n            secret_high: 0 as u128,\n            secret_low: 0 as u128,\n            ownership_hash_high: ownership_hash_tuple.0,\n            ownership_hash_low: ownership_hash_tuple.1,\n            timelock: timelock,\n            claimed: 1 as u8,\n        };\n        storage.contracts_public.at(Id).schedule_value_change(htlc_public);\n\n        let log_msg = TokenLocked {\n            Id: Id,\n            hashlock: hashlock,\n            ownership_hash: ownership_hash,\n            amount: amount,\n            src_receiver: AztecAddress::zero(),\n            token: token,\n            timelock: timelock,\n            dst_chain: dst_chain,\n            dst_asset: dst_asset,\n            dst_address: dst_address,\n        };\n\n        context.emit_public_log(log_msg.pack());\n    }\n\n    #[private]\n    fn redeem_private(Id: Field, secret: [u8; 32], ownership_key: [u8; 32], randomness: Field) {\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address()).redeem_public(Id, secret, ownership_key).enqueue(\n            &mut context,\n        );\n\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n        if (htlc_public.ownership_hash_high == 0 as u128) {\n            if htlc_public.ownership_hash_low == 0 as u128 {\n                Token::at(htlc_public.token)\n                    .transfer_to_private(htlc_public.src_receiver, htlc_public.amount)\n                    .call(&mut context);\n            }\n        } else {\n            Token::at(htlc_public.token)\n                .transfer_to_private(context.msg_sender(), htlc_public.amount)\n                .call(&mut context);\n        }\n    }\n\n    #[public]\n    #[internal]\n    fn redeem_public(Id: Field, secret: [u8; 32], ownership_key: [u8; 32]) {\n        let mut htlc_public = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public.amount > 0, \"HTLCNotExists\"); // If it doesn't exist, all parameters will default to zero values.\n        let hashed_secret = sha256::sha256_var(secret, secret.len() as u64);\n        let hashed_secret_tuple = bytes_to_u128_limbs(hashed_secret);\n        assert(htlc_public.hashlock_high == hashed_secret_tuple.0, \"HashlockNotMatch\");\n        assert(htlc_public.hashlock_low == hashed_secret_tuple.1, \"HashlockNotMatch\");\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n\n        if (htlc_public.ownership_hash_high != 0 as u128) {\n            if htlc_public.ownership_hash_low != 0 as u128 {\n                let ownership_key_hashed =\n                    sha256::sha256_var(ownership_key, ownership_key.len() as u64);\n                let ownership_key_tuple = bytes_to_u128_limbs(ownership_key_hashed);\n                assert(htlc_public.ownership_hash_high == ownership_key_tuple.0, \"NotAnOwner\");\n                assert(htlc_public.ownership_hash_low == ownership_key_tuple.1, \"NotAnOwner\");\n            }\n        }\n\n        let secret_limbs = bytes_to_u128_limbs(secret);\n\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: htlc_public.hashlock_high,\n            hashlock_low: htlc_public.hashlock_low,\n            secret_high: secret_limbs.0,\n            secret_low: secret_limbs.1,\n            ownership_hash_high: htlc_public.ownership_hash_high,\n            ownership_hash_low: htlc_public.ownership_hash_low,\n            timelock: htlc_public.timelock,\n            claimed: 3 as u8,\n        };\n\n        storage.contracts_public.at(Id).schedule_value_change(modified_htlc_public);\n\n        let log_msg = TokenRedeemed {\n            Id: Id,\n            hashlock: u128_limbs_to_bytes(htlc_public.hashlock_high, htlc_public.hashlock_low),\n            secret: secret,\n        };\n\n        context.emit_public_log(log_msg.pack());\n    }\n\n    // This utility function should be invoked by the frontend before each function call\n    // where the existence or non-existence of an HTLC is a critical security check.\n    #[utility]\n    unconstrained fn is_contract_initialized(Id: Field) -> bool {\n        storage.contracts_private.at(Id).is_initialized()\n    }\n\n    #[view]\n    #[public]\n    fn get_htlc_public(key: Field) -> pub HTLC_Public {\n        storage.contracts_public.at(key).get_current_value()\n    }\n}\n"
    },
    "52": {
      "path": "/home/nerses/contracts/chains/aztec/contracts/train/src/types/events.nr",
      "source": "use dep::aztec::prelude::AztecAddress;\nuse dep::aztec::protocol_types::traits::{Packable, Serialize};\n\n#[derive(Serialize)]\npub struct TokenCommitted {\n    pub Id: Field,\n    pub amount: u128,\n    pub token: AztecAddress,\n    pub timelock: u64,\n    pub dst_chain: str<8>,\n    pub dst_asset: str<8>,\n    pub dst_address: str<48>,\n    pub src_receiver: AztecAddress,\n}\n\nimpl Packable<9> for TokenCommitted {\n    fn pack(self) -> [Field; 9] {\n        let zero: Field = 0;\n        let mut out = [zero; 9];\n        out[0] = self.Id;\n        out[1] = self.amount as Field;\n        out[2] = self.token.inner;\n        out[3] = self.timelock as Field;\n\n        let dst_chain_byte_array = self.dst_chain.as_bytes();\n        let mut dst_chain_byte_array_filled = [0 as u8; 31];\n        for i in 0..dst_chain_byte_array.len() {\n            dst_chain_byte_array_filled[i] = dst_chain_byte_array[i];\n        }\n\n        out[4] = Field::from_be_bytes::<31>(dst_chain_byte_array_filled);\n\n        let dst_asset_byte_array = self.dst_asset.as_bytes();\n        let mut dst_asset_byte_array_filled = [0 as u8; 31];\n        for i in 0..dst_asset_byte_array.len() {\n            dst_asset_byte_array_filled[i] = dst_asset_byte_array[i];\n        }\n\n        out[5] = Field::from_be_bytes::<31>(dst_asset_byte_array_filled);\n\n        let dst_address_byte_array = self.dst_address.as_bytes();\n        let mut dst_address_byte_array_filled_1 = [0 as u8; 31];\n        let mut dst_address_byte_array_filled_2 = [0 as u8; 31];\n\n        for i in 0..31 {\n            dst_address_byte_array_filled_1[i] = dst_address_byte_array[i];\n        }\n\n        for i in 31..48 {\n            dst_address_byte_array_filled_2[i - 31] = dst_address_byte_array[i];\n        }\n\n        out[6] = Field::from_be_bytes::<31>(dst_address_byte_array_filled_1);\n        out[7] = Field::from_be_bytes::<31>(dst_address_byte_array_filled_2);\n\n        out[8] = self.src_receiver.inner;\n        out\n    }\n\n    fn unpack(fields: [Field; 9]) -> Self {\n        assert(false, \"unpack not implemented\");\n        TokenCommitted {\n            Id: fields[0] as Field,\n            amount: 0 as u128,\n            token: AztecAddress::zero(),\n            timelock: 0 as u64,\n            dst_chain: \"00000000\",\n            dst_asset: \"00000000\",\n            dst_address: \"000000000000000000000000000000000000000000000000\",\n            src_receiver: AztecAddress::zero(),\n        }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenLockAdded {\n    pub Id: Field,\n    pub hashlock: [u8; 32],\n    pub timelock: u64,\n}\n\nimpl Packable<4> for TokenLockAdded {\n    fn pack(self) -> [Field; 4] {\n        let mut out = [0 as Field; 4];\n        out[0] = self.Id;\n\n        let hb = self.hashlock;\n        let mut h1 = [0 as u8; 31];\n        for i in 0..31 {\n            h1[i] = hb[i];\n        }\n        out[1] = Field::from_be_bytes::<31>(h1);\n\n        let mut h2 = [0 as u8; 31];\n        h2[0] = hb[31];\n        out[2] = Field::from_be_bytes::<31>(h2);\n\n        out[3] = self.timelock as Field;\n        out\n    }\n\n    fn unpack(fields: [Field; 4]) -> Self {\n        let Id = fields[0];\n\n        let b1 = fields[1].to_be_bytes();\n        let b2 = fields[2].to_be_bytes();\n        let mut hash = [0 as u8; 32];\n        for i in 0..31 {\n            hash[i] = b1[i];\n        }\n        hash[31] = b2[0];\n\n        let timelock = fields[3] as u64;\n\n        TokenLockAdded { Id, hashlock: hash, timelock }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenRefunded {\n    pub Id: Field,\n}\n\n#[derive(Serialize)]\npub struct TokenRedeemed {\n    pub Id: Field,\n    pub hashlock: [u8; 32],\n    pub secret: [u8; 32],\n}\n\nimpl Packable<5> for TokenRedeemed {\n    fn pack(self) -> [Field; 5] {\n        let mut out = [0 as Field; 5];\n        out[0] = self.Id;\n\n        let hb = self.hashlock;\n        let mut h1 = [0 as u8; 31];\n        for i in 0..31 {\n            h1[i] = hb[i];\n        }\n        out[1] = Field::from_be_bytes::<31>(h1);\n        let mut h2 = [0 as u8; 31];\n        h2[0] = hb[31];\n        out[2] = Field::from_be_bytes::<31>(h2);\n\n        let sb = self.secret;\n        let mut s1 = [0 as u8; 31];\n        for i in 0..31 {\n            s1[i] = sb[i];\n        }\n        out[3] = Field::from_be_bytes::<31>(s1);\n        let mut s2 = [0 as u8; 31];\n        s2[0] = sb[31];\n        out[4] = Field::from_be_bytes::<31>(s2);\n\n        out\n    }\n\n    fn unpack(fields: [Field; 5]) -> Self {\n        let Id = fields[0];\n\n        let b1 = fields[1].to_be_bytes();\n        let b2 = fields[2].to_be_bytes();\n        let mut hashlock = [0 as u8; 32];\n        for i in 0..31 {\n            hashlock[i] = b1[i];\n        }\n        hashlock[31] = b2[0];\n\n        let b3 = fields[3].to_be_bytes();\n        let b4 = fields[4].to_be_bytes();\n        let mut secret = [0 as u8; 32];\n        for i in 0..31 {\n            secret[i] = b3[i];\n        }\n        secret[31] = b4[0];\n\n        TokenRedeemed { Id, hashlock, secret }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenLocked {\n    pub Id: Field,\n    pub hashlock: [u8; 32],\n    pub ownership_hash: [u8; 32],\n    pub amount: u128,\n    pub src_receiver: AztecAddress,\n    pub token: AztecAddress,\n    pub timelock: u64,\n    pub dst_chain: str<8>,\n    pub dst_asset: str<8>,\n    pub dst_address: str<48>,\n}\n\nimpl Packable<13> for TokenLocked {\n    fn pack(self) -> [Field; 13] {\n        let mut out = [0 as Field; 13];\n        out[0] = self.Id;\n\n        let hb = self.hashlock;\n        let mut h1 = [0 as u8; 31];\n        for i in 0..31 {\n            h1[i] = hb[i];\n        }\n        out[1] = Field::from_be_bytes::<31>(h1);\n\n        let mut h2 = [0 as u8; 31];\n        h2[0] = hb[31];\n        out[2] = Field::from_be_bytes::<31>(h2);\n\n        let ownership = self.ownership_hash;\n        let mut o1 = [0 as u8; 31];\n        for i in 0..31 {\n            o1[i] = ownership[i];\n        }\n        out[3] = Field::from_be_bytes::<31>(o1);\n\n        let mut o2 = [0 as u8; 31];\n        o2[0] = ownership[31];\n        out[4] = Field::from_be_bytes::<31>(o2);\n\n        out[5] = self.amount as Field;\n        out[6] = self.src_receiver.inner as Field;\n        out[7] = self.token.inner;\n        out[8] = self.timelock as Field;\n\n        let dst_chain_byte_array = self.dst_chain.as_bytes();\n        let mut dst_chain_byte_array_filled = [0 as u8; 31];\n        for i in 0..dst_chain_byte_array.len() {\n            dst_chain_byte_array_filled[i] = dst_chain_byte_array[i];\n        }\n        out[9] = Field::from_be_bytes::<31>(dst_chain_byte_array_filled);\n\n        let dst_asset_byte_array = self.dst_asset.as_bytes();\n        let mut dst_asset_byte_array_filled = [0 as u8; 31];\n        for i in 0..dst_asset_byte_array.len() {\n            dst_asset_byte_array_filled[i] = dst_asset_byte_array[i];\n        }\n        out[10] = Field::from_be_bytes::<31>(dst_asset_byte_array_filled);\n\n        let addr = self.dst_address.as_bytes();\n        let mut dst_address_byte_array_filled_1 = [0 as u8; 31];\n        let mut dst_address_byte_array_filled_2 = [0 as u8; 31];\n        for i in 0..31 {\n            dst_address_byte_array_filled_1[i] = addr[i];\n        }\n        for i in 31..48 {\n            dst_address_byte_array_filled_2[i - 31] = addr[i];\n        }\n        out[11] = Field::from_be_bytes::<31>(dst_address_byte_array_filled_1);\n        out[12] = Field::from_be_bytes::<31>(dst_address_byte_array_filled_2);\n\n        out\n    }\n\n    fn unpack(fields: [Field; 13]) -> Self {\n        assert(false, \"unpack not implemented\");\n        TokenLocked {\n            Id: fields[0] as Field,\n            hashlock: [0 as u8; 32],\n            ownership_hash: [0 as u8; 32],\n            amount: 0 as u128,\n            src_receiver: AztecAddress::zero(),\n            token: AztecAddress::zero(),\n            timelock: 0 as u64,\n            dst_chain: \"00000000\",\n            dst_asset: \"00000000\",\n            dst_address: \"000000000000000000000000000000000000000000000000\",\n        }\n    }\n}\n"
    },
    "54": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
    },
    "55": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "62": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "63": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "64": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "65": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "69": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "81": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "84": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/keys/ecdh_shared_secret.nr",
      "source": "use dep::protocol_types::{\n    address::aztec_address::AztecAddress, point::Point, scalar::Scalar, traits::FromField,\n};\nuse std::{embedded_curve_ops::multi_scalar_mul, ops::Neg};\n\n/// Computes a standard ecdh shared secret: [secret] * public_key = shared_secret.\n/// The input secret is known only to one party. The output shared secret is derivable\n/// by both parties, through this function.\n/// E.g.:\n/// Epk = esk * G // ephemeral keypair\n/// Pk = sk * G // recipient keypair\n/// Shared secret S = esk * Pk = sk * Epk // see how this function can be called with two different sets of inputs, depending on which secret the caller knows (either esk or sk)?\n// See also: https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman\npub fn derive_ecdh_shared_secret(secret: Scalar, public_key: Point) -> Point {\n    let shared_secret = multi_scalar_mul([public_key], [secret]);\n    shared_secret\n}\n\n/// Computes a standard ecdh shared secret using the address public key of the given address:\n/// [ephemeral_secret] * recipient_address_public_key = shared_secret.\n/// The intention is that the _creator_ of a shared secret would call this function,\n/// given the address of their intended recipient.\npub fn derive_ecdh_shared_secret_using_aztec_address(\n    ephemeral_secret: Scalar,\n    recipient_address: AztecAddress,\n) -> Point {\n    derive_ecdh_shared_secret(ephemeral_secret, recipient_address.to_address_point().inner)\n}\n\n#[test]\nunconstrained fn test_consistency_with_typescript() {\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let shared_secret = derive_ecdh_shared_secret(secret, point);\n\n    // This is just pasted from a test run.\n    // The original typescript code from which this could be generated seems to have been deleted by someone, and soon the typescript code for encryption and decryption won't be needed, so this will have to do.\n    let hard_coded_shared_secret = Point {\n        x: 0x15d55a5b3b2caa6a6207f313f05c5113deba5da9927d6421bcaa164822b911bc,\n        y: 0x0974c3d0825031ae933243d653ebb1a0b08b90ee7f228f94c5c74739ea3c871e,\n        is_infinite: false,\n    };\n    assert_eq(shared_secret, hard_coded_shared_secret);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let shared_secret = derive_ecdh_shared_secret(secret_a, pk_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_from_address_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let mut pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let mut pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let address_b = AztecAddress::from_field(pk_b.x);\n\n    // We were lazy in deriving the secret keys, and didn't check the resulting y-coordinates\n    // of the pk_a or pk_b to be less than half the field modulus.\n    // If needed, we negate the pk's so that they yield valid address points.\n    // (We could also have negated the secrets, but there's no negate method for\n    // EmbeddedCurvesScalar).\n    pk_a = if (AztecAddress::from_field(pk_a.x).to_address_point().inner == pk_a) {\n        pk_a\n    } else {\n        pk_a.neg()\n    };\n    pk_b = if (address_b.to_address_point().inner == pk_b) {\n        pk_b\n    } else {\n        pk_b.neg()\n    };\n\n    let shared_secret = derive_ecdh_shared_secret_using_aztec_address(secret_a, address_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n"
    },
    "85": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/keys/ephemeral.nr",
      "source": "use std::embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul};\n\nuse dep::protocol_types::{point::Point, scalar::Scalar};\n\nuse crate::oracle::random::random;\n\npub fn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n\n    // Safety: we use the randomness to preserve the privacy of both the sender and recipient via encryption, so a\n    // malicious sender could use non-random values to reveal the plaintext. But they already know it themselves anyway,\n    // and so the recipient already trusts them to not disclose this information. We can therefore assume that the\n    // sender will cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // TODO(#12757): compute the key pair without constraining eph_sk twice (once in from_field, once in the black box\n    // called by fixed_base_scalar_mul).\n    let eph_sk = EmbeddedCurveScalar::from_field(randomness);\n    let eph_pk = fixed_base_scalar_mul(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n"
    },
    "86": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "90": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_notes` utility function PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_notes = generate_sync_notes();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_notes\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_notes() -> Quoted {\n    // TODO(https://github.com/noir-lang/noir/issues/7912): Doing the following unfortunately doesn't work. Once\n    // the issue is fixed uncomment the following and remove the workaround from TS (look for the issue link in the\n    // codebase).\n    // let utility: fn(FunctionDefinition) -> () = crate::macros::functions::utility;\n    // quote {\n    //     #[$utility]\n    //     unconstrained fn sync_notes() {\n    //     }\n    // }\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[aztec::macros::functions::utility]\n        unconstrained fn sync_notes() { }\n    }\n}\n"
    },
    "91": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "94": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_slice, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_view,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_SLICE_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args =  &[];\n    // serialized_args = serialized_args.append(aztec::protocol_types::traits::Serialize::serialize(target_address));\n    // serialized_args = serialized_args.push_back(fee_juice_limit_per_tx as Field);\n    // ```\n    let serialized_args_slice_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_SLICE_NAME = &[];\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append = add_to_field_slice(SERIALIZED_ARGS_SLICE_NAME, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n"
    },
    "95": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "98": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    }
  }
}
