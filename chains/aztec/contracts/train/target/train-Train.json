{
  "transpiled": true,
  "noir_version": "1.0.0-beta.4+0000000000000000000000000000000000000000",
  "name": "Train",
  "functions": [
    {
      "name": "add_lock_private_user",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17476367995570638746": {
            "error_kind": "string",
            "string": "NoAllowance"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert"
      ],
      "verification_key": "AAAAAAAEAAAAAAAAAAAAEgAAAAAAAAAQAAAAAAAAVgkBAAAAAAAAAAEAAAACAAAAAwAAAAQAAAAF\nAAAABgAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAAAAAAAAAAAAAGE0XFjoa\n/2uH1TkeOWNWPHneNHbwwV7wFM+3IIAKx4wr9jNc4w/oj8HqBabIxdyDnVU0AZwwmnA3Nj6rksKP\nyS6v5VEqS/qWJx7T6cfauu2/qBZkWbjXqelyN+Q9MStzHxA4siBCAHrgyisJeBKxU86UnXGMWh6X\nW6anEv0I24YdAyohRGmO1XaJDJdFl/OF96ll3M8JGgrNnMMCWcGd1xpDKkDyaBZoc1lSWYOipBAW\nqGrI1rjY7MMJ/Hggaf+ULDy+stCMq1nMCfPnUxh+fwc4kes5dHCc7jGMwJzC+couI/D3OOlw9fZJ\nMz9k9mPkLW9O523vSKg3icrQqA4RhBYuYUR3h/xnGW+KpUCKaDhsrez2AAyWwkNWkl7QLZNOFKqA\nJBa875K4KzISY6NyXfZp+yYPW1/+YWeFPGyfiisj5RvqxMRXBtA5eqfde/9LHLuL8jgpeHK7wJH/\nfEeBKQM5X+Gde4md+ehrfk53kKIJWG04wkOTOkGtCYQx4DpOIuSmLVifXcWOAD4X0sKeZqqcjXq3\nWBuYEO2nPlPhfd8OP4PTyf+mJHwLpRXOLm9SrLCVbfb6d5ltuCSwof5icCmMMxH8kXD5LelAsEKq\nuZDVPGo7JjOc2mtz35IIMUFZB7BfQIphKEclkBa5IErkvzdTfrGWsFwdmPpRAWqbrLsBDLnYpLU7\nt9czT2t/X/Gq8TuSScYX9bFELI82T4ywxRYgD4DDNUvXwg/INyHNASwsDIXpHgIh0pH0/XIelc+4\nCl0XyXMNyvQD9kY8BZuDOR3iHs5exSpykZmQF5yF3d8bUu7dx7Y0Y2g56y9dyqrC1P9NDhOZDoPm\nqs1vYxwh3iHrSJuRmKhkLL92LlSOA5ve52T8+85x9jwkt2+sZv9oEf1BtfmTbZMquuTG6TPg05wk\n6o4uDu5wKlMm81nJR8AUoX18ClXS1F7o7fbsFlwRPSgrmEfVYv1BQCIOR+GCrxpw0tC/U/KBmNxu\na015bsn0E4YWuRKVxKct3D6sKlhhLtQPb5+ipkKh1bmzX8CWR4AJhqehhLA7qpGTBLSEbK8kds9C\ncn4cjY/Jo03wX+F9zcmC3scxjhB078MAthvCQQP2QHzfk01/l/z6Ti6plhsXB0AyK7xOvtkDa7l3\nhDKuJsFOXXeNZkHqEPUtoFrjnGvjKfXbDPE3iRTXh0I5k0kAaHxLIXNgFhpYyUmDG/h7FMfu3G1s\nxqPCh1yCJPks0wVznjHzhM5qc7d5jONAzzaTqm5BJWW3AzNWoOI9A/MZEAjZgs5wZfFBhM2ddQYJ\nXFbVf123uWQ+h8CnxmJ5BX0MZlf2ZhP8oib9sdrJxyIC+xZemihd4Eelv1Hq8QbxGwgAkyK+sLRI\nVvELoVMwHFAhd+DDm44eQqsaB8UmioRdF4Np8s2xV7aQiysb+mV21F5+1WQzQvwFKtl5l8BWK8Ao\n66fpNX6vSOMkmFoXOn822NDSt2jzLyhAZtxuHLLBqAf1Bf9difNOUYoCNwhOW85G4v+J5FkHUoGO\nC+0uEFMOF1YTz9yEOSDNkuuaZuYXWpqYMUwt/KRXdVDoQXCRJ1kB62Z+UT7Crh9P6s8cJQOvcWWH\nFLrBeNYPug4CQrl+YRzXoVHbPbkfirP7LSxAlVK16J4wpOzjMTNRQkIDSukuA4TsNcTnjXkqsNNK\nJ+b47tHQhIYjz/PV8Ek5BTynPwQOPg32d3I1Zr7X5+UD2kZ//CcH2EGifOJr9GZXPq26ahQlFosY\n+lf1QmMRU/b8aBrhmGkpdjUJGeIMLfxzJeUyItsvujQQwoPJLmYWiB1FGSz4GLL+fU4o26xohxi6\n8vcRVG74Ii7W8a9bK33Gtr27UyldWC//yE9cg+8SQNF7KwrcicSNdbVxY29bvrSoBvb0WWICMBtq\n5OsOu+rdIDNABm8oE1dI8RljHD/gf6nXAANOPidFTvmStL+EuXuqdHEuJXg1Ud9QwATsfNH03Ys7\nZKZvKsSXm2XlZWjFoxsU7Rj3bPDO7MtHmN50GuibZOglj4RHfBtiVlpVm6e7OIMuLSmftoZ40BUL\nzFsW3IJSNT1D+nDpkjnBwcZ+JxoO6sUV06xaGZq7dJM6TvyYxZsoFO3nzSfa7QDDPBKGC8SwRi04\n1tS6Hkdjp07NsRyh80aWgMJw5VFRU0RZL1kYj6dlEts56JKCazJhDuCCUeAF/OkXwNXcoBlHfFL2\nB1MythIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAACA8i25mfOy8TMe7DBPSAaZV3uk9Tj4Zp9HowSsJikRZIeREtF5w1dBClTHsyM\nOAlniDjqrM+EaVsDFFN+exFQSADENyb3W2/aDeIs4ODfq2vMegX/lalrKJQkxfczZw2WL5tuC04s\nAZaN5cMkgqp9HQoJ1xeOyTuteFj5bmTwtI0dWKphxkrVIgQ9ecSAIhnlW6GXUa3+bDYyTT+2wtoJ\niS18GKk8Pa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "add_lock_public_user",
      "is_unconstrained": true,
      "custom_attributes": [
        "internal",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "2722406262643068352": {
            "error_kind": "string",
            "string": "HashlockAlreadySet"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16870384257694633552": {
            "error_kind": "string",
            "string": "Function add_lock_public_user can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "add_lock_public_user"
      ]
    },
    {
      "name": "refund_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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rfdq23qvtq33att6r7at92rbeq+2rfdq23qvtq33att6r7at92rbeq+2rfdq23qvtq33att6r7at92rbeq+2rfdq23qvtq33att6r7at92rbeq+2rfdq23qvtq33att6r7at92rbeq+2rfdq23qvtq33att6r7at92rbeq+2rfdq23qvtq33att6r7at92rbeq+2rfdq23qvtq33att6r7at92rbeq+2rfdq23qvtq33att6r7at92rbeq+2rfdq23qvtq33att6r7at92rbeq+2rfdq23qvtq33att6r7at92rbeq+2rfdq23qvtq33att6r7at92qf9F7z8fLepV1nCqc9UUmMx2nZ/jittOIs034Wl3DiXOGkucLJU4XzrLc9KhwzVzh2rnDcXOHQXOH4ucKZ666c57or57nuynmqu7Lbproru22qu7Lbproru22qu7Lbet+VX27FdInHTxZPmCyeOFk8abJ48lzxmI/vzdfTTNtptu204j3p8hRzX8Lj8qzQV6CZEN1+p7n8O9wW1iluiJDcvojMZb5wlb8dtu1YAGtzt4/JU/qOnyaP3297AoJ37jF+Lzz+IDz+KDz+JDz+LDv+8gsYguI3wuO3wuOfff6txS98/rXC518rfP61wudfK3z+tcLnXyd8/nXC518nfP51wudfJ3z+dcLnXyd8/nXC518nfP51wudfEj7/kvD5l4TPvyR8/iXh8y8Jn39J+PxLwudfEj7/kvD51wuff73w+dcLn3+98PnXC59/vfD51wuff73w+dcLn3+98Pk3CJ9/g/D5Nwiff4Pw+TcIn3+D8Pk3CJ9/g/D5Nwiff4Pw+TcKn3+j8Pk3Cp9/o/D5Nwqff6Pw+TcKn3+j8Pk3Cp9/o/D5Nwmff5Pw+TcJn3+T8Pk3CZ9/k/D5Nwmff5Pw+TcJn3+T8Pk3C59/s/D5Nwuff7Pw+TcLn3+z8Pk3C59/s/D5Nwuff7Ps+Zc22fMvbbLnX9pkz7+0yZ5/aZM9/9Ime/6lTfb8S5vs+Zc22fMvbcLnXyN8/jXC518jfP6dfv2rWvzC51/h61+R8PWvSPj6VyR8/SsSvv4VCV//ioSvf0XC178i4etfkfD1r0j4+lckfP0rEr7+FQlf/4qEr39Fwte/IuHrX5Hw9a9I+PpXJHz9KxK+/hUJX/+KhK9/RcLXvyLh61+R8PWvSPj6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Qjz9Cun0K+Szr2C3069gTr+CPf0K7vQr0OlXOP03bU//TdvTf9Pl9Zw87WvgeoqPt8vyaiA+7icF2gonxZYrlW85fp92faDCSeW7SLL7Sdk9nlT+2rl2kmk5ybac5FpOopaTfMtJ5Z9C2o6TCnkqf2tYOym1nJRfnxS2wpjKn8X4mI+TUuGkoiKC2ekFlwsn2cqVSr+n8hvclR9h+dXf2kktP/fyS0fm8r/vFbMNBRRhazvNtJ1m205zbadR22m+7bTQdlpsOy21nfZEJSkep2X7eFrc6qcVyvxo2k6zbae5ttPKKnHbfgu5/LNw4yl3eOunhbbTYttpqe203HRa2tpOM22nPclbONLtYmGWSWWStxrPeCr8AtITJPn4vdHmH0/LW/20ws80m7bTbNtpru200HZamSQdL4MacubhNFdug9RPK5OksB2nhVA4jZ6cdhtb3AqnPRmbP6RM6VGTzmxtp5m208oqoXzsw3FpsBdOc22nUdtpvu208OTXfeTNW184LbadltqCzE2n2a3tNNN2mm25T7pyJ6N+GrWd5ttOSy13Lmfb7lyu7c7lTNNpTxrTcXNHv9jckLjLM67rabnlNHrSnE72OC250mmm7TTbdpprO43Kp916/MluhdN822mh7bTYdlpqOy03nWa2ttNM22m27TTXdlqbSp709ike3blbyfv91JeedOtfnvOk//76HNNwjm04xzWcQw3n+IZzQsM5seGcBh3YJ921o0ud7MM5bms4xzScY8v9OH/049zjOa7hHGo4xzecExrOiQ3npIZz8ufnlNvulXNMwzkNOqAGHVCDDp6swXOZ3vYnN9HT41nlgjik2/aF2+Pvodw1rp5FTWf5prPKlinmo4+STHg8KzadlZrOyi1nPels184yTWfZprNc01nUdJZvOqtJG6FJG6FJG6FJG7FJG7FJG0+62dkdSx5nKpzlms4q5svdXoF0mW53tlz83tuluyaXC3flx+VJ3/UqsctVUper5B5XKXfG2a9iulzFdrmK63IV6nIV/+FVrmeFprNi01mp6azcclbems4yTWc90SrZ46xgHs9yTWdR01m+6azQdFZsOis1nZUbzvLb1nSWaTrLNp1V1kY+3h25NLvi6ztGuu1fcGkN3frM5a8Gai1YX25TDo3ITxdRmC6iOF1EabqI8mwRlRvZQyMy00Vkp4tounu2me6ebaa7Z5vp7tlmunu2me6ebfvfj7I/Irp7v+8WUfffWuXZn7fn/tau1wgdrhE7XINB4ZN803sLw9rHpxLeZi0jdZuakRo1I7VqRurUjJTUjNSrGWlQM9KoZqRqaiSnpkYiNTUSqamRSE2NRGpqJFJTI5GaGonU1EikpkYiNTUSqamRvJoayaupkbyaGsmrqZG8mhrJq6mR/ELzqb+NNDy8U+3DOvfe11+4+LDOvbc20nXuvbWRrnPvrY10nXtvbaTr+NPaSNfxp7WRrjOf1ka6jj+tjDSu409rI12ncni9AZ+P61QOtZGSmpGuUzm83jfCx3Uqh9pI16kcaiNdp3KojXSdyqEy0rRO5VAb6TrdldpIF6qRKiNdqEaqjJTUjFRNjZT6f1NT+YIldf8OMpl9yaDLP/NjRLn7d5CVxRp9NtNFZKeLyE0XEU0XkZ8uou7fQda+X8txuojSdBHlySIK2zZdRGa6iOx0EbnpIir++m3Ox7op2/12DTZfTyt/YF4/LbSd1hhkajstN51WXpu3fpppO822nebaTqO209pUYttUYttUYttUYttU4tpU4tpU4tpU4tpU4tpU4tpU4tpU4tpU4tpU4tpUQm0qoTaVUJtKqE0l1KYSalMJtamE2lRCbSqhNpX4NpX4NpX4NpX4NpX4NpX4NpX4NpX4NpX4NpX4NpWENpWENpWENpWENpWENpWENpWENpWENpWENpWENpXENpXENpXENpXENpXENpXENpXENpXENpXENpXENpWkNpWkNpWkNpWkNpWkNpWkNpWkNpWkNpWkNpWkNpXkNpXkNpXkNpXkNpXkNpXkNpXkNpXkNpXkNpXkJpXEbWs7zbSdZttOc22nUdtpvu200HZabDsttZ3WphLTphLTphLTphLTphLTppK23mts673Gtt5rbOu9xrbea2zrvca23mts673Gtt5rbOu9xrbea2zrvca23mts673Gtt5rbOu9xrbea2zrvca23mts673Gtt5rbOu9xrbea2zrvca23mts673Gtt5rbOu9xrbea2zrvca23mts673Gtt5rbOu9xrbea2zrvca23mts673Gtt5rbOu9xrbea2zrvca23mts673Gtt5rbOu9xrbea2zrvca23mts673Gtt5rbOu9xrbea2zrvca23mts673Gtt5rfPJ133Zsl+6s8T9OK7zOu18i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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "get_note_internal",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "call_private_function_internal",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "refund_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3564161243949231814": {
            "error_kind": "string",
            "string": "Function refund_public can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "9323748002447105156": {
            "error_kind": "string",
            "string": "NotPassedTimelock"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "refund_public"
      ]
    },
    {
      "name": "commit_public_user",
      "is_unconstrained": true,
      "custom_attributes": [
        "internal",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 48
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "src_receiver",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3559210201980528457": {
            "error_kind": "string",
            "string": "Function commit_public_user can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7Z3bjuS2robfZa7nQgfqlFdZ2AiSrKxggEESTJINbAR59+2qasueMVXs4nK5ZJE3QXfGf4v8RJ1oSf77w79//vGvX77/9Ot/fvvjw3f/+vvD599++uHPT7/9Ov329z8fP/z45dPnz59++X79vz+Yy3+KNVfBH7//8Ovl9z/+/OHLnx++Symnjx9+/vXfH77L1qbpT/zn0+efP3xX4j//83ESAUdUGCIXOCJOSZ7jE3DoAaskjk+BU1LImMh6F8ybynqfw1r2cfu4cW5+2oBbHvbIwxCjfXsYYjL14WiRh3MwYbY+OLt++GJ99LtYX8r8tLXlQOv3YR9yZZ8J9jakORhs9P6+9SWU2dUJNHxrfYo7W2/dV9ZfyshwQBloW5sCoVSVMzbeLwOyhzks8qoFNMIiuRoWOX0LtuBOu1Ujc1+1svjkOC3vIQTwTddijQGezjqmLmE6MLaSMC5XVcBIRBf828PRRSCwFTNXei7OfYPt0imS9vi4tuemKhwVPqCRKlZZkDiqQNOAtFUljioGjiqh4zuAnzsbgJDux89UtF/GkqWDtSGg3XF8e3hq3PVZfxmlt+N4gbmNplKWv+yyQZ72qdq86rkd9qhzdv7Dzq3GhOnhK5VilQpCJSqVDZWpy1cqCBVQKgiVolS2VKzGCkYlK5Utlcb8UjoVHZkRKl5HZoyK9rYYFe1tESrglQpCJSmVLZWga2aMio7MCJWoIzNGRUdmjIqumREqSUdmjIqOzAiVrGtmjIqOzAiVoiMzRiUoFYSKjsxbKs7oyIxR0fwKQsXKHJm9nU123sUtFZmzOIKKk5lfoajIHJkpKjJHZoKKlzkyU1S0t0WogPa2GBWZa2aCitA3HxQVHZkRKkLffFBUQKkgVGSumQkqSdfMGBUdmREqWXtbjIr2thgVXTMjVIrGCkZF5sicYH7WpQDfUvFC33xQVGTmVwgqVuaamaIic81MUZE5MhNUnPa2GBUdmREqQt98UFR0ZEao7PHmw+bl1goIBJUQyvynY3arKy4K9qdLmLHYkhaINsY388upzQ/p1ObHcGrz33EbRvb3zZ/Wi1CXjtF+VQbydEizs9OrAUM8DdHOtzZBXF0Ggz+dQp4tSdEsINF7XdJyCcz047cXH01kQMk0yBQlg5PJGjMtMhozDTJFY6ZFRmMGJwNGY6ZFJisZnIz1SqZBJikZnMw79hoLJeOtkmmQiUoGJwMaMy0y2s80yATNzzTIRMExk00lk+2GTJbbA0/p2Plhn7ZkylitKS1knLlPxts8v4nxzi0Jae/DGxpQNC00Y+UhdkQTzFiLyl3RjLWq3BPNOw6Bi0Uz1ti9Jxqng3cTzVhz4T3RDJaoeQSNi66iyQZBIzdqKDQgt68h0WjUtNAMlqzZFY1GTQtN1KhpotGoaaKRm5Sg0Ay2c29XNGNtj9gTzWBZ8z3RFLn5GhKN3CwfgSYawVFTt+h7b+ErNI89fQMpuGfaFaQVnAvaF6Tgefm+IAXP4ncF6UBB7gLSa0S+C6Q19bTq9GNcng5vICWndR4DWb9hf/k4NwJSm/ZOIAUv/ncFmeTuetkZ5HlXz1f783kXFDf7z7uyvNrf/X7ONG9hhmQy8fQ095oTKjaGsrSWqZ3dvO191bWvt71PRPf0NnW/kXJfb0XVrQVR3oqqWyeq3bre52u7etv91sF9ve19Lrirt91v8HvM25xmb5PNiLdjzRwJb7vfhrevtyDK295zWLt6G3t/hb6vt2PNLghvk6i6TWPNLghvs6gRqPtb7/b1dqz1LeFtGWp9m0Kp3mZAvB1qdkF4m7vfoLevt0ONQJS33W9129dbUXXb/UHofb0FUd6KGoG8qBForAwr5e1YGVbSW1G9FIjqpYKoXiqM1UuV2ZLLvGnrbRxrnkx5O9R7INLboTI1lLfdn3re11tRdZvHysJR3g71Hojytogagcbaw0p6K6mXKmPtYSW9ldRLlcHyyZS3knqpMtaO3VzNnn7c7vwrY+1hpbwdaw/r2tv1mdvq7VC5C8rb7r8nsq+3PdXt1aKu9pneLOpp3LpZ1NPYcrUo9jRLvVnUUzb9alFXexNvFnXX+rs6+3uzqLvW39VeuatFXX3m5GZRZ63fma72hd0s6mnOfrWoq/XwzaLOWr8zXe1TulnUWeufLOqu9fvO5keTRd21/q5WXjeLOpsfOdPb6miyqLvW39vqyJneVkeTRd21/t5WR5NF3bX+rk5A3Szqbn7U2+rIma5O+9ws6m1+ZLtbHdmuTrZcLepudWS7Wx3Zrt66XS3qbnVku1sd2a5OLNws6m1+ZLtbHdmu7j+5WtTd6sh2tzqyXd31cbWou9WR7W51ZFN3rb+71ZHtbnVku7rD4WZRd/Oj41dH0dtqUfDE0yG4+VO4IQTqb6eQZ0tSNKE+jV77nHyet3IkcO7+w3aaksyGWAumrB+/gSydg8yzISE66v7sKVJnNpNnm40rbsrNivJ2qLqd3J3/tgth660dqm6nobJ6G8vWW+dG8tab+re9tYi3SZK3XlTd+rHq1oVqSUDaLYxVtytLkt96e/zS+pnegpkvsnVgMW+DJG+jqLqNY9Wtq7MLCHnrbRqrbutizEFCRqDjv8T8VG9LnScHg9Rt7n3pvK+3ouq2+7TIQ94GV/vkdRJl8Xaoug2u/u0Qt+tbf/yr5ad6W/yS4IOtt8e/tn6pt6Lq1g1Vt3HJS0XIiLdD1W1c8lIxbvtk72Eob/PibUmIt0NlWClvQVTdwlB1S/XJYaiZI1W3YaiZI+VtFFW3cawV3/28lE9D5ZOJ9a1PQ70roLzNour2+KvmYq7vapKlrtCIpj4dTflqI8X24Zz97GzOYbPrwhf3Ul/LV0/fLEqdWQSmN0Zw/NHnBKValKj2aEucDXHGrMcKc7P/+G1cZelPSkCIHn8FAGlRb4zC8VFHWWQPb5kl1nZQVnM+/OkMMBuS4at38A5tNabukCtgv3r65m2S5K0T9LGayVtBn4FwYawL6EhvRdXtWBfQkd6Kqtsgqm4H++gF4e1gH72gvBVVt10dv3q+t6LqtqsrB5/vrai6HewzEJS3kuo2Gkl1GyV9aNdFSR/anbwVVbei8lJRVF4qispLRVF5qSgqLxVF5aWiqLxUFJWXiqLyUlFUXiqKyktFUXmpKCovFUXlpaKovFQ8Pi+1276Li/3JmJPbDye3P5/b/hPvsrrZf/L2607eft3J2687efv1J2+//uTtF07efuHk7ff485P72n/8icid7T/vvuWr/cdnoHa2P5zc/pO333Ty/jOdfP5z+OlFb+J8fsubFIinY4A5WzElu6ncRqk3NJeyOulYPGZHqOdnph/dJrORDs9anYbM4RmubshkP5/L8Rm57zcVsTFT3PyXffF2QyYbsTFDktGYaZCxRsk0yICSaZDJSgYn47ySaZDRmGmQ8WJXByQZsaN2rvdvTGS2N6Bm0NXBhUxEyMid6YWlNWUkZoLc1UEulQxyT1oOcmOGIBM1ZlpkgpJpkClKBieT5K4OKDJyVwcEmawx0yKTlAxORu67gxLmO2LBGGRFKffdwbJumshs3zcVse8OwNhSyUSDkJEaMxMOqGQSEjNWbsxQZDRmGmSc1PdNNBlQMg0yUlcHJBkvdXVAk9GYaZABqe+baDJyR+365a6JzPatSpH77mC9bkoJISM3ZkptTdZt3zcVse8OJhx1RWk9EjNRbMxQZJLGTIuM1PdNNBmp75tIMmLfHdBkxK4OKDJFY6ZFRur7JoKMN4LfHdRviYIFh5DR900XMn5LRu67A1u/TQbOGISM2NWBM3VF6SzSmpzYmCHJaMw0yHix75tIMqBkGmTErg4oMiB2dUCS0ZhpkAli3zeRZOTmgeuNlxMZZEUp99zBat3kbEbIyF1RVqsnSMiKMok9yU6SEXtWhSKTNWZaZDRmGmSKxkyLDCiZBhmx55sIMtaIPd9EkhF7jpIiI/dmHoqM2N31NBmdzzTIeLlrbYqMrrUbZMTuIafJiD2VTJEJOtNrkdHVQYNMBCXTIKOrgwYZzXa2yGi2s0lGZ3oNMoLvIafI6EwPJ+OMrg5aZHSm1yBjdXXQIqMzvQYZsTdmkGTE7nqlyejqoEFG8J3SFBldHTTIiN3bSZPR1UGDTNSZXouMrg4aZA7/guF5yOjqoEFGdzC2yOgOxiYZnenhZLwRe45yetc2u+hRMmJv5iHJiL2ZhyIjNttJkxF7ywpFRu7tByQZ7YFbZLQHbpCRe3MySUZ74AYZsRlymoz2wA0yQddNLTIaMy0yOmo3yIh9dwA+pkpm+3XXiYzY+2coMkns/TMkGbH3z1BkxO6UpsmAkmmQ0R64QaZoD9wioz0wTgYEv2+iyGgP3CKjPXCDjOD3TRQZjZkGGaejdoOM3Aw5mHpvJ9jt3fUg9iQ7QHKLi2VLJspoTTdfZcxqr74K+WLZzdeRMvbW+NkSa0Ik2ncqMFuSSlmcdNlgdqdKxC8cHfaoc3b+w86tUt7Tw1fmQ60Qz8E8DPU9o7Mw177leOYjvWc8CfOh7q48C3ON88OZu5EyTmdhPlJe4iTMh7o99SzMda54PHMdQw9nPtTX1s7CfKQM9kmYD3WLyFmYa17xcOZDfdXuLMx1rng8c50rHs58qBtyzsJc54qHM886VzyeueYVD2c+1L3rZ2Guc8Wjmceh9vmfhTko88OZ61zxcOZDnXo4CXOncf4E5mFhHuOGOWi+ZX/mCeZnXQqwYR5AmR/OXPuWw5kPdW7lLMz13dzhzJOuQ49nrmPo8cx1rng486HuzDkLc50rHs78xPf83Ow/77zrYn868bnFm/2dv3+Jzlb7IRFPZ5Nmb7NZmR0xsyer82zIOsMzH71OvR/VeyGa3k/UvRKNRk0LTe/fjn0lGo2aFhqvUdNEo1HTQtP7OZ5Xoul8mfZCNL2finkhmth5svaVaDpfw74QTe9Xdb0SjUZNC03vV8G/Eo3maxpocu/bWp+JJi9oVjdhVjS9f8fwiWi8mc2+fAIUQSO3QflgKpqARE3v96y8Eo3cNRSFRvDKm0QjN19Doel9b+cL0fS+HfCVaOSuoSg0eSw0PlY0Id9Hk9KyFyNBXD98IVMM3tVkW79AkMHcJzPRfXu2WHvfGptLmB+efo7LX3YF3gwqnRlkdyXkzKYKbHlyAe7ZHrhne9D4WPaOBeQnFwDP9gCe7UHjdcCOBaQnF9C4/mjHAuKTC0jP9qDxhYUdC3h2V5Gf3dnlZze08uyuojy3oYEx7tkFxCcXYO2zC9ihodWNs8URE+QypcrnZ7ONG2uc6coa6Mqa0pM1vis2MFZS9JF1VY7zW4aUU96SkbvizMHfIxMEx0w2lczqzVQlIzhm7pPp/eLSF5IZ643dQ2R8qWSKuf+wtVBHMmuD2w5lg23O2QfklUzvJ9letpUATO8Hzp6Zcrexpty9QdB0fmfj69BYo1HTRCP4HdbdvTlgreCoodAI3kpAoBF8zIxC4+VukSTRCN4HSKABjZomGu1rmmgEb5Ek0OgHUq4r730vSvEuVSA+rB++MtfLxl7AXOP8eOZ62dgTmFtfgawSqTNzvWzsBcz1srHDmZ/4srHzMteLaY9m7vQDKS9grmPo8cx1DD2cuX4g5QXMNc4PZ+50rng4897vg3uIecmzIaUAQRzAlOri6i97CzcyvR9KfyIZ76qLPm3J9L439YlkwFYXVxvGFjIjrbx2JdP73tQXkhkp470rmSS3BybIZG1NLTJye2AXllEbITNUJnZfMnLnwPfJ+KEybLuSsSPle/clI3c+Q5BxGjMtMnL7mbRkITJCxssdtSkynR+deR0ZkNsDE2SC3B641JxeQLKdPsiNGYJM718xeCEZuaM2QSbJHbUJMr3f0/9CMoJH7eV90+r8eCVT5GY7KTIj7VLYkwwYue8OKDJys50Emd4/UfpCMhozDTJO+5kGGX/0mzgX0nwPjYuG8hWirbmCCEA8nUKaLUnREdcoeVeWi9bt8qevZ682T1tTt35NPy47tKYl+Q3k4WepTwuyHri1Zh2RAXs6V6vzag8d/mzIc6iHFemlgkArqO8KylpBr62gydB5GFodQK0VFHSs6LuConZxnVdQ0Qp6cQXZpYKQWVzSFtR5BWkL6ruCstcKenEF1a9AxeS2FXR4nl4r6MEK0ml21xUUDGgF9V1BOknou4KsThI6r6CkFfS+Coq2VlAyW5BOI30fkF7fr+wEMijIXUCCLqR2AqkLnn1ABo3InUBqH7kTSF2J7QMyjdVH5gWkCfdBJrd8Nc5lu374SiaPNTF8hAzYOWgSOITMWL3YI2R8iffIFLkx47NfyLj7D1vr08zRWjBlC1Jut+TrDs/k0ybE4uEfRjsPmbHmBDuSOXxr+2nIOMEdNkFG8CB/n8xgGcM9yWg/0yIz1h7k/cgk/Jq/APM3awIsNzm8XVubUnpckx1DwyinMMopj5eTjWVoGOVYx9DkxzXOMzTojC/kefUasttovGdo8uMaQLlFOzeG6P1WEx/X4LlZQsMoJzLKiYxy8M+uERpGOZnhD94f3NcURhzgB7vvagp+5Pm+Bm8L1oCpOcPV5oCqShwV/lbL2gA1EZDcVlU4qpA4quhYqoirck1wOLOlgUeShfqJSbtOoswqfIslqQosVXlcFQwehZTKWpaKZSF+2dxUybWWw2qWMqvwOT+pShwVPnKQqsxRBc9SscpqtK9Q6lakaP1GlQxLFTiq7FmqzFEVFg08L0qorDEsFd6+vK8qHzbty+K5JlKVOSr8kyGkKnJUjR6AUrFoeBZ5YJUFLPKBRT6wyMcG+ZirKtutKnJU+GqUVGWOKgNLVTgqfIVJqJzhjMvOBJaKM5o7yyoLb8su1RmsSwG2Kry+Yk2G2GS2ZTVGc0KFX1VJqgJLhZOfshKzKtu4UeFngklV5qjwC/VIVeSo8Nf+pIpFI7PIF1ZZhUPeG8dSccg3LlUnVcBSsWg4Fg2Hl1WWUa/AVoVfoEOpGq2yeLuoVt90mkbbq6zRwEhZYsnw/SOkDN9c8ZVs/U2QKsscGZjIklngydCeYBqAaxLffHUo9k2GJ01pWWbJPK80zysNeKVBYskCr7TA8w1vprSMFyX4YpiU4SMhLYssGZ7bomWs6g74uEbLWNXdOJZGy1jVHRwruBoHYWgZK7gahxxoGa+0wPMtNkqrGWFnVi9iq6zVAuqVedOP2zEgtFoAUVppGJlDlZWwkUVjeDJeaa0WQMkyS+YiS+aBJ2s00/p6cJJtgysC8GS80lrj2/2YjKGwZJHVAmKyPFliybLjyXilFZ5vhVUByTaMLGXRlbJ6o17gJnSBKyxMYavV0UJuia2ZJS3kUg2OK+SWGLklRm6JrcZLC/Gdhqlutb9swNjKGuczSBnwZJklK54nY5WWG3vDSVnk1Vy2wBVmptBxTW3Nbmkh10du95SBWyJwSwzcEgO3HiMvUvHOiZThXRMtY3VMmdcx5cwsrbBkhTkGFmO5wsAVMsO6cLunYrklOm6J3NlT8dx69KymVMDxZJElC4YnYzWlEnmlReDJmH1nSdwqT9wSs+MKmcN1KdxepvBKnNIhlivklmgNV8gJuNjYL0fKnOfJEkvmHU/GKw0sTxaYNRe4VR7YJRamMHquMDOFiVti4paYuSXmxBQWXsAVzvAZG/v+aBnwZKz+xfJ6s8aOQVLmeEPZJGRWufXcEv3DlY6ctAdT9/7A6mqRy20h10Ie7wE5hRzhSWAO4JbbRdro/3u3Uj2ml4rfOhXz04tIT/fC4aesp6XrvG9m+nEpwuY3FbBUhaPyrLLwnQ25uBldLhDWKuScZq7HI11ebcGci8Bz1fsW8Xwv8Pz3vkWkpxcRn+9FfL4X6flepOd7gW8G27eI8OwiPL7o3LeIp9eF940+KplaxOrg3KzCx+spvzi/yC5ffeBwVkVOWbERLbl272U1blVVaFhYv5NoVhORWYUfWCJVrLLwBQypyhxV4ZQFxrJUsaFyi2oTh2AtS8UqyxlS5bd+uUYt+1BVsIlD8IZsKes7G2ZVoyzIS/vaWgiNsuo5fKxVAgRGW4ZgWCrgqBqHAaZ6XJ0UWR/6eJvkQ7ZcYeAKC1PYOBjwDiGzxNA87ksKE1OIX0fxHiEzAALe0t8jZAZAYyfme4TAFWamELgBANwACJYr5AZA5JYYuQEQue0xcQMgcQMgc9tj5gZA4ZZYmAHQ2Cr7HmHgCpkB0Nhn+x4hMwCi45bomAEQPaM9IvlEb+upLe+3+cTo4x7FxJpETKubsmohjVtRfI6lFuLjNvfY2Ab8DmHjxgdaGLmmNrpBWpi4pjbOpdHCzDU1c6ujME1NxnKFTB9T43zmO4TcEh23RMcukVmPyXuuMDOFjYPl7xByQy5wQ6517wMpjNwA4PY5KXIDoDH1eoeQGwCZG3KZGwCFG3KFGQCZ28s1dh5NATWPxvHbCx6SwRelJc4nrkuKG00j53RfExia8rjGMa53S42NO5QKf8tNqlhlAassYJUVWGUFVlmRVV+RVVZi+dXIohGqxpUalApYqsxR4bnt+70FPnMrrqZyYaOx+AGNu63Y4q34fjmOYRu+rCI0gaF5vCdrXG1FaBjl4IujUj8Us35LVDX5cU1klBOp0QnRJEa84fOR+5r8+Ihm8Te4hCY+rGlcYkVoGOVYw9AAQ/N4/Tj3eBy4xmgUl7RJdKuDxreMRnL4WRtaFkiZh62sMbSQMlZpAI3bF12djAZwW1lj3UTKAkvWWDORMl5piVdaYpZWHpb9M/36vz98+fTDj59//mMSXf71r19/+vPTb7++/frn//0+/8uPXz59/vzpl+9///LbTz//+68vP3//+befLv/2wbz9519TsjB/nAa+Mhl0qVd7ucN/GqDy9PulxVg7/bO7/HbtEIqJH4u1l19vT9vy8XI93WTXZNv/Aw==",
      "brillig_names": [
        "commit_public_user"
      ]
    },
    {
      "name": "get_htlc_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "view",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "key",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "Train::HTLC_Public",
            "fields": [
              {
                "name": "src_receiver",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "amount",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "token",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "hashlock_high",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "hashlock_low",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "secret_high",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "secret_low",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "timelock",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "claimed",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 8
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "9174444391250494040": {
            "error_kind": "string",
            "string": "Function get_htlc_public can only be called statically"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_htlc_public"
      ]
    },
    {
      "name": "lock_private_solver",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 48
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6418028854678020178": {
            "error_kind": "string",
            "string": "FundsNotSent"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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XquS9VqVrNeqZL1WJeu1KlmvVcl6rUrWa1WyXquS7VqVbNeqZLtWJdu1KtmuVcl2rUq2a1WyXauS7VqVbNeqJF+rknytSvK1KsnXqiRfq5J8rUrytSrJ16okX6uSfKlK8jRd+7Nw7c/itT9L1/5Mrv3ZfO3Plmt/tl77s+3an12rknCtSsK1KgnXqiRcq5JwrUrCtSoJ16okXKuScK1KwrUqideqJF6rknitSuK1KonXqiReq5J4rUritSqJ16okXquSdK1K0rUqSdeqJF2rknStStK1KknXqiRdq5Jr2Wu+lr3ma9lrvpa95mvZa76WveZr2Wu+lr3ma9lrvpa95mvZa76WveZr2Wu+lr3ma9lrvpa95mvZa76WveZr2Wu+lr3ma9lrvpa95mvZa76WveZr2Wu+lr3ma9lrvpa95mvZa76WveZr2Wu+lr3ma9lrvpa95mvZa76WveZr2Wu+lr3ma9lrvpa95mvZa76WveZr2Wu+lr3ma9lrvpa95mvZa76WveZr2Wu+lr3ma9lrvpa95mvZa76WveZr2Wu+lr3ma9lrvpa95mvZa76WveZr2Wu+lL3O06Xs9ePPwrU/i9f+LF37M7n2Z/O1P1uu/dl67c+2a392rUrCtSoJ16okXKuScK1KwrUqCdeqJFyrknCtSsK1KgnXqiReq5J4rUoK2Wvev7wXPpKYgz8rVMm67n+W45c/OzpxVul5Fh/DEV/DmX0NZ/E1nNXXcDZfw8muhlPK+GsNJ/gaTvQ1HF+fysnXp3Ly9amcfH0qJ1+fysnXp3Ly9aksvj6VxfpT+eWjmD7GE52NJzkbjzgbz+xsPIuz8fz6s/n2Z9u1P8uX/uz4Dm4M2/0IjxjDfAItLGvan+67rMvjYJ3DByJs6X6ITJqeD+GZjo8CnfYDsKb0+DH5tn2OPzgf/zzdBVjmlL6PPzY+/tT4+KXx8c+Nj39pfPxr4+PfGh9/bnv8i/f992z8je+/S+P779L4/rs0vv8uje+/S+P779L4/rs0vv8uje+/a+P779r4/rs2vv+uje+/a+P779r4/rs2vv+uje+/a+P779r4/rs1vv9uje+/W+P779b4/rs1vv9uje+/W+P779b4/rs1vv9uje+/ufH9Nze+/+bG99/c+P6bG99/c+P7b258/82N77+58f03t73/hqnt/TdMbe+/YWp7/w1T2/tv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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "notify_created_nullifier_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "random",
        "decompose_hint",
        "lte_hint",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "is_contract_initialized",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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+ARaz+na6qpG+DRXz+na6qpG+GRUz+na6qpG+JRRz+na6qpG+MROz+na6qpG+PRLz+na6qpG+CRJz+na6qpG+FRGz+na6qpG+IRDz+na6qpG+LRAz+na6qpGWPK+53RtdVUjLMXec7q2uqoR1hTvOV1bXVWx1VUVW11VsdVVFVtdVbXVVVVbXVW11VVVW13VCF+x6DldW13VCF+c6DldW13VXN+RaE/XVFcV5vqORHu6prqqMNd3JNrTNdVVhSXYmq6prirM9R2J9nRNdVVhru9ItKdrq6ua7MsQzena6qom+3pDc7q2uqrJvrDQnK6trmqyryA0p2urq5rsSwXN6drqqib7mkBzura6qsm+JtCcrq2uarKvCTSna6urmu1rAq3p2uqqZludvzVdW13VbKvdt6Zrq6uabfX41nRtdVWzrcbemq6trmq21c1b07XVVc22Wnhrura6qmCrqwq2uipba6sHW2urB1trqwdba6sHW2urB1trqwdba6sHW2urB1trqwdba6sHW2urh9nWVv/Yd47Stq1blvWXje8cAxy7cOSbhH048lHCPhz5KmEfjnyWsAvH2Zagf83xPl0zn+++T9fMZ7bv0zXTfN6nG2xN10wrd5+umY7rPl0zjdF9umb6l/t0zXz++Od0Z1uCvjVdW13VbEvQt6Zrq6uabQn61nRtdVWzLUHfmq6trmq2Jehb07XVVc22BH1rura6qtmWoG9N11ZXNdsS9K3p2uqqZluCvjVdW13VbEvQt6Zrq6uabQn61nRtdVWzLUHfmq6trmq2Jehb07XVVc22BH1rura6qtmWoG9N11RXFWdbgr41XVNdVZxtCfrWdE11VXEJtqZrqquKsy1B35quqa4qzrYEfWu6trqq2Zagb03XVlc12xL0rena6qpmW4K+NV1bXdVsS9C3pmurq5ptCfrWdG11VbMtQd+arq2uarYl6FvTtdVVzbYEfWu6trqq2Zagb03XVlc12xL0rena6qpmW4K+NV1bXdVsS9C3pmurq5ptCfrWdG11VbMtQd+arq2uarYl6FvTtdVVzbYEfWu6trqq2Zagb03XVlc12xL0rena6qpmW4K+NV1bXdVsS9C3pmurq5ptCfrWdG11VbMtQd+arq2uys5K8ffp2uqq7Ky7fp+ura7Kzirm9+na6qpsra0eba2tHm2trR4nW1s9+bpN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",
      "brillig_names": [
        "is_contract_initialized"
      ]
    },
    {
      "name": "redeem_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/+xdB3wcxdXf0+lkS7YsuVewZNNMvb1TpZpmeu8dlRMYDAYXbON2BhtswBjc6DWU0BLSSCHtSyGdkAQSUkgIBEJ67+2bsffdPT293dvTvTntYM3v96S9ndn/vHnz5s2bsrMxZ3v49hDHeaJq+3VMUdz7X6GogdyD//g6waQbxtyrZe7VMfdGMvfGKZpJ7k1l0jUw9xqZe9OYe7sz92YoGkru7cnc24u5tzdzbx/m3r7Mvf2Ye0nmnsvcSzH30sy9JuZeM3OvhbnXytxrY+61M/f2Z+4dwNw7kLl3EHPvYObeIcy9mcy9Q5l7hzH3DmfuHcHcO5K5N4u5dxRz72jvHg4x7/9M73862dLUlGlNZdy025FMtXe2NSebmjtb2tw2t7mtuTvVlk5n2praWts721uT7W5TOuP2NLene5Lbw87xPFaypJDqMsnn1H7zmUrTO5q3UYoqEa9aDv/1rvdw8tcz0PVULw0816B+Nyqapmh6PH8fQpzIIFlacPcUxGqIy9XNLmI6lEyalN9egliNgvLb1RL57S2INU1QfrsJyo+zDbsg27Arut4NXU8ntmF39XsPRTMU7VkG27CPINbugnWzlyW6va8g1h6C8tvbEvntJ4g1Q1B++xi2DXshG7A3ut4HXe9JbMO+6vd+ipKK3DLYhqRkOxGsm5Qluu1KthNB+aUtkV9KUpcF5ddk2DakkA1Io+smdO0S29CsfrcoalXUVgbbkBbEahasm3ZLdLtJEKtFUH77WyK/ZkGsVkH5HWDYNrQjG7A/uj4AXbcR23Cg+n2QooMVHVIG29AiiHWgYN3MtES3WwWxDhKU36GWyK9NEOtgQfkdZtg2zEQ24FB0fRi6PoTYhsPV7yMUHaloVhlsQ7sg1uGCdXOUJbq9vyDWEYLyO9oS+R0giHWkoPyOMWwbjkI24Gh0fQy6nkVsw7Hq93GKjld0Qhlsw4GCWMcK1s2Jluj2QYJYxwnK7yRL5HewINbxgvI72bBtOBHZgJPQ9cno+gRiG05Rv09VdJqi08tgGw4RxDpFsG7OsES3ZwpinSoovzMtkd+hglinCcrvLMO24QxkA85E12eh69OJbThb/T5H0bmKziuDbThMEOtswbo53xLdPlwQ6xxB+V1gifyOEMQ6V1B+Fxq2DecjG3ABur4QXZ9HbMNF6vfFijoUdZbBNhwpiHWRYN10WaLbswSxLhaUX7cl8jtKEKtDUH4Zw7ahC9mAbnSdQdedxDb0qN+XKLpU0ewy2IajBbF6BOvmMkt0+xhBrEsE5Xe5Yd2+DOnw5ej6UnQ9m+j2HPX7CkVXKprL6HaFcN3s7sjJ8yo5ebp4n7rGbTAsh6sE9epqQ3K42pNDJZEBDjFhucQcMzbGkeWzi8MWf0lgnljFpjpN8jlfgM/W5qbWdFdzC2fY5iEDNj/Ov9hAX2ZYoH4vVHSNokVl6LRnCGItEDQOiy3ptCVfBlkoKL8llshP8mWQawTld61hp2cxsgdL0PW16HoRsQ1L1e9lipYrWlEG2yD5oslSwbpZaYluS74MskxQfllL5Cf5MshyQfmtMmwbViIbkEXXq9D1CmIbrlO/r1e0WtGaMtgGyRdNrhOsmxss0W3Jl0GuF5TfjZbIT/JlkNWC8ltr2DbcgGzAjeh6LbpeQ2zDOvX7JkU3K7qlDLZB8kWTdYJ1s94S3ZZ8GeQmQfndaon8JF8GuVlQfhsM24b1yAbciq43oOtbiG24Tf2+XdFGRZvKYBskXzS5TbBuNlui25Ivg9wuKL8tlshP8mWQjYLy22rYNmxGNmALut6KrjcR23CH+n2norsU3V0G2yD5oskdgnVzjyW6LfkyyJ2C8rvXEvlJvgxyl6D87jNsG+5BNuBedH0fur6b2Ib71e8HFD2o6KEy2AbJF03uF6ybhy3RbcmXQR4QlN97LJGf5MsgDwrK7xHDtuFhZAPeg64fQdcPEdvwqPr9mKLHFb23DLbhYEGsRwXr5glLdFvyZZDHBOX3pCXymymI9big/J4ybBueQDbgSXT9FLp+L7ENT6vfzyh6n6L3l8E2HCqI9bRg3TxriW4fJoj1jKD8PmCJ/A4XxHqfoPw+aNg2PItswAfQ9QfR9fuJbfiQ+v1hRR9R9FwZbIPkiyYfEqybj1qi25Ivg3xYUH4fs0R+ki+DfERQfh83bBs+imzAx9D1x9H1c8Q2fEL9fl7RJxV9qgy2QfJFk08I1s2nLdFtyZdBnheU32cM6/ankQ5/Bl1/El1/iuj2Z9Xv/1P0OUWf93S70skfQu8XZoqUI5XS+UwzlAfsj3aQjOR4T7p7OPLtQZrHGRbwuKcFPO5lAY97W8DjPhbwuK8FPO5nAY9JC3h0LeAxZQGPaQt4bLKAx2YLeGyxgMdWC3hss4DHdgt43N8CHg+wgMcDLeDxIAt4PNgCHg+xgMeZFvB4qAU8HmYBj4dbwOMRFvB4pAU8zrKAx6Ms4PFoAzya4POzhtYNcqFCmOGrBSf9vyBX+F4nzWjcBmf7ZH2F03dRykRFmjppxhaFk+bzakv4jDuGG7D06TpflBNsyiSfL5RJAUrl80v95zNFb3Arl1+M8ycUvYDuf4msXH5Z/f6Koq8q+hpauaxB5Q+SSbK04H5ZeDUXwtfjBhn+OlrTnSmkHFrow5zynHU2xjFriUrEduECy+IbnsxfhK4b/uuIH5N7L3rdOg7S+yPGlF75Ka/y3W8IukovGrKG1D0slU/JMn+TKXN/MbEefdPTrWIsoqRcJMoC4aW4QYY1uN/4ob/4Lwn6/N8SVDZTMtQ8xoRl+C1hYyBd7he9ckuNPQFXsr6/LeyigHHRuI3OduMSd/iNYjvq2PPLcTv4lOxsJyA+v+Mpw8ve/1e8/9/1/n/P+/+q9//73v8feP9/6P3/kff/Ne//j73/P/H+v+79/6n3/w3v/5ve/595/9/y/r/t/f+59/8d7/8vvP+/pN6ZLkCW3Psuc+97zL1XmXvfZ+79wKsEfE8LYCi59xrz7E+Ye68z937K3HuDufcmw8vPGF7e8jxUfO9trwPA937OpHuHSfcLJt0v43294CHe/5ne/2RpwX2r2Abg+ke9XRyWGxT58/43zD647/QXi+HwF6UbjBzqLwU7uV+VyeCWyuev+82nm6Z3uDmUX6G5ku+g65fR9a/JHMpv1O/fKvqdot/Hzb/Z8IqgY/wbQR36gyEdkpbfdwXl91tB+f3REvl9T1B+vxOU35+EHXVqG/6AbMAf0fWf0PXviW34s/r9F0V/VfS3MtiGVwXr5s+CdfN3S3T7+4Ly+4ug/P5hifx+ICi/vwrK75+GbcPfkQ34B7r+J7r+G7EN/1K//63oP/p+GWzDDwXr5l+CdfM/S3T7R4Ly+7eg/LTi2CC/1wTl9x9B+cUqzdqG/yEboCPgOoau/0tsQ4W6iCuqVJSoNG8bfixYNxWVcnVTZYlu/0RQfnFB+Q2xRH6vC8qvUlB+Qw3bhipkA4ag66HoOlHZ2zZUq4saRcMUDS+DbfipYN1UC9ZNrSW6/Yag/GoE5TfCEvm9KSi/YYLyqzNsG2qRDRiBruvQ9XBiG+rVxUhFoxSNLoNt+Jlg3dQL1s0Yw3UzBtXBSHQ9Cl2PJnUzVl2MUzRe0QSmbqTnyieKyWDbi6C5ILVYD+BfFvTlJ8mVOW2ybib3n89Q6xgT8TjDyV9PQvcnE/2coi52UrSzoqmV+b2glU55tiWa2rkmzecUQdtShfhs8Cqi0fs/zfs/3fu/S2V+b68Ou6rfuynaXdEeimYo2lPRXor2VrSPon0V7adI7y91FaUUpRU1KWpW1KKoVVGbonZF+ys6QNGBig5SdLCiQ3R5FR2q6DBFhys6QtGRimYpOkrR0YqOUXSsouMUHV/p9F6M1sw3OOXdXNwo3AlAOKHSIMMnVMrjnijYs5oq94moOxTCTZZT2aYZUraTKg0yfJIBZTs54sqmy32y5co23ZCynVJpkOFTDCjbqRFXNl3uUw0omwleT/QahrSve1qlnY1sF0ON7PRKgwyfbqCRnRHxRqbLfYYljUwbg9MMNLIzK2XL7deoSuXzrP7z2URvcAPfRjTAnYaud0HXZ5GB79nq4hxF5yo6r9L8pJlg7+2eLdg2zxc2eLRuzkd1cA66Phddn0fq5gJ1caGiixRdXNkbT1Ivtf0400C77BCsa1324U553hRpMGRPHFE+U23msJOpGJItTLp0Krl0KepWlFHUo+gSRZcqmq3oMkWXK5qj6ApFVyqaq+gqRVcrmqdovqIFihYqukbRIkWLFS1RdK2ipYqWKVquaIWilYqyilYpuk7R9YpWK1qj6AZFNypaq2gdnXTprOz7pkAXc6+buZdh7vUw9y5h7l3K3JvN3LuMuXc5c28Oc+8K5t6VzL25zL2rmHtXM/fmMffmM/cWMPcWMveuYe4tYu4tZu4tYe5dy9xbytxbxtxbztxbwdxbydzLMvdWMfeuY+5dz9xbzdxbw9y7gbl3I3NvLXNvHTLuEGZ4/2d6/5OlhV5Gs9SOo1MAK9OzPXTJYXV3y2G1Z+Sw3B4xrIx7iRhWl3upGFabO1sMK+leJoWVSbqXS2F1Jd05UlhtSfcKKSzVtq8UwsoorLlCWF0K6yohrDZ9lJIQlraF82SwMhprvgxWl8ZaIIPVprEWymBt6zuuEcHKbMNaJILVtQ1rsQhW2zasJSJY2/vaayWwMtuxlkpgdW3HWiaB1bYda7kEluebrBDA6vawVgpgdXpYWQGsVg9rVelYuTN5risdywWs60vGausBrNWlY3UC1prSscBfdW8oGas1h3VjyVjNOay1JWO5Oax1hiZF6I6qKIwdAOsmuTLrz4SIT1TpCcIOAxN3NwvXtfSuOb37p1OwbnQ932xAjrdYIEdJHe80JMf1gnLUvNHJeV1PMAm/vjLc6ZG3qosNim5TdHul/+R8srTg6l1uXQZk+uUqs4uFpfKny3yrgXJ/pcpMP1YpXO+3CvZjGwXbuKDeuLbUxW6CdbGp0kwbjlK74GzsRmRXN4W0sZvVxRZFWxXdYdDG6l3E3QZszVcjbmN1mTcbKPfXLGnXmwXb4p2CNlZQb1xb6mJ3wbq4q9JMG45Su+Bs7J3Irt4V0sberS7uUXSvovsM2lj9lkbGgK35esRtrC7z3QbK/Q1L2vXdgm3xfkEbK6g3ri11sYdgXTxQaaYNR6ldcDb2fmRXHwhpYx9UFw8peljRewzaWP0WXI8BW/NixG2sLvODBsr9TUva9YOCbfERQRsrqDeuLXUxQ7AuHq0004aj1C44G/sIsquPhrSxj6mLxxW9V9ETBm2sfsv4EgO25qWI21hd5scMlPtblrTrxwTb4pOCNlZQb1xb6mJPwbp4qtJMG45Su+Bs7JPIrj4V0sY+rS6eUfQ+Re83aGP1KQ6XGrA13464jdVlftpAub9jSbt+WrAtPitoYwX1xrWlLvYSrIsPVJppw1FqF5yNfRbZ1Q+EtLEfVBcfUvRhRR8xaGP1KTmzDdialyNuY3WZP2ig3K9Y0q4/KNgWnxO0sYJ649pSF3sL1sVHK8204Si1C87GPofs6kdD2tiPqYuPK/qEoucN2lh9CtllBmzNdyNuY3WZP2ag3N+zpF1/TLAtflLQxgrqjWtLXewjWBefqjTThqPULjgb+0lkVz8V0sZ+Wl18RtFnFf2fQRurT3m83ICteTXiNlaX+dMGyv19S9r1pwXb4ucEbayg3ri21MW+gnXx+UozbThK7YKzsZ9DdvXzIW3sF9TFFxW9oOhLBm2sPkV3jgFb84OI21hd5i8YKPcPLWnXXxBsi18WtLGCeuPaUhf7CdbFVyrNtOEotQvOxn4Z2dWvhLSxX1UXX1P0dUXfMGhj9fGeVxiwNT+KuI3VZf6qgXK/Zkm7/qrkHh9BGyuoN64tdZEUrItvVpppw1FqF5yNfRHZ1W+GtLEvqYtvKfq2ou8YtLH6FMkrDdiaH0fcxuoyv2Sg3D+xpF2/JLk2ImhjBfXGtaUuXMG6eKXSTBuOUrvgbOzLyK6+EtLGflddfE/Rq4q+b9DG6q/szDVga16PuI3VZf6ugXL/1JJ2/V3JMaWgjRXUG9eWukgJ1sUPK8204Si1C87G/gDZ1R+GtLE/UhevKfqxop8YtLH6K2ZXGbA1b0Tcxuoy/8hAud+0pF3/SLItCtpYQb1xbamLtGBd/LTSTBuOUrvgbOzryK7+NKSNfUNdvKnoZ4reMmhj9VcirzZga34WcRury/yGgXK/ZUm7fkOwLb4taGMF9ca1pS6aBOvi55Vm2nCU2gVnY99GdvXnIW3sO+riF4p+qehXBm2s/grvPAO25u2I21hd5ncMlPvnlrTrdwTb4q8Fbayg3ri21EWzYF38ptJMG45Su+Bs7K+RXf1NSBv7W3XxO0W/V/QHgzZWf+V8vgFb807Ebawu828NlPsXlrTr3wq2xT8K2lhBvXFtqYsWwbr4U6WZNhyldsHZ2D8iu/qnkDb2z+riL4r+quhvBm1sa2X+O3gYt1SZ/jLiNlaX+c8Gyv0rS9r1nwXb4t8Fbayg3ri21EWrYF38o9JMG45Su+Bs7N+RXf1HSBv7T3XxL0X/VvQfgza2rTL/XVGMW/L4MeI2Vpf5nwbK/RtL2vU/BdvifwVtrKDeuLbURZtgXfyv0kwbjlK74Gzsf5Fd/V9IG+sk1H1FFYriCXM2tr0y/51mjFuqTH8bcRury7xNxsK4v7OkXeuyS5W5MiE4hyFoY22pi3ZBu5hImGnDUWoXnI3VOgi2NJEIZ2OrVLohioYqqjZoY/evzH/3HuOWKtPfR9zG6jJXGbCxf7CkXVcJtsUaQRsrqDeuLXWxv6CNHZYw04aj1C44G1uD7OqwkDZ2uEpXq2iEojqDNvYABbzYgI39Y8RtrC7zcAM29k+WtOvhgm2xXtDGCuqNa0tdHCBoY0cmzLThKLULzsbWI7s6MqSNHaXSjVY0RtFYgzb2QAW8xICN/XPEbawu8ygDNvYvlrTrUYJtcZygjRXUG9eWujhQ0MaOT5hpw1FqF5yNHYfs6viQNnaCSjdR0SRFkw3a2IMU8LUGbOxfI25jdZknGLCxf7OkXU8QbItTBG2soN64ttTFQYI2dqeEmTYcpXbB2dgpyK7uFNLG7qzSTVXUoKjRoI09WAEvNWBj/x5xG6vLvLMBG/sPS9r1zoJtcZqgjRXUG9eWujhY0MZOT5hpw1FqF5yNnYbs6vSQNnYXlW5XRbsp2t2gjT1EAS8zYGP/GXEbq8u8iwEb+y9L2vUugm1xD0EbK6g3ri11cYigjZ2RMNOGo9QuOBu7B7KrM0La2D1Vur0U7a1oH4M2dqYCXm7Axv474jZWl3lPAzb2P5a06z0F2+K+gjZWUG9cW+pipqCN3S9hpg1HqV1wNnZfZFf3C2ljkyqdqyilKG3Qxh6qgFcYsLH/jbiN1WVOGrCx/7PlXGjBttgkaGMF9ca1pS4OFbSxzQkzbThK7YKzsU3IrjaHtLEtKl2rojZF7QZt7GEKeKUBG+sMibaN1WVuMWBjY0PsaNctgm1xf0EbK6g3ri11cZigjT0gYaYNR6ldcDZ2f2RXDwhpYw9U6Q5SdLCiQwza2MMVcNaAja2IuI3VZT7QgI2NW9KuDxRsizMFbayg3ri21MXhgjb20ISZNhyldsHZ2JnIrh4a0sYeptIdrugIRUcatLFHKOBVBmxsZcRtrC7zYQZsbMIW30mwLc4StLGCeuPaUhdHCNrYoxJm2nCU2gVnY2chu3pUSBt7tEp3jKJjFR1n0MYeqYCvM2BjqyJuY3WZjzZgY4dY0q6PFmyLxwvaWEG9cW2piyMFbewJCTNtOErtgrOxxyO7ekJIG3uiSneSopMVnWLQxs5SwNcbsLFDI25jdZlPNGBjqy1p1ycKtsVTBW2soN64ttTFLEEbe1rCTBuOUrvgbOypyK6eFtLGnq7SnaHoTEVnGbSxRyng1QZsbE3Ebawu8+kGbOwwS9r16YJt8WxBGyuoN64tdXGUoI09J2GmDUepXXA29mxkV88JaWPPVenOU3S+ogsM2tijFfAaAzZ2eMRtrC7zuQZsbK0l7fpcwbZ4oaCNFdQb15a6OFrQxl6UMNOGo9QuOBt7IbKrF4W0sRerdB2KOhV1GbSxxyjgGwzY2BERt7G6zBcbsLF1lrTriwXbYregjRXUG9eWujhG0MZmEmbacJTaBWdju5FdzYS0sT0q3SWKLlU026CNPVYB32jAxtZH3MbqMvcYsLEjLWnXPYJt8TJBGyuoN64tdXGsoI29PGGmDUepXXA29jJkVy8PaWPnqHRXKLpS0VyDNvY4BbzWgI0dFXEbq8s8x4CNHW1Ju54j2BavErSxgnrj2lIXxwna2KsTZtpwlNoFZ2OvQnb16pA2dp5KN1/RAkULDdrY4xXwOgM2dkzEbawu8zwDNnasJe16nmBbvEbQxgrqjWtLXRwvaGMXJcy04Si1C87GXoPs6qKQNnaxSrdE0bWKliIbC6FCuJ7rHTl5Lk6Y0e24cJmnCOp2oyDWMkH5ab2pcfJ9CQ7S/bUk35jf5QmDDC9PyOOukHyh1VC5VyTyAhbC3aZsGrbCMa9suPEmSwwm+WysNNMoViK9lT/NRdBr0rzFPR6Baa0oVU55rJJkBWDFznoNaJUuk4kKWGnAMq0U7ppNlbvCYLlLfrXGsAyTpQVXK+Z1BoaP1wt372AUNG7Ww5WWxSpDslhtSBarA2RR8tEGhmQxfmCnU7oK8GdMByYMibYd0B3fdQZsqWB9u5Iy1E6FgmO9T6dIGRTSKYxpwn5LyQQ7WGuCPMZkacG9zpBBxEwXybNbKB/N8xoDhmFiROb2inFkSt7floimgZk4xIxe3oA66v7WTyGZS9bPjQjLTadV2+hudXu6e9LNre2pTrcl3dLS09TT2tLW1N3T3NTR3ZpxmzrSqfZMa7LHbctkWpvTXa0tPe3dXS092Gi73el0U3d7Z5fbnGrp6Ey2dac7kj1NrelUsqM73drdnW5raelIp7tb2nra2ttSqY6edFuyubW1PdmSSrenTNXPjV79lHOkOcXQSHOtN9JcZ4sBN8XfWgPG+iZDHddNBkc1WhbrDMjiZkOyuNngqMaUXkyO+KjGlA5MifioZoqhUY1gfbtTBkc1NLhrDY1qbrFxVHOL4VHNLQYMw0474KhmfSKaBmYnQ17zestGNbcKjmqmCI5qTNXPrWhU49cpRHk6yiSfpjqYDTZ2MBsMdzAbDHQwOxvqYBLCfEoasNsEsSSnzSQ7q50NGcPbQnRWpcr09oRcp9Br2ixCnZWp+rn9XTQFt9EzIpu4zR7J0oLrt+lBchdPyd8eEfSETVQ8yDBuiQxLxdoc8frQDWazASdhiyGHaYvB6dpNhmSx1ZAsthqcrjWlF40Rn641pQPTLJiu3Wxgulawvt1pg9O1NGyz31IywY7fHSZH05sNGcQ7DI6mNc93GDAM0y2Zrt0s6BTdmYimgZluaIR1ZxmmayXr5y7B6dppgiNgU/Vz1wCMgE297nC3NwK+xxYDboq/uw0Y63sNdVz3GhzVaFncY0AW9xmSxX0GRzWm9GLXiI9qTOnAbhZsrTcxqhGsb3e3wVENDe7dhkY199s4qrnf8KjmfgOGYfcdcFTzQCKaBmZ3Q17zA5aNah4UHNXsJjiqMVU/Dw7AJpSNCTPt3pYO5iEbO5iHDHcwDxnoYPawZBOKpAF7WBBLctpMsrPaw5AxfLgMm1DeI7gJZdqQaHZWpurnPUz9SO8RENx04k4XPEfqEUG7Xs5zpB4x1Ik+mjDI8KMJedzHBA2zqXI/lsgLWAi3rOdITbfkHCnJnW24UTyeMHiO1GOCQ1ds1YHpd8PWwvd6DeiJhIFzpHQFPG7AMj1ueKFGqtwVBstdKo9PRnyxSyvmkwaGWE8ZGm4+ZXCx6wlDsnjakCyeNrjYZUov9or4YpcpHdjbgi18TxqwpYL17e49uNhFwzb7LSUT7GA9Y3Iu8klDBvEZg3ORmudnDBiGfSxZ7HpS0Cl6XyKaBmYfQ/NT7yvDYpdk/bxfcLFrb8H5Q1P18/4B2MI33dBI81lvpPkBWwy4Kf6eNWCsP2io4/qgwVGNlsUHDMjiQ4Zk8SGDoxpTerFfxEc1pnQgGfFRzXRDoxrB+naTg6MaGtxnDY1qPmzjqObDhkc1HzZgGNwdcFTzkUQ0DYxryGv+iGWjmucERzVJwVGNqfp5bgC28L03Yabd29LBfNTGDuajhjuYjxroYFKWbOGTNGAfE8SSnDaT7KxShozhx8qwhe/jglv49h4Szc7KVP18/F00BfcJz4g8z232SJYWXL9ND5K7eErFEtw4YuTcIpCh9B5RUzIsFeuTEa8P3WA+acBJ+JQhh+lTBqdrnzcki08bksWnDU7XmtKL5ohP15rSgRYLpms/aWC6VrC+3ZbB6VoattlvKZlgx+8zJkfTnzRkED9jcDStef6MAcPQasl07ScFnaLPJqJpYFoNjbA+W4bpWsn6+T/B6doWwRGwqfr5vwEYAZt63eFz3gj487YYcFP8fc6Asf6CoY7rCwZHNVoWnzcgiy8aksUXDY5qTOlFe8RHNaZ0YH8LttabGNUI1re7/+Cohgb3c4ZGNS/YOKp5wfCo5gUDhuGAHXBU86VENA3MAYa85i9ZNqr5suCoZn/BUY2p+vnyAGxC+UTCTLu3pYP5io0dzFcMdzBfMdDBHGjJJhRJA/ZVQSzJaTPJzupAQ8bwq2XYhPI1wU0oLUOi2VmZqp+vGZwBOVVV9BmV8jbo64ZnwSRsz9eZvRbJ0oJkP+R+XdCmfSPi9aHPFPyGgb7wReE9JtL7m/QsjCSPjR6eI6vXRmagpnm8Stf5NwV1vZxnz33TkOP9UsIgwy8l5HG/JWj4TJX7Wzt4I/u2odGstIGV1KXvRLwzGavqWpJHXcffKZOel1r2t+Pb26T0coak/rxsacf087iZjumVhEGGXzHQMX034h2TLvd3LemYdIN92UDH9L2I77/Q9fM9A4bqZUHdfDXio8V3LDD237fU2P/CkLH/QcIgwz8wYOx/GHFjr8v9Q0uMvW6w3zdg7H8UcWOv6+dHBgzV9wV187WIy/A7cXtG2y9bxOsrFvH6XYt4/Z5FvL5qEa/ft4jXH1jE6w8t4vVHFvH6mkW8/tgiXn9iEa+vW8TrTy3i9Q2LeH3TIl5/ZhGvb9k0LlB8vmpg/PvjiI/ddP382EC5vxXxcuvx+WsGyv0TC+r7Jztgff/SkC3SE7/DHH5/uvSc0otxufr6ZemTyLnt00zRxbCxXF/36u+nCU9BYP/l655C43s6UQNhqtgXPAoxaapC+omVgrfbXhecfPxpQlZRTExcv27AoL0R8RW2F71yS++PldRpST18U3DbDLYTbyI7YcJgS8rglx6e9N7/F+OyHa0UlqTsfiaIhfXnZ0h/TGyZet3A4tTbgm38LQt2IpiQ4TuCMnxbWIbCZU2/Q+xYsrSwbWFcl1n6fTWJvivTsy1k3jFkE0vlS9Im/lyuTlMOChXC9SpZ5neEtwiL7xBU/L1jwJ/9hfC7C9D//cLr/7iBsLQd0nrwtmC71H2X3pEpdZ4vtNG3373tHcZyaYcJQti9Bv2/9DqJX9FB/y+ZQf+vApyxZGlh29bdtww0zFnRPoYo/bahAfa3ynTKyo7QmEt+VyjaBxLkJrZ+KVjmXwk6AoJt2BVsF65AveYMfpgOXqJ9SA9OuQ4+WVpICzohacmBlYRDv70qerodJgjpUq8O/teekfgN7eB/zXTwv2Fm9aWNzK8FjcxvEmYcBcnONwqdB1Y68RWCRN5ZFNCTXLl/mzDTaUqPniX1+XcRHz3rOvmdgdm+3wrK8PcRXyrXZf29gfbyh4SYo9BTzvet/iA8cwLhjwmDDP8xIY/7J8FGYKrcf0rkBSyEa2bZ2uNVupH9OerLMV65xZdjBHXzLxFfjnlbeDkGZrZ2lGnQv8rJLs3Vr8TSk/Ry2xsJM9PxUnXyt2i3uW0ja0Hb6mob81cD9v/vgnK0dW/jWxbubfyH57f8k86C/IOZBfmnZXsb3xLc2/gPQaPzz4Ssooi/nKT4+5sBI3FCxL98oZ25vxso94kROdi/QBBte/8S7LQE9cY9MeI6qO3Mvwzo4L8N7cP4t8F9iNp+/8PAXuO34rL1JVXe/xjaK/ofy/rt/+4gtgOC9My7pE7+L+Iz71pX/mfAXupvGkrVNW6LGrfB4fet+elDsrTgvhWxtulNpvcwRTcyyIlVeXKF71RCZegIOsipqDJvLE1VSKmDnFiVHF8VVXKKUkxjicAoHoL7X7mBnssU3UhjiXuNpZI2ljjTWCpDNJaoVkipjSUu2Fgqq2QVRbqX3dbDVsn3sgnBXhbroLRRkKzrKrkyG6lrXSeaxwoDuFIyHCKsNyZkOMRAexkqIMOB2MswVNibhlBdZZDh6ip53BrBRmCq3DVVeQEL4RrhVXdKNQYa2TDDxkViSF5jwED/T3DaYHiZOvZkaUF0JFYr3Laly6qdX0HddnUd1xpofyMi3rnrc4dNTDmdEvGliR/F88vCkuU+1dC0alyYzzrBtiNY166k/MrpFNYZcgrrqwwyXG/AKRwZcadQl3ukAaewnMo2UnDkhPkdVWWQ4VFV4rv8ekYJWrHREVdcLcPRgh4KyHB0lWwj8Jvblu5pRwrOyTPsGpmPHuM1sLF0PnoMMx89lpmPlnYDBCxJbg55jGADGitcuVFvjFDucZbMIUvW9fiIzyHrOhlvoK4nWDKtIOnRTTRc1xLtz0RdTxIst8lDBLBuTqySLf9EOa+77AvJkz3ep9COezLTcU+pMreNECpGGvc0w/M1EoZjkoFynx7tE3RyztVkwcY4RdAYCeqNe/oQWcNgonOYbGCtYpxg3e4U8flmjTHSQDve2ZAzJT3gmlplxmZHzQ6acMInV8k7OpJtr8EyJ0/biqnC5Z8q7+T1OhZVGLuXk9fo8T6NOnmNjJM3zaCTBxUjjXtGxJ08XeYGA+U+0xInr1GwMU4TNEaCeuOeOUTWMJhw8hoj7uRNt8TZ2aXKjO2Kmj0w4ew0RtzZ2TXSs7apLlMzebtFfIClfYedDZR7d+ENDqOcfP+pf2u5/te73h1dvxDPX0+u3H4Nz+2h0s1QtKeivary96Vt98veJikpvNcMbT7a25LVI0k7tI+wHZLWHd1X7yLIo8ba1UD73tfwNgBpO6frfd8qM31vqVjlPv53P2/gmqQD1/2YgWsyYOCaLC3kKkX6kAMBg5EbZO0naHyShpRF2uBKltmN+BIubM2I8jJ4KuJOpK7jlIFOJurl1nZmb/F9it3Nkg5PWkyGqS5tp0928vY67Q0eXoAbjrk+IsoTLE0R11PdjpoMtM9mwXJXeLpFg6RcTci2uSr6PLZI8yjdGPf2OhApxdRYLQaMRosgj632NB53R248rdI87og9ZFukp3+395BtBnrIduFpUBiVt3ujclt7zRfi0edxf0PTo+JKdoBg47JVoQ6woCc5UJJHWyvqixa0/INMtXzpiTpJn/ngiHfRNrg5hxheFTGhP23COnRIVZ7fEmVR9k8CzPR4P5SujMxkVkYOrTK3pc+UP3phxLf0gQJJ415kyZa+mYKN8VBBgy6oN+5FQ2QNg5E3xSO+InRYVbTbse5UdzPQji+2YCveHgbK3SFcbhOORFrQ3mg8Pf5OCNeP4HY8Ny3Yng8X5EuwjbgdEW9vfrZapA8QwjpCeGAFQfpk9t0Ey3zkDqLPEKS3ws8SrIsLBbfCXyR83prpAa72k2YJt+VZ8gPcsh1McJTH+9F0gHsUM8A92uAAFypGGrcn4gPcIwyV+xJLBrhHCTbGowU7GUG9cS+J+MEE2rk5KuID3GMsGODubqAdX2rBAHeGgXLPjvgAd2eyQylZWtg2wD3QwABX8GALd3fB9nysIF+CbcSdbcEA96iID3CPs2SAK6nPx+8g+gxBeoB7gmBd9AgOcC+xbICr/aQThNvyCfID3LIdynKix/tJdIB7IjPAPQkNcG2pGCE+cwOyEwV5PKlKVmFMDHxOjPjA52ThgY+J7TJ7CjvCBxkYUJxieACZLC24froYJcfu1IhvCQNdFD/dNOJtUE+eSq4Y6knJIw3I8fSIy1H30ZIDU91HH29AjmdEXI66zxK0t662O6cZkOOZEe8TtD3bq+Q+oS1Dyi26xfWs/sswTW9wB/tomwEH+JyBrs9E12dV9T7Y52z1+xxF5yo6r2r7fU1DnfzAlQszZeotFXP6fsPExEm4QljG9s2bOlBIms+zq8zJ0swWFyFmdaOodvKzzo4j3xnok6p+LPjdcn2S1iuoFUvJwmFCqditzU09na0trY5lymuCzy/E7eAzLofVaybqfG8m6oIqS4wDnhk7P2DrR7K0sI3n8yM+C3OhIbleGDDjmCwtuK8IHzv4Y0PHDl5kwczMBXJT4L14dXzqPkqzPhcbWs6TXkLqEOQzqt+kDZJfsrQg2XekLhbUv04BLO9rlZlyfma1U7jPgNBVZZDhrip53G5BZTBV7m4DBj7oc6ZRNPjwSVcBg1/2N3UzXv310HXeDLPO24O8LghCG1uNV0ip67sZyY0Wwooi3bAv9hq2+ObqKju8QMm6vjTia3+6Ti41sRG1atB7K0V+lxke3Um0ZRN6c7lgeynHxjGt55dVyZb/MvmNY2V7M2qOx/sV1KGYwzgUV1SZezMKKkYa99qIvxmly3y5gXIvteTNqDmCjfEKQWMkqDfu0oi/GaU7hzkGpqYvEazbKyM+faqdiQ4D7XhumRyzUvm8qsqMzY6aHTTh0M8xsCFSsu1dbZmTp23FVcLlv0reySvb2wHzPN7nUydvHuPkzTfo5EHFSOMui7iTp8t8tYFyL7fEyZsn2BjnCxojQb1xlw+RNQwmnLx5EXfyFlji7CysMmO7omYPTDg78yLu7FwT6RngVJepmbxFER9gad9hroFyLxZev6Y7uxehHdyLq8J9snWJSnetoqWKllXl70OIcvtZLtx+pPsr3ccsFORRY11jQC9XCG+ANv2pUV3vK6rM9BmlYpX7U6MrvQFXlg64VjIDrqzBTadQKdLLcAIGIzc4WClofLKGlEXa4EqWeZVhh0ViY2W3gYGH5PLtdRF3fnQdX2egk4l6ufWrVZcIDhjgU6OSDs/1YjLc/qnR05y8vb7ec3pNfmoU+ogoTwysjrie6na02kD7XCNY7gpPt2iQlKsJ2a6pij6PN0jzKN0Y9/Y6ECnF1Fg3GDAaNwjyeKM9jcfYp0ZtaDw3SvO4I/aQayM9bbm9h1xroIdcJzx9B6Pydd6o3NZe04ZPjd4k2fBtrSgbPuF582BF2fEJz1sMLaCKT4BJ+qLrI9712eA+3Gp4tcGE/qwV1qFbq/L8liiLsr8YuMHj/Ta64rCBWXG4rcrcFi9Tft71Ed/iBQokjbvaki1eGwQb422CBl1Qb9zVQ2QNg4mVlg0RX2m5vSra7Vh3qotMzORasDVriYFy3xDxL5zo/up6QXuj8fS4VvoLJ4skbaJge94oyJdgG3FviHh787PVEn2AFNYm4YEVBOkvnCwSLPPmHUSfIUhvjd4iubIuuDV6tWVfONF+0hbhtrxFfoBbthfVt3q830EHuFuZAe4dBge4UDHSuDdHfIC7yVC5b7FkgLtVsDHeIdjJCOqNe0vEX1TXzs3WiA9w77RggLvYQDteb8EA91oD5b414gPcuWTnT7K0sG2Ae7OBAa7gQQfuYsH2fJcgX4JtxL3VggHu1ogPcO+2ZIArqc/37CD6DEF6gHuvYF3cLDjAvcWyAa72k+4Vbsv3yg9wy3ZIx30e7/fTAe59zAD3/ir/A/WjWjFCfOYGZPcJ8nh/lazCmBj43Bfxgc8DwgMfE9tllgo7wrcYGFA8aHgAmSwtuH66GCXH7qGIbwkDXZTWnYcj3gb15KnkiqGelNxsQI7vibgcdR8tOTDVffQ9BuT4SMTlqPssQXvrarvzsAE5PhrxPkHbs2Ul9wl9P+EpucX1sf7LMNQnPLXNgANdHkHXj6Lrx6p6H/TyuPr9XkVPKHqy6t35Cc8OYd01waMtn/B83KAsjTiKUsxyn/A0xfdFhpTBEeKzHJ/bfNySBrGjf27zKW/W6OkqSxoynsV6KmCbRrK0sI3npyI+Y/KMIbk+Y3B2UDc4wY+w5D6LKn1ClaBhEP3E6vssmN15Wm4avRevjiGdlCz/sZaUOSZY5uMsKXOFYJmPt6TMgo6De0KZypwsLbgnCspvjiUO4kmOHXyebAmfp1jC56mCuq4xpO2P/hT6vxJyePpT7SOq5OV4miX1fbolfJ5hCZ9nWsLnWZbwebYlfJ5jCZ/nWsLneZbweb4lfF5gCZ8XWsLnRZbwebElfHZYwmenJXx2WcJntyV8Zizhs8cSPi+xhM9LLeFztiV8XmYJn5dbwuccS/i8whI+r7SEz7mW8HmVJXxebQmf8yzhc74hPqO8brmgTGVOlhbchYLyu8qS9axrHDv4XGQJn4st4XOJJXxeawmfSy3hc5klfC63hM8VlvC50hI+s5bwucoSPq+zhM/rLeFztSV8rrGEzxss4fNGS/hcawmf6yzh8yZL+LzZEj5vsYTP9ZbweaslfG6whM/bLOHzdkv43GgJn5ss4XOzJXxusYTPrZbweYclfN5pCZ93WcLn3ZbweY8lfN5rCZ/3WcLn/Zbw+YAlfD5oCZ8PWcLnw5bw+R5L+HzEEj4ftYTPxyzh83FL+HyvJXw+YQmfT1rC51OW8Pm0JXw+Ywmf77OEz/dbwuezlvD5AUv4/KAlfH7IEj4/bAmfH7GEz+cs4fOjlvD5MUv4/LglfH7CEj6ft4TPT1rC56cs4fPTlvD5GUv4/KwlfP6fJXx+zhI+P28Jn1+whM8vWsLnC5bw+SVL+PyyJXx+xRI+v2oJn1+zhM+vW8LnNyzh80VL+PymJXy+ZAmf37KEz29bwud3LOHzZUv4fMUSPr9rCZ/fs4TPVy3h8/uW8PkDS/j8oSV8/sgSPl+zhM8fW8LnTyzh83VL+PypJXy+YQmfb1rC588s4fMtS/h82xI+f24Jn+9YwucvLOHzl5bw+StL+Py1JXz+xhI+f2sJn7+zhM/fW8LnHyzh84+W8PknS/j8syV8/sUSPv9qCZ9/s4TPv1vC5z8s4fOflvD5L0v4/LclfP7HEj7/awmf/7OETw1oA58xS/issITPuCV8VlrCZ8ISPqss4XOIJXwOtYTPakv4rLGEz2GW8DncEj5rLeFzhCV81lnCZ70lfI60hM9RlvA52hI+x1jC51hL+BxnCZ/jLeFzgiV8TrSEz0mW8DnZEj6nWMLnTpbwubMlfE61hM8GS/hstITPaZbwOd0SPnexhM9dLeFzN0v43N0SPvewhM8ZlvC5pyV87mUJn3tbwuc+lvC5ryV87mcJn0lL+HQt4TNlCZ9pYT4rCH8S36MfWSWLd3GVvBybIi5HLcOLBOWosUzIsdlQu4kL89kSK12WrR2dyaa29g4J/Qasi6uirYdx4fYcN9SeWy1oz2cLylHL8HEDcmyzQI4XCMvxaQNybDdkFyuE+dw/JifLL8RlyxwT1h1d109VyeM+NSTa5dZt5vwqed05QE7HXWkZQpBu1wdaMk44yBI+D7aEz0Ms4XOmJXweagmfh1nC5+GW8HmEJXweaQmfsyzh8yhL+DzaEj6PsYTPYy3h8zhL+DzeEj5PsITPEy3h8yRL+DzZEj5PsYTPUy3h8zRL+DzdEj7PsITPMy3h8yxL+DzbEj7PsYTPcy3h87wyrRdIrMdLlfn8HbDMF1hS5rhgmS+0ZC3sIsG1sM/G7SjzxYJlvjpuh63tsKRP6LSEzy5L+Oy2hM+MJXz2WMLnJZbweaklfM62hM/LLOHzckv4nGMJn1dYwueVlvA51xI+r7KEz6st4XOeJXzOt4TPBZbwudASPq+xhM9FlvC52BI+l1jC57WW8LnUEj6XWcLnckv4XGEJnyst4TNrCZ+rLOHzOkv4vN4SPldbwucaS/i8wRI+b7SEz7WW8LnOEj5vsoTPmy3h8xZL+FxvCZ+3WsLnBkv4vM0SPm+3hM+NlvC5yRI+N1vC5xZL+NxqCZ93WMLnnZbweZclfN5tCZ/3WMLnvZbweZ8lfN5vCZ8PWMLng5bw+ZAlfD5sCZ/vsYTPRyzh81FL+HzMEj4ft4TP91rC5xOW8PmkJXw+ZQmfT1vC5zOW8Pk+S/h8vyV8PmsJnx+whM8PWsLnhyzh88OW8PkRS/h8zhI+P2oJnx+zhM+PW8LnJyzh83lL+PykJXx+yhI+P20Jn5+xhM/PWsLn/1nC5+cs4fPzlvD5BUv4/KIlfL5gCZ9fsoTPL1vC51cs4fOrlvD5NUv4/LolfH7DEj5ftITPb1rC50uW8PktS/j8tiV8fscSPl+2hM9XLOHzu5bw+T1L+HzVEj6/bwmfP7CEzx9awuePLOHzNUv4/LElfP7EEj5ft4TPn1rC5xuW8PmmJXz+zBI+37KEz7ct4fPnlvD5jiV8/sISPn9pCZ+/soTPX1vC528s4fO3lvD5O0v4/L0lfP7BEj7/aAmff7KEzz9bwudfLOHzr5bw+TdL+Py7JXz+wxI+/2kJn/+yhM9/W8Lnfyzh87+W8Pk/S/h0KuzgM2YJnxWW8Bm3hM9KS/hMWMJnlSV8DrGEz6GW8FltCZ81lvA5zBI+h1vCZ60lfI6whM86S/ist4TPkZbwOcoSPkdbwucYS/gcawmf4yzhc7wlfE6whM+JlvA5yRI+J1vC5xRL+NzJEj53toTPqZbw2WAJn42W8DnNEj6nW8LnLpbwuaslfO5mCZ+7W8LnHpbwOcMSPve0hM+9LOFzb0v43McSPve1hM/9LOEzaQmfriV8pizhM20Jn02W8NlsCZ8tlvDZagmfbZbw2W4Jn/tbwucBlvB5oCV8HmQJnwdbwuchlvA50xI+D7WEz8Ms4fNwS/g8whI+j7SEz1mW8HmUJXwebQmfx1jC57GW8HmcJXwebwmfJ1jC54mW8HmSJXyebAmfp1jC56mW8HmaJXyebgmfZ1jC55mW8HmWJXyebQmf51jC57mW8HmeJXyebwmfF1jC54WW8HmRJXxebAmfHZbw2WkJn12W8NltCZ8ZS/jssYTPSyzh81JL+JxtCZ+XWcLn5ZbwOccSPq+whM8rLeFzriV8XmUJn1dbwuc8S/icbwmfCyzhc6ElfF5jCZ+LLOFzsSV8LrGEz2st4XOpJXwus4TP5ZbwucISPldawmfWEj5XWcLndZbweb0lfK62hM81lvB5gyV83mgJn2st4XOdJXzeZAmfN1vC5y2W8LneEj5vtYTPDZbweZslfN5uCZ8bLeFzkyV8braEzy2W8LnVEj7vsITPOy3h8y5L+LzbEj7vsYTPey3h8z5L+LzfEj4fsITPBy3h8yFL+HzYEj7fYwmfj1jC56OW8PmYJXw+bgmf77WEzycs4fNJS/h8yhI+n7aEz2cs4fN9lvD5fkv4fNYSPj9gCZ8ftITPD1nC54ct4fMjlvD5nCV8ftQSPj9mCZ8ft4TPT1jC5/OW8PlJS/j8lCV8ftoSPj9jCZ+ftYTP/7OEz89ZwufnLeHzC5bw+UVL+HzBEj6/ZAmfX7aEz69YwudXLeHza5bw+XVL+PyGJXy+aAmf37SEz5cs4fNblvD5bUv4/I4lfL5sCZ+vWMLndy3h83uW8PmqJXx+3xI+f2AJnz+0hM8fWcLna5bw+WNL+PyJJXy+bgmfP7WEzzcs4fNNS/j8mSV8vmUJn29bwufPLeHzHUv4/IUlfP7SEj5/ZQmfv7aEz99YwudvLeHzd5bw+XtL+PyDJXz+0RI+/2QJn3+2hM+/WMLnXy3h82+W8Pl3Q3xWED7TyZampkxrKuOm3Y5kqr2zrTnZ1NzZ0ua2uc1tzd2ptnQ609bU1tre2d6abHeb0hm3p7k93eNh7y5Y5n8IlzkmXNaRVY7zPkVx4br+Z4UcjxdXyfH11BA7dLBSsC7+ZUm7SwiW+d+WlLlKsMz/saTMQwTL/F9LyjxUsMz/s6TM1YJl1h2UDWWuESxzzJIyDxMsc4UlZR4uWOa4JWWuFSxzpSVlHiFY5oQlZa4TLHOVJWWuFyzzEEvKPFKwzEMtKfMowTJXW1Lm0YJlrrGkzGMEyzzMkjKPFSzzcEvKPE6wzLWWlHm8YJlHWFLmCYJlrrOkzBMFy1xvSZknCZZ5pCVlnixY5lGWlHmKYJlHW1LmnQTLPMaSMu8sWOaxlpR5qmCZx1lS5gbBMo+3pMyNgmWeYEmZpwmWeaIlZZ4uWOZJlpR5F8EyT7akzLsKlnmKJWXeTbDMOwmWOe6V9WWvwMcqOk7R8YpOUHSiopMUnazoFEWnKjpN0emKzlB0pqKzFJ2t6BxF5yo6T9H5ii5QdKGiixRdrKhDUaeiLkXdijKKehRdouhSRbMVXabockVzFF2h6EpFcxVdpehqRfMUzVe0QNFCRdcoWqRosaIliq5VtFTRMkXLFa1QtFJRVtEqRdcpul7RakVrFN2g6EZFaxWtU3STopsV3aJovaJbFW1QdJui2xVtVLRJ0WZFWxRtVXSHojsV3aXobkX3KLpX0X2K7lf0gKIHFT2k6GFF71H0iKJHFT2m6HFF71X0hKInFT2l6GlFzyh6n6L3K3pW0QcUfVDRhxR9WNFHFD2n6KOKPqbo44o+oeh5RZ9U9ClFn1b0GUWfVfR/ij6n6POKvqDoi4peUPQlRV9W9BVFX1X0NUVfV/QNRS8q+qailxR9S9G3FX1H0cuKXlH0XUXfU/Sqou8r+oGiHyr6kaLXFP1Y0U8Uva7op4reUPSmop8pekvR24p+rugdRb9Q9EtFv1L0a0W/UfRbRb9T9HtFf1D0R0V/UvRnRX9R9FdFf1P0d0X/UPRPRf9S9G9F/1H0X0X/U6Q3dMUUVSiKK6pUlFBUpWiIoqGKqhXVKBqmaLiiWkUjFNUpqlc0UtEoRaMVjVE0VtE4ReMVTVA0UdEkRZMVTVG0k6KdFU1V1KCoUdE0RdMV7aJoV0W7Kdpd0R6KZijaU9FeivZWtI+ifRXtpyipyFWUUpRW1KSoWVGLolZFbYraFe2v6ABFByo6SNHBig5RNFPRoYoOU3S4oiMUHalolqKjFB2t6BhFxyo6TtHxik5QdKKikxSdrOgURacqOk3R6YrOUHSmorMUna3oHEXnKjpP0fmKLlB0oaKLFF2sqENRp6IuRd2KMop6FF2i6FJFsxVdpuhyRXMUXaHoSkVzFV2l6GpF8xTNV7RA0UJF1yhapGixoiWKrlW0VNEyRcsVrVC0UlFW0SpF1ym6XtFqRWsU3aDoRkVrFa1TdJOimxXdomi9olsVbVB0m6LbFW1UtEnRZkVbFG1VdIeiOxXdpehuRfcoulfRfYruV/SAogcVPaToYUXvUfSIokcVPabocUXvVfSEoicVPaXoaUXPKHqfovcrelbRBxR9UNGHFH1Y0UcUPafoo4o+pujjij6h6HlFn1T0KUWfVvQZRZ9V9H+KPqfo84q+oOiLil5Q9CVFX1b0FUVfVfQ1RV9X9A1FLyr6pqKXFH1L0bcVfUfRy4peUfRdRd9T9Kqi7yv6gaIfKvqRotcU/VjRTxS9ruinit5Q9Kainyl6S9Hbin6u6B1Fv1D0S0W/UvRrRb9R9FtFv1P0e0V/UPRHRX9S9GdFf1H0V0V/U/R3Rf9Q9E9F/1L0b0X/UfRfRf9TpDu5mKIKRXFFlYoSiqoUDVE0VFG1ohpFwxQNV1SraISiOkX1ikYqGqVotKIxisYqGqdovKIJiiYqmqRosqIpinZStLOiqYoaFDUqmqZouqJdFO2qaDdFuyvaQ9EMRXsq2kvR3or2UbSvov0UJRW5ilKK0oqaFDUralHUqqhNUbui/RUdoOhARQcpOljRIYpmKjpU0WGKDld0hKIjFc1SdJSioxUdo+hYRccpOl7RCYpOVHSSopMVnaLoVEWnKTpd0RmKzlR0lqKzFZ2j6FxF5yk6X9EFii5UdJGiixV1KOpU1KWoW1FGUY+iSxRdqmi2ossUXa5ojqIrFF2paK6iqxRdrWieovmKFihaqOgaRYsULVa0RNG1ipYq0t+Y199v199G198dzyrS38vW36LW33nW31DW3yfW3/7V39XV36zV34PV31rV3zHV3wjV39/U37bU343U32TU3zvU3xLU3+nT38DT35fT327T30XT3xzT3/PS38rS36HS33jS30/S3ybS3/15UJH+Xo3+Foz+zor+hon+Poj+9ob+roX+ZoT+HoP+1oH+joA+o1+ff6/Pltfntusz0fV54/osb31Otj6DWp/vrM9O1ucS6zN/9Xm6+qxafQ6sPmNVn1+qzwbV525+VpE+L1KfxajPOdRnCOrz+fTZd/pcOX1mmz4PTZ81ps/x0mdk6fOn9NlO+twkfSaRPu9Hn6Wjz6nR/qI+X0WfXaLPBdFnbujzLPRZEfocBn3GgT4/QL+br997f12Rfl9bvwut3zPW7/Dq92P1u6f6vU79zqR+H1G/66ffo9PvqOn3v/S7Vfq9Jf1OkH7fRr/Lot8T0e9g6Pcb9LsDel++3vOu94Dr/dB6H67el6r3aep9i3ofn97Xpvd56X1Peh+Q3hej94nofRN6H4FeV9frzHrdVa9D6nU5vU6l1230Ooae19fz3HreV8+D6nlBPU+m5430PIqeV9DjbD3u1OMwPS7RfnrFdtfD0fuMdTjWyQfPLG3bE67j9b5cvU9V79vU+xj1vj69z03v+9L7oPS+IL1PRu8b0fso9L4Cvc6u1531Oqxel9TrdHrdSq/j6HUNPc+v5731PLCeF9XzhHrerEFRo6JpivS4W49D9bhMj1P0vvw9FM1QtKeivRTtrWgfRfsq2k+RHiy5ilKK0oqaFDUralHUqqhNUbui/RUdoOhARQcpOljRIc728cuhig5TdLiiIxQdqWiWoqMUHa3oGKdvOAVdn+/9H/uzQyde/dXHj8TpLgyIuy0g7g7v/32jrsnufqXW4nzQfZoOS484KL3p1SdX4ri3vbgHntj5I5N/VnEujnsnIO73AXF/DIj7S0Dc3wLi/hcQF6vwj6sKiBsaEDc8IG5EQNy4gLgJAXGTA+J2CojbNSBu94C4vQPi9g2IawuI2z8g7rCAuCMC4o4KiDsmIO6UgLjTAuLODog7NyDuwoC4iwPiLg2Iuywg7oqAuLkBcYsC4pYExK0IiMsGxK324j7xxaX/euj7n70cx93sxT3f9sVjX328bhyOu9OL+8ap97x85qhF9TjuroC4uwPi7gmIuzcg7r6AuPsD4h4IiHswIO6hgLiHA+LeExD3SEDcowFxjwXEPR4Q996AuCcC4p4MiHs6IO59AXHvD4h7zovj+tSPeXGH/+dHRz278YY9cNynA577cUDc6wGYPwt4bob3Al6FUz/i3C9c/kUcl477P5cJiNsSgPlAwHMv+cTVev8fadz+v9oB/O1Bd+H60Zne72Rpwa1GuNL4bcmOHL5jhv90NcI0gJ8C/Eoz+Nve09qmK9ne+A7Jt9b7HUOyhGcgDjusD3pxQ528TunrFd51NcEzUe+YJ2m5jWb4r0Bl0+HwrIm8U12Af4SH7/TCdtNtLelUW0sq1Z1JdnS3tPa0p1uT6c7mdHtXp5tMN6fauls70slkJp3pakp2t7Q3d2c62pvTPZ0d7S2AfSSLnc50Kqjmjpa2Treno6Un2dnU2pbu6Glt7e7obldrVM3Jbrerxe1KuT1tbR3NzR1dze2u25Npb+5py2HPMiKX7W1Fh6OM4KebAf9oM/znbNUxRvBTnYB/bNZh6rY4XukNwD4O8S74fnMO/3gz+DnZn2AGP6ebJ2ZLln2fANgnZU3ozfY+ToeTjeC7Of5PMcN/E+CfivBjBuRzmhn8nG6ebgY/p5tnmJF/D+CfaQTfbQX8szx8B2G7belUqjWt90W0dSfdpu6uVJvqGTubkl3Jjq5Upr3Jbe9pSjWlu7q7Otua2jrcnmRPR1d7T9t2dMA+2wjv6ZxunsPwniwluHnez82a0Jt0rj8/r3je3ULogH1+8diFQq4fv8Afu99qA9gXMtipjnRXsr0n2dHc1tGaaWtWLlhSXXS2ZXpaUh2dyhlLdbuum2lSf1KZ7qb2zu4Wt7Ml05pq7lTZ5WRyUTZfn4LtKOdXXiyM39KRbM+0tOTaaYcwfmdnS2uHkifgdwrjp7taMj3p1pyd7BLG72hu6ulpTncAfrcwfrObzDSnWnO6mRHGb+9MNre0teX0p0cYX40l0t3tHTn/9RJp+XRmkl3dbjuMUy/18CEPHSDv2cJ5e6E9RvJznN7jcIfkX0N4lR6LxEh+mB8sHxjzguwuy/bltZ6JwzaGxsWZe5APh9UhiNUpiNUliNUtiJURxOoRxIJ2bbatNeX60cuM4KfbAP9yI/jJDODPMYGP/MYrEL4jx38O/0qEHzOAP9eM/HP4V5mRT268d7WHbwJ7nhnZ5Hyw+Wbwc2OOBWbwcz7qQjP4OdtwjRn8dsBfZAY/56MuNoOf8/GWmMHP+ajXmsHvBvylRvDdnHyWIXw525nK2bblRvDTOfwVZvBz9m2lEfymHH7WDH5uPmiVGfycfb7ODH7OPl9vBj/n+6w2gt+cGyOvMYLfktOfG8zg5+YobjSDn5vrXmsGP6f/68zg5/T/JjP4Of2/2Qx+zj+5xQx+zj9ZbwY/55/cagY/1z9uMIOf8x9uM4Of8x9uN4Ofs58bzeDn7OcmI/itOf9hsxn8nP3cYgY/Zz+3msHP2c87zODn7OedZvBz9vMuM/g5+3a3GfycfbvHDH7Ovt1rBj9nf+7z8J3+Y6fpDcC+v3TsJnpDv6ei95eNH70dj9uXJ+gnJmHPW2W+KL3WCvR1At0XHAN2h1krwPnXEF5NrBXg/IAfKh+8VqDjqhhe65k4WodVTD5VTD71TBz1K0vB2iyIdZMg1kZBLMky3iaItV4Q63ZBrJsFsZYJYknKXrINbYko1hpBLEmdkJS9pH6tFcSSbNuSOnGjIJakjb5TECuq/SP462Z9q2RLLZM3BIgbgvLGPhUNcfIb86191Z1G53FpOgjDnfx6+PwlV3adOHdBZr4T8IAOR2T5+1ETXozEDQ1RBscpLFg3hGCpA495qyWY+NkYg8Vt1KHKjGVe6cMDxoC6oo7wTO93sqTgpsOUA+dfrkEEZyS4QQTIZ4gZ+aRiBB/zM4SRD9VhWncxJ9+QEwgLpx+CyojT42t4Ht97zftf7/RtR/DCQYyJizP3QL6a9++RsuG6oXpqph6a3LB6CvnXOCbbTV5POb3gOrNqp289S25mClOvnG2rZuIACzYXYj3F6YeiMuL0+Bqex/d+5f2vd/rqNNXTaqY8+B7W07e862qf8sz0fidLCq2tXD9F2wGWk+Tm7LDtAPKvcUzqXb4dcPXE2ROQXQ3Daz0TRyd9aph8aph86pk46oiWgrVREOtGQax1glhbIoq1XhDrdkGsmwWxlglibRDEktT7KMorqB8sFksHSV3dKoh1iyCWpK5KlnGNIFZU2/Y9gljLBbFgYZL6mYDvOHlfifb3M73fyZLC9rEbzg/Kge/h/GsIr7L85H0lTq6cTwvyGWZGPjl+hjH8DGPkA3U5nIkDLJhrwWMGnH4YKiNOj6/heXyv2auweoKpAx0zDGfKg+/hMcN+sd5lw3VD9dRkPeD8gG98D+df45hsN8lAveDaf7XTt54F5ZMMU6+YX6jLWiYOsEZ4v7Ge4vTDURlxenwNz+N7hxM9xTpN9bSWKQ++h/X0IKKnuG6onhqpB7cntJ5C/jWOyXaT11NOL4Yxcqx2+tazoHySYeoV8wt1OYKJA6w67zfWU5y+FpURp8fX8Dy+dwrRU6zT9IWsEUx58D2sp8d5uNU+5Znp/U6WFJqbuLqUw291a5ly0naGZS2n1+nQ7Qzyr3H66oWJdlZH+PHTA5BdPcNrPRNHdaSeyaeeyaeeiaPjmlKw1gliLRPEulEQa4Mg1hpBrPWCWLcJYknqxFpBrNWCWFuEsDj7XApfm4X40mGrIJZk275HEEvSFkq2x9sFsSTr8V5BLEmdkJS9VNt2hMsoqRMbBbGiaick+doRfKbBPm3gZC/ZHm8SxJIs410R5UvSn5AsI10fwGPLmPe/2unb9gTH2ZkYyQ/Kge/h/GsIr7L85MfZnFzrGLmC7EYyvNYzcXScPZLJZySTTz0TR/uMUrDWCWItE8SSLON6QazbBbG2CmJJyv4eQazBeiwO615BLEmdWCuItVEQS9J+bRHEkpS9pK5Kyj6q9ktSVyX16zZBLMl6lNQvyTYkqV+bBbHWCGJJljGqvpxkGSX9iajWY1R9ubsEsaLq50j6mIP+xLujDUnaCUm+pPRLX9N51VL4ukOILx0kZS/pA0BfS/e7Ab4OZufQUqH32NI5NCN7sArMoXF766qdvnooKB83TD1jfqEuRzFxgOW91txrTxhOPxKVEafH1/A8vnekJ5R6gqkD3RM2iikPvgfy1XvCDvF+VPuUZ6b3O1laaKPzoZAHzhvLSVDvQn24Aedf45jUu3w74OqJsy8gu9EMr/VOX92h+jCayWc0k88gVrSwThPCCrJhEK9DNfOctL3F+UE58D2cf41j1C64QXLl7CXIZ4wZ+eT2KI9h+BnDyAfqciwTB1jwtW/cH+H0Y1AZcXp8Dc/je7NJfzQWpaVtYCxTHnwP90ddFb3LhuuG6qmZegj/zgfkX+OYbDd5PeX0gmv/1U7fehaUTzJMvWJ+oS7HMXGANd77jfUUpx+LyojT42t4Ht9bRPQU6zTV03FMefA9rKdXez/qHP/2GaY9Y1zOblMZ4udoezBS324mGbY9QP41jsn2mW8PY0PKFeQzzoh8unvC6A/mF+pyPBMHWBO837g94PTjUBlxenwNz+N7a0l7wG2HtofxTHnwPdweriN2G9cN1VMj9ZBM9oTVU8i/xjFpJ/N6yukF1/9VO33rWZCfTJh6xfxCXU5g4gBrovcb6ylOPx6VEafH1/A8vreV6CnWafqu3gSmPPge1tPbyHiXlmem9ztZUsi4XF3K4XckqxlZy+Gn2quZ+pLD72wD/Elm8FsAf7IR/LZc/U4xgt+ck89OZvC7AX9nM/qT43+qEfx0GvAbjOBncvw3GsFvyuFPM4LfmWu/043gt+f0fxcz8snV765G8HuaAX83M/LJ8b+7Gf5z9n8GwpeciwD8vYzgJ9Mgjz2dfIgzZYL8wRfZA6WP+fwHLBoHedUQLFN+H1c2zD8d9+2J+MEy8MPas0isaibORJ3OCCg3zr82gFdaDh3oGTj9lYkOawWxrhfE2iyExfm2pfC1QpCv8UJ8cf5vKVgTBbHiQlg60A8NlsLXJCG+9PXkiGJNEcTaSRBrZ0GsqYJYDYJYjUJYOtAPQJXC1zRBvjYJ8jVdiC99vYsgllTfoa93FcTaTRBrdyEsHejcaVSwYA3Z7HxXU7vZ+a50h9n5rqZus/NdzWmz811NrWbnu5q6wFeH/hDywLqF+ze5cUVT6HdBIf8awqssP/nx3c6EHyofun9nKsNrPRNH2+hUJp+pTD71TBzdy1sK1p2CWGsEsTYIYq0XxForiLVMEOs2Qax1glhbIoolqas3C2JJyZ7rt6Oiq5LtcasgVlTb4x2CWJJtKKqyv0UQS9JOSPa1kjZaUvaS8oqqfkn6JpL1KCn7HcFO3COEpa/pGLYUvlYJ8jVRiC9JLB1WZuX4miTIl5TsdVgtiCWpE3QuvRSsuBCWDlI6ocP1glhZQSxJ/ZLka7UQVpRt4XBBviR1VbIeJe1qVOW1WghLX9O51ai0bUn7da8glqT/dZMgluScgqRPLjlWkJx7BP8e5rGnoLiY99/sGkCy32sAU8zwE7gGMIWRK7cfVpCf7jD1jPmFumxg4gCr0fuN9/bj9FNRGXF6fA3P43uPexVXTzB1oHv7G5jy4HsgX723/6F477LhuqF6aqYewn8DFvKvcYy2GzdIL3Zm5MjpBTxbz8RRn76ByaeByYere7r3rRSsjYJYN2blsNYJYm2JKNZ6QazbBbFuFsRaJoi1SRBLsg1J1uOdglhrsnJYWwWxJNu2pH5JtiFJu7ojyP42QSxJGw22kHuPStD/SHLvOQni5945aAyQBc6f7sWBeO4/YNE4yKuGYAmXzQ0qW9DYrRHx04Cu/bAai8Ti3o0zUacNjn+5cf5m3wVsTpl9F7C5xey7gE09oPPTkTxjRHa7GqnLttBnqUD+NYRXU21qV8IPlQ8dD+3G8FrPxNG9e7sx+ezG5FPPxNF+uxSsOwWx1ghibRDEWi+ItVYQa5kg1iZBrM2CWJKyj6qubhXEWieIJalfkjZnoyDWjiD72wSxJMu4JaJYkm37ZkEsKdnra7ovNyq6GlUfQBJrsN8e7Ldt6TsG++3Bfnuw3353yj6qunqHIJakvCRtjqTsbxHEkmxDkv12VG10VP0JyTJK+r6S9Sgp+x3BTtwjhBVz+u7PKQWrQRBLap5cXzcKYelA9x6XwtdwQb5WCfGlw2pBrOuFsPT1NEcO690ue31N350oBWuiINYkISwdVmfl+NpFiC9JXdVBsg1FVe+jWsbVWTmsKNpCSb50WC2INdh3DJzsrxPC0teSex6k5KWvJwvylRXkS6qv1WF1Vo4vSXlFse/Q4V5BLMkx302CWJJrOpLzAJLzE5L7c+j7bXhvWMz7z50Xr/OZ6f1Olha6YyQ/KAe+h/OvIbwK8+MGyXVXRq7cefeC/HTFCD7mZ3dGPlCXM5g4wIJzMvH7bTj97qiMOD2+hufxvcrE9v/1BFMH+n4bd1Y6vgfyrVL038reZcN1Q/XUTD2kQr/fBvnXOEbbjRukF1z75/QCnuXqi/b7YeuLw1oviLVFEOtGQayNglh3CmKtE8TaHFG+1gpiLRPEukcQa7kg1r2CWJLyul0QS7I9bhXEktR7SVsoWY83CWJJ2hxJnbhNEEtS9msEsST52iSIJakTkr6JZL8tWY9RtV+S+iXZHqNqoyWxJPXrZkEskD2MV/D4Jub9rybPxRzRsV5TjOQH5cD3cP41hFdZfvJjPU6uuzNyLeb7YsArXOM4nE+5v+Olw0ZBrBsFsdYJYm2JKNZ6QazbBbFuFsRaJogl9W0kHdYIYkm2x62CWJL6JSmvDYJYkvol2YYk7aqkTkja1ai2bcn2KNmG7hTEkmyPO4J+3SaIJekDQF9b58VhfxufR4LjcD5BPj9+HtLVMs/FvP/VhL+YI+ljt4c+rwPyr2FkYsLn3zOkXEF2ezG81jNxdO/KXkw+ezH51DNxtG8qBetOQaw1glgbBLHWC2KtFcRaJoi1SRBrsyCWpOyjqqtbBbHWCWJJ6pekzdkoiLUjyP42QSzJMm6JKJZk275ZEEtK9vqantcRFV2Nqg8giRXVfltS9pI+gKSNlvQnoqqrg/32wPVpgz55cViDPvnA6degXzhw+hVFv1AHSXlFVVfvEMSSlJekzZGU/S2CWJJtSLLviKqNjmqfJllGSd9Xsh4lZb8j2Il7hLBiTt89TqXwtVKQrwYhvvT1cEEsyfUhSXlNFuRrdVYO63ohLH09zZHDktIJHei7zVGQvWTblm6PUm1IXzcKYekg2R53BP2i5w2VgjVREGuSEJYOq7NyfO0ixJekLdRB0kZHVe+jWsbVWTmsKPa1knzpsFoQa9A3GTjZXyeEJelP6CAlL30t6ZNnBfmS6mt1WJ2V40tSXlHsO3S4VxBLck7hJkEsyXUryXmmDYJYkvsL6XlDw1FczPsP+3yxrdP5zPR+J0sKbujzhiD/GqdvXyXHT36f7zinr1yHM3IF2Y1neK1n4ujYeDyTz3gmn3omjq75loK1URDrRkGsdYJYWyKKtV4Q63ZBrJsFsZYJYm0SxJJsQ5L1eKcg1hpBrK2CWJJtW1K/JPmSrEdJviTthKROSNbjbYJYkvaefvOc+gQzvd/JkkJzM/gm2JcBn6ra4X0TmbzdthjJz3F4vw7yryG8yvKT9+u4esPyoX7dBIbXeiaO1uEEJp8JTD71TBxtm6Vg3SqIJcnXRiEsfT3EkcGSLuMyQazbBLG2CGLdLIglKa+tglh3C2JtEsRaJ4glKfv1glhrBbEky3iPINZyQSyY56O+hQ4zvf+qO0y3taRTbS2pVHcm2dHd0trTnm5Npjub0+1dnW4y3Zxq627tSCeTmXSmqynZ3dLe3J3paG9O93R2tLea9R2a26sdvn+VwXddwJ9oBj8F+JPM4KcBf7IZ/CbAbzCD3wz4jWbwWwB/mhn8NrNnH7g5/d/LDH4H4O9tBr8b8Pcxg58B/H3N4PcA/n5G8FNJwE+awc/ZN9cMfs6+pczg5+xb2gx+zr41mcHP2bdmM/g5+9ZiBj/Xv7eawc/ZzzYz+Dn72W4GP2c/9zeDn7OfB5jBz9nPA83g5+znQUbw0zn7ebAZ/Jz9PMQMfs5+zjSDn7Ofh5rBz9mfw8zg5+zP4Wbwc/bhCDP4OftwpBn8TsCfZQa/C/CPMoOfs29Hm8HP2bdjzODn7NuxRvCbcvbnODP4OftzvBn8nP05wQx+zn870Qx+zn87yQx+zn6ebAY/Zz9PMYOf899ONYOfs8+nmcHP2efTzeDn7PMZZvBz9vlMM/g5+3yWGfycfT7bDH7OPp9jBL8553+eawY/Z//PM4Ofs//nm8HP2f8LzODn7P+FZvBz9v8iM/g5+3+xGfyc/e8wg5+z/51OPuSx05lOtZTQ3NHS1un2dLT0JDubWtvSHT2trd0d3e1NmdbmZLfb1eJ2pdyetraO5uaOruZ21+3JtDf3tOV472KxSwn5ef9uE3Jxe3J2IYPwY2L8t+Xwe4zgJ3Pt6hIjepPn/1Ij8u/u0d+mvMXbDABnJM9GeSWI3C7zfsN3N3WYm82nmY3icfoXa7b/1/nd5uVXi8rjoHx0gHJXGpGr2x4j+TkOv9cG8q8hvMryk99rU0n4ofKhe20SDK/1JE4HuvaaYPJJMPlwWPcKYi0TxNokiLVOEOt2Qay1gljrBbEky3izIFZU9WuNINZmQaytgliS+iUprw2CWJL6JdmGNgpiSeqEpF2FPXnVTt++UK5vbklDX4v9awgQh/3jGInLoPRHZvPpaIiT37hMQxUdOjqPS9NRfrDf1I3w/XwGHUCOVShe0scB/Goz+GmQ/VCnt0xpmap9ZAXx3H/AonGQV43TV+4m/EOubJh/2l6GIn6wDPywhhaJVc3EmajTqoBy4/xrA3jlykHHN5w94vxvSF8dwBdOX8fkDc+CDGtQnKAMU0EyxG0R8h+O+OzOdC685Pi5lzgkxIkcQG4TSLqjs3k5UB0c6oPlkN8TyL04wsPB7JhxYPsBKFOx/QCWbTeJ66/d04HaBipzHXRd/5bMLcSZMlEd8ptbiKN4nP5PQ/L5/dG7HobyHB6QZy3hG6fX4ehs7/QjUNniTJrhhEdI/3ePL11/p3j1x8kO+Kkmz7+bdBnKVKwu43qkvAEm6A6tW796qRya5+X00XmeaX61AeWA351MfsB7PUmrA9TxSHRfcI4r9PfAIP8awqtwP5TzYUYSfqh8wLZoGQ7zrufM7eg+vOOq+QvnZCqIKOvQNYavJ3CQBqfFoR6x5Piko9Wuw8nZvs/RAKKsc/o263qSF8aPM/eo6a1neAM1B9ns6am5Nlsjvetah1djHaqdvrIVVIWusKoJ+dc4Js1hXjXrCD9+sgf5GGoqnTGnb7OIM3kCv1CXI5k4wBrl/cYmEqfH7QWnx9fwPL431dOneqdv8z4x25sHrunjeyBfracTPdw6pjwjSNm4eqtjcOuZ56kMcTu+Its7LsGUDeKqAuKGBsRVM+WCuBr03Fzy3DAGU/NwzdA8np9ssF6B+8LZJj/b6oc1i2Dh50cSrFEFsE4iWPj5UQRrdAGsUwgWfn40wRpTAGsewcLPjyFYYwtgzSdY+PmxBGtcAawFBAs/T49dG18AayHBws/Tz2RNKIB1DcHCz9NjSScWwFpEsPDz9Ki0SQWwFhMs/Dw9lnRyAawlBAs/T49Km1IA61qChZ+fQrB2KoB1OcHCz8OztQwW9QN2RvcHwg+A/GsIr6b8gJ2dvnLF8qHLsFMZXuuZOGq3pjL5TGXy4bBGC2KNEcQaK4g1ThBrvCDWBEGsiYJYkwSxJgtiUbtVqL8+I7v9f1B/Dc9h3cXp4igN10djDD9/AI/Z8P2dQpQH36Oy2cknPz/+sGxgvBnkf9SR5zie6wvkE8QzpON85quyvePwFDv1b/F0MPXD8VT5SBJXzZSL+sy4XqnPjOWGfeYEKc8S777Z6bhkEuufn6zovAT333HCTddyU+6m86koUz60PCME88FYR2Z751P+Kb5kJkw5cP6mp/hAFqMDZDHGSN5Noac7xxBZjDYkC9DFQuM2uqTIjc24vgRPj16SWaAW6Q5bcnrHJUNQUmxWKTu1JN1I8nuUD1szSbox5De4f5QPjIUD5SNo+pXLnzMjcJ1g7uvADWvpNCxXbdypZ9w07LiAfEaXmM9oJh+zp8skDZ/+kl/l56YScJkg/6BT+sKaAcirXKfocWULqmfuFL0grLAnvwGW2ROD8nUadHogzr/Y0wPxajG2c1M831C7dY+RpQ7OVpjdPZZuCauPkH+5dpqH3enCuerwbD2J0+G6bD4djYsz9yoCsDYKYt0hiHW7INZaQaxlgliSZZSsR8ky3iiIJVnG2wSxNglibRDEWieItVUQa70glqROSLZHyTYkqROS8rpZEGuLIJak7G8SxJKU/WZBLEl5SdrCNYJYkvKKqi2UlJekzdkRfCZJnZDst6Vkr6/pieZR0XtJ2d8iiCWp95JllLQTkj6ApLzuEcQK8zY2N66H9NwbLNy81I7yBkszSSfxBkszuRd3+DdYNPZvyekI9O0XHczOx6ZTMZIfLaND8q8hvArXf27Oitsexs17guwmMbzWM3H0a8/c1rFJTD71TBztt0vBuk0Qa5Mg1gZBrHWCWFsFsdYLYknqxO2CWMsEsSR1QlJeNwtiScrrJkEsSXndIYglqatrBbF2hHrcLIglKS/JfmiNIJakvKLaD0nKS9LeS+qXpM2RbI+SOiHpM0nJXl/TOZio6L2k7G8RxJLUe8kyStqJqPpf9whiwRwM9yoRfYWBG8NODMgHPz8xBBY3Hob03KtHQXM93KtHMPdg6BWcVFB9cK8v9WeuB+TmknR0rgfbtsk+WA757ZJ7fnM9dN/SBm8iC+RraD8au9Wc7lfEe0bpvshiX7XFz9cF5DO6xHxGM/mYlWXxp2jUk7gMiqOvOPQgLHwKCg1x8huXV7eLs4o4YQPXR7cPZoJJGyNxkPah6jwfXR4fZvcdlq9OZmXz6Wjg6gTKq2XRU2Kd0P2vmG/udekwr3Fzr+HXM8+PDMhn1xLz2ZXJp5Z5LubzH/Kh92g+HM9B8+39zQdjQRs2O3dfvP5TOWP9p3tze1AcPUUPn4CN14Fo4NoGyEK3jSdDtA2z603lkyF95Q3LELdtGjgZgizCyrDO6StD2rbrmHJw7R5j9KfdczxErZ8YTeJwHY8hcbiOx5I4XMd0vQqf8h4jcbNRXBWJuwzF0ZMQL0dxNSRuDorDdU1Dof7s1SL6M6w3Yfoz7ggVwDX7Slk6Hcbu4/xrCK+y/OTXQblXhLmTO0F2Yxle60mcDtlsPh2NizP3KgKw1gtibRHEulEQa6Mg1p2CWOsEsTZHlK+1gljLBLHuEcRaLoh1ryCWpLxuF8SSbI9bBbEk9V7SFkrW402CWJL1KGm/JOW1SRBrjSCWpLwk25CkPyEprw2CWIN2deDsqpTs9TVdB42K3kvK/hZBLEm9lyyjpJ24WRArqv7qCkEs8FfhOTzGx2uWhs8xyH35c5IZ/Nw5CUFruTh/OqaHeO4/YNE4um97rJmyBe7bDtIDPDce5ojQiUViDeR5JljW9DwTjleuHGMEZRLmCyjc3FKxdRt0ZKvhNpbbUzAmQE44/1LeH0mRdLBOWOH0rbsJPlgO+Z0i9/z2FNQ5feu02odPyJfeo7qCn08E5FNTYj41IfOpLzGf+pD5jC4xn9Eh8xmsn975DGT9gB3GZxbBuq1ec1lcw+eJj9THZzXRPROQ/v3oa7hLa/zLGCflx3YCjiI0+wWu4tfJqCwzTHliDBa3xgRlKvZLMfgdPfqlGMD0+1JMFYrH6dfW5HkZNoXHjCFM/K4i/YoQtNkqJ19unIbyAOlvQTzAV4QoZqVPuYb6YD6MdHFDDY/pMJhcuWpIuSgP1YQHSL8JlWsE2qSI08BvrCdXZ3vzNozJy/G5R23aMJ+4oHwLPauv8VeEaBzVFSov/LyfTKmuQPp7A3SliuEBl5fWK+WBpqnx4eFBhgd8bGXX3KuWeF/1cUigHydLkN+0KmkVVDE4fgHEoJ95uIbHwekgUPXDXfFQJo8aHx7xs1o8UL3dmTmZBRkfAVUQsIRPZhUOH8x+7dNMv8Htr8C2lwauT4Hy6udGTsnj0nQQ8DvZg35V//wqisX5SzrMzubjcfrnkR1pmMJjVvhgwmdkgvo0bm8SpOfGjEE+N9ZHOk7n8saypHZ3bJG8FppvqCa8cmPRsLzOKjOviSJ5rWHyxn2PMq6zr8nMO3Hugtwp2g7DhkOuab9D09D+YqgPq8NJujrymx6rTM37KPJ7GMMfFyjPHC9xp3CAJgqy+hpqotN9mqjj8E0U1J4Ov/CzePgFKjGfSQd5LiDlwelxnpB+IcqHc3Hmk3JD+u8wLk49wxPwU02el+12W1tAhtc4fQPELXJ6lx3HLUbpj8jm09HAda1QJi0Lt4jhGq5Hyhtg4i4D161fvfwE1Qv9sCfOb4HjXw74HWfyo7KEeB2gjhcTjJne72RJobkjRvJzHIed5of8a5y+sjUxzb+Y8EPlw5nhgA97XoOuMfw5BA7S4LQ4nINYcnzScdU+nnmOBhBlgvAM5dPm5BfEbOGmT79HjHmIM/eot1XJ8M/lU1ViPlUh87G5PHSntQ70A5CXMWWlO611oB9rnIPi6Acgr3D6lgvirgzAnBuAeVVA3NUBcfOYOM3T8uF5Hmn3wjV1+lFJXHd+7doPaxbBws8vJlhLCmDRj0ri55cQrGsLYJ1CsPDz1xKspQWw6Ecl8fNLCdayAlj0o5L4+WUEa3kBrAUECz+/nGCtKIBFPyqJn19BsFYWwKIflcTPryRY2QJY9KOS+PkswVpVAIt+VBI/v4pgXVcAi35UEj9/HcG6vgAW/agkfv56grW6ABb9qCR+fjXBWlMAi37oDT+/hmDdUACLfhgNP38DwboxAEtf07ed8PM3Eqy1BbAmEiz8PDxby2DFvP/gTq5D9+XcNzf0Wy6Qfw3hVZafvDu5zukrVywf+pbLTQyv9Uwc7otwHM7nJiYfDusaQazFglhLBLGuFcRaKoi1TBBruSDWCkGslYJYWUGsVYJY1wliXS+ItVoQa40g1g2CWLQvC/Lr9TXskAry6+E5bM/odFecPIPTYwy/cUPc4ccDa0OUB9+jslnrk58ff1g2cEJMqeMUfd1AsPo7TtHXjQSrlHHKmdneWP0dp+jraYSv/o5T9PWeBKu/4xR9vRfBKmWcsjTbG6uUccpFBKu/4xR9vbfTGws/T237dQWw9iFY+Plixin6el+C1d9xir7ej2D1d5yir5MEq7/jFH3tEqxSxikpghU0TllXACtNsPDz6wjWTQWwmggWfv4mgnVzAaxmgoWfv5lg3VIAq4Vg4edvIVjrC2C1Eiz8/HqCdWsBrDaChZ+/lWBtKIDVTrDw8xsI1m0BWDock+2NhZ+/jWDdXgDrcIKFn7+dYG10gsu4v9MbCz+/kWBtKoB1AMHCz28iWJsLYB1IsPDzmwnWlgJYBxEs/PwWgrW1ANbBBAs/v5Vg3VEA6xCChZ+/g2DdWQBrJsHCz99JsO4KwNLh7GxvLPz8XQTr7gJYRxEs/PzdBOseJ7iMhzq9sfDz9xCsewtgHUaw8PP3Eqz7ArB0uCzbGws/fx/Bur8AX4cTvvDz9xOsBwpgHUGw8PMPEKwHC2AdSbDw8w8SrIcKYM0iWPj5hwjWwwWwjiJY+PmHCdZ7CmAdTbDw8+8hWI8UwDqGYOHnHyFYjwZg6QC7ueqY5x8lWI8V4OtYwhd+/jGC9XgBrOMIFn7+cYL13gJYxxMs/Px7CdYTBbBOIFj4+ScI1pMFsE4kWPj5JwnWUwWwTiJY+PmnCNbTBbBOJlj4+acJ1jMFsE4hWPj5ZwjW+wpgnUqw8PPvI1jvL4B1GsHCz7+fYD1bAOt0goWff5ZgfaAA1hkECz//AYL1wQJYZxIs/PwHCdaHCmCdRbDw8x8iWB8ugHU2wcLPf5hgfaQA1jkECz//EYL1XAGscwkWfv45gvXRAljnESz8/EcJ1scKYJ1PsPDzHyNYHy+AdQHBws/Ds7UMVsz7D+tcn0D35daVmtwYyQ/Kge/h/GsIr7L85Ne5PuH0lSuWD13nep7htZ6Jo3OOzzP5PM/kw2EtEcS6VhBrqSDWMkGs5YJYKwSxVgpiZQWxVgliXSeIdb0g1mpBrDWCWDcIYt0oiLVOEOsmQaybBbFuEcRaL4h1qyDWBkGs2wSxbhfE2iiItUkQa7Mg1hZBrK2CWHcIYt0piHWXINbdglj3CGLdK4h1nyDW/YJYDwhiPSiI9ZAg1sOCWO8RxHpEEOtRQazHBLEeF8R6ryDWE4JYTwpiPSWI9bQg1jOCWO8TxHq/INazglgfEMT6oCDWhwSxPiyI9RFBrOcEsT4qiEXnHAvtk7vQuw7aJwfP4Xkn+mpmnDyD02MMv314cYffX/fxEOXB96hsPu6Tnx9/WDYXedel7vvT1xcTrFL2/XUQLPx8sfv+xhMsbt9fHfMc3Se6KCAfHYL2iS4KyOfjJebzcSYf7j3Fq7K94y5z+paV+yIMffcRfxHmGhJ3BVMu+p4ibiP0PUWsg/Q9RaxTtd7vq1HcUhI3D8VBneP3FOF9XJBR1rtfTcoGbXem9ztZYuC+rkjliOst5vPfcfquTehA9QN/FShWpnwqypQPLc81gvlgrCOy2/9z7Zce31Fs+8XPL/LBgqMNdMBferwcxeP0Gz1d1ti7kaM2uD3ql6F7RweUFZ6FNkL7t5ne72RpwQX8pWbw00H9Iy4TtSlYdsXoF86rhmBJyy6obJh/qoe4vw7jR1xbJFY1E2eiTpcElJvrQzheuXL4tU2cT9ApyEsD+MLpg/wnkCH2YQRlmAqSIeeD9ecUZJDbZJKOflmZ80UplkN+Tyb34k7wKci4Tqt9+IR8C9lx/Dz1wxYRvrj/kA+9R/PheIZ88HkW+FTaZ8nZDKB3+Mgc/B7VBBTfK/3oPOaHPEzuPS+/thJD+eGzMOhRS5Cf31FLl/vw9zHU79ETLS9nyjwhgGfAxOeNYJ7h3A/Kw6eIH2moj2T9SMirjvBL64eWhasTqncLGTn4yVYH7KdgPwan/3yRfgrWb+qnYJ7gWW7MX+MUzieon6xh8inVP+Dy4XimYzcdcDv/BmnnoA9Y5/GzcB5CgqT/06g85ksB7ZzuH6I+DbV9tJ1Dfn7tnOoNpH8loJ1zPvPJWX+eARO3c8wzbeeQ/geknRvya9h2Dnlx/Rht58X2Y5wd5/IZVmI+w5h8TPeXw0g+SwTzwVj0HCa/9voOaa9Qr1x7pf02Tv9p1F5/Rdor1veg+qR9xxImX9pmHCfcHGXQu8nURukQ1HfkbFRA3xE0BtAhaIwbNCeM0+E0QfOm8YA8sD7h++Cz4j7tcpL2WpJ2SUBav/Gcvu7yrs2OuVu7oC3guV8IELec4Rni8DvZZ2Xz6WiIk9+4TFpXZoQ40ZkbGy73waQy1YGe/g5lrmBwlxJcbAOovOC8Ndr+R3uF0e1/aC2PR/VEh/M9PLPjytZuWr840Pql8qGBq1/gW9fv2UXUL67DFSQO22x6xh/uIwFDy34nL9OotqX+tJezS2wvnDzpWgSWJ2BgeSYIxkyk71OJvkMa2l/oAO0H2izIr5J5Xgfq+0H66V6eWj6PTOHzD2pvjsPbBSwHetbocofnhSszpD2I6CNuY3L62ORCPa4kPOO8s4byDuOv4fxrGX6A7xomrrIEXpvd1tZUS1N3c09nS1tzcyZG8IFXeo/OHa5i0tcx6UHW16Hn5WSd7oamFs/m8VchuepQieKyJC6B4oBH3YYen9Kb/1WG+A8jf5x/PZN+FipDMXVZz+RDx2qlYC3pJ9Yop3cb4PpC7NvQvhD7L/g82PN97HIYWwe2jdp9XE5qB88htg73f4I61MT5o9TWrTSUd1hbB/nXOv51W8PElWLrupub3Kae9ubO7p50pru1J+b07RPizD1q67JM+hFMesO2IsnZuiySqw6VKG4licO2DnjkbF3WEP9h5I/zr2fSU1sXti7rmXyorSsFa0k/scDWYT+I+qnY1lE/dSlTHmzr6LjsImKTzHzSgZ8jpDYV86sDHkMvRXKi8qU4+B72m/EzdM4G0l+C/PbuWp4/KMOJDH/c3iVcrtm1/umWMun0FBL4UZdkFpx2ace8TPdpma55mQVxh2ePFpEWnw6nHJJOB/rlsqvIbzp9cxnBgS447JfL4D/G4qoOY9Ou9wo05PkgMWGXk7xmev+TJQZu6Ei7WjPLa6nQwwrIv8bpq3ImtnVwU5tYPrR7NLMskUrqDzfRJQMd5mT7yobyAfrCLd1h+dG2EGaZ8jImH+7zCzGf/5APvUfz4XiG30Gm1s80rkemcUVtPj21NWG2bIVZisf3cPoMicNLdLEAfDrdshrZixFkCgm7VFCO3MdJUZxke9Z8fATxQfUWu2t+7Yz7XAikD9pKpgMsaQRtLeJ0C+sS6AhXz0FtysTSP5dPbYn51DL5mG67tSQfv6W6u3zapN9S3X4oHqd/P1qqu5fUp5/t2laubD6uTG0mVWyb4exUUJsp9OoGyJBbYj032zuO03cqVx0uzfbm4TKGB64/rWeeh3Rh/BTMn1wduaH9FMi/XH7K5SHlCvJZZEY+ySDdXMTIh24NoHWHbTdu+9zwh1vuw/0EHS4+5zX2oC0FQW2HW4Lftv2PDItM+0G0beHXp5IICz6PZHrbB7aXtD4Edb8Jyr00oNw0f014GYjbbkvT0zEPxaevSMHz+MPvnG5Rffwq8km/UMtjOk6wT0plUuXw/SVd9ob0X2b8SK6O8bLhV0m/imVJtxpdy8hh21a6EP09t4xP+/v5eCsd4YuzP5xfRX34Yv0qLh+KFXaLIKT/HqoX+sHlQp9FC7M1HssW+OFk47cNA9qGDmBnaNvx00vcNk4h5Yf0P0blP4V8PRS3P7/tQH6vNMadYP2KEaJTd5rqmfy5ZRFNM73fyRIDtWWVKI/lDD90+eYXpL3B9G2cKSsn1xVMvnjKuJ7ku4Lkq+vxa0SPgbdhTt92xtUJ3ZZO+ewh8ZD+d8jO/ob01X5b+v9Sy+dd4/B66NdOMK+4HS7L9o6H9H9C8nrRZ2yA+eF45doo/gh7sW30JMIrpP9HQBsN0iXOp6Nbebg2SvmOkfth9SKHMyJf7v8F+HBYL+pG9OaBbiksZB+o7zDT+50sMdC6xO2Us5e0LqtJuaD9xpmycnW6nMkXLwNR+7Cc5MvZB/xKH/BxCcL00+MEw7MOtM3llj0QD7TNXc6UmdMDro8NeqUDvzLNpadlgfSjEa9B837gD5idw3DZeT/cdhLZ3uXmPhPM+VZUTo6PnMB3qXcK22S8jYsbL8Fx/HRtZg9kJ3Ya0busQXMShpYj22MkP5ANvofzL9ecRLF1u4jhH+Z/uPRcG+PmPPTaCZ3DxTYZ8sWvhi8l97h5Cjof5Te22ZvYBm4ODOsdjOVonjpcmuXzxLg4T26uk9rJYubkCsmA0/8w+snlE7S2tFAwH247bNCY0U9f6b2guRtsj6ltMjFHsgzxGWa8sxyVIYx/y71yym1Ppm230kd2dI4E0s9FtvcQ0q6CyqgDHpdSnrixK50HAP+lyodnOnaF9EegPrrQ63O4HDrQ+QBIfxTCpPMB3Of0guwut50H+2rAD9cm6LgRjwFpnXPYdOseh0OP26bl9PO1AYPbuqZppvc7WWIAvKyHh33eVQw/CZL+DKLH12//2cvXDvpM4XXe70oGA8skQdKfEeBrZ700eCyO653WCV2XpnzSMRekPw+153OIL4X7d9yfdozg88bjgmwArysZXnGboeMCSH9RwLiAm/PEvHI+ObTJgfDJsd1KZHvLJ+hznDr0135wWwuXkjjc54c5AiRMH1Plk57qLKS/ghlTBb2uq/HnEn8L50P3AyxEZQjqp2hd4Wd1nvNH8Li4L8Eyuzzbu7yQvhvNmV9D2qDffNhinzbIHXGhwyySN6SfgvJeSmTIrSkFrd3HmLgw/uzlIfNZ5JOPEzIfrjySfjM3Xz+K8FzsWgZ+vlx7REaRfK5l8jHsN4ceU0P+NU7fdm9iTB10LCSWK6Tn5kuWBKTnjnfkjp7CY2pswx2SLx5TLyf3uHZO5xGLHWMF7fPi1j8L2bk7i7RzC7P5eJz+9yPzmPcQOxe1fWWjS8xnNJOPaZsxmpRnUUB5itUp/Hy5js4YTfLx2yf3jM/6Q7FH0HwL6eez/dTPoOMuynVMiok5mh2hPO/mNvKCUBv5DGojXyFthNuPFnTcSX/lHDafd0N9XiuYDzc3X0hvXvVZ0wurN5D+caQ3PwyhN5xs/I7KxPmWS9+CsIJ8S26fUtC8ZNAaKk7PHc8BumD29eTw+4Eh/xrCqyw/+XECN4ezjJHdcCc/N9WRme+m2o7IdM1bctUCWhkAWO/0FvJyAgjpHfKbPqeZqiRpFjF56IDPk8OKVE+epwMRih+Gp0JpC8VzjXCZTzkdJ1wjxM/7NUK/87zoOSa5AQma5ApznhdWnmLO8/IzIHGmDDU+z1HZc2eYHR1QZkj/t4AyX1ugzLNImf3Oy8W/aTpu88xQh59gD1qIHOP05r1YfcLPl6tzH0Py8et043X5Z7Ac/F78uRTF4/SbUadb5WEWe0YfPYevWDlz+ZiWMz2L9dqA8hR7zjh3rndQPV2K0vhtzqpkMHWgL0ZD+rFeXRo+m5t9xx/y4t53xy9ujhfS4RuQDk8iOsxNdJVrQq2YthJz+t9WylWeICyuPcQIzzi91Q6tm0mGsUE4f+sd2p/Eegs5rENLnwtyaGlaagxBkUp1aDme/NIW69DimSTq0BY7Q4yfx6vguEHIKlKqz5uJePUVNyY6s7cYlYFz1Pxm5WM++NRQ4sNdONnRnVCQvtXrELQD+S3PmeXqaqwPf44Trq7w8+WazR9L8jGx208H+pZnId3Yj/Dl58QeThwA7gMQ3Moy/bhBC3IAZhEHgJslDlo1CnNaBbdjl+ugOMfTb5dDIb2mMqpkMHXw+wBEJ3EIzZxQ05wcuNXo5tCdMj24iXvrpoaJK+nQzdYeN9nS0pruSXW0ZZpbaN8FvNJ7YVaqd2LSm53Ra2IP3cSOvw6VKG4piUugOLziTQ+iM+MwNXWHkT/Ov55J7/c2MYelQ4UBLDg8LuiNL7rjSQdsV+gbgpA+g/rOMB9CWcSUJ+gDHXHym9oyaqt0mOn9L1TDPQWCQ+Q2hOGFviEHaecgubw8pXdZuEPqwHbEA/JwmHsxx192NI84g3dstnfctSF44ybsMMZCHz41BjfonkLKUuxkyhSGH5MrXzjPQv7LUuK/FFr5ujabj8fpd0H+ywriv3C7cagfFnN434HaFPwmHjchTO0ApL8e6XuhD1jhclIeMWbYD1hB+rXEfzG0o42d0IK8ynUyHMWqdPK71rF9PC7bW1aQ/hRvUKrr+da64jCP98F8vi6PeXuRmCf4YD6NMDcH6P04p3d+xe4oxc/TU1fMnICU/1joFWbwcx+WnMPIApcJ8i91By3Oq1xvRnJlC6pn/BFo2pY4rDlFYlUzcSbqNOiUKpx/bQCvXDmoX8HlM46RCaS/MoAvnB7aMNZ9eBZkOBfFCcowFVTf+GPfkH9/PhYKchtP0tGPhWLZX+GD5ZDf48m9uMN/LFTbzC96dp7rl4b78Aw8FOqX8PNU/83YzNZ27k1eCNybvJhHGuLkN+Zb1/dOo/O4NB3GoHpMPyYYZHP9MLi5z0LtXgc8eQ8LxfMXzJ2XOXne7Gs6FmSOvCZz5QJGf4eS8lG9u4r8voKkxfOZOB1dnJ1Dfl9Nfs9j+KGBygSHWiadXyjUPnZH1/1pH/j5oHnFqSXmM5XJJwhrdwYryH5PZdLvKPZ7OkkHY7tS7Pd0cs/PflNe8PgJNtHgNkZ959fIeMiMT9KernX62jQoC+R9paG8YyQ/x+H9Usi/luEH+K5h4kqZz021pV23TS0FZ5JNyY7uZFAbw/dom5zLpJ/BpAdZX+0YkTX7YZG5SK46VKK4K0lcAsUBj9x8rhm70R5K/jj/eiY9nS8JW5cc1qx+YsF8Lra90LbNtvXi/S/6dmbQiZZ43QLPPdPA+W1QXq1PZ4Xw24JOoTI7Li+fDLGu0sDJEMpbrAyxrlEZmmnL5ZMhbqM0cDKE8moZ9hQhQ6xrdA4b26bcqXJOtOQbI3F4HerIbD4dDYVkeGgRMuTmweNOXzldxmDRcUgnww+Uc57Tm39cfzrQdS38/DyCtbAAFt0sjZ8P8+YcxjqJYAXtX1hSAOsUghX0psy1BbDmEayg0xCXFsCaT7CCTmZaVgBrAcHyO/lW0/ICWAsJFn6enraxogDWNQQLP+93Qosf1iKCFXQ6TrYA1mKCxX2sjZvrwD5OLXMP2rrZD8+5RX+QlRsvmJjjzhJ+qHzoZtdVDK/1TBzut3EczmcVkw+Hdbkg1mJBrLmCWPMEsRYKYi0SxFoiiHWtINZSQaxlgljLBbFWCGKtFMS6QhAL5pG5edArST7FzoPi58PMg3I2dLiTXzPYNm9+eMdV8xfOyTgkYL8V8sC/r/bJv5553gnAws8ElSXoCxZg5/2+YEH3dED6o72M8eld1czzguOOVu6lLggQR/sHHIf91iOzveO4L/nFmHy4MQmUV8tiJDkd2mGwuLUFrBM7kzJcTfKn96iu4+chHZfP1BLzmcrkE4S1M4MF6bkxRdDaArePzPCXcHJrC9wYjxuX9GdtAeQ2maSjawvcWI9iOeT3ZHKv0NoC8OL3AjBdW4D08z3drmZ4lauPtnTQewtm96m3hV5bgPxrGX7oSeF0P+TMfvLa05ZKdqV7MsnmdGdnV7I7qI0Ve5LEdCa92T11bezaAp4H06ESxS0hcQkUh08cp2sLZuxGWzKM/HH+9Ux62m+HrUtJLFhbwLYX2rbZth7dtQW8J6GYeXHcX9JDCLAMd0XXOA74ofdove/K8FrLPBfz+Q/50Hs0H45n7v01vP95dX3+GaxXeP8zfnZJNh+P049C+59vDNizQcfoVFexbuhA2wk+FTZMfwjpb0G+Mt3/zL1bsSTrzzPkEfb9LUh/O+mTzfSL/P5nyCvopDsqD8fJ10nQu3HcO3hmy9jaQe0NDpy9oXto8RwD3XuA5wzmkjg8B0Dn9eiYHsdlUdzVJG4ViltM4q5DcfSd1OtRHNZRGjibiQ9lebUIm8l9qYeOCbF8uX1Iu6FrHAe80ntU3/DzV/g8R+2I4T1PruE2ndtXzL2zhctEfV1unj5M/4LzKtc8Ole2oL0aeJ6BziNzWIuLxKpm4kzU6dyAcnM2geOVKwedF+Ta2W6MTCD9kgC+cHrusKFyzwdwMpSaDwC57UXS0b3iWAcX+2A55Pde5J7ffABnRy/34RPyLWRHw75jgv3F/6vn8wz7vj+k/wd6v+kL6JrOyWGs2U7vuNko7hrv2vD+qmZuvsMhsrsG5U3HQIuY8oTts/EeKrefe6gwbxgT198ClMZv7vnbyJ8eNoXHjDn8GIL69KATYd9phPTfDfDpIU2lT7nm+GD+Guni93103WEwuXJdScpFebiC8ADpX2Pm9R2nr/3FOqTD1dnevM1l8nJ87tE+Z65PXFC+hZ7V1/PRNY2jukLlpQnWp/xkSnUF0r8doCvcuxxBe0opDzTNlT48/JLhQfdHw7z4rrlXLfFZzqpE19Q8c1VJq+ByBscvgBh08X5dz+PA7yD147a/4mev9OERP4vPuOrOzMks8FvvqyBgl/lkVuHwwex7US3d3B58CNRX5/oN3JZnk7irUBy2vTRwfQp+nyrsutktQ7Zfl8snCeNr6DA7m4/H6f+H2h39gtwViA8OE/bkQXrOz+TmRiB9ofEa5A+y5Pz+oLy5fY2QfkmRvHJrDdiHnkt4DToksxCvs8rM6xVF8srtY8C2Whmj2ddk5p04d0EGNw/KhkOuq8k9moZuc73Sh9XhJB2dRqZHjND+gb7mdxXDHxcozxwvcadwoOcV13nTx7qJTvdpoo4TvJ2CDl3ws3jowk2B0ileTh3DHMuBTRPGoMeGQPrxqNzUNIX96C+k57bL4ilQOgWMmwE99gkv8+EpXR0qUZzgUL6b+3gflkEiG768nHy4LcDc8Yz1JD2WFbfUQqdBcReGz8pdTfSPO7IsqGxBW4jwOeBxBuPybD4ep58RoH+mPo7IbYuGZzn9w69U6FCJ4gT1L8PpH5YB1b+g8nLyyTLp8ZIB/aB7FsUtJ3FYXyBPzv6BzPFRR9wybsznP/BK7wUtbZ+Y7Z2PqY+bwDIbtZecK6ev9/OuwdWnH+Sd6f1Olhho+8FTECsZfvp8RHlk73KtQvLh7Pp+Tu/0WSbfVSjNZSTfLMkXfySXTjnrgKcDZxFeVyBsOu0eVOZOtHx8jHcd5GbSozGPR7x/b4r/87QPxL4aPQIg6MOm3DFhWDepvYX0pyI+f0CGW9jm4elzHSpRnKCu9hTb53J9QlCfW6hPoP0qbh90+MMNpbDM/YY/fh/FxUfV4vQXoDqiH8XFfTv9oO/CInkP68MuRuWgx+0G1QfHx0qExaXH7Ren72FkQjFxW8B1vNwHczbC3K1IzEt9MOcE+DNZJx84H4nq7iomfRalAX6416lWkTjMO+13syh/WqfnZHvnz73+5TD5OgH80j67EL/U5kLc9chmL/KuuQ/Qm1gyzTr5ALLZgylP2LpcHFB+igXP4Y/Q47qnbSjLyGvFSB4zUSTmKqbf43ylq7L5vK/36bN1oH22DtQ2LWb4wr4AN76hy4DA2zqmvQ7YGMDNJLn+EMuR9ofcOC3oOxqFxqB0DIDTX5ntHRf0rRBueixsf4OPGB0f4lsskGfQfIW+nkDSQ7mxjcc6043icfq7Amw8J19u20eQ7uNxKT02FNcVHndtez6bj8PHLOhQieJM62uQ/8bJZ2kJ8qH6yo33OX2lrwtK6Wuc6Ctng7i6pO0nbDulcqrySU99IEj/TAi/CvMQ9KpAlknPzS9wfVzW4fPGbRPLhH4AFNJ/KEr2POm6XPvAcqXtI4vi4kz6Yn1EOm+zCsVRfwy3j5UkjpurDWN3dQhqO/As/ggsNzb2OwK6UJ6UR268zNl6SP+FAFvP9b1Btr5Qm6avAGDbAc8O3Fid12UsgzC2Pmi8U4qtp2NhbitwIdv9QoD+0WXlsN8XC9KVpUzZil0bGci6L+faiJ9fSmWFZYKxONsQNKdSqr+pA/2WbiF/k85NQvo3i/Q3g/TQan+zH3oYNX+Ts0F4nvCZABtEfT5O/4L8s0I2iH6+irNBcYYv3Bdzr4HqMNP7nywxBK3pGP5OaXOM5AfywPdw/jWMHAX5cYPqlZsDMPs5p2STNlPcetycbF/Z+NkdasNhLU2HUxAO6Crd1qwDXh9yRvXG5fxA/CzkQf3AqlF5zDjB5I5VwzaY+r/csWoa907S9rFMqP/B1XmQv7wc5cOlx30TTj/MKys3PuRsZdDcU6G1GDo+5tbnad7cfgOuL4X0I1F5Bn58mHIHes2f9llZFEfHjlgH6VFEXF/EvUbLvYaAx4COT9vCa+q4bdFjBrnXv/141AHWSWm7pG2CKxMc2Uf9tWmMjtF26CDMkehesf5I0JwSrSMu76BXnbk5JVxvfnNKM0LYDL95HSpTSL93gEy5NhEk0yyTfiVTrjDzVIVkSreZcuufQTKF9OkAmRaaK6MyhfQtATLNOn3LFSTTVUz6LFOuoLXKsDKlW6Ihn7AyhfQHBch0EXomjEwh/cwBlCku8yryHLYZ1D+m9q7G57n6AMwVPphB3xKnGH51ydk0WpfHBtQlV64VIcu1UqhcK4ssF6Q/2VC5FvmUa1GR5Sq07rCIlAvSnxmiXNw8yTaZZHtjQvpzQvp2AzlXUc75Ujonyvna3CcE6fy+1PhmMRnf4HTUV+P2s2M+qA5A+ktD6kB59pTzOhC0ns/50UFjqkJzOrSeuWOOOB2gc6rckSxh/Xt8ZM78Eb3TYX5iPv8hT3qvIkTZaNvC4wgsVxhHRGFvLuaH2s0VZHy0CsmH81NOIXLIMvmuQmWle62yJF9ub67f3EuW8Mr5/otClHkTmnu53rvmfB66f9bP5/HrY7A++PUxa0PaF+Aran1MkN+ig+T+WeorcP0It3+Wm2+ga3jcuozWj2/UFubfzw/C+l7lBPuDtH3cEeDPZNEz3Hgz6YN5L9L7u0f1Lj+uR9iXpdM9Mkom7wcCxjGrUN5h1pyuY9JjmwP81BEe8LO03LSuHiF2gZvjojLBfjNOT/1mbh9kzCk8HsgyZaQyrPJJT8cDkP4pRs/qmXLSuZ9C71IF9d/Yx8+GsL+QZ9Cn33WgehLk++hrukaO56/x+tq257P5uPLY4lRqoH09ujaJ9YEe28/Z4rBr5PTzQ9xxO1pX7vIqg/ron0U6TPfdc34/t6ZOMT8fYK84uQXpYdi9CNyc8/KA57h1UpzXTO9/MtlTUoD8oN0OYXjxm7v9GpLjy1N4XmN9+C0tBI0Fqh3e7srknUrGSH6O03esgfOvYWRpYk03rJ9mdrzi9uA1Xay/eE3X75NAeM8atXd4nPAK8Vk4G4Dt3L4oHqf/IfKXXvXBdJxge1doj9g7w3vjmpqz4WwLfd8naB2Ie98HeCj0bhPdCwnp30S2IejdQeDL7N7zngHfW0v3z65CcWHeh8C64Pc+fZUTPO6i6/W/DfAPg/b3LimS96UM77Sd07bzCvEdcZ6LQ+RZyv7eCSgep/97Gf2Gwf29fdP3d38v1pew+3u/4dlu7r3sMJ835Oa8g/osrN8TUTxOX+Mdwxbl81dATob1LzXQe4yhfsOcvxK0t5P7LI3Wv2c9/TMpx9a2ZM6nhTrEx8rjUInicfopnk7WoHLA/5I+SdLa4fakO3o6mju6u5u6Ougx8TpAneljrrQ+jB+dlxnISVpmOgB+wgx+7r3hSlTWOFMmyB90CR8XGPP57zj8mAXyqiFYwmVzg8qG+afrNZWEH7j2w6osEqvaJ26mTLlzdRoPKDfN3y891wbgflUAPk4Pdh3rcBWRxRAzskgF1VsVyhPy788x2PB7CklHP4uF5Z3wwXLI7ynkXtzhj8GmdqnW6VtueMawTUmFtQOQf41jtD3k7ECC8OPXdvFxhnPmdnR7J6tSk0erDosTw9Fi06rLdYvkHlUHekIruHpcF0r5jDEYnAjoF8BjTP6cKYn75Os4eXWl5qMQFlzHA3jxw4gRjNoAjMGmM9h0mDDYdMI1HWlvPNXW1tKe6kw2tXZ39XQ3pQt549L5d3W2dDZlOrta3KaWdFOyu5jRAPU28Kg7zsgvQdKfh0bddAWqIgBTB3qSKqS/MGAkz3lFXDnDmAHMT53TV6/oCKJc+tTa0dbZ3tXe1NHUkuxKtrb0pz65cmPZL872Tg+eZZUTPJpKkPSXo7qiuzWq0DOAdW22LyblGdcP9tjpx9gg/VzEw2tk1gPLgXaJ2JsW7IK6YiQ/x+G7RMi/xjHaRbu0PoAfKh+6EmZohNMZI/iYnyGMfKAuhzJxgAUzQdjW4PRDUBlxenwNz+N7yz3dqieYOsDpqDEmLs7cA/luO2WNuG64bmI+/wGX3qMjeCwbasOw/cQrh9f52A8sT/ws2A/aFjePzmOu8a45/4LWH7XJQX4Czs/PXtH+CtLfhGwF/XgI7a9wOSmPOL9KJl8dqL2C9BvITJyhds9+PBLy4vq7mMPLw3HCzUJx/WMtkw/Ia5gTPNMSZCeCZrygzVX5pAe8BEl/V0BfNhQ9E2f4or4MpL83wJepZsrFtWu4X8Okr2bKVef0tX/wLLcqAbI3fEJtF7cqgWWYyBaWz5AS5AM6UE/SY1lxNnQIyafQ0JKu4nKzaNjmYv+tjsmflpNrD1VMOYPaA1c+qrvPFunb4Q/tDvHhIaxvB+k/jHh4PcC3w33Zc6ODeaX2Bo99cPpPob7s46R+uFlQzg7GSRyuS5ARtoNVDC7XnqlOcG0Fp6e+Nuh+lU967E/h9J8P0Ika9AznX1KfAdK/EGAjhzl9y4XHMVQOw5n0w5y+cqhz+tqA4Q6fNy4PljP9gDak/zpTHs7u4hUFHSpRnKDdZb/GgeVK7W6QDHWgMq9l0mNZQvnqSXosf67tDCNxON+hhIdCYxtqkzl/A9sObnoVywD4rGbKK1d3XW6M5Aflw/dw/jVOX503MZYMqyMgn1oz8kkG6WAtIx/gZ4QRfpJp0JV6Jm/gFd5Ux3YFp69FMsTp8TU8j+/9huhrHXoO8OtJnA50HIvj4sy9igHCqmewsNygTnU7foPIgn7ZivsPuPQe5RHXJ+h8kI3obz4YC/wbrj1pmun9TpYU0ikoxwimHJA31iu5ttPcGtbWQf41jtG27AbpMJYPHevWM7zWO311eGU2n66QfuN8OKytEcVaJ4h1myDWJkEsSXmtF8S6XRDrZkGsZYJYkmXcKIglydeNgliS7VGyHtcKYkm2oS2CWJL1KKmrdwpiSerXZkGsuwWxJPU+qjZHsoz3CGItF8S6VxBLUl6SvomkfkXVL5TU+6j6cmsEsTYIYu0IvlxU9V7SNxns04rDiqovF1VbuFkQS9IWStajpLyi6n+tEMSKqv91kyCWZNuWbEOS8pLshyTbUFRlL2m/JOflojo3JKlfkr5vVH3MKPYd+pquWUn0HdxaL96jWM3wIbneC/ijDOGDrEYGyArnT9d+IZ77D1g0DvKqIVjCZXODyha0RozXw7EM/LBGFolVzcSZqNP6gHLj/GsDeOXKUSsok4QgFt3bxu3Z4NZVIf0oJj2nJ3VM3vAs1O1oFCdYt6mgusU2AvLvz9vbILczSTr4mkOF07dtjPTBcsjvM8m9OMLDoc7pq2tDffiEfOk9qiv4+VrCB/yGPS94DyzsExm4vQst6bC29d2yd2FVNp+u1L78LkEsyblzSX84qvMMkmWUXMON6nrKGkEsSZ24VRBrR9CJwbWGgZO9pLwk5+okyyg5zxDVtVLJuSdJvb9FECuq8/CSOjHof707bLRkX7taEGtHsIVRXcu6QRDrDkGsqM53S/Zpg+sDxWGtEcSKqr2XbEOS8pK00asFsQb7joFr24P7IAZOJwbnFAaujJLvCkR1PCQpe8l9zlGdL5T0cwbtxMD5E4N2YuBkH1U7Ecb/wuf40XNzuXMWAGtkAaxZBAs/P5JgjSqAdRLB4vY/1DJYMe9/OfZG4PygHPgezr+G8CrMT26NfLTTV65YPnSNfAzDaz0Th+se/+b2MFyd7Z3HaPKsDtVMHnLySHeGrR/Iv8Yxqi+5+hlD+KHyofUzluG1nsTpcF02n47GxZl7FQFYawSx1gtibRDEWieItVYQa5kg1lZBrI2CWJJlvFEQS7KMtwlibRLEukMQS1K/JNujpH5J2kJJvm4XxJLU+x1BJ24RxJLUry2CWJJllJT9TYJYknq/WRBr0E68O+yEZBnvFsSS9CeiKvt7BLEG21BxWKsFsQbb0MDJXnLsLjlGhjlOOoekw0zvf7KkkG6uZfKNOb3zHYfuD8TcIuRfQ3gV5ic3dzWO8ONXZyC78Qyv9UzcGCJX+fpMpqqZMghh596bHS+P3QSyxN+DwN8HmDouL0dN3LfP8LnwFSgep185Lo85zbuuRbgOwsB1VYHuy+lcKhm2DUD+NYRXU22ggvBD5UPbQJzhtZ7E6ZDN5tPRuDhzLwhrvSDWFkGsGwWxNgpi3SmItU4Qa3NE+VoriLVMEGuNIJYkX1sFsST1XpIvSdlvEMSSrEdJ2d8kiCVZxnsEsZYLYt0riCUpr9sFsaLatiX7DvAnuG/2wbcouO9SDSP5cd/M08Hw91BdwB9qBj93nkqh76JB/kHfhqX/AYvGQV7l+nYrVzbu2631JD2VgR/WkCKxDH8jNlenQd91wvnXBvDKlYN+I6/Y70oPDeALp69j8oZnQYb4G4WCMkwFyZD71lt/zqIBuU0l6WCPXIXTVweH+GA55PdUci+O8HAI+j439/1RyBd/d28Ciqfn2ExAecWZe7S94Ocn+GBxcw06zM7m43H6Nd78AveNvIkMf0G6O4lJPxGlAX442UwK8ZwOtUxewBPo/WR0X9p24PyAX3wP519DeDVlwycTfqh8qM5OYXitZ+JoO5rC5DOFyYfDmkh4wLpVpvpL9bf+JprhJ7D+JjJyLbb+6FzuFCPlcLuBr52cvgHidkZ5U12YiuJwW6EhTn7jMmn79Sb5JqbDYEGeWMeAtzqnb33jdH42kaureuZ5SFft9JWJYH30ULk6TPkb0L37snk+aOBkDnxrmf+tCJljuTaQOFzvjSQO6+00ErcTipvuXdc5/joXI3FQRnqP1iN+fueAfCaVmM8kJp9a5rmYz3/Ih96j+QS1x4mC+WC5TSL5TBLMB8ttCslnimA+WBd3IvlgXx+vC32OrAvBc9hXw8/C+xYJkv7vk/OYX/QwwZY0IL7kbEnKhbI1On0DxE1DeVOdnY7iqJ7tguKobuyK4rDMaeDsU4N3re3ThJ3yuDQdLQfuh6idCfJXDPl3of0VyL9c/kqQn69DkL8Cz3LtCdZs6xi5UvvN8cD5vP21Q2Z9pvB1C/mXaywxJaRcOb9uCpE5joO1/jrHXyeCeAgaZ3C2H2wntPu/eoNNbTvfGtc7Dbw/9Su07v5zsu6O878i67Ay0IGeGdvAxGn8TRPyPGN7U4nKjL8JPyvbm2dIn/AaDegrtrdy+tHSSm025IHz3tVQ3mHbCuTP9SHAdw0TV1kCrz1dbcl0sqWlO9PS1Nnc1BMj+MArvUfnTnZj0nPn6YKsd3eMyDoF7SWezePvhuSqQyWK25XEJVAc8Kj74cen9OZ/N0P8h5E/zr+eSX8SKkMxdclhzRLCwvZAAmtIP7FGOb3bE7Y5Zm1QqomzQRC4Nl9H4rDO1ZM43J7wnDINnL8J5dV67hbhb2K/Gfg2a0tTLVQWDsMXlsVUhv8gWeyKZPHhImSBdWZ3Eod1bQ/v2qwdSbVSWTgMz3ugvKmuzUBxVNf2RHHF6hqUt1hdw/qE+caYlejedIRxanb7/wRJv4vne2zbpzi+d36NKA/IW6d7L0m3O8N3NcPnQMzjQ/41jsk+N+9770H4ofKhvvcMhtd6Jo5+a2MGk88MJh8Oi9opM3WUaq9l+HJI+XE7onMLe6E4XG80cG0MylTsnDJuY8BbHcMDTkfrOKjeuX4c0kF94HIL1kcXlHFvp2+AuH3QvWLnlIHvYueUsVz3IXFYN/clcVin9yNxWK+S3nWdE6xXOA7KSO/ResTP7xWQzx4l5rMHk08t81zM5z/kQ+/RfDjZBNn5/uaD5bYHyWcPwXyw3GaQfGYI5oN1cU+SD/bT8JzymePzz+Dn8JwyfpbOKUP6N9G8yDlkLgG3g4GyJZzO7oviqJ7th+KobiRRHJY5DZx9AlkUO6eM/VNcJsx7WL8L0l9C6smQn5QcRcrFyXTQfzPvv+HxD7U9xfpvoI9R89/onPxA+G+4rQb5bzgdreMw/ht+ftB/y8cN+m98PoP+W//yiYL/hudQsf92Vwj/jZuTpv7bS8h/u5f4BYbmxqz03/C82YR+zptR+9SI4rg5rhjJ28/POz27/T+dX3sGza89Nd6fr0aUtzuhd7pB/8yu+TWoy8H5tb784PYW5J/hdLSOw/hn+PlB/ywfN+if8fkM+mf9yyfK82s/EZpf+xTyz94YnF/bFqIyv0b9Lkj/+wjNr01nym92D1B4/w3yryG8CvPj0voEfqh8qP+2B8MrZ3vo/BrnJ+7B5MNh0fm1qOxPoPNruH3ieqOh0FiqGP+N28dRx/BA62M64cev3uuZ5+neJFxuwfrooL6Nw5Qf+wLF+m/Ad7H+G5YrtfNYN/cmccX6fXVOsF7hOCgjvUfrET8/IyCf3UrMZzcmH9N+yHSSz3TBfLDcdiP57CaYDzePXW5/tBE9h/23aWR/NTyH/Tf8LPXfIP2TyH/b1bsGW4LtzEDZEk5n90ZxVM+wj0R1g/P7wtonkEWx/lsjiqP2qdAcF9QD9jvl6iGde/fJdfoGiEuhvPH3emjgZAZ8a5nN2zmPS9PRPHH7TpE4rJNpEofbaxOJw/XdTOKwvW8hcdimtZI4PL5pI3FYf9tJHNbf/Ukc1t8DSBzW3wNJHB63HORdg/64KE5Qf1JUR3CAuDTKm7bVJhS3C4lrRnG4Xmng9A7Kq/Xu1al5XJqO8orbGfCtz/aA97YuySw4LrPkzI45s7s7Fsyee+WpmasXZuYvqCSwtKujr5Ts5sMuxnEC2NWhgsQlSTy8ilPh8KGWeQ7yALXBTX8ghl+Qf41j0gzmh18pwg+VDx1+pRle65k4uh0yzeSTZvLhsEBX6hjssSSfYl+fGMvwHDUTMpbEYROC9YOGQmaiv9tggbc6hgda70nCj59+cdtgIR3UBy63YH00U/PrMOVvQfeKHeYB38UO87BcaReNdZN20diG0S4a6xV00XVOsF7hOCgjvUfrET/fFJCPW2I+LpNPLfNczOc/5EPv0Xw42QT1J/3NB8vNJfm4gvlguVF3MyWYD9ZF6ro2oufwMO86MswD3yLsMA/S34GGeWvI8MLMtGZxtoTT2VYUR/WsDcVR3WhHcVjmNHD2CWRRyjCP2if8avVV2d5x+BXyaeS5BhQH+PjVakiHj+SjR4NwxwBBHD5apgHhP+fNpVIdugvp0ONEL7GPG+RrQHrudeBdmPJy06d0CtrMNEW09Bfi9kdxxU5r4ymMaQ15XJoOAlfP3FR1I7oHxxdy7WI6wgW7RqejnkY69gmS955M3ljvqI5xy9x4yE51jFvmNryU2clNnUPgpgvoVNg+KI4Or/F0AZ0Kw9MFdGoT97tYJjQUWuYMq2Of8JnKhDyK0bE9EO40omPA22eQjn2D5L13gbypju3DpMf1BXKvc/rqETxbzTwnqGPdtQyvEDhdodOUxeoK55dTvcX9MpYJDZyOgZyK0bFvhLAluE+iOsZtncfbKKiOfRvp2OshdAznXayOQT87qGO948qtY6+H0DHsE1Ed416vxVupqY69hXTsTyF0LMgfG7Rj+bgo69ifDNkx+roljBX8jmui40xIX+/tozV7bF/+uKZGp6+sIO9phvKOkfwch5+/puM5zA/wXcPEmTiuaRrhld6j9oDz84OOazIzBuOPa8J+rg6VKG4aiUugODz+occ1mZkDyR/XFCR/nH89k54e1xS2Lk1iYXsggTWkn1hwXFMjer7Bu+aOrx1F8in2+Fr8PKSL2hGldNulQ8qIA+Zbt4vzG/K4NB3Nk5u7qnb61oegLFK0vJwscFumxxZhO1VP4rD/RefKcL9Zha5p4OQLstDy7W7I49J0tBwNKI5u8zNjr4o/gqzY47Pw/OqH+zm/So9BxLpfnrnBVDOVhcPwjHWG6iHejkL1EM+5UD3E21GK1UPc/xWjh9zcK7WfeAt6I8KAIx7qnL71QY+85eaQufk97shbSMflM6nEfCYx+VC/91CPGV0nh3jXdP4fy1Kn+xpJV/6jR8PvxYD8axyT7Sq/F4Pbu8DVEdfW4FluGyd9lZFbh+DmYjgsqEtujYLqNudPTw/IZyKTT9SOTqSvTPq9ckADZ5vwsYpv9nP7N/DG2QCcrj82AD8P6aL0CqsOxe7FwK+p/q2frzn4HQegr0vdjs+ty5T6KkvQKxo4n11LzIc7jrKWeS7m8x/yofeCXs2hWyh3EcwHy83vGGqJfLgjjDm7VGo+QVv78fgP78W4ZmL+Gfwc3ouBn6VzZJD+LfSZiyVkvszMK2/Fvw5PdRZvZ6Z6xq1F0LlaKnMaOPuEj9ee0M+jdnGZMO+F/NUESX8jqSdD/hj7yiSV6aCfaN5PxGNKansk/UQ6NinWT5zE5BM1P5G+mjnoJw76iYN+Yt/nB/3E8PlE2U/8pJCf+G3kJ36G+B+G5n+t9BPxnHIxfiJev6D2Cc/ZQTo8Z0f7az9/kh7BAelfQvOFL07052sKyvv0Sb3TDfqBds0XQl0OzuP15Qe3tyD/DKejdRzGP8PPD/pn+bhB/4zPZ9A/618+UfDP8LgZ+2cVk/LP4Oewf4af9fPPPoP8s4SHOTiP1ztgWZRzHo/6XZB+NKmngZzHa2TKb3bfQnj/jX5OstEMPy6tT+CHyof6b7syvHK2h87jlfJJwajuwaHza7h94nqjodBYqhj/DcuZvo+AeaD10Uj48at3bs8gpIvSUXQ6FOu/4ePm/tbP44L9jlXEfUV//b46J1ivcByUkd6j9Yif3y0gn+kl5sPtXTLthzSSfBoF88Fym07ymS6YDzePXW5/FL83jf23I4n/Bs9h/w0/S/03SP808t+OJn6BmXcHij/Wkuosd5Q65/dR3eD8vrD2CWRRrP+Gx9rUPhWa44J6wH6nYD1kgI99nb4B4vD7QsUefQZ8F3v0GW7f9FhxrJNJEofbK32fHNc3fZ+cO8uG8yNsO04N9Ae/DyaoPz1UR3CAOPxOGW2r+J0y+p4QfqcM1ysNnN5BeYs9+gy3M+C7H0efNZLf08jv6T7slnL02T4kPuzRZ/sweYDa4KY/EMMvyL/GMWkG88Ov/Qg/VD50+JVkeOWO7cFmHsfhfIKOwMJY9CRejE2PPiv2tZ6xDM9RMyH06DNsQrB+0FDITBQzzMMyp1+2wDzQet+H8OOnX/XM85AuSkfR6VDsMA8fN1fMMA/LlXbRWDdpF41tGO2iuePU6pxgvcJxUEZ6j9Yjft4NyGffEvPZl8mnlnku5vMf8qH3aD6cbIL6k/7mg+VGvzyzr2A+WG7U3dxPMB+si9R19RvmPUqGeY1emrDDPEh/FxrmvZcML7CdGShbwuksPmKP6hk+GZfqBj6OCsucBs4+gSxKGeZR+4T9Onr0GT6arIE8h48mw8NDejQZ4H+tPPWaO4KiwekrE7Ovvqa7w7Q9nD83pGzwrrlp/VKOHUhlOrtaOjp60l09ya6Ongxts8ArvVeB8tc0jUk/mklv+OjCDtB7fOwAHqbpUIniGklcAsXhKXV67ICZaaZ0Rxj54/zrmfRHozIUU5fcVCV9vT8sFrze34Cep6/E0jGoDmbtQPhxHORfQ3gV5ic3juPGPZWMXGsD5FrPxNFtUA1MPg1MPhwW2P2oHZtAt0Fh24LrjQauL23wrksZXwFvdQwPdHxVSfjxq3dufAXpDE99p6lcHab8eGmh2PEVnqYuZnyF5UqXOvBruHR5ogHF0Wn6RhRHt7Nh+eK8cRyUkd6j9YifnxaQz8QS85nI5FPLPBfz+Q/50HtBy7uVJJ9KwXyw3Gi7nyiYD5ZbA8mnQTCfBpSmkeTjN776j9D46gY0vgLjbvgYmKJsCaezeNmD6hle9qC6gZc9GtA1DZx9AlmUsk2d2qcg3wfr3kD4PpB/uXyfiYQfvz6Qs9/wLNee8BE3tN0W6/vQuWUz/mkqydkYh5Qft026hcivj6Kh0DxCMb4P1lfgjfN9aF9WrO+Dn6e+jyF7VdSxVToU6/tg29Jf34duGeCOveFsUhi/iNsKRn2fRqd3Gem9oD68MSCfSSXmM4nJhxtbxHz+Qz70XtB4uVy+D233kwTzwXKjY/adBfPButhA8vHzfQ6cnH8GPxfW94H085HvcwjxffC86EDZEk5nsV9E9SzstlIscxo4+wSyKNb34Y5BorwnmLQTSBykPR7V11XeNdfHDHd6x01AccPQNc4X684EJx9mZ3k+T/Hy1zL5wRQes8IHE/SRm6fEfZoOlShOTg+7XM33R1BfQ+1HItu7TLg9xZn0dC6Ym8vCbYr6bFgnqc/G+QjYX8THJG9Lk80/DzwOhDwxj2HkidMXK0+QESfPyQRrEoOFZRwkT+BxIOSJeaTynFygTFSenPyxnEBG3KuHOxEsbuyC2zudiwfsKiY9tUk4/RXI5oyY0pu/4eh5qgvDGGxsQ4PaWQ1TjloSh5/VuFPH9ea/wYtbiOz39SRvbk4rqD1MZ9LjcQ/UVx3hAT8bpTlTrq8PO89B+3o8z0F9N7y9swFd01BojnZaQx6XpoPA1XMDyYO2RapjUxh+sQ9I57PWIh3bSvLmdIbbVwbpudeasG9GdawRxdHXk82sdRb/uhGdS8N6RHUs7GvmDSSO2+YeVsfwemtYHaP13EjyKEbHGhHuf8h+BYi7B+nYEyHsWJCOFWvHsDzLY8eitR8G4vDn2YrVsf7YsScM6dijRMegrb4P6dgnSd67M3lz6z+QnnttHrdtqmPca/OGX41uq2V4hcDZFbpmx30aDuLw6wd0ngy/fkDnyfZBcVgmNHA6hl+bDqtjtJ65113D6tiuCPdIomPA2/8hHfsmyXtGgbypjnGfssH1BXKvc/rqETxbzTwnqGMdtQyvEDhdoa89FasrdM8np7fcZ43C6hjIqRgd+2YIW4L7JKpj0xl+8bEMVMdeRjr2Rggdw3kXq2PQzw7qWO+4cuvYGyF0DPtEVMd2ZvjFR7NRHfs50rG/DOrYDqFjfzGkY9cQHYO5nn8iHRtK5nunMnnj+SiqYw1MejznCeOwOsIDfraaeW4g16DpPEPYvXl07oI7Lowbx2KZ0MDpGMipGB2j9bwTyQPXlQ5UxyoZfjXu57z5sRqSLzwz0/udLDKkurszbpPb2t6WaWrqbm/mPiUFujjMQP5NzR2tXR2trtve5Gaa3IL567oYP5qXJ+gzhFrmHuBCW0iQZ2f2sxxUrDGSn+Pwe2Yg/xrCqzA/uT0zCcIPlQ/dM1PF8FrPxFH7w9VJzOmr/0Hz7vXM85UhsLjyDHfy893zF8ydlzm846r5C+dkHBKorsTI7wqf/GPM804AFn7GRLvqam7p7FKNK5lxt+ljudt1c3dnW7I11dHe3dXSnW7uKnf+mc6m9tbO9q7mZHey3W1PF2NXTO7B0OHq7Pb/YINwO5K0QYA/hPAnhJ/bb59g5AR5DzVStp6esPYV8q9xjNr7nH0dSvih8qHvM1WbkU9mpJPXPWyzqhjZUD6GEB5rDPHIrRUDTxBXieKAD53msMbePFYY4tFsG+3p5nwUvG/pYOJPQt3gvSdY7ytQPE5/+JQ85qHedZ3Tu1/CdmoYih/CxMNvqK8KJi19B2wIkSEnV5wedLLKp6xVpKyQ/hivfJq3U0bzmFh+mK8KH8zjEWYDqRO83h3U5iH9MCY9bmPAT53Tt20OI89h3vHnuuk9rn5iJC3tg6Gfws/5/a5mcPx4GMrgcHsV6eeGcZ6cr0fHUnEmH9ymcJ9fzeQv2D80c30lBM7XjpE4XPYLsvl0NHDjWCiTLu+MIvYKc21N0jeC+wl0n+ZL/fEqkpa+p4h5TAjwWM/kU0VwhwTwHyM4lcxztQ7fHrn/YfmNMfwGjYf7mw/GujDbOx9cz7hPm0fsJ7bjcebZpdl8PE6/CPVpC0P2adSW4DJclM3fozab+rG0TdL9WrTvomlwP47TL2P6LmofMJa+tyKEj8D5fdRHuB/JcxWRJ+cD1Dl9ZUN1uJrkhf1j6F+oDNYhPm6Y4p8XyLU2oIz63s1T+HSYB5yOYnB9J2Bw7Rqeq2P4om2P2o6qgDy4/ozLI0HiSq0frt/Gvgbnw3DxuD/H+dB7FUz6Qv5HjQ82h1vF4HB2fiiJizFx1Ibh8mIbRn0TbkyGbSPX7vzqLsj35ngP41dVBfDOyQ/bIem5nGRb0k12tTb39LjdLR2dTYXmcuD+kGzvcm37j+4lULl0GIrTk7hqFFeZ7Z1/jfe7EuWDsYCPBEn/AVTXOlShZ+D5eib/KpJ/L76Ze1jXKFacuQfpdZ0+6fFoYo4u1dze1tHemXRTPalUuq2lUL1ycsJzBzqArHFdVDFlS5D0H0d9zvPER04w+el0Xw1IF/P5vw2DuVeZ7X2PqyOsu5Ae8q7J9uUR4oahuATJZ7j3G8sLYwEfCZL+S0R3sb7B8/VM/kNJ/r34Zu5R3R3GpB/GpNf181lij3DZpef+tuVJ8PE9yttXDbarlqYWt62to62rpaunvamrs9xz713tLT3t6XSnm27vzrS7LWWf+29Kd/a4PWr+P92TTLe5ZV/76Eim1FpmZ2ezm+lob+8pe/ld1+1paepsa+lKqSnGsq+9NPW0drT0tCabU91NmVR3R7nz72jNtDe1pFNd6Z72jrZkW7nz7+xu6Uq2p93ujo7WZGtLWzFrTzGUP4S409f/A58M/MRi10grArBiAViJAlizCBZ+Hp7l5gdy/Z7T1w8XtNVNYfpjnH+N09dfL9e6PJZPf9fl6VwUN06pYvLhsGKCWPS9EYxdaF02SG8M7Z8IrTc5H8Ypj97ECT+F9Ibbl8GtUcOZ6kE2JGjPhmkszu7ROTtONvGAfGhd6RBmD5GpNYOwOgf5l2sPUdg9N3QeHj9L51t0oHrC2URuXc0WLGznuHWUK7K94zibyM0fBekqzLtTW1rn+NcNte9cH475pfPyO3sbF7n9J4L6yH5yj+5dMORHtHBzyRBqmXLTesfzh7Ru6Z4QHMe9Px1jeIiT31gWOu8zGvO4NB0ETkdiJK6KKQc3d0n7mhjDV9B+laA5cK6fgLOnYwTTcYLnODkfuJA/ErT/ydDertBnskH+5dr/xPmEnG3k2gita679xEgczmcIkw+HRXnAMqT1Z8h/C70/GPKvYeRgov64dhJj5MqNQ4L8/dw8s9O3HQ+kXaZjUm6tLMZgcfY1N/euaH1jHpemo/xgHaPrepwuxJy+9RJUV/U+z2MegtqAoboK7d/SMZXpNhAPKVfOv6X9HLZ9eD8VjSvWJ406lsm9Jpz+4r4f7zW5aKfez8BzeG8Efpae+wbpH94pj9npXUMb5Xzxco1PDfvYbdQu4kD9VR3uz+b5oIGzmcB3sedYYrlWkzjsF9eQONxWh5E43F/R8+A4X7a/vkjQPg5un01/8wnaa0b3T3D/IR96L8i3CjNvItH+y3VeJvUPTO8p5PpjbM9WE3vG7Z3Dz56Szcfj9BuRPbuRjNcN+bxF2RJOZ+l7CDgOn1dGdQOfc4ZlTgNnn0AWxZ5jiXUCyoT3H3LviXDztjGnr42NEwycHzcuh2fNvpOTbOf6AyoXbp87V4e0frmz6iCuFsXR9joCxWGZ0MDVPcgp7Pu/tE0CLm2TdD9VjOERt3VuLED7IM5n494zDupLgvSP09egPaF+7xnh57DNwvxTmwXpn/Tkgd/B4N4hAjmZPW8y2cydN4nlmiA8BclQh2LbPJ03w7YzzLwZ5y8BJvad8ZyXQ56hfrIOMF9Oz+J9HvU5H9upNw9Y907N9o7j/H6NMdc7QKDa6ds+NM30fidLCq0d3DqPHH6qe+DmEZu6YiQ/x3n3ziPqcH02n87PDoaZR9RhoyDWVkGsdYJYywSxbhHEWiOItUUQS1JekmWU4guel+JLUlc3C2JJtm1JnbhdEGvQfg3aL5NllJT9jYJYknp/hyCWZNuOanuUtNFR7Wsl63GtINaO0A/tCGWU5EvSrkax39bXpa6jmNIvSXndJYi1XhBL0jeJap822B4HroxR7bd3hHGapE7cIIgVVb3fJIgV1bmOOwWxTNromHef23+vA+wfpusbc8iag5l3P5q6uX2MwIPZPT9N3TGSn+PwawKQf9AcfI3D+2Mz+8lrp9uTziQ7O5tSnd3NLS0txeoGpI/GOY1Nndz6ZdAZiENIXALFAY/6+cen9ObfzJp/U2cY+eP8ubY5F5WhmLoc5fTWNdweuXXFK7O94/CaP6xZ4nXF/r6H4/eeAM6PtmVD75BlwrblqL5Dpvd9wDnxl2QWnLywc87sruMyS+YfemX3yR3zFszumHNod/e8zPz5uDRUE2hpsTS4NDQdTQ9xhU7Tpm+VcCvtgFVVAGsWweJ2jwW1IIx1EsHiTvThdhzQHTRBLR3Hc/i0PqoL8HwK4dnv9FpNNQWw5hEs7vRKwBpWAGs+wcLP09M6h/vkg9PgXVDDmbw5fCrL2gI8L8j25hnzVUuwRhTAWkiw8PMjCFZdAaxrCBZ+vo48V++TD05Th+7XM3lz+FSWIwvwvCjbm2fM10iCNaoA1mKChZ8fRbBGF8BaQrDw86PJc2N88sFpRqP7Y5i8OXwqy7EFeL4225tnzBc8G6Y3HYvuC/ZeoT1jyL9cvWkhuVKvZRzDaz0TR2dOxzH5jGPy4bASglhDBLGGCmJVC2INE8QaLohVK4hVJ4hVL4g1UhALbCEdtesw0/ufLCmkm+gOasgb54tlPRAjDMi/xumr3yZsIudrYPnQEf5oM/x0B/XXoxn5QF2OZeKoPuId1Dj9aFRGqo9YbxPk3te8oVY9g0ltLtfn4HsgX+37f5GMqHEbiPn8B1x6L2ilj77RhUf/+C2al3buXRZ4zu8EavClEiT9C1PzmN/xMLk3/4DHcr1NJmhruukNwB5HytBPfBLcVqi78U7fAHETmDLHmPRx8hvzXewbh9heTSBxuH3SL9fhNk6/XIfbF3z9j9MR6gsUqyP4+SBdrCsxnzomn3K3+WGC+WC5UftcJ5gPlttoks9owXywLtLxlJ+t/CuxlfCcn62EMVyCpH8O2cp/kFUUM+M1t4WOd3CgdobTWWxnqJ5NRHFUNyahODoWxoGzTyCLYt84xPU/nsRxba/a6avjgn5P6BNqIH9upciEX8jN53E2jbPt8CzXbmk/zvmfdUw+HBbMe9ATOBw5efQM4Jgh9Ok3UR0zcH07PMvZ2nhZ5OqmuT7DITzjOTVq0/z8fRo4u5U7CVzRm/08yQF4K7efPIbkM9P7nSwpuM1Urg5Tftw33ZfN80EDJ3Pgu1hfFst1HInDbYz2I1hvqQ+M9R36Rm4el44jublkfC/I9xsTkM+wEvMZxuRTyzwX8/kP+dB7NB9ONoM+c+F8gnxmP1/2oKn5Z/Bzfr4sPQ0I0r8H+bIzveuojYupzmJ/leoZ9lepbkxGcXSNDIdCY+1ifFncD01A+FS/cDq/LzoOY/KjtoHr9+B3nU/+OpyX3f6/momb6f0nFZnq6nHTzZnW5mRLR1Nzd0s61Z1qTXY3Nfe4bpubam9qS6d7uprauttS6Z5Ua6oryOYYXu8Kfeo1Xe8y058Gr3dxtryY9S4d6EloUVi/0YGeDBzksxvShXR/dcG0z87pQpDPHnbtU3KNkfaDQeNxQ2Ou0G2ZjrlMj8e5MRfXlsuh3371HLRuNN4MPyngZwLDDzfO0WuWVU5fHcLywjqJ+cZ9LNzzqxucN93fxvl+gDWmABbd38bNhwS1eYxF97dx+0gSJG4D8ukWTu2dBvZc3YjSLPKuOb+Mtmnslw1Em4b8axyjOusG6SyWD9bZIU6w7uC689vzV8OUNYwuY55K1WWMVYwuF5JVkC7TMXjQGI9bT+b6RMDf9kXUqeXFx7up6RgF1yddu8BzD+MQ/qYA/KEB+NUB+DUMPuWZvjWC86anmm31MDQ/DzX680RPiKxieOJO2asncZgnv1M0OfngtldL4rBc/U7M5OSK2/AIEofb30gSh/VwOInDe51gT+Iwp+8Y/lFkyz9E5gXC7qcL8hlwe4D0dY6/vkZtLYzOH3Br7tzcArULeG6B2gU8t1DKOtm0hjwuTQeBq2duTw6e/wn6au9ohEvnlTh9CNKf8Ux6bDOp/mAdgWejui/DhI5A3BQUh2VCQ6G5qTD6E2QbwuoMPIvX1Tl/g44960LmOZD2i+aN5+Mw/377A15E/WDQ6Z4gJ8One2a40z2xXBPZ3uUOkqEOxbZ5up6IbfNoEof1xW9fB8bEe+Dwm2rAB/dFA4yJ70EbMfzFm9BjHfrmadwMP4EnVXJtLegtWZOn7FEdKBULdCNqXx4odu0U+C527RTXC/VnsZxNfHmgVJ3AzwftAyxVX4LGcabWNGMkn5hgPvg5vzeAJfIJM46SyCfoywN+X1KJN+Sfwc+F/ZIKpB/VkMes8q4NvwUt+uUBqmfYb6O6UcqXB0AWpewDpPYJ6wukK/RVgiC/sdAJ5UGnwtv4VQJa97h+ad3XoriofpWA+0IANxeEv0oAdoD7mij3xbcwX7aBMnFfrNGBfmkU0s9o2P7f7Ckd/JdG6bt+Q1AZ4k5fmVN7COkPb9j+X6fdu6G3zLivbwf119y78bQeMN+0HqAdYJs+NKAMkD7dsP1/obEblMfw2K2JG7vhMwES2d7l5vYE4/TU7nHv5WM7QU878esH8G+MhWVOx/a92qLTt74Bj/a7Bzds/6/TjpjSmz+s1zWEd86X4/ZU0q9RYN2qRjyf17D92vB4sZXzNyFwc9rUtuN2Qm17sV8iijE8cLYdZFHsF3ol7AQ9LyUq7Rb327Tdcud84PS03RZq5+DvcnsZqX5zfUExbUaHo0l+3PoLbjP0ZKEYgxl3evOH8wn6YiH192g67gtjfnlTuWMMzheF9H4nJ5X/FLTw+50g/xrHqD1zqZ+B5Y3lQ23VUIbXesff/sWcvn0Q1y9VBGBRHrAMaf1VmJHXu+YLy5z9Djrl2PBYuuh+lc4vUL/ZcXqXH8sGB1ymUr6wTNe1g3TTkAxD6yY9lc20bnKnsgXpJnfyXr3T1ybRrwJzX+s07A+G/to0XT8wpAOB6wdYPv1ZP9CB7mXu75y/DVhBfkKYeufyCTpVEo/Z8Bzp1ob8M/g5vy8d0vE0pE825jHv8jC5MwSBR+5MQDq2L/ar3txZhYbnWTq4sToEOr7SodivTeMTUotZ8yl27YZrq3TPFO4jYT6Qm6Oh8wXcnCs35uHm+qsD8qkqMR9ubpcbw5XaLjnZlHuNxJSdKddaGfWB/N6Xe74h/wx+zu99OfrlVkjf0JjH/LSHaXjevyhbwuksN2fHze1T3cBz+8W+Q43n9otZ88G2mp45GsG9HKHH1u+WvRxSX6DB9Vnng42vOX++MiCfGMNztcPr0Uzvd7K00MLZVAicnGMkjlvrCNveoEzFnlnArVPVOf4yjJE44IfeC/LBaNsc3HfDr3nbvO8mXmI+cSafd8u+G7rOEhfMh1vHKrdP6eeD/bch/wx+LuyZBbl8GvOYMe/63bLvhurGQOy7wXOMQftu8FoHraM6VEc7NeafoTIM6stjhAecnpuj3xH25lD9iMreHK6eOR807PsFeG8AtRvcWmmQ/gStlXL6g3UE79GnzwnqTyc3JwSB0wPaLovVA4gLOucSn0ONZUIDpz8gp2L3dnG2IazO4HVmGO8HzTVCnpxvkmDyDLJHmEeqf0Fr+zgvTv9ovwHPcWfE6EDnLSB9W+P2/4X2NeGxkg6VKE5yDWMg90dgmXH7I+iep6D5wASDiefPc/uFsvl0JtbfQF5xJ98eK717OH+o86EoDtLl+kozvCaB1xoPH3QY54nLUkHS0+sEuXc66n9wGaEc+B7Gh/TDUFxuLwm6Bzzm3j1CccOyxWENJVhDSsACvuqZ9EP6yReHVUWwqhksfA/kq9vDLK9u/PbF+K1Dne3jU4Rdh4L0cxvzmOd519xaE5SN8yWpn8CNdwvtR6N2KydLx6h/EXrNGPKvcfr2UybmKTm7zu0BMnzGbxPww+2H5foZ/R7/CKdvnXHfvMK+Kf32F9e3UF0vJBtuPYnO4eI6pvv/uPFe0DxM0B6/YU7wHnrqc3HtmD7rJwvOR6N70hc0bv+/7YwO0u65uR+u/dJ2T9sEjsO6QOc8Od3i9qFB+lomPTcfwL13XRsCa0hA3ty30moD8sZ84Wdp3n5thPNFQTYD4Yti/zGR7S2boD3zOoSRJVeP9SQ9ll3Q/CvXjun53rj90TaO9RSfCQPthfN18fgc+mhuP2+hfVh0Py/mM8y+D4w1i2AFfaOSw6oI4Iuzn9x8J+3PDa01hX6HPOcjO311xER/XkiuQfvuaDsI6j+K7Ru5PVASWDFSHix7PD9Kv5EJfMz0fieLDK2pruaOdHN7sivT3NrR0krf63JI/u3edTWJk9aDaqacUvhtyZY2Or8qzH/a7DpCqsmwXUhCn3BENo/P2cE4SUef0fHcOhikMbnnvS3Z1GxWTqlUOd658LMt3JxR0H7isLY+qvt9ObsZ5pvRYW1wmc7xSIcpN63TbWmy+bgKEleJ4qpIHPY78f6OBpSOtkE614Dn5i/J5jH2Qnh7e9cgP5O226APkhzt+PfBcA/Ps3HzXyBzbp40TuLwXFdltnc+MCcJ71BTLOCDzmHu6f3m5hjp3BzOn87N9eKbuUflUsxc3nTvepiTn89LIzy/NsL5gdwcHH5H02B7TgWNUbi9rHrMBmdSzV8wd17mmCuPXJzpWrhg9twrD+/oujTjkEA3dsRQ4f06ZlxQDiOOnueCrhCTA+bWtvxEPjSIBOHTIfknSPo277e0U9zT2uH2pDt6Opo7urubujoKOcVwIJ/dTnFT2ZxiU4NZw5t0WaeYMzigwzCRgK+BJ0hzFEpzFEqjQ5DjzE0aHEnicFuaReKwsYJ8tQGGg2X1Nei92Q69aUA7dOh4wCBr49zgXV85d8HsniVHXnn1wszCTPfJCzvnzO6atfDKru2Ges4chwTqdMfIbzrBQ21yJYNDA34uhsoQdVsNB5oOtK1e50VYPoHRYvcEhvG+IGerj8s6vfTMcfgJjBOyeVmekO3NE2eHAZezw8eTONxOAFvbnN2d/HXSyT+jw4mIhxiJOwnF0YHgydnevOO4U1AcPdzkVBSXIHGnoTg6uDwdxdEB6xkobiiJOxPFVZO4s1BcDYk7G8UNI3HnoDi6IHQuiqslceehuBEk7nwUV0fiLkBx9STuQhQ3ksRdhOJGkbiLUdxoEteB4saQuE4UN5bEdaG4cSSuG8WNJ3EZFAcHWUO7xYdXC/oCGcCfZABfmeW20Qz/k1DZdDg8ayLvZArwjzCDn+tzwA905LCTgD3LDO9pwD/KDH4T4B8tJxsXLgD7GDnsXA6AfawZubSD//uUh8dNROL+q5q5J8NL/mO93AsmZsd2br8P0zbkvwROjnOHFOj+DvpDPanUcUnm1ExHN2Ydw41mioaLjtMUO6yh6eMMTlAwPBws+v1Kuk6P99ockc2no4EOj3CZNMYHEC5NR/nB9UTfl6P7RPB1BeGH3qPrIdwQ2XB9dBgeaojVN5UBDVx943eniqlvbr9c0Fl1/a1v/Dyt71qSz0zvd7K0kKHvkzhM+en3xRwnvMxzay6K/oJwaTqaJ5Yr/eYK1k36/SjcJQV9l2kUicN6Rb/jgqcP6HeH8BQK/bYF3hNHv2OO94rRb+RE5RtLtMvFgatr/M2jYuo6xsiCeweKfk8O76mbSOKwzk4icfgdqMkkbiSKm0Li8HTWTiQO9+E7kzj8Tbyp6BrLTAfOpTgiu/0/t5duLHmO6g2+5vYpcHnTb1ZzePSbOnHmGfpc3Omre+D+xxncMPwHffM2iP/xJfA/PoD/oLbD8c99Y2e8D/+Ypwkl8I+/53gM4X+iw/MfZ57H6f0wJvjgTQrgf0IB/ieheCr/ST75OT78T2L4n+TDP+Zpcgn8T0bxVP5TfPiPM8/j9Bgj7sOnHwatoxi5X+HzXDwg34QPZoLBxM9RG451KUbiJjP51TL5B30nkp63we215/oh6o/gvob6HLg/oX4F7jOo74DtMO33cJ1Rv4L7hjLXt9N+L4biKkhc0F4kvz1S+Le+DvoGKK13rBN+Z5vpa79z3PR10Hc36bc8sR9B/UnsK1CfEfsD1C/EfT7YFBuWBp/1fg/00iCeBos5vXVtG79Ob93UAU/LYTtQxaTHeAmS/jnvv+ah02PQ7BKZ22cfot87VEHnKDti/GzXI9yG/d61pzKE9J9EMsx4zHHbHWKkPIa2i3TESH6OE25K0dbzdY/M5tPRuDhzr2IQaxCrH1jcfF7M5z/kQ+8F7QMv07nxSW5fqiOH73K+DZRFl/cH6D61q9RX1gH6Ono2808Q5mveNfe+G8gYv9sbdJ5K0LfXaL+KfbEqn/T4rFac/mfef9z3Ukzu+0+4n6SYP0eYlxJM7l11TjfhfqEzSIAf7r1iukViAM5o6dD8XU76Y1y3iWxh+QwtQT6gA9wZLfRdec7fw23giGxvLKyzdNxXqN1x/macyT/G5B9mLaDQO7OHEyyO3zD+k6El0NDfhKDvppr2n7h3U4P8p2LfTY3a+bLU33dI+XHAfGv9XoXaPU1H8+TWvIJkjjFgW0qYd7arCmAdRbCKPfe8HO+bOE7hdvFu+Q5Tmd7LK/pszmLPQsTn/BbTLrjvFRgeuzbHGFnQtoLz585Cof1hUFsxdJ5m6LYC+ZerrXByDWor1Qyv3Hk9Q8oj16LPKS3l3NBi2go3/2u4rbTEGFmEaSu4bui8clBbMXSWVui2AvmXq61wcg1qKzUMr/VM3NDyyLXo724U21aA72LbStD5tIbqtDXGyCJMW8F1Q9d1gtqKoXPwQrcVeg6e6bYS9hw8Tu/od465cXLUzi8utq3g84SLaSvcOp/httIWY2QRpq1w5wjGHf/61teVTl998cvbr1+vRLwF8awDzCXWBeTJ8UznCDl5cHlzZy3BdbHr0XESF2beRF8H7RkIWscOWnMOWqsO2ocAdWjiTKmm5o7Wro5W121vcjNNbnOhdVfxdd+mVCbT3NbU2amu3G633Pl3Nbd0dikhJDPb3hBJFcqfO6MDz9PqMMT7jc8BwekBL0HSz/UAtF5cTexdgslPp8sGpIv5/N+GwdyrzPa+V53tmx6fmwLpIe8ahkeIw2cKJ0g+w73fWF4YC/hIkPTLPQCoE3zWCTzPnWmMz4imeXH5033k3HnKw5j0un6u8R4CvcVll/YptuVJ8PE9yhvojt9+Con57UJrQQmH7xe4vP3endAYQf2CLt/+3rXdr5K3psv1KnncDH7K9Dotd+wH1+fHSTruGapTOA31NXQ40ovTbQn2dOlrvJdOh1konxiJOwrFVZC4owl/OO4YFEdfF8f7nuj8eth5YJNzVG3Jpk6z4/pUG7emSl+Br0Rx9BV4bLfxGH4GkY+J+W4lnxazc4Sp7tEM//h8b33dhGSC4yE9loOhemwP48vg/GuMyi143otbB9fjUdj7eUlmwfZzao7oWNBx1uwFV2bmz6fzI3Hym67t0v389Hm6Ngd87uH959YV/QLwQ20ixqsg6WPkd4VPOlxOri8PGscVM1YLu1c5zFhtmNPX53cc3lcG+wH2pNxnDMJZfVE+YxDOpLRhHzScrTzQ+6Bhb7zlx9m1Dvq1wSGsX1uKzwrvOehrenwO57MaPg+6xXCduaN9+NcBfB54B4fGVzn+482g/ssG2wbvDw20bYN3YQdtW2BIm2yHSU8+Btsha9uC5vA520btFz3i60iETcfcs5h8TZYZn3VvqL9IjXb8+wh6dJYTPl+3UMZgN8Ev4eb/cDvjvgNNxwOODwZne2kecQYPyl0bwFt/15lssO9w/sBA2/dG73rQvgeGQd/VGfRdSQjlu+KzBLCcE46/baPvC8H74trfHe2DF8YXjvs8h8evFMMRlFeQrcd82O67N3i/B9q2vzu+PdVk+benkoPfngoRzH97Kjn47an+h8FvTwWUm9bptjTZfBxdQ65Ecaa/PQVr2QPz7ammwW9PofR+60J7er8Hvz1VnncBqc2itgfnP/jtqeS769tTF3jXljvFXeVyik29MGm4oeec4iOzeXyugf9/dVewEjEMRKetuAcRBPdD3INnL6us4EHwIHgr4kHYk4hnP10CffX5fI1VG+3m0jaZzkwyyUwybSbow3BQ8D14AgzHwt8MwFwSDP8QlpKbXIM/51y5kDJn2N0kciNlrGfAE5/hlO45gF1KGqiLy/iMmD9y1rdzctaXWJiktC6DfwWDfUZyVINdxUc5lpxQM70Iv7CZ62b8NCGAE+6+3W6vnx5f2ucHHHPGVWC0tamimnP2/8UAnKoIVQuqCnj4M96h9zUPtHPxiar4zGdj8nLruZyKrAauoBNf0HE8O3X7Uzqlv80eCa9Mq7BaPHUmJKQNc3JkNaJjIEz7BsHwWQDnhFfhlB+WAx8xyfVw8nLrehdHxZkI5M8tFo3K4zdnM7A/4jvyyMWf5bGm/xg4H8cuLHXW3fMc4rPC5LuYVarbWU61wLENcX4/TI3csiFiOnOtcWCvumuq663w7PwRjWmrMVMArq/zXyxG0Ob2Wr962vvh9RDHnGX4m+6a6n/X3Tu710hZbXC7MYk6zmHf53/vu+U9/SmVOQPk3XWwLIP/hPt5SF2YrrpIYkIegA/90s0vdD7c+zSFv2p6/lYhyc3/kLAcWFIeL62Z11LxNYD/oAx+22c4dobGn4Ds3Blm1cBzLdccbJXBe2jKgBOyYn5RD5wDwDFMgXfKtuS4qwXw9/qj1BLe9QXO0/HKslKbpDp1Yl77mOJq25mm8sgwrv/W8rwn+c0IWNd/UdZ/68m8p3vdNE+/K4aBBy6O8+twLaic4RcCW0qGx4Yn8P4GU2/6TyJtCwA=",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "lock_public_solver",
      "is_unconstrained": true,
      "custom_attributes": [
        "internal",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 48
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "15001264570739363109": {
            "error_kind": "string",
            "string": "Function lock_public_solver can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "lock_public_solver"
      ]
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "constructor"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "772057049813214347": {
            "error_kind": "string",
            "string": "HTLCNotExists"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2570651705007895968": {
            "error_kind": "string",
            "string": "HashlockNotMatch"
          },
          "2722406262643068352": {
            "error_kind": "string",
            "string": "HashlockAlreadySet"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3559210201980528457": {
            "error_kind": "string",
            "string": "Function commit_public_user can only be called internally"
          },
          "3564161243949231814": {
            "error_kind": "string",
            "string": "Function refund_public can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "9174444391250494040": {
            "error_kind": "string",
            "string": "Function get_htlc_public can only be called statically"
          },
          "9323748002447105156": {
            "error_kind": "string",
            "string": "NotPassedTimelock"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "15001264570739363109": {
            "error_kind": "string",
            "string": "Function lock_public_solver can only be called internally"
          },
          "16870384257694633552": {
            "error_kind": "string",
            "string": "Function add_lock_public_user can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17814817983036354427": {
            "error_kind": "string",
            "string": "Function redeem_public can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [
        "aztec::macros::functions::utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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11RXFWdbgr41XVNdVZxtCfrWdE11VXGJtqZrqquKsy1B35quqa4qzrYEfWu6trqq2Zagb03XVlc12xL0rena6qpmW4K+NV1bXdVsS9C3pmurq5ptCfrWdG11VbMtQd+arq2uarYl6FvTtdVVzbYEfWu6trqq2Zagb03XVldlZ6X4+3RtdVV21l2/T9dWV2VnFfP7dG11VbbWVo+21laPttZWj5OtrZ5C3aZb/vhzb//0b31woWwzrPX7tneMc3VrYhjn6gKlME62xvznML7/ikqcbPF6OY5z9cNyHOdqtOU4Rjh24TiXNZDjOJfnKPufjiW2OOYUvjbOOe3bRv9FZi570pPMXI6jJ5m5TMQbMn9Od7JPHzSnO1dP3pzuXK1zc7pzdbjN6UZb052qX1xdXLeNXTrIVuf69EF7ulP1au3pTtWAtac7VVfVnO5cnz5oT3eqrqo93am6qvZ0p+qq2tONs07XO38w3Wm7quPpTttVHU93rq4qu7xvXOrBdOfqqprTnaurak13rk8ftKc7V1fVnO5cXVVzunN1Vc3pRlvTnaurak53rq6qOV1bXdVcnz5oT9dWVzXXpw/WEpZt45pK40/HurN5fr35NoE7mrk6sK5o5urWuqKZq7PriiaC5hWauTrGrmjm6i67opmrE+2KZq6utSuauTrc30Jzy8m3jWP5iWauT1b0RWO4G26hMdwNt9AY7oZbaCJoXqEx3A230BjuhltoDHfDLTSGu+F13bvhctANz/X5kJ5o1rk+NdIXjeVuuIHGcjfcQGO5G26giaB5hcZyN9xAY7kbbqCx3A030NANv0Rjphv+c7pzffalPV0zXet9ulN1omlZtoGkkNzBdKfqLtvTjbamO1UX2J7uVJ1de7pTdWvt6U7VgbWnO1VX1ZzuXJ99aU93qq6qPV1bXdVcn31pTzfamq6trmquz760p2urq5rrsy/t6drqqub67Et7ura6qrk++9Kerq2uaq7PvrSna6urmuuzL+3p2uqq5vo8S3u6trqquT530p6ura5qro+HtKdrq6ua61Mc7ena6qrm+rBFe7q2uqq5PkHRnq6trmqu70q0p2urq5rruxLt6drqqub6rkR7ura6qrm+K9Gerq2uaq7vSrSna6urmuu7Eu3p2uqq5vquRHu6trqqub4r0Z6ura5qru9KtKdrq6ua67sS7ena6qrm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",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "commit_private_user",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "src_receiver",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 48
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6652550611004701521": {
            "error_kind": "string",
            "string": "Funds Not Sent"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "notify_created_nullifier_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "random",
        "decompose_hint",
        "lte_hint",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "redeem_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "772057049813214347": {
            "error_kind": "string",
            "string": "HTLCNotExists"
          },
          "2570651705007895968": {
            "error_kind": "string",
            "string": "HashlockNotMatch"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17814817983036354427": {
            "error_kind": "string",
            "string": "Function redeem_public can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "redeem_public"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000001"
            },
            {
              "kind": "string",
              "value": "HTLC_Private"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Train"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "contracts_private",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "contracts_public",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "events": [
        {
          "fields": [
            {
              "name": "Id",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::TokenRefunded"
        },
        {
          "fields": [
            {
              "name": "Id",
              "type": {
                "kind": "field"
              }
            },
            {
              "name": "amount",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            },
            {
              "name": "token",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "timelock",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 64
              }
            },
            {
              "name": "src_receiver",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::TokenCommitted"
        },
        {
          "fields": [
            {
              "name": "Id",
              "type": {
                "kind": "field"
              }
            },
            {
              "name": "timelock",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 64
              }
            }
          ],
          "kind": "struct",
          "path": "Train::TokenLockAdded"
        },
        {
          "fields": [
            {
              "name": "Id",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::TokenRedeemed"
        },
        {
          "fields": [
            {
              "name": "Id",
              "type": {
                "kind": "field"
              }
            },
            {
              "name": "amount",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            },
            {
              "name": "token",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "timelock",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 64
              }
            }
          ],
          "kind": "struct",
          "path": "Train::TokenLocked"
        }
      ],
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "Train::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::add_lock_public_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::add_lock_public_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::add_lock_private_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::add_lock_private_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 48
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::lock_public_solver_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::lock_public_solver_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "secret",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::redeem_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::redeem_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "secret",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::redeem_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::redeem_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "key",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::get_htlc_public_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "src_receiver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "hashlock_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "hashlock_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "secret_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "secret_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "claimed",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::HTLC_Public"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::get_htlc_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 48
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::lock_private_solver_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::lock_private_solver_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::refund_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::refund_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 48
                    }
                  },
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "src_receiver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::commit_public_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::commit_public_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::refund_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::refund_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "src_receiver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 48
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::commit_private_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::commit_private_user_abi"
        }
      ]
    }
  },
  "file_map": {
    "101": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "102": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash =\n            compute_unique_note_hash(nonce, compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash));\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.nonce, note_and_data.nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == first_note_and_data.nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == second_note_and_data.nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "103": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    pending_partial_notes.for_each(|i, pending_partial_note: DeliveredPendingPartialNote| {\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log sans the extra\n            // fields) to get the complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                // temporary node connectivity issue - is simply throwing good enough here?\n                assert(\n                    deliver_note(\n                        contract_address,\n                        pending_partial_note.storage_slot,\n                        discovered_note.nonce,\n                        complete_packed_note,\n                        discovered_note.note_hash,\n                        discovered_note.inner_nullifier,\n                        log.tx_hash,\n                        pending_partial_note.recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "105": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/private_logs.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{\n            ComputeNoteHashAndNullifier,\n            partial_notes::process_partial_note_private_msg,\n            pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n            private_notes::process_private_note_msg,\n        },\n        encoding::decode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        msg_type::{\n            PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n        },\n    },\n    oracle::{logs::store_private_event_log, message_discovery::sync_notes},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `syncNotes` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    sync_notes(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get the logs from the capsule array and process them one by one\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    logs.for_each(|i, log: PendingTaggedLog| {\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n        logs.remove(i);\n    });\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(log_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            pending_tagged_log.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        // In the case of events, the msg metadata is the event selector.\n        let event_selector = EventSelector::from_field(msg_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            msg_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n            pending_tagged_log.tx_index_in_block,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "106": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n        // issue, and we should perhaps not have marked the tag index as taken.\n        assert(\n            oracle::message_discovery::deliver_note(\n                contract_address,\n                storage_slot,\n                discovered_note.nonce,\n                packed_note,\n                discovered_note.note_hash,\n                discovered_note.inner_nullifier,\n                tx_hash,\n                recipient,\n            ),\n            \"Failed to deliver note\",\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "107": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\nglobal MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "108": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "115": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/logs/note.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    messages::{\n        encoding::encode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        logs::utils::prefix_with_tag,\n        msg_type::{PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID},\n    },\n    note::{note_emission::NoteEmission, note_interface::NoteType},\n};\nuse protocol_types::{\n    abis::note_hash::NoteHash, address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS,\n    traits::Packable,\n};\n\n// TODO: it feels like this existence check is in the wrong place. In fact, why is it needed at all? Under what circumstances have we found a non-existent note being emitted accidentally?\nfn assert_note_exists<let N: u32>(context: PrivateContext, note_hash_counter: u32) {\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists =\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n}\n\npub fn compute_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PRIVATE_NOTE_MSG_TYPE_ID,\n    )\n}\n\npub fn compute_partial_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID,\n    )\n}\n\nfn compute_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    msg_type: u64,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let packed_note = note.pack();\n\n    // A note message's content is the storage slot followed by the packed note representation\n    let mut msg_content: [Field; N + 1] = std::mem::zeroed();\n    msg_content[0] = storage_slot;\n    for i in 0..packed_note.len() {\n        msg_content[1 + i] = packed_note[i];\n    }\n\n    // Notes use the note type id for metadata\n    let plaintext = encode_message(msg_type, Note::get_id() as u64, msg_content);\n\n    let ciphertext = AES128::encrypt_log(plaintext, recipient);\n\n    let log = prefix_with_tag(ciphertext, sender, recipient);\n\n    log\n}\n\npub unconstrained fn compute_note_log_unconstrained<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_note_log(note, storage_slot, recipient, sender)\n}\n\n/// Sends an encrypted message to `recipient` with the content of the note, which they will discover when processing\n/// private logs.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n        assert_note_exists(*context, note_hash_counter);\n\n        let encrypted_log = compute_note_log(note, storage_slot, recipient, sender);\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n\n/// Same as `encode_and_encrypt_note`, except encryption is unconstrained. This means that the sender is free to make\n/// the log contents be whatever they wish, potentially resulting in scenarios in which the recipient is unable to\n/// decrypt and process the payload, **leading to the note being lost**.\n///\n/// Only use this function in scenarios where the recipient not receiving the note is an acceptable outcome.\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n\n        assert_note_exists(*context, note_hash_counter);\n\n        // Safety: this function does not constrain the encryption of the log, as explained on its description.\n        let encrypted_log =\n            unsafe { compute_note_log_unconstrained(note, storage_slot, recipient, sender) };\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n"
    },
    "116": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/logs/utils.nr",
      "source": "use crate::{\n    oracle::notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n    prelude::AztecAddress,\n};\n\npub(crate) fn prefix_with_tag<let L: u32>(\n    log_without_tag: [Field; L],\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> [Field; L + 1] {\n    // Safety: we assume that the sender wants for the recipient to find the tagged note, and therefore that they will\n    // cooperate and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the\n    // note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    let mut log_with_tag = [0; L + 1];\n\n    log_with_tag[0] = tag;\n    for i in 0..log_without_tag.len() {\n        log_with_tag[i + 1] = log_without_tag[i];\n    }\n\n    log_with_tag\n}\n\nmod test {\n    use super::prefix_with_tag;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn prefixing_with_tag() {\n        let sender = AztecAddress::from_field(1);\n        let recipient = AztecAddress::from_field(2);\n\n        let app_tagging_secret = 42;\n        let index = 5;\n\n        // I am using the deserialize trait instead of directly instantiating the IndexedTaggingSecret struct because\n        // direct instantiation functionality is not exposed.\n        let indexed_tagging_secret = IndexedTaggingSecret::deserialize([app_tagging_secret, index]);\n\n        // Mock the tagging oracles\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(indexed_tagging_secret);\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        let log_without_tag = [1, 2, 3];\n        let log_with_tag = prefix_with_tag(log_without_tag, sender, recipient);\n\n        let expected_result = [indexed_tagging_secret.compute_tag(recipient), 1, 2, 3];\n\n        // Check tag was prefixed correctly\n        assert_eq(log_with_tag, expected_result, \"Tag was not prefixed correctly\");\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "121": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_interface::{NoteHash, NoteType},\n    retrieved_note::RetrievedNote,\n    utils::{compute_note_hash_for_nullify_from_read_request, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::notify_created_note;\nuse protocol_types::traits::Packable;\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    let note_hash_counter = context.side_effect_counter;\n\n    let note_hash = note.compute_note_hash(storage_slot);\n\n    let packed_note = Note::pack(note);\n    notify_created_note(\n        storage_slot,\n        Note::get_id(),\n        packed_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(note, storage_slot, note_hash_counter)\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n\n    destroy_note_unsafe(context, retrieved_note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_from_read_request(retrieved_note, note_hash_for_read_request);\n    let nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash = if retrieved_note.metadata.is_settled() {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifying so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, note_hash)\n}\n"
    },
    "123": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub note: Note,\n    pub storage_slot: Field,\n    pub note_hash_counter: u32, // a note_hash_counter of 0 means settled\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note, storage_slot: Field, note_hash_counter: u32) -> Self {\n        Self { note, storage_slot, note_hash_counter }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "126": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/note/note_getter.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n    retrieved_note::RetrievedNote,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::oracle;\nuse crate::utils::{array, comparison::compare};\nuse dep::protocol_types::{\n    constants::{GET_NOTES_ORACLE_RETURN_LENGTH, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL},\n    traits::{Packable, ToField},\n};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    packed_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the packed note.\n    // This allows easier packing and custom (un)packing schemas. A note property is located\n    // inside the packed note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = packed_note[selector.index as u32].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[(31 + offset - i) as u32] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_packed_note<let N: u32>(packed_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(packed_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (RetrievedNote<Note>, Field)\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    // Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do\n    // is check that the metadata is correct, and that the note exists.\n    let retrieved_note = unsafe { get_note_internal::<Note, N>(storage_slot) };\n\n    // For settled notes, the contract address is implicitly checked since the hash returned from\n    // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n    // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the contract\n    // address returned from the oracle matches. Since branching in circuits is expensive, we perform this check on all\n    // note types.\n    assert(\n        retrieved_note.contract_address.eq(context.this_address()),\n        \"Note contract address mismatch.\",\n    );\n\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (retrieved_note, note_hash_for_read_request)\n}\n\n/// Returns a BoundedVec of notes that have been proven to have been created by this contract, either in the current or\n/// past transactions (i.e. pending or settled notes). A second BoundedVec contains the note hashes used for the read\n/// requests, which can save constraints when computing the note's nullifiers.\n///\n/// WARNING: recall that notes are never destroyed! Note existence therefore does not imply that the note is _current_\n/// or _valid_ - this typically requires also emitting the note's nullifier to prove that it had not been emitted\n/// before. Because of this, calling this function directly from end-user applications should be discouraged, and safe\n/// abstractions such as aztec-nr's state variables should be used instead.\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // Safety: The notes are constrained below.\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the notes (as opposed to simply removing some), the private\n    // kernel will later validate that these note actually exist, so transformations would cause for that check\n    // to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = array::collapse(filtered_notes);\n    let mut note_hashes = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_packed_note = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let retrieved_note = notes.get_unchecked(i);\n\n            // For settled notes, the contract address is implicitly checked since the hash returned from\n            // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n            // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the\n            // contract address returned from the oracle matches. Since branching in circuits is expensive, we perform\n            // this check on all note types.\n            assert(\n                retrieved_note.contract_address.eq(context.this_address()),\n                \"Note contract address mismatch.\",\n            );\n\n            let packed_note = retrieved_note.note.pack();\n            check_packed_note(packed_note, options.selects);\n            if i != 0 {\n                check_notes_order(prev_packed_note, packed_note, options.sorts);\n            }\n            prev_packed_note = packed_note;\n\n            let note_hash_for_read_request =\n                compute_note_hash_for_read_request(retrieved_note, storage_slot);\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> RetrievedNote<Note>\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let opt_notes: [_; 1] = oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_fields,\n    );\n\n    opt_notes[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_fields,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\n/// Unconstrained variant of `get_notes`, meant to be used in unconstrained execution contexts. Notably only the note\n/// content is returned, and not any of the information used when proving its existence (e.g. nonce, note hash, etc.).\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteType + Packable<N> + Eq,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n\n    // We fetch the notes from the same oracle we use in the constrained case, except we don't bother inspecting the\n    // metadata in order to prove existence.\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_fields,\n    );\n\n    // Even though we don't expect for the opt_notes array to be sparse, collapse is still useful in this case to\n    // convert it into a BoundedVec.\n    array::collapse(opt_notes).map(\n        // view_notes just returns the actual note, so we drop the metadata\n        |retrieved_note| retrieved_note.note,\n    )\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects as u32] = select.unwrap_unchecked().value;\n            select_comparators[num_selects as u32] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
    },
    "129": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "132": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "135": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "136": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "137": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "138": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "139": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "140": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "144": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "145": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "146": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "147": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use crate::messages::encoding::MAX_MESSAGE_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        msg_content,\n        tx_hash,\n        log_index_in_tx,\n        tx_index_in_block,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {}\n"
    },
    "148": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr",
      "source": "use crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn sync_notes(pending_tagged_log_array_base_slot: Field) {\n    sync_notes_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "150": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::{\n    note::{note_interface::NoteType, note_metadata::NoteMetadata, retrieved_note::RetrievedNote},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::IndexedTaggingSecret,\n    traits::{FromField, Packable},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {\n    // This wrapper exists to extract the ORACLE_RETURN_FIELD_LENGTH generic numeric param into a value and pass it to\n    // the oracle, so that it knows how big the return array must be.\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        ORACLE_RETURN_FIELD_LENGTH,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let MAX_NOTES: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    _placeholder_fields: [Field; ORACLE_RETURN_FIELD_LENGTH], // TODO: Compute this value automatically from MAX_NOTES\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let fields: [_; ORACLE_RETURN_FIELD_LENGTH] = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n\n    let mut opt_notes = [Option::none(); MAX_NOTES];\n    for i in 0..opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let maybe_nonce = fields[read_offset];\n            let maybe_note_hash_counter = fields[read_offset + 1] as u32;\n            let packed_note = array::subarray(fields, read_offset + 2);\n\n            let note = Note::unpack(packed_note);\n            let retrieved_note = RetrievedNote {\n                note,\n                contract_address,\n                metadata: NoteMetadata::from_raw_data(maybe_note_hash_counter != 0, maybe_nonce),\n            };\n\n            opt_notes[i] = Option::some(retrieved_note);\n        };\n    }\n    opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "151": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "152": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "153": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "155": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "157": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/state_vars/private_immutable.nr",
      "source": "use dep::protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\nuse crate::context::{PrivateContext, UtilityContext};\nuse crate::note::{\n    lifecycle::create_note,\n    note_emission::NoteEmission,\n    note_getter::{get_note, view_notes},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateImmutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context, let N: u32> Storage<N> for PrivateImmutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateImmutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateImmutable>` type (for example), because the storage slot often also identifies an actor.\n    // e.g. the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<Note> PrivateImmutable<Note, &mut PrivateContext> {\n    // docs:start:initialize\n    pub fn initialize<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: NoteType + NoteHash + Packable<N>,\n    {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:get_note\n    pub fn get_note<let N: u32>(self) -> Note\n    where\n        Note: NoteType + NoteHash + Packable<N>,\n    {\n        let storage_slot = self.storage_slot;\n        let retrieved_note = get_note(self.context, storage_slot).0;\n\n        // Because the notes obtained from PrivateImmutable are not meant to be nullified and get_note(...) function\n        // has already constrained the note (by pushing a read request to the context), we can return just the note\n        // and skip the additional data in RetrievedNote.\n        retrieved_note.note\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateImmutable<Note, UtilityContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    // docs:start:is_initialized\n    pub unconstrained fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // view_note does not actually use the context, but it calls oracles that are only available in private\n    // docs:start:view_note\n    pub unconstrained fn view_note<let N: u32>(self) -> Note\n    where\n        Note: Packable<N>,\n    {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: x_coordinates_match,\n        };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "166": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable.nr",
      "source": "use dep::protocol_types::{\n    shared_mutable::{\n        ScheduledDelayChange,\n        ScheduledValueChange,\n        shared_mutable_values::{unpack_delay_change, unpack_value_change},\n        SharedMutableValues,\n    },\n    traits::Packable,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\n\nmod test;\n\npub struct SharedMutable<T, let INITIAL_DELAY: u32, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// This will make the Aztec macros require that T implements the Packable and Eq traits, and allocate `M` storage\n// slots to this state variable.\nimpl<T, let INITIAL_DELAY: u32, Context, let M: u32> Storage<M> for SharedMutable<T, INITIAL_DELAY, Context>\nwhere\n    WithHash<SharedMutableValues<T, INITIAL_DELAY>, _>: Packable<M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in blocks. Reads in private are only valid as long as they are included in a block not too far into the\n// future, so that they can guarantee the value will not have possibly changed by then (because of the delay).\n// The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, let INITIAL_DELAY: u32, Context> SharedMutable<T, INITIAL_DELAY, Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PublicContext>\nwhere\n    T: Eq,\n{\n\n    pub fn schedule_value_change<let N: u32>(self, new_value: T)\n    where\n        T: Packable<N>,\n    {\n        let _value_change = self.schedule_and_return_value_change(new_value);\n    }\n\n    pub fn schedule_and_return_value_change<let N: u32>(\n        self,\n        new_value: T,\n    ) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n        let current_delay = delay_change.get_current(block_number);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let block_of_change = block_number + current_delay;\n        value_change.schedule_change(new_value, block_number, current_delay, block_of_change);\n\n        self.write(value_change, delay_change);\n\n        value_change\n    }\n\n    pub fn schedule_delay_change<let N: u32>(self, new_delay: u32)\n    where\n        T: Packable<N>,\n    {\n        let mut delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n\n        delay_change.schedule_change(new_delay, block_number);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    pub fn get_current_delay<let N: u32>(self) -> u32\n    where\n        T: Packable<N>,\n    {\n        let block_number = self.context.block_number() as u32;\n        self.read_delay_change().get_current(block_number)\n    }\n\n    pub fn get_scheduled_value<let N: u32>(self) -> (T, u32)\n    where\n        T: Packable<N>,\n    {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay<let N: u32>(self) -> (u32, u32)\n    where\n        T: Packable<N>,\n    {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change<let N: u32>(self) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        // We don't read ScheduledValueChange directly by having it implement Packable because ScheduledValueChange\n        // and ScheduledDelayChange are packed together (sdc and svc.block_of_change are stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_value_change::<T, N>(packed)\n    }\n\n    fn read_delay_change<let N: u32>(self) -> ScheduledDelayChange<INITIAL_DELAY>\n    where\n        T: Packable<N>,\n    {\n        // Since all ScheduledDelayChange member are packed into a single field, we can read a single storage slot\n        // here and skip the ones that correspond to ScheduledValueChange members. We are abusing the fact that\n        // the field containing the ScheduledDelayChange data is the first one in the storage layout - otherwise we'd\n        // need to offset the storage slot to get the position where it'd land.\n        // We don't read ScheduledDelayChange directly by having it implement Packable because\n        // ScheduledValueChange and ScheduledDelayChange are packed together (sdc and svc.block_of_change are\n        // stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_delay_change::<INITIAL_DELAY>(packed)\n    }\n\n    fn write<let N: u32>(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>,\n    )\n    where\n        T: Packable<N>,\n    {\n        // Whenever we write to public storage, we write both the value change and delay change to storage at once.\n        // We do so by wrapping them in a single struct (`SharedMutableValues`). Then we wrap the resulting struct in\n        // `WithHash`.\n        // Wrapping in `WithHash` makes for more costly writes but it also makes private proofs much simpler because\n        // they only need to produce a historical proof for the hash, which results in a single inclusion proof (as\n        // opposed to 4 in the best case scenario in which T is a single field). Private shared mutable reads are\n        // assumed to be much more frequent than public writes, so this tradeoff makes sense.\n        let values = WithHash::new(SharedMutableValues::new(value_change, delay_change));\n\n        self.context.storage_write(self.storage_slot, values);\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext>\nwhere\n    T: Eq,\n{\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction block number as this proof\n        // will only be valid for however many blocks we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n        let (value_change, delay_change, historical_block_number) =\n            self.historical_read_from_public_storage();\n\n        // We use the effective minimum delay as opposed to the current delay at the historical block as this one also\n        // takes into consideration any scheduled delay changes.\n        // For example, consider a scenario in which at block 200 the current delay was 50. We may naively think that\n        // the earliest we could change the value would be at block 251 by scheduling immediately after the historical\n        // block, i.e. at block 201. But if there was a delay change scheduled for block 210 to reduce the delay to 20\n        // blocks, then if a value change was scheduled at block 210 it would go into effect at block 230, which is\n        // earlier than what we'd expect if we only considered the current delay.\n        let effective_minimum_delay =\n            delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon =\n            value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any block after the block horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_tx_max_block_number(block_horizon);\n        value_change.get_current_at(historical_block_number)\n    }\n\n    fn historical_read_from_public_storage<let N: u32>(\n        self,\n    ) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u32)\n    where\n        T: Packable<N>,\n    {\n        let header = self.context.get_block_header();\n        let address = self.context.this_address();\n\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        let values: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::historical_public_storage_read(header, address, self.storage_slot);\n\n        (values.svc, values.sdc, historical_block_number)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, UtilityContext>\nwhere\n    T: Eq,\n{\n    pub unconstrained fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let smv: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::utility_public_storage_read(self.context, self.storage_slot);\n\n        let block_number = self.context.block_number() as u32;\n        smv.svc.get_current_at(block_number)\n    }\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "178": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "181": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "182": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "184": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "185": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "187": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "189": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "190": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/random.nr",
      "source": "use crate::oracle::random::random;\n\n/// Returns as many random bytes as specified through N.\npub unconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n"
    },
    "193": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "20": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "217": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "219": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "262": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "277": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "279": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "280": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "281": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr",
      "source": "use crate::traits::{Deserialize, Serialize, ToField};\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\nuse std::meta::derive;\n\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\n\n#[derive(Serialize, Deserialize)]\npub struct IndexedTaggingSecret {\n    app_tagging_secret: Field,\n    index: u32,\n}\n\nimpl IndexedTaggingSecret {\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\n        poseidon2_hash(\n            [self.app_tagging_secret, recipient.to_field(), self.index as Field],\n        )\n    }\n}\n"
    },
    "290": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "294": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `omit`: A list of field names (as `Quoted`) to be excluded from the serialized output.\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, &[], false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, &[], false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], &[], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, &[], false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with Omitted Field and packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// Serializing while omitting `value2`:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, MyStruct, &[quote { self.value2 }], true)\n/// // Returns:\n/// // ([`value_packed[0]`], [`let value_packed = self.value.pack()`])\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    omit: [Quoted],\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // Proceed if none of the omit rules omits this name\n    if !omit.any(|to_omit| to_omit == name) {\n        // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n        let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n        let packable_constraint =\n            quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n        if (should_pack & typ.implements(packable_constraint)) {\n            // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n            // method, add the resulting field array to `aux_vars` and each field to `fields`.\n            let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n            // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n            let name_at_one_token = collapse_to_one_token(name);\n            let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n            // We add the individual fields to the fields array\n            let pack_method = get_trait_impl_method(\n                typ,\n                quote { crate::traits::Packable<$packed_len> },\n                quote { pack },\n            );\n            let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n            for i in 0..packed_len {\n                fields = fields.push_back(quote { $packed_struct_name[$i] });\n            }\n\n            // We add the new auxiliary variable to the aux_vars array\n            aux_vars = aux_vars.push_back(packed_struct);\n        } else if typ.is_field() {\n            // For field we just add the value to fields\n            fields = fields.push_back(name);\n        } else if typ.as_integer().is_some() | typ.is_bool() {\n            // For integer and bool we just cast to Field and add the value to fields\n            fields = fields.push_back(quote { $name as Field });\n        } else if typ.as_data_type().is_some() {\n            // For struct we pref\n            let nested_struct = typ.as_data_type().unwrap();\n            let params = nested_struct.0.fields(nested_struct.1);\n            let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n                let maybe_prefixed_name = if name == quote {} {\n                    // Triggered when the param name is of a value available in the current scope (e.g. a function\n                    // argument) --> then we don't prefix the name with anything.\n                    param_name\n                } else {\n                    // Triggered when we want to prefix the param name with the `name` from function input. This\n                    // can typically be `self` when implementing a method on a struct.\n                    quote { $name.$param_name }\n                };\n                generate_serialize_to_fields(\n                    quote {$maybe_prefixed_name},\n                    param_type,\n                    omit,\n                    should_pack,\n                )\n            });\n            let struct_flattened_fields = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n            );\n            let struct_flattened_aux_vars = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n            );\n            fields = fields.append(struct_flattened_fields);\n            aux_vars = aux_vars.append(struct_flattened_aux_vars);\n        } else if typ.as_array().is_some() {\n            // For array we recursively call `generate_serialize_to_fields(...)` for each element\n            let (element_type, array_len) = typ.as_array().unwrap();\n            let array_len = array_len.as_constant().unwrap();\n            for i in 0..array_len {\n                let (element_fields, element_aux_vars) = generate_serialize_to_fields(\n                    quote { $name[$i] },\n                    element_type,\n                    omit,\n                    should_pack,\n                );\n                fields = fields.append(element_fields);\n                aux_vars = aux_vars.append(element_aux_vars);\n            }\n        } else if typ.as_str().is_some() {\n            // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n            // then we add each byte to fields as a Field\n            let length_type = typ.as_str().unwrap();\n            let str_len = length_type.as_constant().unwrap();\n            let as_member = name.as_expr().unwrap().as_member_access();\n            let var_name = if as_member.is_some() {\n                as_member.unwrap().1\n            } else {\n                name\n            };\n            let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n            let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n            for i in 0..str_len {\n                fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n            }\n            aux_vars = aux_vars.push_back(as_bytes);\n        } else {\n            panic(\n                f\"Unsupported type for serialization of argument {name} and type {typ}\",\n            )\n        }\n    }\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) =\n        generate_serialize_to_fields(quote { self }, typ, &[], packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "296": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "297": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "306": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize, ToField},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "310": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_delay_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initially equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation\n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the\n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a\n// reduced delay, invalidating prior private reads.\npub struct ScheduledDelayChange<let INITIAL_DELAY: u32> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option,\n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pub(crate) pre: Option<u32>,\n    pub(crate) post: Option<u32>,\n    // Block at which `post` value is used instead of `pre`\n    pub(crate) block_of_change: u32,\n}\n\nimpl<let INITIAL_DELAY: u32> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u32>, post: Option<u32>, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current block number - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_block_number: u32) -> u32 {\n        // The post value becomes the current one at the block of change, so any transaction that is included in the\n        // block of change will use the post value.\n        if current_block_number < self.block_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the block at which it will become the current\n    /// delay. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u32, u32) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.block_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current block number. This function is only meaningful\n    /// when called in public with the current block number.\n    /// The block at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u32, current_block_number: u32) {\n        let current = self.get_current(current_block_number);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let blocks_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior constraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value block of change\n            //       block                 block of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   blocks until change               new delay            |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.block_of_change = current_block_number + blocks_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical block number. It only returns a meaningful value when called in private with historical blocks. This\n    /// function can be used alongside `ScheduledValueChange.get_block_horizon` to properly constrain the\n    /// `max_block_number` transaction property when reading mutable shared state.\n    /// This value typically equals the current delay at the block following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is\n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_block_number: u32) -> u32 {\n        if self.block_of_change <= historical_block_number {\n            // If no delay changes were scheduled, then the delay value at the historical block (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // block of change the current delay will be the scheduled one, with an overall delay from the historical\n            // block number equal to the number of blocks until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //         block                  delay                  actual earliest value\n            //           v                block of change              block of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest block in            |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |         blocks                  new delay                      |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest block in\n            //                             which to scheduled value change\n            let blocks_until_change = self.block_of_change - (historical_block_number + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                blocks_until_change + self.post.unwrap_or(INITIAL_DELAY),\n            )\n        }\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Empty for ScheduledDelayChange<INITIAL_DELAY> {\n    fn empty() -> Self {\n        Self { pre: Option::none(), post: Option::none(), block_of_change: 0 }\n    }\n}\n"
    },
    "312": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_value_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some block\n// called the `block_of_change`. The value can only be made to change by scheduling a change event at some future block\n// of change after some minimum delay measured in blocks has elapsed. This means that at any given block number we know\n// both the current value and the smallest block number at which the value might change - this is called the\n// 'block horizon'.\npub struct ScheduledValueChange<T> {\n    pub(crate) pre: T,\n    pub(crate) post: T,\n    // Block at which `post` value is used instead of `pre`\n    pub(crate) block_of_change: u32,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given block. This function can be called both in public\n    /// (where `block_number` is simply the current block number, i.e. the number of the block in which the current\n    /// transaction will be included) and in private (where `block_number` is the historical block number that is used\n    /// to construct the proof).\n    /// Reading in private is only safe if the transaction's `max_block_number` property is set to a value lower or\n    /// equal to the block horizon (see `get_block_horizon()`).\n    pub fn get_current_at(self, block_number: u32) -> T {\n        // The post value becomes the current one at the block of change. This means different things in each realm:\n        // - in public, any transaction that is included in the block of change will use the post value\n        // - in private, any transaction that includes the block of change as part of the historical state will use the\n        //   post value (barring any follow-up changes)\n        if block_number < self.block_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the block at which it will become the current\n    /// value. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u32) {\n        (self.post, self.block_of_change)\n    }\n\n    // Returns the previous value. This is the value that is current up until the block of change. Note that this value\n    // might not be the current anymore since block of change might have already passed.\n    pub fn get_previous(self) -> (T, u32) {\n        (self.pre, self.block_of_change)\n    }\n\n    /// Returns the largest block number at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_block_number`,\n    /// since due to its asynchronous nature private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum number of blocks that need to\n    /// elapse from the next block until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical block number is only safe to use\n    /// if the transaction's `max_block_number` property is set to a value lower or equal to the block horizon computed\n    /// using the same historical block number.\n    pub fn get_block_horizon(self, historical_block_number: u32, minimum_delay: u32) -> u32 {\n        // The block horizon is the very last block in which the current value is known. Any block past the horizon\n        // (i.e. with a block number larger than the block horizon) may have a different current value. Reading the\n        // current value in private typically requires constraining the maximum valid block number to be equal to the\n        // block horizon.\n        if historical_block_number >= self.block_of_change {\n            // Once the block of change has been mined, the current value (post) will not change unless a new value\n            // change is scheduled. This did not happen at the historical block number (or else it would not be\n            // greater or equal to the block of change), and therefore could only happen after the historical block\n            // number. The earliest would be the immediate next block, and so the smallest possible next block of change\n            // equals `historical_block_number + 1 + minimum_delay`. Our block horizon is simply the previous block to\n            // that one.\n            //\n            //      block of      historical\n            //       change         block            block horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n            historical_block_number + minimum_delay\n        } else {\n            // If the block of change has not yet been mined however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the block horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the block of change is in the past: the time horizon is the\n            //      block prior to the earliest one in which a new block of change might land.\n            //\n            //         historical\n            //           block                        block horizon      block of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` blocks away from the historical block number, in which case\n            //      the block of change would become the limiting factor for the time horizon, which would equal the\n            //      block right before the block of change (since by definition the value changes at the block of\n            //      change).\n            //\n            //           historical                         block horizon\n            //             block     block of change       if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the block of change to an arbitrary\n            // value, and therefore scenario a) is not currently possible. However implementing #5501 would allow for\n            // this to happen.\n            // Because historical_block_number < self.block_of_change, then block_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.block_of_change - 1,\n                historical_block_number + minimum_delay,\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current block number. This function is only meaningful when\n    /// called in public with the current block number.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_block_number: u32,\n        minimum_delay: u32,\n        block_of_change: u32,\n    ) {\n        assert(block_of_change >= current_block_number + minimum_delay);\n\n        self.pre = self.get_current_at(current_block_number);\n        self.post = new_value;\n        self.block_of_change = block_of_change;\n    }\n}\n\nimpl<T> Eq for ScheduledValueChange<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n\nimpl<T> Empty for ScheduledValueChange<T>\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        Self { pre: T::empty(), post: T::empty(), block_of_change: 0 }\n    }\n}\n"
    },
    "314": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/shared_mutable_values.nr",
      "source": "use crate::{\n    hash::poseidon2_hash,\n    shared_mutable::{\n        scheduled_delay_change::ScheduledDelayChange, scheduled_value_change::ScheduledValueChange,\n    },\n    traits::{Hash, Packable},\n    utils::arrays,\n};\nuse std::meta::derive;\n\nmod test;\n\n/// SharedMutableValues is just a wrapper around ScheduledValueChange and ScheduledDelayChange that then allows us\n/// to wrap both of these values in WithHash. WithHash allows for efficient read of values in private.\n///\n/// Note that the WithHash optimization does not work in public (due to there being no unconstrained). But we also want\n/// to be able to read the values efficiently in public and we want to be able to read each value separately. Reading\n/// the values separately is tricky because ScheduledValueChange and ScheduledDelayChange are packed together (sdc and\n/// svc.block_of_change are stored in the same slot). For that reason we expose `unpack_value_change` and\n/// `unpack_delay_change` functions that can be used to extract the values from the packed representation. This\n/// is \"hacky\" but there is no way around it.\n#[derive(Eq)]\npub struct SharedMutableValues<T, let INITIAL_DELAY: u32> {\n    pub svc: ScheduledValueChange<T>,\n    pub sdc: ScheduledDelayChange<INITIAL_DELAY>,\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutableValues<T, INITIAL_DELAY> {\n    pub fn new(svc: ScheduledValueChange<T>, sdc: ScheduledDelayChange<INITIAL_DELAY>) -> Self {\n        SharedMutableValues { svc, sdc }\n    }\n}\n\npub fn unpack_value_change<T, let N: u32>(packed: [Field; 2 * N + 1]) -> ScheduledValueChange<T>\nwhere\n    T: Packable<N>,\n{\n    let svc_pre_packed = arrays::subarray(packed, 1);\n    let svc_post_packed = arrays::subarray(packed, N + 1);\n    ScheduledValueChange::new(\n        T::unpack(svc_pre_packed),\n        T::unpack(svc_post_packed),\n        packed[0] as u32,\n    )\n}\n\npub fn unpack_delay_change<let INITIAL_DELAY: u32>(\n    packed: Field,\n) -> ScheduledDelayChange<INITIAL_DELAY> {\n    // This function expects to be called with just the first field of the packed representation, which contains sdc\n    // and svc block_of_change. We'll discard the svc component.\n    let svc_block_of_change = packed as u32;\n\n    let mut tmp = (packed - svc_block_of_change as Field) / TWO_POW_32;\n    let sdc_block_of_change = tmp as u32;\n\n    tmp = (tmp - sdc_block_of_change as Field) / TWO_POW_32;\n    let sdc_post_is_some = tmp as bool;\n\n    tmp = (tmp - sdc_post_is_some as Field) / TWO_POW_8;\n    let sdc_post_inner = tmp as u32;\n\n    tmp = (tmp - sdc_post_inner as Field) / TWO_POW_32;\n    let sdc_pre_is_some = tmp as bool;\n\n    tmp = (tmp - sdc_pre_is_some as Field) / TWO_POW_8;\n    let sdc_pre_inner = tmp as u32;\n\n    ScheduledDelayChange {\n        pre: if sdc_pre_is_some {\n            Option::some(sdc_pre_inner)\n        } else {\n            Option::none()\n        },\n        post: if sdc_post_is_some {\n            Option::some(sdc_post_inner)\n        } else {\n            Option::none()\n        },\n        block_of_change: sdc_block_of_change,\n    }\n}\n\nglobal TWO_POW_32: Field = 2.pow_32(32);\nglobal TWO_POW_8: Field = 2.pow_32(8);\n\n// We pack to `2 * N + 1` fields because ScheduledValueChange contains T twice (hence `2 * N`) and we need one extra\n// field to store ScheduledDelayChange and the block_of_change of ScheduledValueChange.\nimpl<T, let INITIAL_DELAY: u32, let N: u32> Packable<2 * N + 1> for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; 2 * N + 1] {\n        let mut result = [0; 2 * N + 1];\n\n        // We pack sdc.pre, sdc.post, sdc.block_of_change and svc.block_of_change into a single field as follows:\n        // [ sdc.pre_inner: u32 | sdc.pre_is_some: u8 | sdc.post_inner: u32 | sdc.post_is_some: u8 | sdc.block_of_change: u32 | svc.block_of_change: u32 ]\n        result[0] = self.svc.block_of_change as Field\n            + ((self.sdc.block_of_change as Field) * 2.pow_32(32))\n            + ((self.sdc.post.is_some() as Field) * 2.pow_32(64))\n            + ((self.sdc.post.unwrap_unchecked() as Field) * 2.pow_32(72))\n            + ((self.sdc.pre.is_some() as Field) * 2.pow_32(104))\n            + ((self.sdc.pre.unwrap_unchecked() as Field) * 2.pow_32(112));\n\n        // Pack the pre and post values from ScheduledValueChange\n        let svc_pre_packed = self.svc.pre.pack();\n        let svc_post_packed = self.svc.post.pack();\n        for i in 0..N {\n            result[i + 1] = svc_pre_packed[i];\n            result[i + 1 + N] = svc_post_packed[i];\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; 2 * N + 1]) -> Self {\n        let svc = unpack_value_change::<T, N>(fields);\n        let sdc = unpack_delay_change::<INITIAL_DELAY>(fields[0]);\n        Self::new(svc, sdc)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32, let N: u32> Hash for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn hash(self) -> Field {\n        poseidon2_hash(self.pack())\n    }\n}\n"
    },
    "317": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "331": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n"
    },
    "335": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "336": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "352": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "353": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "355": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "361": {
      "path": "/home/nerses/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "390": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER},\n        hash::poseidon2_hash_with_separator,\n        traits::{Deserialize, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// The returned `PartialUintNote` value must be sent to public execution via a secure channel, since it is not\n    /// possible to verify the integrity of its contents due to it hiding information. The recommended ways to do this\n    /// are to retrieve it from public storage, or to receive it in an internal public function call.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient, sender);\n        context.emit_private_log(encrypted_log);\n\n        PartialUintNote { commitment }\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nimpl PartialUintNote {\n    pub fn commitment(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, value: u128, context: &mut PublicContext) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; 2] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "50": {
      "path": "/home/nerses/contracts/chains/aztec/contracts/train/src/lib.nr",
      "source": "pub fn bytes_to_u128_limbs(bytes: [u8; 32]) -> (u128, u128) {\n    let mut high: u128 = 0;\n    let mut low: u128 = 0;\n    for i in 0..16 {\n        high = (high << 8) + (bytes[i] as u128);\n    }\n    for i in 16..32 {\n        low = (low << 8) + (bytes[i] as u128);\n    }\n    (high, low)\n}\n\npub fn u128_limbs_to_bytes(high: u128, low: u128) -> [u8; 32] {\n    let mut bytes: [u8; 32] = [0; 32];\n\n    let mut temp = high;\n    for i in 0..16 {\n        bytes[15 - i] = (temp & 0xff) as u8;\n        temp >>= 8;\n    }\n\n    temp = low;\n    for i in 0..16 {\n        bytes[31 - i] = (temp & 0xff) as u8;\n        temp >>= 8;\n    }\n\n    bytes\n}\n"
    },
    "51": {
      "path": "/home/nerses/contracts/chains/aztec/contracts/train/src/main.nr",
      "source": "mod lib;\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract Train {\n    use crate::lib::{bytes_to_u128_limbs, u128_limbs_to_bytes};\n    use dep::aztec::messages::logs::note::encode_and_encrypt_note;\n    use dep::aztec::protocol_types::traits::{Packable, Serialize};\n    use dep::aztec::state_vars::{private_immutable::PrivateImmutable, SharedMutable};\n    use dep::sha256;\n    use dep::token::Token;\n    use aztec::macros::{\n        events::event,\n        functions::{initializer, internal, private, public, utility, view},\n        notes::note,\n        storage::storage,\n    };\n    use aztec::prelude::{AztecAddress, Map};\n    use std::meta::derive;\n\n    #[note]\n    #[derive(Eq)]\n    struct HTLC_Private {\n        owner: AztecAddress,\n        randomness: Field,\n    }\n    #[derive(Eq, Packable, Serialize)]\n    pub struct HTLC_Public {\n        src_receiver: AztecAddress,\n        amount: u128,\n        token: AztecAddress,\n        hashlock_high: u128,\n        hashlock_low: u128,\n        secret_high: u128,\n        secret_low: u128,\n        timelock: u64,\n        claimed: u8,\n    }\n\n    // TODO: Figure out how to emit all required data while staying within the public log size limit.\n    #[derive(Serialize)]\n    #[event]\n    struct TokenCommitted {\n        Id: Field,\n        amount: u128,\n        token: AztecAddress,\n        timelock: u64,\n        // dst_chain: str<8>,\n        // dst_asset: str<8>,\n        // dst_address: str<48>,\n        src_receiver: AztecAddress,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct TokenLockAdded {\n        Id: Field,\n        // hashlock: [u8; 32],\n        timelock: u64,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct TokenRefunded {\n        Id: Field,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct TokenLocked {\n        Id: Field,\n        // hashlock: [u8; 32],\n        amount: u128,\n        token: AztecAddress,\n        timelock: u64,\n        // dst_chain: str<8>,\n        // dst_asset: str<8>,\n        // dst_address: str<48>,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct TokenRedeemed {\n        Id: Field,\n        // hashlock: [u8; 32],\n        // secret: [u8; 32],\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor() {}\n\n    #[storage]\n    struct Storage<Context> {\n        contracts_private: Map<Field, PrivateImmutable<HTLC_Private, Context>, Context>,\n        contracts_public: Map<Field, SharedMutable<HTLC_Public, 3, Context>, Context>, // later block delay number can be changed to smth reasonable\n    }\n\n    #[private]\n    fn commit_private_user(\n        Id: Field,\n        src_receiver: AztecAddress,\n        timelock: u64,\n        token: AztecAddress,\n        amount: u128,\n        dst_chain: str<8>,\n        dst_asset: str<8>,\n        dst_address: str<48>,\n        randomness: Field,\n    ) {\n        assert(amount > 0, \"Funds Not Sent\");\n\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address())\n            .commit_public_user(\n                dst_chain,\n                dst_asset,\n                dst_address,\n                Id,\n                src_receiver,\n                timelock,\n                token,\n                amount,\n            )\n            .enqueue(&mut context);\n\n        let htlc_note = HTLC_Private { owner: context.msg_sender(), randomness: randomness };\n        storage.contracts_private.at(Id).initialize(htlc_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n\n        Token::at(token)\n            .transfer_in_private(context.msg_sender(), context.this_address(), amount, randomness)\n            .call(&mut context);\n    }\n\n    #[internal]\n    #[public]\n    fn commit_public_user(\n        dst_chain: str<8>,\n        dst_asset: str<8>,\n        dst_address: str<48>,\n        Id: Field,\n        src_receiver: AztecAddress,\n        timelock: u64,\n        token: AztecAddress,\n        amount: u128,\n    ) {\n        assert(context.timestamp() + 900 < timelock, \"InvalidTimelock\");\n        let htlc_public = HTLC_Public {\n            src_receiver: src_receiver,\n            amount: amount,\n            token: token,\n            hashlock_high: 0 as u128,\n            hashlock_low: 0 as u128,\n            secret_high: 0 as u128,\n            secret_low: 0 as u128,\n            timelock: timelock,\n            claimed: 1 as u8,\n        };\n        storage.contracts_public.at(Id).schedule_value_change(htlc_public);\n        let log_msg = TokenCommitted {\n            Id: Id,\n            amount: amount,\n            token: token,\n            timelock: timelock,\n            // dst_chain: dst_chain,\n            // dst_asset: dst_asset,\n            // dst_address: dst_address,\n            src_receiver: src_receiver,\n        };\n        context.emit_public_log(log_msg);\n    }\n\n    #[private]\n    fn add_lock_private_user(Id: Field, hashlock: [u8; 32], timelock: u64) {\n        let htlc_private = storage.contracts_private.at(Id).get_note();\n        assert(htlc_private.owner == context.msg_sender(), \"NoAllowance\");\n\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address()).add_lock_public_user(Id, hashlock, timelock).enqueue(\n            &mut context,\n        );\n    }\n\n    #[internal]\n    #[public]\n    fn add_lock_public_user(Id: Field, hashlock: [u8; 32], timelock: u64) {\n        assert(context.timestamp() + 900 < timelock, \"InvalidTimelock\");\n\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n        assert(htlc_public.hashlock_high == (0 as u128), \"HashlockAlreadySet\");\n        assert(htlc_public.hashlock_low == (0 as u128), \"HashlockAlreadySet\");\n\n        let hashlock_tuple = bytes_to_u128_limbs(hashlock);\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: hashlock_tuple.0,\n            hashlock_low: hashlock_tuple.1,\n            secret_high: htlc_public.secret_high,\n            secret_low: htlc_public.secret_low,\n            timelock: timelock,\n            claimed: htlc_public.claimed,\n        };\n        storage.contracts_public.at(Id).schedule_value_change(modified_htlc_public);\n        // let log_msg = TokenLockAdded { Id, hashlock, timelock };\n        let log_msg = TokenLockAdded { Id, timelock };\n        context.emit_public_log(log_msg);\n    }\n\n    #[private]\n    fn refund_private(Id: Field, randomness: Field) {\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address()).refund_public(Id).enqueue(&mut context);\n\n        let htlc_private = storage.contracts_private.at(Id).get_note();\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n\n        // Token::at(htlc_public.token)\n        //     .transfer_in_private(context.this_address(), htlc_private.owner, htlc_public.amount, 0)\n        //     .call(&mut context);\n        Token::at(htlc_public.token).transfer(htlc_private.owner, htlc_public.amount).call(\n            &mut context,\n        );\n    }\n\n    #[public]\n    #[internal]\n    fn refund_public(Id: Field) {\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n        assert(htlc_public.timelock < context.timestamp(), \"NotPassedTimelock\");\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: htlc_public.hashlock_high,\n            hashlock_low: htlc_public.hashlock_low,\n            secret_high: htlc_public.secret_high,\n            secret_low: htlc_public.secret_low,\n            timelock: htlc_public.timelock,\n            claimed: 2 as u8,\n        };\n\n        storage.contracts_public.at(Id).schedule_value_change(modified_htlc_public);\n        let log_msg = TokenRefunded { Id };\n        context.emit_public_log(log_msg);\n    }\n\n    #[private]\n    fn lock_private_solver(\n        Id: Field,\n        hashlock: [u8; 32],\n        amount: u128,\n        timelock: u64,\n        token: AztecAddress,\n        randomness: Field,\n        dst_chain: str<8>,\n        dst_asset: str<8>,\n        dst_address: str<48>,\n    ) {\n        assert(amount > 0, \"FundsNotSent\");\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address())\n            .lock_public_solver(\n                Id,\n                hashlock,\n                amount,\n                token,\n                timelock,\n                dst_chain,\n                dst_asset,\n                dst_address,\n            )\n            .enqueue(&mut context);\n\n        let htlc_note = HTLC_Private { owner: context.msg_sender(), randomness: randomness };\n        storage.contracts_private.at(Id).initialize(htlc_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n\n        Token::at(token)\n            .transfer_in_private(context.msg_sender(), context.this_address(), amount, randomness)\n            .call(&mut context);\n    }\n\n    #[internal]\n    #[public]\n    fn lock_public_solver(\n        Id: Field,\n        hashlock: [u8; 32],\n        amount: u128,\n        token: AztecAddress,\n        timelock: u64,\n        dst_chain: str<8>,\n        dst_asset: str<8>,\n        dst_address: str<48>,\n    ) {\n        assert(context.timestamp() + 2700 < timelock, \"InvalidTimelock\");\n        let hashlock_tuple = bytes_to_u128_limbs(hashlock);\n        let htlc_public = HTLC_Public {\n            src_receiver: AztecAddress::zero(),\n            amount: amount,\n            token: token,\n            hashlock_high: hashlock_tuple.0,\n            hashlock_low: hashlock_tuple.1,\n            secret_high: 0 as u128,\n            secret_low: 0 as u128,\n            timelock: timelock,\n            claimed: 1 as u8,\n        };\n        storage.contracts_public.at(Id).schedule_value_change(htlc_public);\n\n        let log_msg = TokenLocked {\n            Id: Id,\n            // hashlock: hashlock,\n            amount: amount,\n            token: token,\n            timelock: timelock,\n            // dst_chain: dst_chain,\n            // dst_asset: dst_asset,\n            // dst_address: dst_address,\n        };\n\n        context.emit_public_log(log_msg);\n    }\n\n    #[private]\n    fn redeem_private(Id: Field, secret: [u8; 32], randomness: Field) {\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address()).redeem_public(Id, secret).enqueue(&mut context);\n\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n\n        if htlc_public.src_receiver == AztecAddress::zero() {\n            // Token::at(htlc_public.token)\n            //     .transfer_in_private(\n            //         context.this_address(),\n            //         context.msg_sender(),\n            //         htlc_public.amount,\n            //         0 as Field,\n            //     )\n            //     .call(&mut context);\n            Token::at(htlc_public.token).transfer(context.msg_sender(), htlc_public.amount).call(\n                &mut context,\n            );\n        } else {\n            // Token::at(htlc_public.token)\n            //     .transfer_in_private(\n            //         context.this_address(),\n            //         htlc_public.src_receiver,\n            //         htlc_public.amount,\n            //         0 as Field,\n            //     )\n            //     .call(&mut context);\n            Token::at(htlc_public.token)\n                .transfer(htlc_public.src_receiver, htlc_public.amount)\n                .call(&mut context);\n        }\n    }\n\n    #[public]\n    #[internal]\n    fn redeem_public(Id: Field, secret: [u8; 32]) {\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public.amount > 0, \"HTLCNotExists\"); // If it doesn't exist, all parameters will default to zero values.\n        let hashed_secret = sha256::sha256_var(secret, secret.len() as u64);\n        let hashed_secret_tuple = bytes_to_u128_limbs(hashed_secret);\n        assert(htlc_public.hashlock_high == hashed_secret_tuple.0, \"HashlockNotMatch\");\n        assert(htlc_public.hashlock_low == hashed_secret_tuple.1, \"HashlockNotMatch\");\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n        let secret_limbs = bytes_to_u128_limbs(secret);\n\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: htlc_public.hashlock_high,\n            hashlock_low: htlc_public.hashlock_low,\n            secret_high: secret_limbs.0,\n            secret_low: secret_limbs.1,\n            timelock: htlc_public.timelock,\n            claimed: 3 as u8,\n        };\n\n        storage.contracts_public.at(Id).schedule_value_change(modified_htlc_public);\n\n        let log_msg = TokenRedeemed {\n            Id: Id,\n            // hashlock: u128_limbs_to_bytes(htlc_public.hashlock_high, htlc_public.hashlock_low),\n            // secret: secret,\n        };\n\n        context.emit_public_log(log_msg);\n    }\n\n    // This utility function should be invoked by the frontend before each function call\n    // where the existence or non-existence of an HTLC is a critical security check.\n    #[utility]\n    unconstrained fn is_contract_initialized(Id: Field) -> bool {\n        storage.contracts_private.at(Id).is_initialized()\n    }\n\n    #[view]\n    #[public]\n    fn get_htlc_public(key: Field) -> pub HTLC_Public {\n        storage.contracts_public.at(key).get_current_value()\n    }\n\n}\n"
    },
    "52": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
    },
    "53": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "60": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "61": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(gas_for_call(gas_opts), contract_address, calldata);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(gas_for_call(gas_opts), contract_address, calldata);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_opcode(gas, address, args)\n}\n\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "62": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "63": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "67": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "79": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "82": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/keys/ecdh_shared_secret.nr",
      "source": "use dep::protocol_types::{\n    address::aztec_address::AztecAddress, point::Point, scalar::Scalar, traits::FromField,\n};\nuse std::{embedded_curve_ops::multi_scalar_mul, ops::Neg};\n\n/// Computes a standard ecdh shared secret: [secret] * public_key = shared_secret.\n/// The input secret is known only to one party. The output shared secret is derivable\n/// by both parties, through this function.\n/// E.g.:\n/// Epk = esk * G // ephemeral keypair\n/// Pk = sk * G // recipient keypair\n/// Shared secret S = esk * Pk = sk * Epk // see how this function can be called with two different sets of inputs, depending on which secret the caller knows (either esk or sk)?\n// See also: https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman\npub fn derive_ecdh_shared_secret(secret: Scalar, public_key: Point) -> Point {\n    let shared_secret = multi_scalar_mul([public_key], [secret]);\n    shared_secret\n}\n\n/// Computes a standard ecdh shared secret using the address public key of the given address:\n/// [ephemeral_secret] * recipient_address_public_key = shared_secret.\n/// The intention is that the _creator_ of a shared secret would call this function,\n/// given the address of their intended recipient.\npub fn derive_ecdh_shared_secret_using_aztec_address(\n    ephemeral_secret: Scalar,\n    recipient_address: AztecAddress,\n) -> Point {\n    derive_ecdh_shared_secret(ephemeral_secret, recipient_address.to_address_point().inner)\n}\n\n#[test]\nunconstrained fn test_consistency_with_typescript() {\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let shared_secret = derive_ecdh_shared_secret(secret, point);\n\n    // This is just pasted from a test run.\n    // The original typescript code from which this could be generated seems to have been deleted by someone, and soon the typescript code for encryption and decryption won't be needed, so this will have to do.\n    let hard_coded_shared_secret = Point {\n        x: 0x15d55a5b3b2caa6a6207f313f05c5113deba5da9927d6421bcaa164822b911bc,\n        y: 0x0974c3d0825031ae933243d653ebb1a0b08b90ee7f228f94c5c74739ea3c871e,\n        is_infinite: false,\n    };\n    assert_eq(shared_secret, hard_coded_shared_secret);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let shared_secret = derive_ecdh_shared_secret(secret_a, pk_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_from_address_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let mut pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let mut pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let address_b = AztecAddress::from_field(pk_b.x);\n\n    // We were lazy in deriving the secret keys, and didn't check the resulting y-coordinates\n    // of the pk_a or pk_b to be less than half the field modulus.\n    // If needed, we negate the pk's so that they yield valid address points.\n    // (We could also have negated the secrets, but there's no negate method for\n    // EmbeddedCurvesScalar).\n    pk_a = if (AztecAddress::from_field(pk_a.x).to_address_point().inner == pk_a) {\n        pk_a\n    } else {\n        pk_a.neg()\n    };\n    pk_b = if (address_b.to_address_point().inner == pk_b) {\n        pk_b\n    } else {\n        pk_b.neg()\n    };\n\n    let shared_secret = derive_ecdh_shared_secret_using_aztec_address(secret_a, address_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n"
    },
    "83": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/keys/ephemeral.nr",
      "source": "use std::embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul};\n\nuse dep::protocol_types::{point::Point, scalar::Scalar};\n\nuse crate::oracle::random::random;\n\npub fn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n\n    // Safety: we use the randomness to preserve the privacy of both the sender and recipient via encryption, so a\n    // malicious sender could use non-random values to reveal the plaintext. But they already know it themselves anyway,\n    // and so the recipient already trusts them to not disclose this information. We can therefore assume that the\n    // sender will cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // TODO(#12757): compute the key pair without constraining eph_sk twice (once in from_field, once in the black box\n    // called by fixed_base_scalar_mul).\n    let eph_sk = EmbeddedCurveScalar::from_field(randomness);\n    let eph_pk = fixed_base_scalar_mul(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n"
    },
    "84": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "88": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_notes` utility function PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_notes = generate_sync_notes();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_notes\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_notes() -> Quoted {\n    // TODO(https://github.com/noir-lang/noir/issues/7912): Doing the following unfortunately doesn't work. Once\n    // the issue is fixed uncomment the following and remove the workaround from TS (look for the issue link in the\n    // codebase).\n    // let utility: fn(FunctionDefinition) -> () = crate::macros::functions::utility;\n    // quote {\n    //     #[$utility]\n    //     unconstrained fn sync_notes() {\n    //     }\n    // }\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[aztec::macros::functions::utility]\n        unconstrained fn sync_notes() { }\n    }\n}\n"
    },
    "89": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "92": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_slice, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_view,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_SLICE_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args =  &[];\n    // serialized_args = serialized_args.append(aztec::protocol_types::traits::Serialize::serialize(target_address));\n    // serialized_args = serialized_args.push_back(fee_juice_limit_per_tx as Field);\n    // ```\n    let serialized_args_slice_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_SLICE_NAME = &[];\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append = add_to_field_slice(SERIALIZED_ARGS_SLICE_NAME, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n"
    },
    "93": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "96": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, &[], false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "98": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, &[], true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "99": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\nuse super::utils::is_note;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract. Only a single struct in the entire contract\n/// should have this macro (or `storage_no_init`) applied to it.\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot }, false);\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n/// Only a single struct in the entire contract should have this macro (or `storage`) applied to it.\npub comptime fn storage_no_init(_s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(\n    typ: Type,\n    slot: Quoted,\n    parent_is_map: bool,\n) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot }, true);\n        (quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }, 1)\n    } else {\n        let storage_size = if parent_is_map {\n            // Variables inside a map do not require contiguous slots since the map slot derivation is assumed to result\n            // in slots very far away from one another.\n            1\n        } else {\n            let (_, container_struct_generics) = typ.as_data_type().unwrap();\n            let stored_struct = container_struct_generics[0];\n\n            if is_note(stored_struct) {\n                // Private notes always occupy a single slot, since the slot is only used as a state variable\n                // identifier.\n                1\n            } else {\n                get_storage_size(typ)\n            }\n        };\n\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        (quote { $struct_name::new(context, $slot)}, storage_size)\n    }\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    }
  }
}
