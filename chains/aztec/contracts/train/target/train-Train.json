{
  "transpiled": true,
  "noir_version": "1.0.0-beta.3+0000000000000000000000000000000000000000",
  "name": "Train",
  "functions": [
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "772057049813214347": {
            "error_kind": "string",
            "string": "HTLCNotExists"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2570651705007895968": {
            "error_kind": "string",
            "string": "HashlockNotMatch"
          },
          "2722406262643068352": {
            "error_kind": "string",
            "string": "HashlockAlreadySet"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3559210201980528457": {
            "error_kind": "string",
            "string": "Function commit_public_user can only be called internally"
          },
          "3564161243949231814": {
            "error_kind": "string",
            "string": "Function refund_public can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "9323748002447105156": {
            "error_kind": "string",
            "string": "NotPassedTimelock"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "15001264570739363109": {
            "error_kind": "string",
            "string": "Function lock_public_solver can only be called internally"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16870384257694633552": {
            "error_kind": "string",
            "string": "Function add_lock_public_user can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17814817983036354427": {
            "error_kind": "string",
            "string": "Function redeem_public can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "redeem_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2588366281349374274": {
            "error_kind": "fmtstring",
            "length": 136,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "3473764466780631008": {
            "error_kind": "fmtstring",
            "length": 106,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5533887251808526417": {
            "error_kind": "fmtstring",
            "length": 120,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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Ye3IO6wdeYe1I++wduQd1o68w9qRd1g78g7rRt5h3cg7rBt5h3Uj77Bu5B3WjbzDupF3WDfyDutG3mHdyDusH3mH9SPvsH7kHdaPvMP6kXdYP/IO60feYf3IO6wfeYf1I++wNPIOSyPvsDTyDksj77A08g5LI++wNPIOSyPvsDTyDksj77Bh5B02jLzDhpF32DDyDhtG3mHDyDtsGHmHDSPvsGHkHTaMvMPGkXfYOPIOG0feYePIO2wceYeNI++wceQdNo68w8aRd9g48g6bRt5h08g7bBp5h00j77Bp5B02jbzDppF32DTyDptG3mHTyDtsHnmHzSPvsHnkHTaPvMPmkXfYPPIOm0feYfPIO6zonk5V4UfeYUfu6RRG7ukURu7pFEbu6RRG7ukURu7pFEbu6RRG7ukURu7pFEbu6RRH7ukUR+7pFEfu6RRH7ukUzcA7bBy5p1McuadTHLmnUxy5p1McuadTHLmnUxy5p1McuadTHLmnUxy5p1McuadTHLmnUxy5p1McuadTHLmnUxy5p1McuadTHLmnUxy5p1McuadTHLmnUxy5p1McuadTHLmnUxy5p1McuadTHLmnUxy5p1McuadTHLmnUxy5p1McuadTHLmnUxy5p1McuadTHLmnUxy5p1McuadTHLmnUxy5p1McuadTHLmnUxy5p1McuadTHLmnUxy5p1McuadTHLmnUxy5p1McuadTHLmnUxy5p1McuadTHLmnUxy5p1McuadTHLmnUxy5p1McuadTHLmnUxy5p1McuadTHLmnUxy5p1McuadTHLmnUxy5p1McuadTHLmnUxy5p1McuadTHLmnUxy5p1McuadTHLmnUxy5p1McuadTHLmnUxy5p1McuadTHLmnUxy5p1McuadTHLmnUxy5p1MU3dMpZVqEz778EH7rarteHJ/ESN+KSt6NWRWVvHOzKip5l2dVlAQrami5OJpMGwuM5IjAmPh9ccoxVaz05w3676tDDk82dVtXZ5sWQbItj992KX+DkRxtXApGciRzKRjJUdKlYCRHYBeCSaL7iV0KRnI0eCkYydHjpWDERJt3cUiWOGKivLs4YmKruzhiIpq7OGLiiLs4YnbvL3HkdAi7iyNmp7qLI2Z/uIsja1WW02nrLo6sVVlON6y7OLJWZTkdq+7iyFqV5XSVuosja1WW0/npLo6sVVlOd6a7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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "add_lock_private_user",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2588366281349374274": {
            "error_kind": "fmtstring",
            "length": 136,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "3473764466780631008": {
            "error_kind": "fmtstring",
            "length": 106,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5533887251808526417": {
            "error_kind": "fmtstring",
            "length": 120,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17476367995570638746": {
            "error_kind": "string",
            "string": "NoAllowance"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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NPG5miY+V0/vH8wp+8Tnapr4XE0Tn6tp4nM1TXyu5onP1TzxuZonPlfzxOfq6f1lOWWf+FzNE5+reeJzNU98ruaJz9Uy8blaJj5Xy8Tnapn4XD29/yin7BOfq2Xic7VMfK6Wic/VMu+5ms2852o2856r2cx7rmYz77mazbznajbznqvZzHuuZjPvuZrNvOdqNhOfq3bic9VOfK7aic9VO/G5enr/Qk7ZJz5X7cTnqp34XLUTn6t24nPVTXyuuonPVTfxueomPldP72/HKfvE56qb+Fx1E5+rbuJz1U18rvqJz1U/8bnqJz5X/cTn6un9zzhln/hc9ROfq37ic9VPfK76ic9VmvhcpYnPVZr4XKWJz9XT+2Nxyj7xuUoTn6s08blKE5+rNPG5GiY+V8PE52qY+FyduN9SnrjfUp6431KeuN9SnrjfUp6431KeuN9SnrjfUp6431KeuN9SnrjfUp6431KeuN9SnrjfUp6431KeuN9SnrjfUp6431KeuN9SnrjfUp6431KeuN9SnrjfUp6431KeuN9SnrjfUp6431KeuN9SnrjfUp6431KeuN9SnrjfUp6431KeuN9SnrjfUp6431KeuN9SnrjfUp6431KeuN9SnrjfUp6431KeuN9SnrjfUp6431KeuN9SnrjfUpm431KZuN9SmbjfUpm431Ix856rZeJ+S2Xifktl4n5LZeJ+S2Xifktl4n5LZeJ+S2Xifktl4n5LZeJ+S2Xifktl4n5LZeJ+S2Xifktl4n5LZeJ+S2Xifktl4n5LZeJ+S2Xifktl4n5LZeJ+S2Xifktl4n5LZeJ+S2Xifktl4n5LZeJ+S2Xifktl4n5LZeJ+S2Xifktl4n5LZeJ+S2Xifktl4n5LZeJ+S2Xifktl4n5LZeJ+S2Xifktl4n5LZeJ+S2Xifktl4n5LZeJ+S2Xifktl4n5LZeJ+S2Xifktl4n5LZeJ+S2Xifktl4n5LZeJ+S2Xifktl4n5LZeJ+S2Xifktl4n5LZeJ+S2Xifktl4n5LZeJ+S2Xifktl4n5LZeJ+S2Xifktl4n5LZeJ+S2Xifktl4n5LZeJ+S0V0v6XkrP26OLkU3l9sKdHXxTZYv19sc65hMXmj4uLDtelORfKJfRkV0T2irqMiOcq4jork+OU6KpIjo+uoEKhUqEiO5q6jIjlOvI6K5Aj0OiqIbWtUENtWqIju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",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert"
      ],
      "verification_key": "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"
    },
    {
      "name": "lock_private_solver",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 48
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2588366281349374274": {
            "error_kind": "fmtstring",
            "length": 136,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "3473764466780631008": {
            "error_kind": "fmtstring",
            "length": 106,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5533887251808526417": {
            "error_kind": "fmtstring",
            "length": 120,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6418028854678020178": {
            "error_kind": "string",
            "string": "FundsNotSent"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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9w/mtH3iczVNfK6mic/VNPG5miY+V/PE52qe+FzNE5+reeJzdXh/WU7bJz5X88Tnap74XM0Tn6t54nO1THyulonP1TLxuVomPleH9x/ltH3ic7VMfK6Wic/VMvG5WuY9V7OZ91zNZt5zNZt5z9Vs5j1Xs5n3XM1m3nM1m3nP1WzmPVezmfdczWbic9VOfK7aic9VO/G5aic+V4f3L+S0feJz1U58rtqJz1U78blqJz5X3cTnqpv4XHUTn6tu4nN1eH87TtsnPlfdxOeqm/hcdROfq27ic9VPfK76ic9VP/G56ic+V4f3P+O0feJz1U98rvqJz1U/8bnqJz5XaeJzlSY+V2nic5UmPleH98fitH3ic5UmPldp4nOVJj5XaeJzNUx8roaJz9Uw8bk6cb+lPHG/pTxxv6U8cb+lPHG/pTxxv6U8cb+lPHG/pTxxv6U8cb+lPHG/pTxxv6U8cb+lPHG/pTxxv6U8cb+lPHG/pTxxv6U8cb+lPHG/pTxxv6U8cb+lPHG/pTxxv6U8cb+lPHG/pTxxv6U8cb+lPHG/pTxxv6U8cb+lPHG/pTxxv6U8cb+lPHG/pTxxv6U8cb+lPHG/pTxxv6U8cb+lPHG/pTxxv6U8cb+lPHG/pTxxv6U8cb+lPHG/pTJxv6Uycb+lMnG/pTJxv6Vi5j1Xy8T9lsrE/ZbKxP2WysT9lsrE/ZbKxP2WysT9lsrE/ZbKxP2WysT9lsrE/ZbKxP2WysT9lsrE/ZbKxP2WysT9lsrE/ZbKxP2WysT9lsrE/ZbKxP2WysT9lsrE/ZbKxP2WysT9lsrE/ZbKxP2WysT9lsrE/ZbKxP2WysT9lsrE/ZbKxP2WysT9lsrE/ZbKxP2WysT9lsrE/ZbKxP2WysT9lsrE/ZbKxP2WysT9lsrE/ZbKxP2WysT9lsrE/ZbKxP2WysT9lsrE/ZbKxP2WysT9lsrE/ZbKxP2WysT9lsrE/ZbKxP2WysT9lsrE/ZbKxP2WysT9lsrE/ZbKxP2WysT9lsrE/ZbKxP2WysT9lsrE/ZbKxP2WysT9lsrE/ZbKxP2WysT9lorofkvJWft1cXIpXF9sKdHXxTZYv19scz7CYvJGxcWna9OdiuQT+2NURPeI+hwVySrjc1Qk65fPUZGsjD5HhUDlgIpkNfc5KpJ14ueoSFagn6MCbXtEBdr2gIroPm2fowJte0Rl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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "notify_created_nullifier_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "debug_log_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_integer_quotient",
        "directive_invert"
      ],
      "verification_key": "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"
    },
    {
      "name": "commit_public_user",
      "is_unconstrained": true,
      "custom_attributes": [
        "internal",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 48
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "src_receiver",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3559210201980528457": {
            "error_kind": "string",
            "string": "Function commit_public_user can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7Z3bjhu3sobfZa59wSJZPORVFjaCHLwWDBh24CQb2Ajy7rsludk9aVIl1Wq1KFbdBDNx/8Pix+KpePrr7dePP//5nx8/ffn319/ffvjXX2+fv/7y0x+fvn6Zfvvr7w9vP3/79Pnzp//8uP7fb+b0nwzxLPj9t5++nH7//Y+fvv3x9kOMKX54+/jl17cfEkCc/sS/P33++PYDWPP3/3x4yxZYqsBROctSsdLyrHx5FkNkpYWsfAVWWgFrKnAWzXcZOJfwne7D9ntj7fy58Xb5+pTi5msfAnz/2odoytcBKx8nNDhnAC2sPz7ZH80+9uc8fw6Qj7R/J/6YCv9E8QeMs09AcO66/RnznNkcnP+n/cntbT/Y9/afUslwSCrVejf5Qy4yayAQqfjk/OwdaVUXGt4RbfGOFP9BF4ypZ9yu6pt9V+HqJu3nsJNJt1Dy/p8tDRgArjAzhdbXhC7CrHPRLU6DNRrBovv+cbDBE+iymYs+ZWs36Gwm7fFubc9ZVe/mKFW9myNVrLTQs1Q0DfQbVfAcVbQsVbXT9+Dm5tND8Nf9ZzLYLT3LAgEC1L5OYf44p/Ktg+/2JOjMntCXPbkzPrkvPmD64jM1AZ3Zk/uyB3xn9qSj7cHZnmnE886e7bcx+3ncEnNe/rKNqfK1K3/Z22VAZH3lUwt57tWtBbv++EzFZaWypeK9UqlQ0RpUoYJWqVSoRKWypRLUV2pUglLZUqkHB8VT0Z65RkV75gqVpK1tjYq2thUqx0dfXoIKKpUKFZ0zb6lMixhKpUJFe+YKFdCeuUZF58wVKlZ75hoV7ZkrVJzOmWtUtGeuUdGeuULFO6VSoaI9c4UKas9co6LxlQqVKNNXrFuoeNxQyTLnQRHmDcs2rrbwFioyW9vrVJyRWYMoKjLnQRQVmRFKggrIHNtSVLS1rVCx2jPXqKivVKg47ZlrVHbomSEth2RWw+c6FcQ4fx0SrI8VudrfzjhzgRxXX08/n+3fIxLyTPv3mJ0/1f782vYHOuqazXX7rbNl+ugCvEuj8vVivw3GEF/7UKqvD+vzZ9WvI6bZkhjMQrJ6kiwux86mH/956nIik5RMnUx0SqZBRn2mQSapz7TIqM80yGT1mRYZ9Zk6GW+skmmQiUqmTgZAyTTIZCVTJ3PDziahZG7Y3SSVjPpMi4y2Mw0yN5zxFkoGBftMMoVM2lwf5ZPcFtiFsozgYoXMWLUpLmQsceWYW+4dmVYNl1vQ3LQmckEz1pRyTzSDxSF2RTPWpHJHNGjGmlXuiiYomgYaGKvv3hWNdt5NNGONhfdEM1ig5h40NtiCJpkKGrleQ6FxctsaEo16TQvNYMGaXdGo17TQoHpNE416TQtNkBuUINHIDWVRaOJY2yP2RDNY1HxXNHLjNRSaLDfKR6IR7DV5XqBzDvw7NPd9fQI5ZUVB7gNScCxoX5CCx+W7ggTBo/h9QQoe8+8K0qlH3gQSTDmxenrTa/kav4OUHNa5D2R5OQ/M6uW8BeTrVu2z/eF159wX+193j8fZ/tj7FC3O+xx9NIn4emqgy7OUAZdnVB3Mue191rVrbrsP2uyb2967lF1zm0WVbe59brpnbmP3IY19cyup3kbT+3ht19xC76O7fXPb+1hw19zasUaOqTxJHyFVcjvWyJHIrRNVtt0fPdw3t72Hp3fNre89YrdvbscaXRC5RVFli2ONLojcBlE9UBDVA8Wx5rdUbv1IuY2YS26Tr+R2qNEFldvuL27bN7dD9UBUbvNQsQsyt5LKNnV//Hjf3A41uiBzK6kHSt3vkdo3t6JaqbEirGRuRbVS3R8v3jW33e+b2ze3Y7VS5VW4yWvNNrd+rHEylduh1oGo3OJQkRoyt2P1QERug6iy7f4pj31zO9Q6EJXb7s/t7ptbUT3QWHtYydyKaqW6v1Vz19wOFk+mciuplcpj7dhNzpTculzJ7VD1lsrtWHtY17ldH8wruR0qdkHl1ooqW9tT2Z4t6mqf6cWinvqts0W+p77lYpHvzqKeoulni7ram3ixqLva39XZ34tF3dX+rvbKXSzqKUp6sai72t/VvrCLRT2N2c8WdTUfvljUWe23pqt9SheLOqv9k0Wd1X5rurqL/2JRZ7Xfmq5mXheLOhsfWdPb7GiyqLva39vsaLKou9rf1amws0W9zY4mi7qr/V2dgLpY1N34qLfZ0WRRd7W/t9mRNb3NjiaLuqv9vc2OJot6q/3Q1arbxaLexkfQ3ewIujqxcLGot/ERdDc7gq7uPzlb1N3sCLqbHUFXd32cLepudgTdzY4Au6v93c2OoLvZEXR1h8PZou5mR3D87Cg4KBahI75GtPN7mYhI/e07H19P81aO6K29/vE0RoqzIQDe5PXnZ5DHb4u9E2Sat6JgsNT92VN2ZjZ2WoMtX3/fuDL9M0rKbR6qbKfszn/bIlZyO1TZTk1cyW3YbCa0UwR9pNw6U/62A6jkNknKLYgqWxirbC0WS7BSb+1YZbuyJLptbo+fWj8yt97MF9naKQuV3AZJufWiytaPVba2jC48pm1ucayyLZMx62OlBzr+/eOH5jaXcTKaStkef4D5qbkVVbbdh0Xuyi3a0iavgyhLbocqW7Tlb2PYzm/t8UvLD81tdkuAz29ze/yy9VNzK6lsnRmqbMMSlwo+VXI7VNmGJS4VwrZNdjBUFG65knkaSMRtbu1QEVYyt6LK1g1VtlSb7Lyosh1q5Ejl1osqWz/WjO96XMrhUPFkYn7rcKi1Aiq3QVTZHn/VXEhlrSaCIb4OpnwdTH63kWL7cUpuzmxKuNl1Ma2VPDWv+d3XF4tSbxal7hgdf/Q5+lwsilR9hBzm+miNWfUVU2072e+Pj/zmpT3JuCXqj4/OUhbF7hgl251Fh0c0cij1IK/GfPWvk/dzPUj+3Rq8qdYaU3bIZQ/vvj7n9vhI5FNzO9Z1e1cvWJ/GIYIeRphyK6psQVTZgqiylfSgyZRbUWU71pPRZG5Fla0XVbaDPfFB5BZFlS2KKtuxHlEmcyuqbKOosh3s0Qsit0lU2SZRZZtFla2ouFQQFZcKouJSQVRcKoiKSwVRcakgKi4VRMWlgqi4VBAVlwqi4lJBVFwqiIpLBVFxqSAqLhWOj0vttu/iYj++uP35te0/fv/gzva/7i6rs/35xetvfvH6m1+7/kbz2vU3mteuvxFeu/5GeO36G+HF66/1L25/em373evuW77YH17b/uMfFNrZ/hevv/7F20988fHP4Vd9OxPm81vORCS+DujnaMUURqJiG7nc0Jzz6qTj6Rzg1g4s52emH+0mshEPj1q9DpkglUxy87kclyr3/cYo1meynf+yyw4qZMT6DEUmqc+0yKCSaZDJSqZOJjsl0yCTlEyVTDLqMy0yYmcHFBkQ22uncv/GRAYrZHR2cCKzfeklWbkjPVxqU6r4jJU7O0i5kKnck5acXJ+hyKjPNMgcHtN+HTJeyTTIyJ0dEGRQ7uyAIqM+0yATrJJpkJHba+N8R6w3pjKjlLt2sMybJjK2Qkaqz3gDuZAJZktG7NrBhMMXMrHiM0muzxBksvpMi4zU9SaajNT1JopMFrt2QJOROjsgyYD6TIuM1PUmkozYtYNpDJwWMqFCRtebTmS2c+0sdu3Am1xqE1iskBE7OwBbZpRTbrdkvFifIcmozzTIoNT1JpqMVzINMmJnBxSZIHZ2QJJRn2mQiVLXm2gycuPA5S1RD74yo5R77mA1bwLvKmTkjvTK22Temu16U5a7dmBNmVFaqNSmLNZnrpNxxqjPtMiIXW8iyYhdb6LIyF07IMmInR1QZKz6TIuM2PUmiozctQMoN15OZGKFjK43ncikLRmxawcuFasnSK5CRuxJdoqM2LUDmoz6TINMUJ9pkVGfaZERe2MGRSaKPd9EkhF7vokik7ySaZDRdqZBRuzueooMGB3PtMjInWsTZATfP0OREXtnEUXGij2VTJLRkV6DjNPZQYuMjvQaZOTeskKR0Whnk4zODhpk5N5DTpLR2UGDjNj9wDQZnR00yCQd6bXI6OygQSZ7JdMgo7ODOhkrdtcrSQZ0dtAioyO9Bhm5d0qTZHSk1yDjdHbQIqMjvQYZr7ODFhkd6TXIiL39gCSjOxibZHR20CAj+H5giozYc5RTDHzOoquRSWJv5iHJSO2baDJiz1FSZLLYW1ZIMmJvPyDIOLF7O2ky2gK3yGgL3CAD2gK3yGgL3CBjtQVukdF5U4OMU59pkdFeu0VGbq8dShbd9nXXyWXE3j9DkhF7/wxFBsXeP0OSkdtrU2TE3hpHkZF7pzRJRlvgBhmx6000GW2BW2S0BW6QEbu7niaj86YGmaw+0yKjvXadjJcbIfem3NvpV3+5kBF7kt37WF4e9ylXyMioTee8Crmj9JJXGWtC57wOdbIejJstAYOBqN8x+9mSmPMSmbYx1ezG5RLfxQ7ra0CgPKNo15dETx+fmQ81Q3wV5iPV6RdhPtQuyldh7pX54cxHit68CPOhTtC/CvORIk6vwRzNSHGJV2GuY8XDmQ91h8OrMNc+9Hjm2oceznyod9xehflIsfEXYT7U23OvwlzHiocz9zpWPJ65V+aHM9e44uHMUceKxzPXseLhzIPGFY9nrmPFw5lHHSsez3ykff6vwlzHioczH+pswqsw1/j50cyDUT/fn7l1C3OPG+bWK/PdmUeYjzrYuLqKojDXPvRw5kOdLnkV5hpvOZz5UOdnXoW5zkOPZ6596OHMh3ov4FWYq58fznyo23hehfnrjhXP9r/wWcuL/a+7ZnS2v/czgMFCsd9H4utk4pzbZNJSWULN7MnqNBtiw/sKfkHTebf9TDSd965PRNP7wbdnolGvaaCJRr2miUa9poWm9wNCz0TT+TrkE9H0ftzmmWg6n009EY3rPFj7RDS9rx08E03n0+Mnoun9JvhnotG2poWm9xd2n4im922tj0STFjSrmzALmt7fMXwgGmdms50Dt0GTen/I8JFo0BQ0mCtoBHsNgQbkzqFINHJn3hSa3jeNPhON3Cgfhab37YBPRCN45k2hCWOhcaGgwXQdTYzLXowpALH++EymcRQLS2Y9rgyqkklpNicDXLcGUi67Paafw2q/R76swafGQvMTDdqV0GqLy1wE2T86gQfnIBv/6ATSgxNoDGF3TODRObCPzkFjOWC/BJx9dALhwQk0euAdE3h0DhovLOyYwKObCnx0YxceXdHCo5uK+OiKFh/dVKRHV7T06IqWd6ho0ZQEiAFyjmkeBU7swtYa7Mqa3I813uwxuNnRmq7YwFhB0XvmVSnMqwwxxbQhY+XOOBO6q2QE+0wyhcxqZWom0/uVqE8koz7TINP7VZdPJDNWEH1HMr0fwXwiGfWZBpnejzM+kozLhUw21z8G8GXEDIB2O2QOgl2sCfJMJgneHnl1y5I3WfC+HJg9zDlnKmjkbnQj0IDk3VwUGsH7cgg0kndzUWjUa1poBJ+jItEI3rJ0db/xhKDzi92fiUa9poWm96vSnogGBQ/5KDR67KOFZrDgzq5oBA/5CDTRK5oWGsEb+Ak0gi+SItFoW9NCk3Wi0EBjrT6O9evuF01OeSxAwK8/vjDXS8kPZ957rGBE5vp47ROY60XwhzPvPWwyJHP18+OZ60Xw+zO32RYgBjfMg1fmhzPXh/cOZx51fH48c32k+XDmvT8SMCRz7UOPZ6596OHMsz4adDxz9fOjmU/ZVuZHMx/qkeacZkNy9gRx78187sT71V92YL+TGakFuI+Ms4WMi1syvZ+7fSAZD4XM6mBTITPUE7n7klGfaZAZ6unTfcmMFJfelcxQ0eN9yajPNMjEkWaR95GxuIxnamTkjvQIMkl9pkEmyx3pUWTkjvSuk/FmpLWwfcnI7bUJMr2/X/k8MnakFbd9yYy0h2pXMk59pkVGbjsTlzhwqpDxcnttisxI6zW7khlqF+uuZHp/nPGBZMpCnMfKepMPcn2GIBPVZ1pk5EauCDKCI1cUGfWZBpmh9lntS0bwSG/ZC7G6g3Mmg4JjehQZ9ZkGGRA8O7hORnBMjyIjd1WFIOPk9toUGbkjPYJM7+9jPJGM3JU4gozgfXoUGW1nGmTi0btELMb5zQAbDJVXH6BEa4P3xNcR42xJDO8fL6wUkc3L49urOwecc5WvwZTjD9OPy2EJh+47SFSQt4Esl4iBWXsk1r5OxerkPPEtptnVcXU52VJAWQuo6wI6PCCqBfTPfghmM4KrNHGHx2W1gO4roKw1qOsCCkZHW50XUNAC6rqAQGtQ5wWkNajvAjp8BUMLaBPumS9HCKdMbQpIh9l9F5DTYXbfBeR1kNB5Aekgoe8CQh0kdF5AXgvotgIKUAoomgpIXRbYB2RQj9wH5OEXEg8LMirIXUDqytxOILMOq3YCqbstdgEZdUVqL5A6pd0HpK7w7AVS28idQOoUcR+Qbqw2Mi0gV/dWV0FGm2aQ04+w/vhMxo81MLyHjIfZaaK3FTJjtWL3kHE5XCMzWIz2LjLJLWTs9Y9hAjJzBPAmb0HKbZZcOaYQXdy6WBhrLLYnGfWZBpnolUyDzFjjyB3JJMGd/HUyeazFgD3JjBXd349MMmOF6/ckM9bWuh3JgPpMi4y2Mw0yVmcHDTJIkwn+OpkpmFZ2Fk1T2MX6E6Xt12W3kDWr3UJQNf5Jr7inG+bZAqkE9ZUalaxUtlRumFtLpKK+UqGS1FdqVJJIKtffWE03HByXSCUqlQ2VbGSOVygqqFQqVGT2zAQV0Na2RkVb2woVa5VKhYr6SoWKkxlfuUoFTf2GQ7RzAmjjVoP3a5JhaBjpZEY6mZNOvlsD5v50AAxDE+7XWGBoqu0MhnkvH65C1rPGAUMT7tfUtwxinqPYAexW4xmafL8GGekgI53ASCek+zWRkU5k5KfRHlzVZIYf1F/Avaqx9XnfdU29LthYFmZsdG6rqlKAsHRNIW3qg/WOo6qv1JCqwFHVXxaDuGxPjBm3KmSpMkdVf4GdVEWOKgFLxaKRWeQzLy0OeWccS8Uh7wBYKmSpWDQsi4atp5VhHh9CtluVixxVo1ZmV05AZL+MJxyai6xRwUhZYslSYMnqL8e/k2GqyDJH5hs+TMkAWbL67WdT51Y2Fph3l6bNMs+TZZbM8VJzvNQ8LzWfWDLkpYa8vNWrKSmLPC+JgSWr94S0LLJk9R2ltIxV3Fjv12gZq7gRWM6FvEYBLcu50AFPxnIu9JYn46WGvLyFRmpYNoeZ1Qy4yFo1oLx5Mf247QOwVQOI1HLDyIRFthqUzLLGnc+0jJdaqwZQskZ9S7DItuUWWt0iJeOl5iJL1qoBlIyXGvJSw8Bx5RCAJ+OlFj1PllmyhCxZq3ZTMlZbElv9GyVLLBnwUgNe3iyrAKJvGJmXOP308yKc4vcXYavzoIXIFAauqSEyhZGbx9bYkhQmboqJm2Lmppi55VifevpYDlD75LayZDxPllgysDxZZMksL7XGK56UzBleySWXmMJWr04KkWtqa+ZKC7l55DZPKXBTjNwUIzfFxC3HxPPUeuNEy5AnYzVMmdcwtbZbUbLGfiRSxuwDs0WuMDOFznGFTLfO3EFQ9twUkZsicssxsKpSDqyKm+sxOVrGq0qRV5USL7XEGlHkzGw7c+YVeTDGcoWBKQTDFSJTaLkpWm6Kjpui81whx+GC8Y4niywZAk8WWLLASy0gT5aZJRe5RR65KSbHFXJbmcxtZbjtGnDbNTDcFAG4QpbDgTU8mefJWO0LOMeT8VLzlidjdmWA3CJHborh7kKvbPL1Zl4XgfVm3NMdkJdE8IBE4hE5icwOHLhNJKT432crlksR4mpfdclUto9P4uG5sPVpUUp53ts+/bgkAemiqi/GkKrIUQVWWvXJUMplW3LKHteqygb4VC6jsGm17XBOoh5y3jeJx+eivr1+3yTw4Unkx+ciPzwXzpjHJ/H4XEB6eBL1fYz7JpEfnoR7fFmERhsVTUli9QrWrKpPabIpNwpnE3GjqsdoqLRSw1tSad7Xp5pmVf1g/WShLxauBiJFlRgqbzhp+fo8hFSFhsouqk0pewssFSutemiEVGWOyrPS8qy00JEqty0vbHiUw6LyG+/1wZH1a32v1qxqpOXTUiu3FsZGWj5eqcs+JkYL4JNjqSJD1djJeJp/wDIXQb+ZGjT2Mt4iTExhfcn4FmFkCh03xfpmyBuE9VNztwiRK+Q6QL2m3yLkOkDgphi4DlCfm9wi5DpA4jpA4tbHxHWAzE0xMx0gGMsVMh0gAHCFzPoYrOEK2SkyHaDx0PgtQq4DeK4DeGZ9DMh1AOSmGLgOEBj1sRKFdDAPaaZ49zYKGULeI5lQQo9xdSlCSaS+jDRF0kMuibiwjViG+n6dW4SBKcxcUxvNIClsvOV2g7C+WH2LkGuqZRZHdFxTnecKuXlsnOy+QchNEbkpIjfFwC3HwPXVxtDrBiEyhYnrconrco2hFy3MXAfgtjnJWK4wMoUAXCHT5ZI1XCFyhUwHSMxWLpr65nAw5coLMGuZv6jqe8NJVb0gpmHFrJrWnDeq+pI+pWpM1SlV5Kh83TOhxJAB0pZGown1xpQSM9u0Gu0noYqGpfIsVd2j0BaGiGajqse4SBUrrfrJSEIF9YORpCpyVI1gGqXKHFWjsSJUjfEYpeKl1chXOdgFmO1G5SNHVV+Cp1SNORqlQpaKRaNxkwelYjFsTZ2WK0qc27Qb0LjGg1IhS5UZKtu49IZSRY4KgKXikLeWlZZFlopF3rHIN3pz55eARti0Nq2LuQgVGpYKOaoALFXgqFqBF0KVGCMHmyxLxRkR2cxJq7EHI7p52Bu922gaa7S+LIAibjR1HyQ08X5NPZpJaJAx9nf1C3EoVSOESalYaUVWWpGVVmKllVhpZVZ5ZU5a3niWijMH9aw5aGMnCKVqRAIoFd7dWjSu4MplJ3C2W01j78i1Wuzrtfh6OsiwrbUn46om3q+J97dkjfuvrmsSI510fw/gM6NM8/3poPEMTX0XC85+vd6PNmvqh3YJDSOdxu6rq5r6DVeEhpGOZ6RT38exKp+Kpj4WvV6miPdrAiOdxm6rq5roGBpGXUj3tweYgaG5f6TW2OpAaBjpADA0yNDcXz7B3u8HrUXwsCxqB7u63+qy3hynhUqeLJAy57eyxt3CpIyVWmoFxmwZzKC3W1krMkbJAksWgCfjpRZ5qUVeasncLft7+vV/f/r26aefP3/8fRKd/vXPL7/88enrl++//vF/v83/8vO3T58/f/rPj799+/rLx1///Pbxx89ffzn925v5/p9/TfGS/OE0dZ8MOuUd0NgPkwWn30+1bFqx+AA2nf719Pmpj8rBn349f+0zfJj+4ya7Jtv+Hw==",
      "brillig_names": [
        "commit_public_user"
      ]
    },
    {
      "name": "redeem_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "772057049813214347": {
            "error_kind": "string",
            "string": "HTLCNotExists"
          },
          "2570651705007895968": {
            "error_kind": "string",
            "string": "HashlockNotMatch"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17814817983036354427": {
            "error_kind": "string",
            "string": "Function redeem_public can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "redeem_public"
      ]
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [
        "aztec::macros::functions::utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2588366281349374274": {
            "error_kind": "fmtstring",
            "length": 136,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "3473764466780631008": {
            "error_kind": "fmtstring",
            "length": 106,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5533887251808526417": {
            "error_kind": "fmtstring",
            "length": 120,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "refund_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2588366281349374274": {
            "error_kind": "fmtstring",
            "length": 136,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "3473764466780631008": {
            "error_kind": "fmtstring",
            "length": 106,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5533887251808526417": {
            "error_kind": "fmtstring",
            "length": 120,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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QE6aQF6aQCRNoCBNoChNIGmeOg711NcpyvApkhk/hR0/hRs/hR8/BYNXcoa2KXxyryme92ezv11F6v7M8fBsydu1paX8fPYqephX9Div6Gle0fO8opdpRedo2H+W6HZe0d28ovt5RZ93N83z7qZ53t00z7ubcrQ1tsnswWl+DE45mv62pnDjp/Djp6DxU4TxU8TxU6TxU+TxU5TRU3hjxk9hx0/hxk/hx09B46cI46eI46dI46fI46cYv7rt+NVtx69uO3512/Gr245f3Xb86rbjV7cdv7rt+NVtx69uN351u/Gr241f3W786nbjV7cbv7rd+NXtxq9uN351u/Gr249f3X786vbjV7cfv7r9+NXtx69uP351+/Gr249f3X786qbxq5vGr24av7pp/Oqm8aubxq9uGr+6afzqpvGrm8av7jB+dYfxqzuMX91h/OoO41d3GL+6w/jVHcav7jB+dYfxqzuOX91x/OqO41d3HL+64/jVHcev7jh+dcfxqzuOX91x/OpO41d3Gr+60/jVncav7jR+dafxqzuNX91p/OpO41d3Gr+68/jVncev7jx+defxqzuPX915/OrO41d3Hr+68/jVncev7vHvqvnx76r58e+q+fHvqvnx76r58e+q+fHvqvnx76r58e+q+fHvqtH4d9XISP4SIG7PWmPcj4evskv+FKAlu+RvAVqy08SyS/4aoCW75M8BWrIP/R7gOgWDz/f7pwHk774N2Kcow6fgeIOxNYUdP4UbPwWNnyKMnyKOnyKNn2L80rPjl54bv/Tc+KXnxi89jtcLW1OMX91u/Op241e3G7+63fjV7cavbj9+dfvxq9uPX91+/Or241e3H7+6/fjV7cevbj9+dfvxq5vGr24av7pp/Oqm8aubxq9uGr+6afzqpvGrm8avbhq/usP41R3Gr+4wfnWH8as7jF/dYfzqDuNXdxi/usP41R3Gr+44fnXH8as7jl/dcfzqjuNXdxy/uuP41R3Hr+44fnXH8as7jV/dafzqTuNXdxq/utP41Z3Gr+40fnWn8as7jV/dafzqzuNXdx6/uvP41Z3Hr+48fnXn8as7j1/defzqzuNXdx6/usv41V3Gr+4yfnWX8au7jF/dZfzqLuNXdxm/usv41V2Gr+5gzPgp7Pgp3Pgp/PgpaPwUYfwUcfwUafwUefwU41f3+BfJwvgXycL4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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "get_note_internal",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "add_lock_public_user",
      "is_unconstrained": true,
      "custom_attributes": [
        "internal",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "2722406262643068352": {
            "error_kind": "string",
            "string": "HashlockAlreadySet"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16870384257694633552": {
            "error_kind": "string",
            "string": "Function add_lock_public_user can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "add_lock_public_user"
      ]
    },
    {
      "name": "is_contract_initialized",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2588366281349374274": {
            "error_kind": "fmtstring",
            "length": 136,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "3473764466780631008": {
            "error_kind": "fmtstring",
            "length": 106,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5533887251808526417": {
            "error_kind": "fmtstring",
            "length": 120,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "is_contract_initialized"
      ]
    },
    {
      "name": "refund_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3564161243949231814": {
            "error_kind": "string",
            "string": "Function refund_public can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "9323748002447105156": {
            "error_kind": "string",
            "string": "NotPassedTimelock"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "refund_public"
      ]
    },
    {
      "name": "commit_private_user",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "src_receiver",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 48
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2588366281349374274": {
            "error_kind": "fmtstring",
            "length": 136,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "3473764466780631008": {
            "error_kind": "fmtstring",
            "length": 106,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5533887251808526417": {
            "error_kind": "fmtstring",
            "length": 120,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6652550611004701521": {
            "error_kind": "string",
            "string": "Funds Not Sent"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7b3briw7bqb7LnVdFzpQp36VRqNhu70bBRTshu3ewIbhd985Z46IzLFSmVpDSSkp8feFMWYtKUV+1IFkRFD/+Zf/9c//+H//9//827/8P//673/5b//9P//y93/9p3/4j7/9679c/vWff0nl9//27//nH/7l1z///T/+4d/+4y//zQVKf/3LP//L/7r8Ga37r7/+5f/529//+S//zTrzX399bO3IHK1dvLUuttLYmxK+Gnsb8+vGNhR7CHL525uzuUu51j6GfDSPKd1al1Br7aM/WpM131r/j7/+JRugeYbGAs0zNA5onqHxQPMMDQHNMzQBaJ6hiUDzDE0CmmdoMtA8QwNv+BmaAm/4KRp4w0/RwBt+igbe8FM0BDTP0MAbfooG3vBTNPCGn6KBN/wUDbzhZ2isgTv8nA384eds4BA/ZwOP+DkbApunbOATP2cDp/g5G3jFz9nALX7OBn7xUzYWfvFzNvCLn7OBX/ycDfzi52wIbJ6ygV/8nA384uds4Bc/ZwO/+Dkb+MVP2Tj4xc/ZwC9+zgZ+8XM28IufsyGwecoGfvFzNvCLn7OBX/ycDfzi52zgFz9l4+EXP2cDv/g5G/jFz9nAL37OhsDmKRv4xc/ZwC9+zgZ+8XM28Iufs4Ff/JQNwS9+zgZ+8XM28Iufs4Ff/JwNgc1TNvCLn7OBX/ycDfzi52zgFz9nA7/4KZsAv/g5G/jFz9nAL37OBn7xczYENk/ZwC9+zgZ+8XM28Iufs4Ff/JwN/OKnbCL84uds4Bc/ZwO/+Dkb+MXP2RDYPGUDv/g5G/jFz9nAL37OBn7xczbwi5+ySdL94kA3NnfN62ycdfGQ5PJY8l020v3iT7KR7hd/kk3dL6Zsb2x8gw1ddq2v1uTMTaJI1yFo/BBVL816Fw6jWe9zaAxyaW/P5iHeWttUa238KdPl7xzvhaqZLZWb3bJ71CFuoEOq65CNO4UqwX7T4Xe/ukcQwzlajDfZwtfULR2dnlwE1ehkezq5nk6+p1N9gaV0nL3e3M2bUN0mbA7nRLA53za4UJs3l03lMKhP1kp2Gp5cOQM4v+FEwHkOJwHOczgZcJ7DKYDzFM6Ty2cA5zccCzjP4TjAeQ7HA85zOAQ4z+HAQ34BBx7yCzjwkF/AgYf8Ag485KdwnIGH/AIOPOQXcOAhv4ADD/kFHAKc53DgIb+AAw/5BRx4yC/gwEN+AQce8nM4Fh7yCzjwkF/AgYf8Ag485BdwCHCew4GH/AIOPOQXcOAhv4ADD/kFHHjIz+E4eMgv4MBDfgEHHvILOPCQX8AhwHkOBx7yCzjwkF/AgYf8Ag485Bdw4CE/h+PhIb+AAw/5BRx4yC/gwEN+AYcA5zkceMgv4MBDfgEHHvILOPCQX8CBh/wcDsFDfgEHHvILOPCQX8CBh/wCDgHOczjwkF/AgYf8Ag485Bdw4CG/gAMP+TmcAA/5BRx4yC/gwEN+AQce8gs4BDjP4cBDfgEHHvILOPCQX8CBh/wCDjzk53AiPOQXcOAhv4ADD/kFHHjIL+AQ4DyHAw/5BRx4yC/gwEN+AQce8gs48JCfw0nwkF/AgYf8Ag485Bdw4CG/gEOA8xyOeA/5c/dFuSTeQ/4kHPEe8ifhsHjI5bxIyhZfGnDOnyZ/Q/NLk9/ycDilhW7GKiW+lufSwp/7VCnh9utdt225bJbXwM7WwBkTz4v8jLu7eK6qwUXF87ddvptD/ip/1QPzzhzLzDvvGvKb27Kx9/fgxfoSjjfhz7be1n45FTqETxe7NRa7P3+Z3N3irZo12YP4xc3yrxvblI4fvsyG0Ghs7O06uvv96Wu6eOCeiZuAeybuANwzccf3cV8ctGMEd+cg1XGHcB5rMX+7cNbXTp503ONZ8t3BE78OnrSy8LkpPKXXwl8enR7T8fJEw30bouaHlPOuWW9Lo3V2529fXBbXmOobLowC8wg2T/3+vB+aJ9JpnmIbwC8h5oEw+mheO8yX8PXM3BRzk+Ny1lylt7Olp1OgSIneDFiKW1t8/774yfpz3kffEt+ZU/r7Q6Marpd4zDMy5f5GcCd4G3BnRsJ501rZ3t7uwb5LSXRtAwRT7mLKAFPucjhHmHIXU6bJpkzmaJybpszn87GS/aOTlSeLns8UbE62Ifrl2d6xc4biyrseTdGiqjdGsKrR5EP46IJ9rWo+Rc53z3Auaf+rnk9ChHhIczlv82s9w+3JVfDxLqK0sbYbWTo20Uvy6+55Q3UTNSWcje92DXkPsr1xAMkD0u8E8nPPgL0hgOQBGQCSB2RsgSTTSKR7f/rg/h7kz99J8CYxSJNujX3reX6Mp0NwMdR3F+W3QFmaQGWyQJdo5jxJsnn0yqyRJpBlFSga+1ogd3qtl9lyE+YSiVz+8Y//9re///1v//t//v1f/+kf/uNv//ov//6ro/n1/+yT2wJyTufP3T85uMSoF+3skzL6rV6xq1fq6pW7epWeXk9qWLd62a5erquX7+rVNTd819zwXXPDd80N3zU3fNfcoK65QV1zg7rmBnXNDeqaG9Q1N6hrblDX3KCuuUFdcyN0zY3QNTdC19wIXXMjdM2N0DU3QtfcCF1zI3TNjdA1N2LX3IhdcyN2zY3YNTdi19yIXXMjds2N2DU3YtfciF1zI3XNjdQ1N1LX3EhdcyN1zY3UNTdS19xIXXMjdc2N1DU3ctfcyF1zI3fNjdw1N3LX3Mhdc+PJO4nhfAvdh7sX3C+5ht+dUk+n3NOpdHR68r5So5Pt6VTPd8fzuZpPd+/w/8rUPDS+zMdbcB1vr9uk2vMRSscPB3cT5uKEXKXxb0vjzC3VZfw3aX6PQMNHCMNHiMNHSMNHyMNHKINHcE8eLnKOYIeP4IaP4IePwLCm3W0E5xt72OVZ7flEONw95Q21hwD53H5zutvwyFXT9D6dafq7B8JU+2GX7Xksfmv6G0kAkj8iiUDyRyQJSP6IJAPJH5EUIPkDEmuA5I9ILJD8EYkDkj8i8UDyRyQEJH9EAu/1AQm81wck8F4fkMB7fUAC7/WPSBy81wck8F4fkMB7fUAC7/UBCQHJH5HAe31AAu/1AQm81wck8F4fkMB7/SMSD+/1AQm81wckHN4rncJ423qvxZrj8w+yRPdIfovjZYlDssQJssSJssRJssTJssQposQhI0scK0scWbsyydqVSdauTLJ2ZZK1K5OsXZlk7coka1cOsnblIGtXDrJ25SBrVw6yduUga1cOsnblIGtXDrJ25SBrV46yduUoa1eOsnblKGtXjrJ25ShrV46yduUoa1eOsnblKGtXTrJ25SRrV06yduUka1dOsnblJGtXTrJ25SRrV06yduUka1fOsnblLGtXzrJ25SxrV86yduUsa1fOsnblLGtXzrJ25SxrVy6yduUia1cuk3dlT+a8A5WovG5sKd0q6N5f+5drBXTj+cvxvmxJTldFvRZFSYuiQYuiUYuiSYuiWYuiRYei3hgtilotiirxjLxR4hk9u6VjQ0WVeEbeTPeMznvYfPDpdeNiyxF5FX/3Wn39Yh9OKglUKlQyqFSoFFB5pGINqFSoWFCpUHGgUqHiQaVChUClQiWASoUKfNsaFfi2NSrwbWtU4NtWqDjRvm1wh6Il3N1v++TGzHRcQ+1svqUdbDG11smcrZO73VERr1RE+7YfoyLat/0YFdG+7ceoEKhUqIj2bT9GRbRv+zEqon3bj1ER7dt+jIpo3/ZTVDx82xoV+LY1KvBta1Tg29aokGQqOR5F1kqxjUyCi+GsIRdjuKMSanJYdz7Yt+G+dVVqnw4VvS/+W+vfFEX7wstQFO07L0NRtK+9DEXRvvkyFEX78qtQJNG+/zIURccKy1AUHVssQ1F0LLIMRQJFBoqIXTgoInbhoIjYhYMiYhcOiohdGCgGxC4cFBG7cFBE7MJBEbELB0UCRQaKiF04KCJ24aCI2IWDImIXDoqIXRgoRsQuHBQRu3BQROzCQRGxCwdFAkUGiohdOCgiduGgiNiFgyJiFw6KiF0YKCbELhwUEbtwUETswkERsQsHRQJFBoqIXTgoInbhoIjYhYMiYhcOiohdGChmxC4cFBG7cFBE7MJBEbELB0UCRQaKiF04KCJ24aCI2IWDImIXDoqIXRgoFsQuHBQRu3BQROzCQRGxCwdFAkUGiohdOCgiduGgiNiFgyJiFw6KiF3ep0gGsQsHRcQuHBQRu3BQROzCQZFAkYEiYhcOiohdOCgiduGgiNiFgyJiFwaKsu+1XoYiYhcOiohdOCgiduGgSKDIQBGxCwdFxC4cFBG7cFBE7MJBEbELA0XZ95YvQxGxCwdFxC4cFBG7cFAkUGSgiNiFgyJiFw6KiF04KCJ24aCI2IWBoux76ZehiNiFgyJiFw6KiF04KBIoMlBE7MJBEbELB0WtsYujcMjhcosilZNiMKY8UtQau/BS1Bq7sFIkrbELL0WtsQsvRa2xCy9FrbELL0UCRQaKWmMXXopaYxdeiohdOCgiduGgiNiFgWJA7MJBEbELB0XELhwUEbtwUCRQZKCI2IWDImIXDoqIXTgoInbhoIjYhYFiROzCQRGxCwdFxC4cFBG7cFAkUGSgiNiFgyJiFw6KiF04KCJ24aCI2IWBYkLswkERsQsHRcQuHBQRu3BQJFBkoIjYhYMiYhcOiohdOCgiduGgiNiFgWJG7MJBEbELB0XELhwUEbtwUCRQZKCI2IWDImIXDoqIXTgoInbhoIjYhYFiQezCQRGxCwdFxC4cFBG7cFAkUGSgiNiFgyJiFw6KiF04KCJ24aCI2OV9ipf/DRQZKCJ24aCI2IWDImIXDooEigwUEbtwUETswkERsQsHRcQuHBQRuzBQtIhdOCgiduGgiNiFgyJiFw6KBIoMFBG7cFBE7MJBEbELB0XELhwUEbswUHSIXTgoInbhoIjYhYMiYhcOigSKDBQRu3BQROzCQRGxCwdFxC4cFBG7MFD0iF04KCJ24aCI2IWDImIXDooEigwUEbtwUETswkERsQsHRcQuHBQRuzBQJMQuHBQRu3BQROzCQRGxCwdFAkUGiohdOCgiduGgiNiFgyJiFw6KiF0YKAbELhwUEbtwUETswkERsQsHRQJFBoqIXTgoInbhoIjYhYMiYhcOiohdGChGxC4cFBG7cFBE7MJBEbELB0USTNEak+irtTW22AZHk90hiAt30GsYbUyHhWyyptHYGXM0djbfN/4NUXLosgxEyZHLMhAlBy7LQJQctywDUXLYsgrEJDlqWQai5KBlGYiSY5ZlIEoOWZaBSID4PkRELAwQEbEwQETEwgAREcufgUjulIMSvW4c6ZAixpuCPpRqti/f6ddoHO3ZOrpgGq0vWsV00/BXju/1rxdzAInF3gS3NdTZ0QEku+juG/+eVQjhMKvYZ1VGTItZxT+rEORjVvHPKmQ9MKv4ZxXSQJhV/LOKMKswq9hnFRKFmFX8swqZU8wq/lmFVDJmFf+sQm4ds4p/ViG3jlnFPqsKcuuYVfyzCrl1zCr+WYXcOmYV/6xCbh2zin9WEWYVZhX7rEJuHbOKf1Yht45ZxT+rkFvHrOKfVcitY1bxzyrk1jGruGdVNMitrzOrXEjnrMqtn7Y5+sOIv/6mb+1/2x4ZcL22R55ar+2RTdZre4Lt1doemVm9tkf+VK/tkeXUa3vkIvXaHhlDtba3yOvptT3yenptj7yeXtsjr6fX9qTV9smH0/b+W+PfXNTmvBpc1OaDGlzU5koaXNTmERpc1MbYr7k4tfFng4va2KzBRW3c0uCi1qdvcCFwqXKBv1vnAn+3zgX+bp2LbH83n7clWlNceM3F2hzO7IHN6ZYgiTWxkzkpJufu2v7mItvf/RgXL9vf/RwX0f6uDXTm7OwlZnnN5fIw/UzZ3TaMC6CrpqI9WFZNRfukrJqSGk1F+42smor2BFk1Fe3bsWoq2ltj1VS0/8WpKYn2qFg1VeMjkRofidT4SERqNBXtIznrjjjs8vd9+qOaK/Epn4KUW0D4O8nynz+L8Ui0R/VBLqL9rw9yEe2tfZCLaN/uc1yCaE/wg1xE+40f5CLay/wgF9E+6Qe5ELhUucDfrXOBv1vnAn+3zgX+bp3LTv4u2eMqe0dkvnH5pWvcyYdt6bqTX9rSdSdfs6XrTv5jS1dSpOtOfl5L1518t5auO/ljLV138rFauirym5Iivykp8puSIr8pKfKbEinSVZHflBT5TUmR35QU+U1Jkd+UFflNWZHflBX5TVmR35RJka6K/KasyG/KivymrMhvyor8Jtl3zTPrqshvkn0vN7Ouivwm2XcYM+uqyG+Sfd8rs66K/CbZd2My66rHb0qy7xFk1lWP35Rk3xPHrKsevykZUqSrHr8pyb7niVlXPX5Tkn2PD7Ouivwm2fe0MOuqyG+SfQ8Hs66K/CbZ9yww66rIb5J9HwKzror8Jtn3FjDrqshvkn2/ALOuivwm2fcAMOuqyG+SXa+fWVdFfpPsuvrMuirym2TXv2fWVZHfJLtOPbOuivwm2dXnmXVV5DfJrkDPrKsiv0l2FXpmXRX5TbIr0TPrqshvkl2NnllXRX6T7Ir0zLoq8ptkV6Vn1lWR37RVrfmWror8pq1qwrd0VeQ3bVW7vaWrIr9pqxrrLV1n+00pn7pmZ183jhQPMWKw5b7xb9lpYdnDwrLHhWVPC8ueF5a9rCv79PrWnLLbhWV3C8u+8Lk6vT40p+wLn6tx4XM1LnyuxoXP1bjwuZoWPlfTwudqWvhcTQufq9PrB3PKvvC5mhY+V9PC52pa+FxNC5+reeFzNS98ruaFz9W88Lk6vb4sp+wLn6t54XM1L3yu5oXP1bzwuVoWPlfLwudqWfhcLQufq9Prj3LKvvC5WhY+V8vC52pZ+Fwt656r2ax7rmaz7rmazbrnajbrnqvZrHuuZrPuuZrNuudqNuueq9mse65ms/C5ahc+V+3C56pd+Fy1C5+r0+sXcsq+8LlqFz5X7cLnql34XLULn6tu4XPVLXyuuoXPVbfwuTq9vh2n7Aufq27hc9UtfK66hc9Vt/C56hc+V/3C56pf+Fz1C5+r0+ufccq+8LnqFz5X/cLnql/4XPULn6u08LlKC5+rtPC5Sgufq9PrY3HKvvC5Sgufq7TwuUoLn6u08LkaFj5Xw8Lnalj4XF243lJeuN5SXrjeUl643lJeuN5SXrjeUl643lJeuN5SXrjeUl643lJeuN5SXrjeUl643lJeuN5SXrjeUl643lJeuN5SXrjeUl643lJeuN5SXrjeUl643lJeuN5SXrjeUl643lJeuN5SXrjeUl643lJeuN5SXrjeUl643lJeuN5SXrjeUl643lJeuN5SXrjeUl643lJeuN5SXrjeUl643lJeuN5SXrjeUl643lJeuN5SXrjeUl643lJeuN5SWbjeUlm43lJZuN5SWbjeUjHrnqtl4XpLZeF6S2Xhektl4XpLZeF6S2Xhektl4XpLZeF6S2Xhektl4XpLZeF6S2Xhektl4XpLZeF6S2Xhektl4XpLZeF6S2Xhektl4XpLZeF6S2Xhektl4XpLZeF6S2Xhektl4XpLZeF6S2Xhektl4XpLZeF6S2Xhektl4XpLZeF6S2Xhektl4XpLZeF6S2Xhektl4XpLZeF6S2Xhektl4XpLZeF6S2Xhektl4XpLZeF6S2Xhektl4XpLZeF6S2Xhektl4XpLZeF6S2Xhektl4XpLZeF6S2Xhektl4XpLZeF6S2Xhektl4XpLZeF6S2Xhektl4XpLZeF6S2Xhektl4XpLZeF6S2Xhektl4XpLZeF6S2Xhektl4XpLZeF6S2Xhektl4XpLRXS9peSs/WqcXAqvG1tK9NXYBuvPxjbnGhaTDyou3rVNVyqST+yPURFdI+pzVCR7GZ+jItl/+RwVyZ7R56gQqFSoSPbmPkdFsp/4OSqSPdDPUYFvW6MC37ZCRXSdts9RgW9bozLbt83enlSS+WMIP71cXEMckiVOkCVOlCVOkiVOliVOkSSONdOLnrXkscLkEbUxX+QRtTNf5BG1NV/kEbU3X+QRtTlf5BG1O1/kEbU9X+QRtj9bYfuzFbY/W2H7sxW2P1th+7MVtj9bYfuzFbY/W2H7sxW2Pzth+7MTtj87YfuzE7Y/O2H7sxO2Pzth+7MTtj87YfuzE7Y/e2H7sxe2P3th+7MXtj97YfuzF7Y/e2H7sxe2P3th+7MXtj+TsP2ZhO3PJGx/JmH7Mwnbn0nY/kzC9mcStj+TsP2ZhO3PQdj+PL1gSM6nPKX1+ohNxzseztzeB3EpVdpmc7w8kn1ptC3nKyyX58ff2l6ZODB5YOLB5IEJgckDkwAmD0wimDwwSWDywCSDyQOTAiZ/ZDK9kM4KTODHPjKBH/vIZLYfW7z7akwuxwYTFw8o1tubGIlqvxxdOGSOudw3vmpKajQNajSNajRNajTNajQtWjSdXpLpc5paNZo6NZqq8ZGml5L6nKZqfKSkxkdKanykpMZHSmp8pKzGR8pqfKSsxkfKanyk6aWfPqepGh8pq/GRshofKavxkbIaH6mo8ZGKGh+pqPGRihofaXpBpc9pqsZHKmp8pKLGRypqfKSixUeyRouPZI0WH8kaLT6SNVp8JGtIjaZafCRrtPhI1mjxkazR4iNZo8ZHsmp8JKvGR7JqfCSrxkeaXl3wc5qq8ZGsGh/JqvGRrBofyarxkZwaH8mp8ZGcGh/JqfGRplf4/Jymanwkp8ZHcmp8JKfGR3JqfCSvxkfyanwkr8ZH8mp8pOlVdj+nqRofyavxkbwaH8mr8ZG8Gh+J1PhIpMZHIjU+EqnxkaZXuv6cpmp8JFLjI5EaH4nU+EikxkcKanykoMZHCmp8pKDGR5pe4fxzmqrxkYIaHymo8ZGCGh8pqPGRohofKarxkaIaH0lNnW2rps62VVNn26qps23V1Nm2aupsWzV1tq2aOttWTZ1tq6bOtlVTZ9uqqbNt1dTZtmrqbFs1dbatmjrbVk2dbaumzrZVU2fbqqmzbdXU2bZq6mxbNXW2rZo621ZNnW2rps62VVNn26qps23V1Nm2aupsWzV1tq2aOttWTZ1tq6bOtlVTZ9uqqbNt1dTZdmrqbDs1dbadmjrbTk2dbWdIjaZafCSnps62U1Nn26mps+3U1Nl2aupsOzV1tp2aOttOTZ1tp6bOtlNTZ9upqbPt1NTZdmrqbDs1dbadmjrbTk2dbaemzrZTU2fbqamz7dTU2XZq6mw7NXW2nZo6205NnW2nps62U1Nn26mps+3U1Nl2aupsOzV1tp2aOttOTZ1tp6bOtlNTZ9upqbPt1NTZdmrqbDs1dbadmjrbTk2dbaemzrZTU2fbqamz7dTU2XZq6mw7NXW2nZo6205NnW2nps62U1Nn26mps+3U1Nl2aupsOzV1tp2aOttOTZ1tp6bOtlNTZ9upqbPt1NTZdmrqbDs1dbadmjrbTk2dbaemzrZTU2fbqamz7dTU2XZq6mw7NXW2nZo6205NnW2nps62U1Nn26mps+3U1Nl2aupsOzV1tp2aOttOTZ1tp6bOtlNTZ9upqbPt1NTZdmrqbDs1dbadmjrbTk2dbaemzrZTU2fbqamz7dTU2XZq6mw7NXW2vZo6215NnW2vps62V1Nn2xtSo6kWH8mrqbPt1dTZ9mrqbPt96myTT/H4ZaLyurGlRMcvB+vPxjbnSutoDjGii3dt05XhPhW8P8hwG7/ugwy38Rg/yHAbX/SDDAkM32a4jf/8QYbbeOYfZLiNz/9BhttEEx9kiDjlbYb7VNH/IEPEKe8zRJzyPkPRcYo/k042XCR+icXZfGBxZONDhkr2nQKsmor2+Vk1Fe2Zs2oq2n9m1VS0l8uqqWhflFNT2XcKsGoq2q9j1VS098WqqRofSfadAqyaqvGRZN8pwKqpGh9J9p0CrJqq8ZFk3ynAqqkaH0n2nQKsmqrxkWTfKcCqqRofSfadAqyaqvGRZN8pwKqpGh9J9p0CrJqq8ZFk3ynAqqkaH0n2nQKsmqrxkWTfKcCqqRofSfadAqyaqvGRZN8pwKqpGh9J9p0CrJqq8ZFk3ynAqqkaH0n2nQKsmqrxkWTfKcCqqRofSfadAqyaqvGRZN8pwKqpGh9J9p0CrJqq8ZFk3ynAqqkaH0n2nQKsmqrxkWTfKcCqqRofSfadAqyaqvGRZN8pwKqpGh9J9p0CrJqq8ZFk3ynAqqkaH0n2nQKsmqrxkWTfKcCqqRofSfadAqyaqvGRZN8pwKqpGh9J9p0CrJpq8ZFI9p0CrJpq8ZFI9p0CrJpq8ZHIkBpNtfhINPtOAfLm1NTf1zHzX/IkYfJkYfIUWfLMrkjflMcKk8cJk8cLk4eEyROEySNsf7bC9mcrbH+2wvZnJ2x/dsL2Zydsf3bC9mcnbH92wvZnJ2x/dsL2Zydsf3bC9mcvbH/2wvZnL2x/9sL2Zy9sf/bC9mcvbH/2wvZnL2x/9sL2ZxK2P5Ow/ZmE7c8kbH8mYfszCdufSdj+TML2ZxK2P5Ow/TkI25+DsP05CNufg7D9OQjbn4Ow/TkI25+DsP05CNufg7D9OQrbn6Ow/TkK25+jsP05Ctufo7D9OQrbn6Ow/TkK25+jsP05Cdufk7D9OQnbn5Ow/TkJ25+TsP05Cdufk7D9OQnbn5Ow/TkL25/z9P05mkMeMvl1Y5uOm2yd8WdTl1KlbTbHe7HZl0bbko+7d0v53vbKxIHJAxMPJg9MZp+VZMvBJOTwurFL7nxRPGV3a2xrUEI4dokcHd03vmoa1Gga1Wia1Gia1WhatGg6uw7DBzW1ajR1ajT1ajQlNZqq8ZGKGh+pqPGRihofqWjxkYLR4iMFo8VHCkaLjxSMFh8pGFKjqRYfKRgtPlIwWnykYLT4SMGo8ZGsGh/JqvGRrBofyarxkabXFfmcpmp8JKvGR7JqfCSrxkeyanwkp8ZHcmp8JKfGR3JqfKTptX0+p6kaH8mp8ZGcGh/JqfGRnBofyavxkbwaH8mr8ZG8Gh9pen2tz2mqxkfyanwkr8ZH8mp8JK/GRyI1PhKp8ZFIjY9Eanyk6TXuPqepGh+J1PhIpMZHIjU+EqnxkYIaHymo8ZGCGh8pqPGRpteZ/JymanykoMZHCmp8pKDGRwpqfKSoxkeKanykqMZHimp8pOm1Xj+nqRofKarxkaIaHymq8ZGiGh8pqfGRkhofKanxkZIaH2l6veXPaarGR0pqfKSkxkdKanykpMZHymp8pKzGR8pqfKSsxkdSU2c7qKmzHdTU2Q5q6mwHNXW2g5o620FNne2gps52UFNnO6ipsx3U1NkOaupsBzV1toOaOttBTZ3toKbOdlRTZzuqqbMd1dTZjmrqbEdDajTV4iNFNXW2o5o621FNne2ops52VFNnO6qpsx3V1NmOaupsRzV1tqOaOttRTZ3tqKbOdlRTZzuqqbMd1dTZjmrqbEc1dbajmjrbUU2d7aimznZUU2c7qqmzHdXU2Y5q6mxHNXW2o5o621FNne2ops52VFNnO6qpsx3V1NmOaupsRzV1tqOaOttRTZ3tqKbOdlRTZzuqqbMd1dTZjmrqbEc1dbajmjrbUU2d7aimznZUU2c7qqmzHdXU2Y5q6mxHNXW2o5o621FNne2ops52VFNnO6qpsx3V1NmOaupsRzV1tqOaOttRTZ3tqKbOdlRTZzuqqbMd1dTZjmrqbEc1dbajmjrbUU2d7aimznZUU2c7qqmzHdXU2Y5q6mxHNXW2o5o621FNne2ops52VFNnO6qpsx3V1NmOaupsRzV1tqOaOttRTZ3tqKbOdlRTZzuqqbMd1dTZjmrqbEc1dbajmjrbUU2d7aimznZUU2c7qqmzndTU2U5q6mwnNXW2k5o628mQGk21+EhJTZ3tpKbOdlJTZzupqbOd1NTZTmrqbCc1dbaTmjrbSU2d7aSmznZSU2c7qamzndTU2U5q6mwnNXW2k5o620lNne2kps52UlNnO6mps53U1NlOaupsJzV1tpOaOttJTZ3tpKbOdlJTZzupqbOd1NTZTmrqbCc1dbaTmjrbSU2d7aSmznZSU2c7qamzndTU2U5q6mwnNXW2k5o620lNne2kps52UlNnO6mps53U1NlOaupsJzV1tpOaOttJTZ3tpKbOdlJTZzupqbOd1NTZTmrqbCc1dbbT9Drb0dhD00j2vvFVHidMHi9MHhImTxAmTxQmTxImTxYmT5Elz/TqwS15hO3PSdj+nITtz0nY/pyE7c9J2P6chO3PSdj+nITtz1nY/pyF7c9Z2P6che3PWdj+nIXtz1nY/pyF7c9Z2P6che3PRdj+XITtz0XY/lyE7c9F2P5chO3PRdj+XITtz0XY/lxk7c/ZyNqfs5G1P2cja3/ORtb+nI2s/TkbWftzNrL252xk7c/ZyNqfsxG2P1th+7MVtj9bYfuzFbY/W2H7sxW2P1th+7MVtj9bYfuzFbY/O2H7sxO2P0+v+pLj8X5LsKY8yuOFyUPC5AnC5InC5EnC5MnC5Cmy5JleJaMljxUmj7D92Qvbn72w/dkL25+9sP3ZC9ufvbD92Qvbn0nY/kzC9mcStj+TsP2ZhO3PJGx/JmH7Mwnbn0nY/kzC9ucgbH8OwvbnIGx/DsL25yBsfw7C9ucgbH8OwvbnIGx/DsL25yhsf47C9ucobH+OwvbnKGx/jsL25yhsf47C9ucobH+OwvbnJGx/TsL25yRsf07C9uckbH9OwvbnJGx/TsL25yRsf07C9ucsbH/OwvbnLGx/zsL25yxsf87C9ucsbH/OwvbnLGx/zsL25yJsfy7C9ucibH8uwvbnImx/LsL25yJsfy7C9ucibH8usvbnYmTtz8XI2p+LkbU/FyNrfy5G1v5cjKz9uRhZ+3MxsvbnYmTtz8UI25+tsP3ZCtufrbD92Qrbn62w/dkK25+tsP3ZCtufrbD92Qrbn52w/dkJ25+FfT9YhH0/WIR9P1iEfT9YhH0/WIR9P1iEfT9YhH0/WIR9P1iEfT9YhH0/WIR9P1iEfT9YhH0/WIR9P1iEfT9YhH0/WIR9P1iEfT9YhH0/WIR9P1iEfT9YhH0/WIR9P1iEfT9YZH0/6AxHfGpcPOQxnh6HYFgy9qayDe5xiLqVkw/HEDml10P4mN0pT7nJc71Y6jJEGj9EHj9EGT7Ek4iDdQg7fgg3fgg/fggaP0QYP8T41e3Hr24/fnX78aubxq9uGr+6afzqpvGrm8avbhq/umn86qbxq5vGr24av7rD+NUdxq/uMH51h/GrO4xf3WH86g7jV3cYv7rD+NUdxq/uOH51x/GrO45f3XH86o7jV3ccv7rj+NUdx6/uOH51x/GrO41f3Wn86k7jV3cav7rT+NWdxq/uNH51p/GrO41f3YlhdeeYz8bFPwyRzfgh7Pgh3Pgh/PghaPwQYfwQcfwQiXWIYuhxCIbVnc3ZuFh3P8Rj42zoq232t6cp7tcYD21LPp6LlPK97VX0sqzoxawrul1XdLeu6H5d0Wld0cO6osd1RU/rir7uaVqWPU2tWfY0tWbZ09QayadpPNpeJoeryC75OG3JLvk8bcku+UBtyS75RG3JLvlIbcnOcKYWb0/ZvftjEGxNGT6ENeOHcOOHYNg3C90SEsk/DkHjhwjjh4jjh0jjh8jjhyjDh3Bm/BCWYwi6DREehwjjh3h/0pKhI9NPl0ePr08JR/588ZnolpsM8UueJEyeLEyeIksehjeXeeWxwuRxwuTxwuSh2fK4fJMnPsoThMkThckze38O4fBOXYj+Xp7KL1+2o+OXbW2yZdHCm/JS+Nk7f7D+FD7Z18Jnc6zyTLfgz5K7yk5mYdntwrK7hWX3C8tOC8seFpY9Lix7Wlf2IHp/D4cUOcVvsld++OLgHD9sw+2HqfbDLp+JM/Ot6ZWJ6HPjQ0xEn0cfYiL6nPsQE9Hn54eYiD6XP8RE9Hn/ISai/YgPMclg8sBEdD7hM0wi/NhHJvBjH5nAj31kAj/2kQmByQMT+LGPTODHPjBJ28wTU9zJxMTXTHI+hLh/4a7+w7Zke/zy5W939yJd+UrMpW0m1ichbhNRfRLiNiHYJyFuE7N9EGLeJsj7JMRtosJPQtwmjPwkxG3izk9CJEB8HyIiFgaIiFgYICJiYYCIiIUBIiKW9yEWRCwMEBGxMEBExMIAERELA0QCxPchImJhgIiIhQEiIhYGiIhYGCAiYnkbojOIWBggImJhgIiIhQEiIhYGiASI70NExMIAERELA0RELAwQEbEwQETE8j5Ei4iFASIiFgaIiFgYICJiYYBIgPg+REQsDBARsTBARMTCABERCwNERCzvQ3SIWBggImJhgIiIhQEiIhYGiASI70NExMIAERELA0RELAwQEbEwQETE8j5Ej4iFASIiFgaIiFgYICJiYYBIgPg+REQsDBARsTBARMTCABERCwNERCzvQ5R9cdWPIKZyg5heQ3xZmNPJvhDrQ0z2iSfYmHz2Apz8mkmKR9uU4qPobl3R/bqi00jRr0OE8UPE8UNwOJnlKNRMNjRs7Ckc8ni6s7EN9CVQliZQESYQy80SrAJZaQI5aQJ5aQKRNIGCNIGiNIGk7dRx6E59HaIMHyKZ8UPY8UO48UP48UMw7ErO0DGET+71FM9n2+xvV5G6X2M8tC35uLa0lO9tr6KHdUWP64qe1hU9ryt6WVZ0joL9nxLdriu6W1d0v67o656med3TNK97muZ1T1OOssY2mdM5zY/OKUfR39YQbvwQfvwQNH6IMH6IOH6INH6IPH6IMnoIb8z4Iez4Idz4Ifz4IWj8EGH8EHH8EGn8EHn8EONXtx2/uu341W3Hr247fnXb8avbjl/ddvzqtuNXtx2/uu341e3Gr243fnW78avbjV/dbvzqduNXtxu/ut341e3Gr243fnX78avbj1/dfvzq9uNXtx+/uv341e3Hr24/fnX78avbj1/dNH510/jVTeNXN41f3TR+ddP41U3jVzeNX900fnXT+NUdxq/uMH51h/GrO4xf3WH86g7jV3cYv7rD+NUdxq/uMH51x/GrO45f3XH86o7jV3ccv7rj+NUdx6/uOH51x/GrO45f3Wn86k7jV3cav7rT+NWdxq/uNH51p/GrO41f3Wn86k7jV3cev7rz+NWdx6/uPH515/GrO49f3Xn86s7jV3cev7rz+NU9/l01P/5dNT/+XTU//l01P/5dNT/+XTU//l01P/5dNT/+XTU//l01Gv+uGhnJXwLEo601xn1rfJVd8qcALdklfwvQkp0Wll3y1wAt2SV/DtCSfej3ANchGPZ8f34aQP7u24BziDJ8CI43GFtD2PFDuPFD0Pghwvgh4vgh0vghxi89O37pufFLz41fem780uN4vbA1xPjV7cavbjd+dbvxq9uNX91u/Or241e3H7+6/fjV7cevbj9+dfvxq9uPX91+/Or241e3H7+6afzqpvGrm8avbhq/umn86qbxq5vGr24av7pp/Oqm8as7jF/dYfzqDuNXdxi/usP41R3Gr+4wfnWH8as7jF/dYfzqjuNXdxy/uuP41R3Hr+44fnXH8as7jl/dcfzqjuNXdxy/utP41Z3Gr+40fnWn8as7jV/dafzqTuNXdxq/utP41Z3Gr+48fnXn8as7j1/defzqzuNXdx6/uvP41Z3Hr+48fnXn8au7jF/dZfzqLuNXdxm/usv41V3Gr+4yfnWX8au7jF/dZfjqDsaMH8KOH8KNH8KPH4LGDxHGDxHHD5HGD5HHDzF+dY9/kSyMf5EsjH+RLNjxq3v8u2ph/LtqYfy7aoHjXbVkz4tBcrb3Q7z5iuvLstGB4x24T4lelhWd4529YaK/fic6cLwM+DHZ3cKy+4Vlp4VlDwvLznD2FXM0vqQkGrK/vJI0cLz0yShNFiVNGSnN7yE4XiVtDWHHD+HGD+HHD0Hjh3h/37qcl8ecvWzhje+uvCv5+GVv6fbLX+JEWeIkWeLkyeL4WE5x7j6wrd0zTfYUnZxND6KXZUVneP32m+jFPKxChtdvm0O48UO8vyOGFA9ThEyVIWj8EGH8EHH8EGn8EHn8EGX4EAyv3zaHsOOHcOOHGL+6w/jVHcavbobXb8Ml/vtqHI0tr486Oi8LDncug830JU6SJU6WJU4RJQ7D68Ks4lhZ4jhZ4nhZ4pAsccJccS4p50McyhVxoixxkixxsixxiihxkpEljpUljpMljpclzuRd+eLv3ZzTijhBljhRljhJljhZljhFlDjZyBLHyhLHyRLHyxJH1q6ch+7K1yHi+CHS+CHe3xGjOW0RybrHIcrwIRg+PWgOYccP4cYP4ccPQeOHCOOHiOOHSOOHGL+6y/DVHY0ZP4QdP4QbP4QfPwSNHyKMHyKOHyKNHyKPH2L86rbjV7cdv7rt+NVtx69uO3512/Gr245f3Xb86rbjV7cdv7rd+NXtxq9uN351u/Gr241f3W786nbjV7cbv7rd+NXtxq9uP351+/Gr249f3X786vbjV7cfv7r9+NXtx69uP351+/Grm8avbhq/umn86qbxq5vGr24av7pp/Oqm8aubxq9uGr+6w/jVHcav7jB+dYfxqzuMX91h/OoO41d3GL+6w/jVHcav7jh+dcfxqzuOX91x/OqO41d3HL+64/jVHcev7jh+dcfxqzuNX91p/OpO41d3Gr+60/jVncav7jR+dafxqzuNX91p/OrO41d3Hr+68/jVncev7jx+defxqzuPX915/Ooe/65aHP+uWhz/rloc/65aHP+uWhz/rloc/65aHP+uWhz/rloc/65aHP+uWhz/rloa/65aGv+uWhr/rloa/65aMjR+iDB+iDh+iDR+iDx+CIbVHbw7hgjRPwzB8a4auVOL6ML9EI+N+WpfJo534D4lultXdL+u6LSu6GFd0eO6oqd1Rc/ril6WFd2te5q6dU9Tt+5p6tY9TTnevf2U6Ouepk7yafq6iHRyko/TluySz9OW7JIP1IbsXvKJ2pJd8pHakn3omXodwo8fgsYPEcYPEccPkcYPkccPUYYPQWb8EHb8EONXN41f3TR+ddP41U3jVzeNX900fnXT+NUdxq/uMH51h/GrO4xf3WH86g7jVzfHu9eRzFfjFL5fGvfYmOztnoLb79p8vaggcbzh/Fyc6xDvz75U0nEzQzYmvdb4MuLxyxfv9faEKxwqe2HykDB5gjB5ojB5kjB5sjB5iix5GN4k/6E85XjC7vJdletTHitMHidMnsn7s3fmvPbH3Z2RpzwkTJ4gTJ4oTJ40XR7zSp48ef/xZI96mJ6ceZTHCpPHCZPHC5Nn9v7jbxfKkf0mTy288MfkJ0uPm3kOooU/d5K68LN3NvLnzkbBvkk+iRa+QT7PFj7FU/iSH+UpsuQpRpg8Vpg87nPyhLvHZ6c8Xpg8JEyeIEye2Tu/P7OGPtj0evO0MR87v013l5ray99X6WfvnumswO4vU/29c6sU0cK/PLeymb0vXx4Onr/8PZauzBtTjrtY7cUID/Mmm9m7eHZ0/vLjLp6NEyaPFyYPCZMnCJMnCpMnCZMny5KH49sjvmdj2VpZ4jhZ4nhZ4pAscYIscaIscZIscUQ9k88c37v8SJyzLYXv4tRELzfZ7wKVL9GdWVd0u67obl3R/bqi07qih3VFj+uKntYVPa8r+rqnqV/3NPXrnqZ+3dPUr3uacnyZ8ynR1z1N/bqnqV/3NPXrnqZ+3dOU1j1Nad3TlNY9TWn2aepPaSI1RG89A84c38J9TviwsvBxZeHTysLnlYUvCwsfzMrC25WFd3KFT8Ydb1klKu71D9uSjlegnI2390dtoC9NBR/HzJoKPrtfaHqVXfDR3ZRdzMl9Fad+IkRzvMXlk8uvxXGWblMt3Gnsr0M8uUPpZ0NEf5vN5XEIO34IN34IP34IGj9EeH8Id64h5zzdD1FpTP5sTJXXJZ982vs5eZIwebIweYoseZIRJo8VJo8TJo+fLY/LN3niozwkTJ4gTJ7Z+3MIx+vs7r44fc+HBDkl0cK//pAgzd75gz09h5AaX+9lc/zwJWvxGJKmsq7s2Swsu11Ydrew7H5h2aNk2cMReF9Oom+y10Iffxfp3n6Yaj/sbp98mW9Nr0wSmDwwEX0efYiJ6HPuM0yK6PPzQ0xEn8sfYiL6vP8QE9F+xIeYEJg8MAlg8sAEfuwjE/ixf2RSzDZ+rLlVUbQmvmZyCVG/2hbrGj9sS7bHL1/+dnd3QRT3BXEbx/eDEO02nvInIW7jWn8S4ja++CchbuO8fxIiAeL7ELcJDz4JcZt44pMQtwlAPgkREQsDREQs70N0iFgYICJiYYCIiIUBIiIWBogEiO9DRMTCABERCwNERCwMEBGxMEBExPI+RI+IhQEiIhYGiIhYGCAiYmGASID4PkRELAwQEbEwQETEwgAREQsDREQs70MkRCwMEBGxMEBExMIAERELA0QCxPchImJhgIiIhQEiIhYGiIhYGCAiYnkfYkDEwgAREQsDREQsDBARsTBAJEB8HyIiFgaIiFgYICJiYYCIiIUBIiKW9yFGRCwMEBGxMEBExMIAERELA0QCxPchImJhgIiIhQEiIhYGiIhYGCAiYnkfYkLEwgAREQsDREQsDBARsTBAJEB8HyIiFgaIiFgYICJiYYCIiIUBIiKW9yHKvkdrFYiIWBggImJhgIiIhQEiAeL7EBGxMEBExMIAERELA0RELAwQEbG8D3Gfmws/CRERCwNERCwMEBGxMEAkQHwfIiIWBoiIWBggImJhgIiIhQEiIpZ3IXpjELEwQETEwgAREQsDREQsDBAJEN+HiIiFASIiFgaIiFgYICJiYYCIiOV9iLjzngMiIhYGiIhYGCAiYmGASID4PkRELAwQEbEwQETEwgAREQsDREQs70PEnfccEBGxMEBExMIAERELA0QCxPchImJhgIiIhQEiIhYGiIhYGCAiYnkfIu6854CIiIUBIiIWBoiIWBggEiC+DxERCwNERCwMEBGxMEBExMIAERHL+xBx5z0HREQsDBARsTBARMTCAJEA8X2IiFgYICJiYYCIiIUBIiIWBoiIWN6HiDvvOSAiYmGAiIiFASIiFgaIBIjvQ0TEwgAREQsDREQsDBARsTBARMTyPkTcec8BERELA0RELAwQEbEwQCRAfB8iIhYGiIhYGCAiYmGAiIiFASIilvch4s57DoiIWBggImJhgIiIhQEiAeL7EBGxMEBExMIAERELA0RELAwQEbG8DxF33nNARMTCABERCwNERCwMEAkQ34eIiIUBIiIWBoiIWBggImJhgIiI5X2IuPOeAyIiFgaIiFgYICJiYYBIgPg+REQsDBARsTBARMTCABERCwNERCxvQ7S4854DIiIWBoiIWBggImJhgEiA+D5ERCwMEBGxMEBExMIAERELA0RELO9DxJ33HBARsTBARMTCABERCwNEAsT3ISJiYYCIiIUBIiIWBoiIWBggImJ5HyLuvOeAiIiFASIiFgaIiFgYIBIgvg8REQsDREQsDBARsTBARMTCABERy/sQcec9B0RELAwQEbEwQETEwgCRAPF9iIhYGCAiYmGAiIiFASIiFgaIiFjeh4g77zkgImJhgIiIhQEiIhYGiASI70NExMIAERELA0RELAwQEbEwQETE8j5E3HnPARERCwNERCwMEBGxMEAkQHwfIiIWBoiIWBggImJhgIiIhQEiIpb3IeLOew6IiFgYICJiYYCIiIUBIgHi+xARsTBARMTCABERCwNERCwMEBGxvA8Rd95zQETEwgAREQsDREQsDBAJEN+HiIiFASIiFgaIiFgYICJiYYCIiOV9iLjzngMiIhYGiIhYGCAiYmGASID4PkRELAwQEbEwQETEwgAREQsDREQs70PEnfccEBGxMEBExMIAERELA0QCxPchImJhgIiIhQEiIhYGiIhYGCAiYnkbosOd9xwQEbEwQETEwgAREQsDRALE9yEiYmGAiIiFASIiFgaIiFgYICJieR8i7rzngIiIhQEiIhYGiIhYGCASIL4PERELA0RELAwQEbEwQETEwgAREcv7EHHnPQdERCwMEBGxMEBExMIAkQDxfYiIWBggImJhgIiIhQEiIhYGiIhY3oeIO+85ICJiYYCIiIUBIiIWBogEiO9DRMTCABERCwNERCwMEBGxMEBExPI+RNx5zwEREQsDREQsDBARsTBAJEB8HyIiFgaIiFgYICJiYYCIiIUBIiKW9yHiznsOiIhYGCAiYmGAiIiFASIB4vsQEbEwQETEwgAREQsDREQsDBARsbwPEXfec0BExMIAERELA0RELAwQCRDfh4iIhQEiIhYGiIhYGCAiYmGAiIjlfYgb3Xmfyg1ieg3RZXuoZ+x90yuTfQIQPib7xBN8TPYJD/iYEJg8MNnHeWdj8tm7EfNrJikebVOKj6KndUXP64o+1Nv7PcTYu+muQ9jxQ3Cc1JSOIbxt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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "notify_created_nullifier_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "debug_log_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_integer_quotient",
        "directive_invert"
      ],
      "verification_key": "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"
    },
    {
      "name": "lock_public_solver",
      "is_unconstrained": true,
      "custom_attributes": [
        "internal",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 48
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "15001264570739363109": {
            "error_kind": "string",
            "string": "Function lock_public_solver can only be called internally"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "lock_public_solver"
      ]
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "constructor"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000001"
            },
            {
              "kind": "string",
              "value": "HTLC_Private"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Train"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "contracts_private",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "contracts_public",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "events": [
        {
          "fields": [
            {
              "name": "Id",
              "type": {
                "kind": "field"
              }
            },
            {
              "name": "hashlock",
              "type": {
                "kind": "array",
                "length": 32,
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 8
                }
              }
            },
            {
              "name": "timelock",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 64
              }
            }
          ],
          "kind": "struct",
          "path": "Train::TokenLockAdded"
        },
        {
          "fields": [
            {
              "name": "Id",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::TokenRefunded"
        },
        {
          "fields": [
            {
              "name": "Id",
              "type": {
                "kind": "field"
              }
            },
            {
              "name": "amount",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            },
            {
              "name": "token",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "timelock",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 64
              }
            }
          ],
          "kind": "struct",
          "path": "Train::TokenLocked"
        },
        {
          "fields": [
            {
              "name": "Id",
              "type": {
                "kind": "field"
              }
            },
            {
              "name": "amount",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            },
            {
              "name": "token",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "timelock",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 64
              }
            },
            {
              "name": "src_receiver",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::TokenCommitted"
        },
        {
          "fields": [
            {
              "name": "Id",
              "type": {
                "kind": "field"
              }
            },
            {
              "name": "hashlock",
              "type": {
                "kind": "array",
                "length": 32,
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 8
                }
              }
            },
            {
              "name": "secret",
              "type": {
                "kind": "array",
                "length": 32,
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 8
                }
              }
            }
          ],
          "kind": "struct",
          "path": "Train::TokenRedeemed"
        }
      ],
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 48
                    }
                  },
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "src_receiver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::commit_public_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::commit_public_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::add_lock_public_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::add_lock_public_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::add_lock_private_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::add_lock_private_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "secret",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::redeem_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::redeem_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 48
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::lock_private_solver_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::lock_private_solver_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 48
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::lock_public_solver_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::lock_public_solver_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::refund_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::refund_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "secret",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::redeem_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::redeem_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "Train::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::refund_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::refund_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "src_receiver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 48
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::commit_private_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::commit_private_user_abi"
        }
      ]
    }
  },
  "file_map": {
    "103": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "108": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "112": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    discovery::private_notes::MAX_NOTE_PACKED_LEN,\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{\n            stub_registry,\n            utils::{check_each_fn_macroified, create_message_discovery_call},\n        },\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_notes` utility function PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_notes = generate_sync_notes();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_notes\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_notes() -> Quoted {\n    let message_discovery_call = create_message_discovery_call();\n\n    // TODO(https://github.com/noir-lang/noir/issues/7912): Doing the following unfortunately doesn't work. Once\n    // the issue is fixed uncomment the following and remove the workaround from TS (look for the issue link in the\n    // codebase).\n    // let utility: fn(FunctionDefinition) -> () = crate::macros::functions::utility;\n    // quote {\n    //     #[$utility]\n    //     unconstrained fn sync_notes() {\n    //         $message_discovery_call\n    //     }\n    // }\n\n    quote {\n        #[aztec::macros::functions::utility]\n        unconstrained fn sync_notes() {\n            $message_discovery_call\n        }\n    }\n}\n"
    },
    "113": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "116": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_slice, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_view,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_SLICE_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args =  &[];\n    // serialized_args = serialized_args.append(aztec::protocol_types::traits::Serialize::serialize(target_address));\n    // serialized_args = serialized_args.push_back(fee_juice_limit_per_tx as Field);\n    // ```\n    let serialized_args_slice_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_SLICE_NAME = &[];\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append = add_to_field_slice(SERIALIZED_ARGS_SLICE_NAME, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n"
    },
    "117": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "120": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, &[], false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "122": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher, poseidon2::Poseidon2Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, &[], true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "123": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use std::{collections::umap::UHashMap, hash::{BuildHasherDefault, poseidon2::Poseidon2Hasher}};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\nuse super::utils::is_note;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract. Only a single struct in the entire contract\n/// should have this macro (or `storage_no_init`) applied to it.\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot }, false);\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n/// Only a single struct in the entire contract should have this macro (or `storage`) applied to it.\npub comptime fn storage_no_init(_s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(\n    typ: Type,\n    slot: Quoted,\n    parent_is_map: bool,\n) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot }, true);\n        (quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }, 1)\n    } else {\n        let storage_size = if parent_is_map {\n            // Variables inside a map do not require contiguous slots since the map slot derivation is assumed to result\n            // in slots very far away from one another.\n            1\n        } else {\n            let (_, container_struct_generics) = typ.as_data_type().unwrap();\n            let stored_struct = container_struct_generics[0];\n\n            if is_note(stored_struct) {\n                // Private notes always occupy a single slot, since the slot is only used as a state variable\n                // identifier.\n                1\n            } else {\n                get_storage_size(typ)\n            }\n        };\n\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        (quote { $struct_name::new(context, $slot)}, storage_size)\n    }\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "127": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_interface::{NoteHash, NoteType},\n    retrieved_note::RetrievedNote,\n    utils::{compute_note_hash_for_nullify_from_read_request, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::notify_created_note;\nuse protocol_types::traits::Packable;\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    let note_hash_counter = context.side_effect_counter;\n\n    let note_hash = note.compute_note_hash(storage_slot);\n\n    let packed_note = Note::pack(note);\n    notify_created_note(\n        storage_slot,\n        Note::get_id(),\n        packed_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(note, storage_slot, note_hash_counter)\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n\n    destroy_note_unsafe(context, retrieved_note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_from_read_request(retrieved_note, note_hash_for_read_request);\n    let nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash = if retrieved_note.metadata.is_settled() {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifying so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, note_hash)\n}\n"
    },
    "132": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/note/note_getter.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n    retrieved_note::RetrievedNote,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::oracle;\nuse crate::utils::{array, comparison::compare};\nuse dep::protocol_types::{\n    constants::{GET_NOTES_ORACLE_RETURN_LENGTH, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL},\n    traits::{Packable, ToField},\n};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    packed_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the packed note.\n    // This allows easier packing and custom (un)packing schemas. A note property is located\n    // inside the packed note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = packed_note[selector.index].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_packed_note<let N: u32>(packed_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(packed_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (RetrievedNote<Note>, Field)\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    // Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do\n    // is check that the metadata is correct, and that the note exists.\n    let retrieved_note = unsafe { get_note_internal::<Note, N>(storage_slot) };\n\n    // For settled notes, the contract address is implicitly checked since the hash returned from\n    // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n    // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the contract\n    // address returned from the oracle matches. Since branching in circuits is expensive, we perform this check on all\n    // note types.\n    assert(\n        retrieved_note.contract_address.eq(context.this_address()),\n        \"Note contract address mismatch.\",\n    );\n\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (retrieved_note, note_hash_for_read_request)\n}\n\n/// Returns a BoundedVec of notes that have been proven to have been created by this contract, either in the current or\n/// past transactions (i.e. pending or settled notes). A second BoundedVec contains the note hashes used for the read\n/// requests, which can save constraints when computing the note's nullifiers.\n///\n/// WARNING: recall that notes are never destroyed! Note existence therefore does not imply that the note is _current_\n/// or _valid_ - this typically requires also emitting the note's nullifier to prove that it had not been emitted\n/// before. Because of this, calling this function directly from end-user applications should be discouraged, and safe\n/// abstractions such as aztec-nr's state variables should be used instead.\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // Safety: The notes are constrained below.\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the notes (as opposed to simply removing some), the private\n    // kernel will later validate that these note actually exist, so transformations would cause for that check\n    // to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = array::collapse(filtered_notes);\n    let mut note_hashes = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_packed_note = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let retrieved_note = notes.get_unchecked(i);\n\n            // For settled notes, the contract address is implicitly checked since the hash returned from\n            // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n            // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the\n            // contract address returned from the oracle matches. Since branching in circuits is expensive, we perform\n            // this check on all note types.\n            assert(\n                retrieved_note.contract_address.eq(context.this_address()),\n                \"Note contract address mismatch.\",\n            );\n\n            let packed_note = retrieved_note.note.pack();\n            check_packed_note(packed_note, options.selects);\n            if i != 0 {\n                check_notes_order(prev_packed_note, packed_note, options.sorts);\n            }\n            prev_packed_note = packed_note;\n\n            let note_hash_for_read_request =\n                compute_note_hash_for_read_request(retrieved_note, storage_slot);\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> RetrievedNote<Note>\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let opt_notes: [_; 1] = oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_fields,\n    );\n\n    opt_notes[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_fields,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\n/// Unconstrained variant of `get_notes`, meant to be used in unconstrained execution contexts. Notably only the note\n/// content is returned, and not any of the information used when proving its existence (e.g. nonce, note hash, etc.).\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteType + Packable<N> + Eq,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n\n    // We fetch the notes from the same oracle we use in the constrained case, except we don't bother inspecting the\n    // metadata in order to prove existence.\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_fields,\n    );\n\n    // Even though we don't expect for the opt_notes array to be sparse, collapse is still useful in this case to\n    // convert it into a BoundedVec.\n    array::collapse(opt_notes).map(\n        // view_notes just returns the actual note, so we drop the metadata\n        |retrieved_note| retrieved_note.note,\n    )\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
    },
    "135": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "138": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "141": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "142": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "143": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "144": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "145": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "146": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "150": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "151": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "152": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "153": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use crate::discovery::MAX_LOG_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    log_content: BoundedVec<Field, MAX_LOG_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        log_content,\n        tx_hash,\n        log_index_in_tx,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    log_content: BoundedVec<Field, MAX_LOG_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n) {}\n"
    },
    "154": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr",
      "source": "use crate::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn sync_notes(pending_tagged_log_array_base_slot: Field) {\n    sync_notes_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "156": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::{\n    note::{note_interface::NoteType, note_metadata::NoteMetadata, retrieved_note::RetrievedNote},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::IndexedTaggingSecret,\n    traits::{FromField, Packable},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {\n    // This wrapper exists to extract the ORACLE_RETURN_FIELD_LENGTH generic numeric param into a value and pass it to\n    // the oracle, so that it knows how big the return array must be.\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        ORACLE_RETURN_FIELD_LENGTH,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let MAX_NOTES: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    _placeholder_fields: [Field; ORACLE_RETURN_FIELD_LENGTH], // TODO: Compute this value automatically from MAX_NOTES\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let fields: [_; ORACLE_RETURN_FIELD_LENGTH] = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n\n    let mut opt_notes = [Option::none(); MAX_NOTES];\n    for i in 0..opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let maybe_nonce = fields[read_offset];\n            let maybe_note_hash_counter = fields[read_offset + 1] as u32;\n            let packed_note = array::subarray(fields, read_offset + 2);\n\n            let note = Note::unpack(packed_note);\n            let retrieved_note = RetrievedNote {\n                note,\n                contract_address,\n                metadata: NoteMetadata::from_raw_data(maybe_note_hash_counter != 0, maybe_nonce),\n            };\n\n            opt_notes[i] = Option::some(retrieved_note);\n        };\n    }\n    opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "158": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "159": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        embedded_curve_add_unsafe(point1, point2)\n    } else {\n        // In a constrained context we need to do some black magic in order to satisfy the backend's\n        // expectations about the inputs to an `embedded_curve_add` opcode.\n        //\n        // TODO: document this better.\n        let x_coordinates_match = point1.x == point2.x;\n        let y_coordinates_match = point1.y == point2.y;\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: x_coordinates_match,\n        };\n        // point1_1 is guaranteed to have a different abscissa than point2\n        let mut result = embedded_curve_add_unsafe(point1_1, point2);\n        result.is_infinite = x_coordinates_match;\n\n        // dbl if x_match, y_match\n        let double = embedded_curve_add_unsafe(point1, point1);\n        result = if double_predicate { double } else { result };\n\n        // infinity if x_match, !y_match\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"
    },
    "161": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "163": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/state_vars/private_immutable.nr",
      "source": "use dep::protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\nuse crate::context::{PrivateContext, UtilityContext};\nuse crate::note::{\n    lifecycle::create_note,\n    note_emission::NoteEmission,\n    note_getter::{get_note, view_notes},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateImmutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context, let N: u32> Storage<N> for PrivateImmutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateImmutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateImmutable>` type (for example), because the storage slot often also identifies an actor.\n    // e.g. the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<Note> PrivateImmutable<Note, &mut PrivateContext> {\n    // docs:start:initialize\n    pub fn initialize<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: NoteType + NoteHash + Packable<N>,\n    {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:get_note\n    pub fn get_note<let N: u32>(self) -> Note\n    where\n        Note: NoteType + NoteHash + Packable<N>,\n    {\n        let storage_slot = self.storage_slot;\n        let retrieved_note = get_note(self.context, storage_slot).0;\n\n        // Because the notes obtained from PrivateImmutable are not meant to be nullified and get_note(...) function\n        // has already constrained the note (by pushing a read request to the context), we can return just the note\n        // and skip the additional data in RetrievedNote.\n        retrieved_note.note\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateImmutable<Note, UtilityContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    // docs:start:is_initialized\n    pub unconstrained fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // view_note does not actually use the context, but it calls oracles that are only available in private\n    // docs:start:view_note\n    pub unconstrained fn view_note<let N: u32>(self) -> Note\n    where\n        Note: Packable<N>,\n    {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "172": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable.nr",
      "source": "use dep::protocol_types::{\n    shared_mutable::{\n        ScheduledDelayChange,\n        ScheduledValueChange,\n        shared_mutable_values::{unpack_delay_change, unpack_value_change},\n        SharedMutableValues,\n    },\n    traits::Packable,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\n\nmod test;\n\npub struct SharedMutable<T, let INITIAL_DELAY: u32, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// This will make the Aztec macros require that T implements the Packable and Eq traits, and allocate `M` storage\n// slots to this state variable.\nimpl<T, let INITIAL_DELAY: u32, Context, let M: u32> Storage<M> for SharedMutable<T, INITIAL_DELAY, Context>\nwhere\n    WithHash<SharedMutableValues<T, INITIAL_DELAY>, _>: Packable<M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in blocks. Reads in private are only valid as long as they are included in a block not too far into the\n// future, so that they can guarantee the value will not have possibly changed by then (because of the delay).\n// The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, let INITIAL_DELAY: u32, Context> SharedMutable<T, INITIAL_DELAY, Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PublicContext>\nwhere\n    T: Eq,\n{\n\n    pub fn schedule_value_change<let N: u32>(self, new_value: T)\n    where\n        T: Packable<N>,\n    {\n        let _value_change = self.schedule_and_return_value_change(new_value);\n    }\n\n    pub fn schedule_and_return_value_change<let N: u32>(\n        self,\n        new_value: T,\n    ) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n        let current_delay = delay_change.get_current(block_number);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let block_of_change = block_number + current_delay;\n        value_change.schedule_change(new_value, block_number, current_delay, block_of_change);\n\n        self.write(value_change, delay_change);\n\n        value_change\n    }\n\n    pub fn schedule_delay_change<let N: u32>(self, new_delay: u32)\n    where\n        T: Packable<N>,\n    {\n        let mut delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n\n        delay_change.schedule_change(new_delay, block_number);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    pub fn get_current_delay<let N: u32>(self) -> u32\n    where\n        T: Packable<N>,\n    {\n        let block_number = self.context.block_number() as u32;\n        self.read_delay_change().get_current(block_number)\n    }\n\n    pub fn get_scheduled_value<let N: u32>(self) -> (T, u32)\n    where\n        T: Packable<N>,\n    {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay<let N: u32>(self) -> (u32, u32)\n    where\n        T: Packable<N>,\n    {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change<let N: u32>(self) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        // We don't read ScheduledValueChange directly by having it implement Packable because ScheduledValueChange\n        // and ScheduledDelayChange are packed together (sdc and svc.block_of_change are stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_value_change::<T, N>(packed)\n    }\n\n    fn read_delay_change<let N: u32>(self) -> ScheduledDelayChange<INITIAL_DELAY>\n    where\n        T: Packable<N>,\n    {\n        // Since all ScheduledDelayChange member are packed into a single field, we can read a single storage slot\n        // here and skip the ones that correspond to ScheduledValueChange members. We are abusing the fact that\n        // the field containing the ScheduledDelayChange data is the first one in the storage layout - otherwise we'd\n        // need to offset the storage slot to get the position where it'd land.\n        // We don't read ScheduledDelayChange directly by having it implement Packable because\n        // ScheduledValueChange and ScheduledDelayChange are packed together (sdc and svc.block_of_change are\n        // stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_delay_change::<INITIAL_DELAY>(packed)\n    }\n\n    fn write<let N: u32>(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>,\n    )\n    where\n        T: Packable<N>,\n    {\n        // Whenever we write to public storage, we write both the value change and delay change to storage at once.\n        // We do so by wrapping them in a single struct (`SharedMutableValues`). Then we wrap the resulting struct in\n        // `WithHash`.\n        // Wrapping in `WithHash` makes for more costly writes but it also makes private proofs much simpler because\n        // they only need to produce a historical proof for the hash, which results in a single inclusion proof (as\n        // opposed to 4 in the best case scenario in which T is a single field). Private shared mutable reads are\n        // assumed to be much more frequent than public writes, so this tradeoff makes sense.\n        let values = WithHash::new(SharedMutableValues::new(value_change, delay_change));\n\n        self.context.storage_write(self.storage_slot, values);\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext>\nwhere\n    T: Eq,\n{\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction block number as this proof\n        // will only be valid for however many blocks we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n        let (value_change, delay_change, historical_block_number) =\n            self.historical_read_from_public_storage();\n\n        // We use the effective minimum delay as opposed to the current delay at the historical block as this one also\n        // takes into consideration any scheduled delay changes.\n        // For example, consider a scenario in which at block 200 the current delay was 50. We may naively think that\n        // the earliest we could change the value would be at block 251 by scheduling immediately after the historical\n        // block, i.e. at block 201. But if there was a delay change scheduled for block 210 to reduce the delay to 20\n        // blocks, then if a value change was scheduled at block 210 it would go into effect at block 230, which is\n        // earlier than what we'd expect if we only considered the current delay.\n        let effective_minimum_delay =\n            delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon =\n            value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any block after the block horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_tx_max_block_number(block_horizon);\n        value_change.get_current_at(historical_block_number)\n    }\n\n    fn historical_read_from_public_storage<let N: u32>(\n        self,\n    ) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u32)\n    where\n        T: Packable<N>,\n    {\n        let header = self.context.get_block_header();\n        let address = self.context.this_address();\n\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        let values: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::historical_public_storage_read(header, address, self.storage_slot);\n\n        (values.svc, values.sdc, historical_block_number)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, UtilityContext>\nwhere\n    T: Eq,\n{\n    pub unconstrained fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let smv: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::utility_public_storage_read(self.context, self.storage_slot);\n\n        let block_number = self.context.block_number() as u32;\n        smv.svc.get_current_at(block_number)\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "184": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "186": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/utils/array/mod.nr",
      "source": "pub mod append;\npub mod collapse;\npub mod subarray;\npub mod subbvec;\n\npub use append::append;\npub use collapse::collapse;\npub use subarray::subarray;\npub use subbvec::subbvec;\n\n// This will eventually be replaced by `BoundedVec::for_each`, once that's implemented.\npub unconstrained fn for_each_in_bounded_vec<T, let MaxLen: u32, Env>(\n    vec: BoundedVec<T, MaxLen>,\n    f: fn[Env](T, u32) -> (),\n) {\n    for i in 0..vec.len() {\n        f(vec.get_unchecked(i), i);\n    }\n}\n"
    },
    "187": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "188": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "190": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "191": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "193": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "195": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "199": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "215": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "217": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "24": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "260": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "275": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "277": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "278": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "288": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "292": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `omit`: A list of field names (as `Quoted`) to be excluded from the serialized output.\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, &[], false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, &[], false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], &[], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, &[], false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with Omitted Field and packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// Serializing while omitting `value2`:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, MyStruct, &[quote { self.value2 }], true)\n/// // Returns:\n/// // ([`value_packed[0]`], [`let value_packed = self.value.pack()`])\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    omit: [Quoted],\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // Proceed if none of the omit rules omits this name\n    if !omit.any(|to_omit| to_omit == name) {\n        // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n        let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n        let packable_constraint =\n            quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n        if (should_pack & typ.implements(packable_constraint)) {\n            // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n            // method, add the resulting field array to `aux_vars` and each field to `fields`.\n            let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n            // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n            let name_at_one_token = collapse_to_one_token(name);\n            let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n            // We add the individual fields to the fields array\n            let pack_method = get_trait_impl_method(\n                typ,\n                quote { crate::traits::Packable<$packed_len> },\n                quote { pack },\n            );\n            let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n            for i in 0..packed_len {\n                fields = fields.push_back(quote { $packed_struct_name[$i] });\n            }\n\n            // We add the new auxiliary variable to the aux_vars array\n            aux_vars = aux_vars.push_back(packed_struct);\n        } else if typ.is_field() {\n            // For field we just add the value to fields\n            fields = fields.push_back(name);\n        } else if typ.as_integer().is_some() | typ.is_bool() {\n            // For integer and bool we just cast to Field and add the value to fields\n            fields = fields.push_back(quote { $name as Field });\n        } else if typ.as_data_type().is_some() {\n            // For struct we pref\n            let nested_struct = typ.as_data_type().unwrap();\n            let params = nested_struct.0.fields(nested_struct.1);\n            let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n                let maybe_prefixed_name = if name == quote {} {\n                    // Triggered when the param name is of a value available in the current scope (e.g. a function\n                    // argument) --> then we don't prefix the name with anything.\n                    param_name\n                } else {\n                    // Triggered when we want to prefix the param name with the `name` from function input. This\n                    // can typically be `self` when implementing a method on a struct.\n                    quote { $name.$param_name }\n                };\n                generate_serialize_to_fields(\n                    quote {$maybe_prefixed_name},\n                    param_type,\n                    omit,\n                    should_pack,\n                )\n            });\n            let struct_flattened_fields = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n            );\n            let struct_flattened_aux_vars = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n            );\n            fields = fields.append(struct_flattened_fields);\n            aux_vars = aux_vars.append(struct_flattened_aux_vars);\n        } else if typ.as_array().is_some() {\n            // For array we recursively call `generate_serialize_to_fields(...)` for each element\n            let (element_type, array_len) = typ.as_array().unwrap();\n            let array_len = array_len.as_constant().unwrap();\n            for i in 0..array_len {\n                let (element_fields, element_aux_vars) = generate_serialize_to_fields(\n                    quote { $name[$i] },\n                    element_type,\n                    omit,\n                    should_pack,\n                );\n                fields = fields.append(element_fields);\n                aux_vars = aux_vars.append(element_aux_vars);\n            }\n        } else if typ.as_str().is_some() {\n            // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n            // then we add each byte to fields as a Field\n            let length_type = typ.as_str().unwrap();\n            let str_len = length_type.as_constant().unwrap();\n            let as_member = name.as_expr().unwrap().as_member_access();\n            let var_name = if as_member.is_some() {\n                as_member.unwrap().1\n            } else {\n                name\n            };\n            let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n            let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n            for i in 0..str_len {\n                fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n            }\n            aux_vars = aux_vars.push_back(as_bytes);\n        } else {\n            panic(\n                f\"Unsupported type for serialization of argument {name} and type {typ}\",\n            )\n        }\n    }\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) =\n        generate_serialize_to_fields(quote { self }, typ, &[], packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "294": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "295": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "304": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize, ToField},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "308": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_delay_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initially equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation\n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the\n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a\n// reduced delay, invalidating prior private reads.\npub struct ScheduledDelayChange<let INITIAL_DELAY: u32> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option,\n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pub(crate) pre: Option<u32>,\n    pub(crate) post: Option<u32>,\n    // Block at which `post` value is used instead of `pre`\n    pub(crate) block_of_change: u32,\n}\n\nimpl<let INITIAL_DELAY: u32> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u32>, post: Option<u32>, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current block number - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_block_number: u32) -> u32 {\n        // The post value becomes the current one at the block of change, so any transaction that is included in the\n        // block of change will use the post value.\n        if current_block_number < self.block_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the block at which it will become the current\n    /// delay. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u32, u32) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.block_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current block number. This function is only meaningful\n    /// when called in public with the current block number.\n    /// The block at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u32, current_block_number: u32) {\n        let current = self.get_current(current_block_number);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let blocks_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior constraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value block of change\n            //       block                 block of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   blocks until change               new delay            |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.block_of_change = current_block_number + blocks_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical block number. It only returns a meaningful value when called in private with historical blocks. This\n    /// function can be used alongside `ScheduledValueChange.get_block_horizon` to properly constrain the\n    /// `max_block_number` transaction property when reading mutable shared state.\n    /// This value typically equals the current delay at the block following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is\n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_block_number: u32) -> u32 {\n        if self.block_of_change <= historical_block_number {\n            // If no delay changes were scheduled, then the delay value at the historical block (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // block of change the current delay will be the scheduled one, with an overall delay from the historical\n            // block number equal to the number of blocks until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //         block                  delay                  actual earliest value\n            //           v                block of change              block of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest block in            |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |         blocks                  new delay                      |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest block in\n            //                             which to scheduled value change\n            let blocks_until_change = self.block_of_change - (historical_block_number + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                blocks_until_change + self.post.unwrap_or(INITIAL_DELAY),\n            )\n        }\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Empty for ScheduledDelayChange<INITIAL_DELAY> {\n    fn empty() -> Self {\n        Self { pre: Option::none(), post: Option::none(), block_of_change: 0 }\n    }\n}\n"
    },
    "310": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_value_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some block\n// called the `block_of_change`. The value can only be made to change by scheduling a change event at some future block\n// of change after some minimum delay measured in blocks has elapsed. This means that at any given block number we know\n// both the current value and the smallest block number at which the value might change - this is called the\n// 'block horizon'.\npub struct ScheduledValueChange<T> {\n    pub(crate) pre: T,\n    pub(crate) post: T,\n    // Block at which `post` value is used instead of `pre`\n    pub(crate) block_of_change: u32,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given block. This function can be called both in public\n    /// (where `block_number` is simply the current block number, i.e. the number of the block in which the current\n    /// transaction will be included) and in private (where `block_number` is the historical block number that is used\n    /// to construct the proof).\n    /// Reading in private is only safe if the transaction's `max_block_number` property is set to a value lower or\n    /// equal to the block horizon (see `get_block_horizon()`).\n    pub fn get_current_at(self, block_number: u32) -> T {\n        // The post value becomes the current one at the block of change. This means different things in each realm:\n        // - in public, any transaction that is included in the block of change will use the post value\n        // - in private, any transaction that includes the block of change as part of the historical state will use the\n        //   post value (barring any follow-up changes)\n        if block_number < self.block_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the block at which it will become the current\n    /// value. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u32) {\n        (self.post, self.block_of_change)\n    }\n\n    // Returns the previous value. This is the value that is current up until the block of change. Note that this value\n    // might not be the current anymore since block of change might have already passed.\n    pub fn get_previous(self) -> (T, u32) {\n        (self.pre, self.block_of_change)\n    }\n\n    /// Returns the largest block number at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_block_number`,\n    /// since due to its asynchronous nature private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum number of blocks that need to\n    /// elapse from the next block until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical block number is only safe to use\n    /// if the transaction's `max_block_number` property is set to a value lower or equal to the block horizon computed\n    /// using the same historical block number.\n    pub fn get_block_horizon(self, historical_block_number: u32, minimum_delay: u32) -> u32 {\n        // The block horizon is the very last block in which the current value is known. Any block past the horizon\n        // (i.e. with a block number larger than the block horizon) may have a different current value. Reading the\n        // current value in private typically requires constraining the maximum valid block number to be equal to the\n        // block horizon.\n        if historical_block_number >= self.block_of_change {\n            // Once the block of change has been mined, the current value (post) will not change unless a new value\n            // change is scheduled. This did not happen at the historical block number (or else it would not be\n            // greater or equal to the block of change), and therefore could only happen after the historical block\n            // number. The earliest would be the immediate next block, and so the smallest possible next block of change\n            // equals `historical_block_number + 1 + minimum_delay`. Our block horizon is simply the previous block to\n            // that one.\n            //\n            //      block of      historical\n            //       change         block            block horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n            historical_block_number + minimum_delay\n        } else {\n            // If the block of change has not yet been mined however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the block horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the block of change is in the past: the time horizon is the\n            //      block prior to the earliest one in which a new block of change might land.\n            //\n            //         historical\n            //           block                        block horizon      block of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` blocks away from the historical block number, in which case\n            //      the block of change would become the limiting factor for the time horizon, which would equal the\n            //      block right before the block of change (since by definition the value changes at the block of\n            //      change).\n            //\n            //           historical                         block horizon\n            //             block     block of change       if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the block of change to an arbitrary\n            // value, and therefore scenario a) is not currently possible. However implementing #5501 would allow for\n            // this to happen.\n            // Because historical_block_number < self.block_of_change, then block_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.block_of_change - 1,\n                historical_block_number + minimum_delay,\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current block number. This function is only meaningful when\n    /// called in public with the current block number.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_block_number: u32,\n        minimum_delay: u32,\n        block_of_change: u32,\n    ) {\n        assert(block_of_change >= current_block_number + minimum_delay);\n\n        self.pre = self.get_current_at(current_block_number);\n        self.post = new_value;\n        self.block_of_change = block_of_change;\n    }\n}\n\nimpl<T> Eq for ScheduledValueChange<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n\nimpl<T> Empty for ScheduledValueChange<T>\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        Self { pre: T::empty(), post: T::empty(), block_of_change: 0 }\n    }\n}\n"
    },
    "312": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/shared_mutable_values.nr",
      "source": "use crate::{\n    hash::poseidon2_hash,\n    shared_mutable::{\n        scheduled_delay_change::ScheduledDelayChange, scheduled_value_change::ScheduledValueChange,\n    },\n    traits::{Hash, Packable},\n    utils::arrays,\n};\nuse std::meta::derive;\n\nmod test;\n\n/// SharedMutableValues is just a wrapper around ScheduledValueChange and ScheduledDelayChange that then allows us\n/// to wrap both of these values in WithHash. WithHash allows for efficient read of values in private.\n///\n/// Note that the WithHash optimization does not work in public (due to there being no unconstrained). But we also want\n/// to be able to read the values efficiently in public and we want to be able to read each value separately. Reading\n/// the values separately is tricky because ScheduledValueChange and ScheduledDelayChange are packed together (sdc and\n/// svc.block_of_change are stored in the same slot). For that reason we expose `unpack_value_change` and\n/// `unpack_delay_change` functions that can be used to extract the values from the packed representation. This\n/// is \"hacky\" but there is no way around it.\n#[derive(Eq)]\npub struct SharedMutableValues<T, let INITIAL_DELAY: u32> {\n    pub svc: ScheduledValueChange<T>,\n    pub sdc: ScheduledDelayChange<INITIAL_DELAY>,\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutableValues<T, INITIAL_DELAY> {\n    pub fn new(svc: ScheduledValueChange<T>, sdc: ScheduledDelayChange<INITIAL_DELAY>) -> Self {\n        SharedMutableValues { svc, sdc }\n    }\n}\n\npub fn unpack_value_change<T, let N: u32>(packed: [Field; 2 * N + 1]) -> ScheduledValueChange<T>\nwhere\n    T: Packable<N>,\n{\n    let svc_pre_packed = arrays::subarray(packed, 1);\n    let svc_post_packed = arrays::subarray(packed, N + 1);\n    ScheduledValueChange::new(\n        T::unpack(svc_pre_packed),\n        T::unpack(svc_post_packed),\n        packed[0] as u32,\n    )\n}\n\npub fn unpack_delay_change<let INITIAL_DELAY: u32>(\n    packed: Field,\n) -> ScheduledDelayChange<INITIAL_DELAY> {\n    // This function expects to be called with just the first field of the packed representation, which contains sdc\n    // and svc block_of_change. We'll discard the svc component.\n    let svc_block_of_change = packed as u32;\n\n    let mut tmp = (packed - svc_block_of_change as Field) / TWO_POW_32;\n    let sdc_block_of_change = tmp as u32;\n\n    tmp = (tmp - sdc_block_of_change as Field) / TWO_POW_32;\n    let sdc_post_is_some = tmp as bool;\n\n    tmp = (tmp - sdc_post_is_some as Field) / TWO_POW_8;\n    let sdc_post_inner = tmp as u32;\n\n    tmp = (tmp - sdc_post_inner as Field) / TWO_POW_32;\n    let sdc_pre_is_some = tmp as bool;\n\n    tmp = (tmp - sdc_pre_is_some as Field) / TWO_POW_8;\n    let sdc_pre_inner = tmp as u32;\n\n    ScheduledDelayChange {\n        pre: if sdc_pre_is_some {\n            Option::some(sdc_pre_inner)\n        } else {\n            Option::none()\n        },\n        post: if sdc_post_is_some {\n            Option::some(sdc_post_inner)\n        } else {\n            Option::none()\n        },\n        block_of_change: sdc_block_of_change,\n    }\n}\n\nglobal TWO_POW_32: Field = 2.pow_32(32);\nglobal TWO_POW_8: Field = 2.pow_32(8);\n\n// We pack to `2 * N + 1` fields because ScheduledValueChange contains T twice (hence `2 * N`) and we need one extra\n// field to store ScheduledDelayChange and the block_of_change of ScheduledValueChange.\nimpl<T, let INITIAL_DELAY: u32, let N: u32> Packable<2 * N + 1> for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; 2 * N + 1] {\n        let mut result = [0; 2 * N + 1];\n\n        // We pack sdc.pre, sdc.post, sdc.block_of_change and svc.block_of_change into a single field as follows:\n        // [ sdc.pre_inner: u32 | sdc.pre_is_some: u8 | sdc.post_inner: u32 | sdc.post_is_some: u8 | sdc.block_of_change: u32 | svc.block_of_change: u32 ]\n        result[0] = self.svc.block_of_change as Field\n            + ((self.sdc.block_of_change as Field) * 2.pow_32(32))\n            + ((self.sdc.post.is_some() as Field) * 2.pow_32(64))\n            + ((self.sdc.post.unwrap_unchecked() as Field) * 2.pow_32(72))\n            + ((self.sdc.pre.is_some() as Field) * 2.pow_32(104))\n            + ((self.sdc.pre.unwrap_unchecked() as Field) * 2.pow_32(112));\n\n        // Pack the pre and post values from ScheduledValueChange\n        let svc_pre_packed = self.svc.pre.pack();\n        let svc_post_packed = self.svc.post.pack();\n        for i in 0..N {\n            result[i + 1] = svc_pre_packed[i];\n            result[i + 1 + N] = svc_post_packed[i];\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; 2 * N + 1]) -> Self {\n        let svc = unpack_value_change::<T, N>(fields);\n        let sdc = unpack_delay_change::<INITIAL_DELAY>(fields[0]);\n        Self::new(svc, sdc)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32, let N: u32> Hash for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn hash(self) -> Field {\n        poseidon2_hash(self.pack())\n    }\n}\n"
    },
    "315": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "329": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n"
    },
    "333": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "334": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "350": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "351": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "353": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "359": {
      "path": "/home/nerses/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "388": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    encrypted_logs::log_assembly_strategies::default_aes128,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER},\n        hash::poseidon2_hash_with_separator,\n        traits::{Deserialize, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// The returned `PartialUintNote` value must be sent to public execution via a secure channel, since it is not\n    /// possible to verify the integrity of its contents due to it hiding information. The recommended ways to do this\n    /// are to retrieve it from public storage, or to receive it in an internal public function call.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log = default_aes128::note::compute_partial_note_log(\n            private_log_content,\n            storage_slot,\n            recipient,\n            sender,\n        );\n        context.emit_private_log(encrypted_log);\n\n        PartialUintNote { commitment }\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nimpl PartialUintNote {\n    pub fn commitment(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, value: u128, context: &mut PublicContext) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; 2] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n"
    },
    "46": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "47": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "54": {
      "path": "/home/nerses/contracts/chains/aztec/contracts/train/src/lib.nr",
      "source": "pub fn bytes_to_u128_limbs(bytes: [u8; 32]) -> (u128, u128) {\n    let mut high: u128 = 0;\n    let mut low: u128 = 0;\n    for i in 0..16 {\n        high = (high << 8) + (bytes[i] as u128);\n    }\n    for i in 16..32 {\n        low = (low << 8) + (bytes[i] as u128);\n    }\n    (high, low)\n}\n\npub fn u128_limbs_to_bytes(high: u128, low: u128) -> [u8; 32] {\n    let mut bytes: [u8; 32] = [0; 32];\n\n    let mut temp = high;\n    for i in 0..16 {\n        bytes[15 - i] = (temp & 0xff) as u8;\n        temp >>= 8;\n    }\n\n    temp = low;\n    for i in 0..16 {\n        bytes[31 - i] = (temp & 0xff) as u8;\n        temp >>= 8;\n    }\n\n    bytes\n}\n"
    },
    "55": {
      "path": "/home/nerses/contracts/chains/aztec/contracts/train/src/main.nr",
      "source": "mod lib;\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract Train {\n    use crate::lib::{bytes_to_u128_limbs, u128_limbs_to_bytes};\n    use dep::aztec::protocol_types::traits::{Packable, Serialize};\n    use dep::aztec::state_vars::{private_immutable::PrivateImmutable, SharedMutable};\n    use dep::sha256;\n    use dep::token::Token;\n    use aztec::macros::{\n        events::event,\n        functions::{initializer, internal, private, public, utility},\n        notes::note,\n        storage::storage,\n    };\n    use aztec::prelude::{AztecAddress, Map};\n    use std::meta::derive;\n\n    #[note]\n    #[derive(Eq)]\n    struct HTLC_Private {\n        owner: AztecAddress,\n        randomness: Field,\n    }\n    #[derive(Eq, Packable)]\n    struct HTLC_Public {\n        src_receiver: AztecAddress,\n        amount: u128,\n        token: AztecAddress,\n        hashlock_high: u128,\n        hashlock_low: u128,\n        secret_high: u128,\n        secret_low: u128,\n        timelock: u64,\n        claimed: u8,\n    }\n\n    // TODO: Figure out how to emit all required data while staying within the public log size limit.\n    #[derive(Serialize)]\n    #[event]\n    struct TokenCommitted {\n        Id: Field,\n        amount: u128,\n        token: AztecAddress,\n        timelock: u64,\n        // dst_chain: str<8>,\n        // dst_asset: str<8>,\n        // dst_address: str<48>,\n        src_receiver: AztecAddress,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct TokenLockAdded {\n        Id: Field,\n        hashlock: [u8; 32],\n        timelock: u64,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct TokenRefunded {\n        Id: Field,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct TokenLocked {\n        Id: Field,\n        // hashlock: [u8; 32],\n        amount: u128,\n        token: AztecAddress,\n        timelock: u64,\n        // dst_chain: str<8>,\n        // dst_asset: str<8>,\n        // dst_address: str<48>,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct TokenRedeemed {\n        Id: Field,\n        hashlock: [u8; 32],\n        secret: [u8; 32],\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor() {}\n\n    #[storage]\n    struct Storage<Context> {\n        contracts_private: Map<Field, PrivateImmutable<HTLC_Private, Context>, Context>,\n        contracts_public: Map<Field, SharedMutable<HTLC_Public, 10, Context>, Context>,\n    }\n\n    #[private]\n    fn commit_private_user(\n        Id: Field,\n        src_receiver: AztecAddress,\n        timelock: u64,\n        token: AztecAddress,\n        amount: u128,\n        dst_chain: str<8>,\n        dst_asset: str<8>,\n        dst_address: str<48>,\n        randomness: Field,\n    ) {\n        assert(amount > 0, \"Funds Not Sent\");\n\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address())\n            .commit_public_user(\n                dst_chain,\n                dst_asset,\n                dst_address,\n                Id,\n                src_receiver,\n                timelock,\n                token,\n                amount,\n            )\n            .enqueue(&mut context);\n\n        let htlc_note = HTLC_Private { owner: context.msg_sender(), randomness: randomness };\n        storage.contracts_private.at(Id).initialize(htlc_note);\n\n        Token::at(token)\n            .transfer_in_private(context.msg_sender(), context.this_address(), amount, randomness)\n            .call(&mut context);\n    }\n\n    #[internal]\n    #[public]\n    fn commit_public_user(\n        dst_chain: str<8>,\n        dst_asset: str<8>,\n        dst_address: str<48>,\n        Id: Field,\n        src_receiver: AztecAddress,\n        timelock: u64,\n        token: AztecAddress,\n        amount: u128,\n    ) {\n        assert(context.timestamp() + 900 < timelock, \"InvalidTimelock\");\n        let htlc_public = HTLC_Public {\n            src_receiver: src_receiver,\n            amount: amount,\n            token: token,\n            hashlock_high: 0 as u128,\n            hashlock_low: 0 as u128,\n            secret_high: 0 as u128,\n            secret_low: 0 as u128,\n            timelock: timelock,\n            claimed: 1 as u8,\n        };\n        storage.contracts_public.at(Id).schedule_value_change(htlc_public);\n        let log_msg = TokenCommitted {\n            Id: Id,\n            amount: amount,\n            token: token,\n            timelock: timelock,\n            // dst_chain: dst_chain,\n            // dst_asset: dst_asset,\n            // dst_address: dst_address,\n            src_receiver: src_receiver,\n        };\n        context.emit_public_log(log_msg);\n    }\n\n    #[private]\n    fn add_lock_private_user(Id: Field, hashlock: [u8; 32], timelock: u64) {\n        let htlc_private = storage.contracts_private.at(Id).get_note();\n        assert(htlc_private.owner == context.msg_sender(), \"NoAllowance\");\n\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address()).add_lock_public_user(Id, hashlock, timelock).enqueue(\n            &mut context,\n        );\n    }\n\n    #[internal]\n    #[public]\n    fn add_lock_public_user(Id: Field, hashlock: [u8; 32], timelock: u64) {\n        assert(context.timestamp() + 900 < timelock, \"InvalidTimelock\");\n\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n        assert(htlc_public.hashlock_high == (0 as u128), \"HashlockAlreadySet\");\n        assert(htlc_public.hashlock_low == (0 as u128), \"HashlockAlreadySet\");\n\n        let hashlock_tuple = bytes_to_u128_limbs(hashlock);\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: hashlock_tuple.0,\n            hashlock_low: hashlock_tuple.1,\n            secret_high: htlc_public.secret_high,\n            secret_low: htlc_public.secret_low,\n            timelock: timelock,\n            claimed: htlc_public.claimed,\n        };\n        storage.contracts_public.at(Id).schedule_value_change(modified_htlc_public);\n        let log_msg = TokenLockAdded { Id, hashlock, timelock };\n        context.emit_public_log(log_msg);\n    }\n\n    #[private]\n    fn refund_private(Id: Field, randomness: Field) {\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address()).refund_public(Id).enqueue(&mut context);\n\n        let htlc_private = storage.contracts_private.at(Id).get_note();\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n\n        Token::at(htlc_public.token)\n            .transfer_in_private(\n                context.this_address(),\n                htlc_private.owner,\n                htlc_public.amount,\n                randomness,\n            )\n            .call(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn refund_public(Id: Field) {\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n        assert(htlc_public.timelock < context.timestamp(), \"NotPassedTimelock\");\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: htlc_public.hashlock_high,\n            hashlock_low: htlc_public.hashlock_low,\n            secret_high: htlc_public.secret_high,\n            secret_low: htlc_public.secret_low,\n            timelock: htlc_public.timelock,\n            claimed: 2 as u8,\n        };\n\n        storage.contracts_public.at(Id).schedule_value_change(modified_htlc_public);\n        let log_msg = TokenRefunded { Id };\n        context.emit_public_log(log_msg);\n    }\n\n    #[private]\n    fn lock_private_solver(\n        Id: Field,\n        hashlock: [u8; 32],\n        amount: u128,\n        timelock: u64,\n        token: AztecAddress,\n        randomness: Field,\n        dst_chain: str<8>,\n        dst_asset: str<8>,\n        dst_address: str<48>,\n    ) {\n        assert(amount > 0, \"FundsNotSent\");\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address())\n            .lock_public_solver(\n                Id,\n                hashlock,\n                amount,\n                token,\n                timelock,\n                dst_chain,\n                dst_asset,\n                dst_address,\n            )\n            .enqueue(&mut context);\n\n        let htlc_note = HTLC_Private { owner: context.msg_sender(), randomness: randomness };\n        storage.contracts_private.at(Id).initialize(htlc_note);\n\n        Token::at(token)\n            .transfer_in_private(context.msg_sender(), context.this_address(), amount, randomness)\n            .call(&mut context);\n    }\n\n    #[internal]\n    #[public]\n    fn lock_public_solver(\n        Id: Field,\n        hashlock: [u8; 32],\n        amount: u128,\n        token: AztecAddress,\n        timelock: u64,\n        dst_chain: str<8>,\n        dst_asset: str<8>,\n        dst_address: str<48>,\n    ) {\n        assert(context.timestamp() + 2700 < timelock, \"InvalidTimelock\");\n        let hashlock_tuple = bytes_to_u128_limbs(hashlock);\n        let htlc_public = HTLC_Public {\n            src_receiver: AztecAddress::zero(),\n            amount: amount,\n            token: token,\n            hashlock_high: hashlock_tuple.0,\n            hashlock_low: hashlock_tuple.1,\n            secret_high: 0 as u128,\n            secret_low: 0 as u128,\n            timelock: timelock,\n            claimed: 1 as u8,\n        };\n        storage.contracts_public.at(Id).schedule_value_change(htlc_public);\n\n        let log_msg = TokenLocked {\n            Id: Id,\n            // hashlock: hashlock,\n            amount: amount,\n            token: token,\n            timelock: timelock,\n            // dst_chain: dst_chain,\n            // dst_asset: dst_asset,\n            // dst_address: dst_address,\n        };\n\n        context.emit_public_log(log_msg);\n    }\n\n    #[private]\n    fn redeem_private(Id: Field, secret: [u8; 32], randomness: Field) {\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address()).redeem_public(Id, secret).enqueue(&mut context);\n\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n\n        if htlc_public.src_receiver == AztecAddress::zero() {\n            Token::at(htlc_public.token)\n                .transfer_in_private(\n                    context.this_address(),\n                    context.msg_sender(),\n                    htlc_public.amount,\n                    randomness,\n                )\n                .call(&mut context);\n        } else {\n            Token::at(htlc_public.token)\n                .transfer_in_private(\n                    context.this_address(),\n                    htlc_public.src_receiver,\n                    htlc_public.amount,\n                    randomness,\n                )\n                .call(&mut context);\n        }\n    }\n\n    #[public]\n    #[internal]\n    fn redeem_public(Id: Field, secret: [u8; 32]) {\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public.amount > 0, \"HTLCNotExists\"); // If it doesn't exist, all parameters will default to zero values.\n        let hashed_secret = sha256::sha256_var(secret, secret.len() as u64);\n        let hashed_secret_tuple = bytes_to_u128_limbs(hashed_secret);\n        assert(htlc_public.hashlock_high == hashed_secret_tuple.0, \"HashlockNotMatch\");\n        assert(htlc_public.hashlock_low == hashed_secret_tuple.1, \"HashlockNotMatch\");\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: htlc_public.hashlock_high,\n            hashlock_low: htlc_public.hashlock_low,\n            secret_high: htlc_public.secret_high,\n            secret_low: htlc_public.secret_low,\n            timelock: htlc_public.timelock,\n            claimed: 3 as u8,\n        };\n\n        storage.contracts_public.at(Id).schedule_value_change(modified_htlc_public);\n\n        let log_msg = TokenRedeemed {\n            Id: Id,\n            hashlock: u128_limbs_to_bytes(htlc_public.hashlock_high, htlc_public.hashlock_low),\n            secret: secret,\n        };\n\n        context.emit_public_log(log_msg);\n    }\n\n    // This utility function should be invoked by the frontend before each function call\n    // where the existence or non-existence of an HTLC is a critical security check.\n    #[utility]\n    unconstrained fn is_contract_initialized(Id: Field) -> bool {\n        storage.contracts_private.at(Id).is_initialized()\n    }\n}\n"
    },
    "56": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n}\n"
    },
    "57": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "64": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use dep::protocol_types::debug_log::debug_log_format;\n\nuse crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n\n        // WARNING(https://github.com/AztecProtocol/aztec-packages/issues/10558): if you delete this debug_log_format line, some tests fail.\n        debug_log_format(\n            \"Context.note_hashes, after pushing new note hash: {0}\",\n            self.note_hashes.storage().map(|nh: NoteHash| nh.value),\n        );\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index],\n                },\n            );\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "65": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(gas_for_call(gas_opts), contract_address, calldata);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(gas_for_call(gas_opts), contract_address, calldata);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_opcode(gas, address, args)\n}\n\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "66": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "67": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "69": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/discovery/mod.nr",
      "source": "use crate::encrypted_logs::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\nuse protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\n/// We reserve two fields in the note private log that are not part of the note content: one for the storage slot, and\n/// one for the combined log and note type ID.\nglobal PRIVATE_LOG_EXPANDED_METADATA_LEN: u32 = 1;\n\n/// The maximum length of the log's content, i.e. after log type ID and metadata extraction.\npub global MAX_LOG_CONTENT_LEN: u32 =\n    PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS - PRIVATE_LOG_EXPANDED_METADATA_LEN;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "70": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/discovery/nonce_discovery.nr",
      "source": "use crate::{\n    discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    array::for_each_in_bounded_vec(\n        unique_note_hashes_in_tx,\n        |expected_unique_note_hash, i| {\n            // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n            // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n            let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n            // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n            // the note hash at the array index we're currently processing.\n            // TODO(#11157): handle failed note_hash_and_nullifier computation\n            let hashes = compute_note_hash_and_nullifier(\n                packed_note,\n                storage_slot,\n                note_type_id,\n                contract_address,\n                candidate_nonce,\n            )\n                .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n            let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n            let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n            if unique_note_hash == expected_unique_note_hash {\n                // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n                // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n                // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n                // PXE may fail to realize that a given note has been nullified already, and calls to the application\n                // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n                // application already has more direct means of making a call to it fail the transaction.\n                discovered_notes.push(\n                    DiscoveredNoteInfo {\n                        nonce: candidate_nonce,\n                        note_hash: hashes.note_hash,\n                        inner_nullifier: hashes.inner_nullifier,\n                    },\n                );\n\n                // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n                // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n                // notes containing random values in order to hide their contents.\n            }\n        },\n    );\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n"
    },
    "71": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    discovery::{\n        ComputeNoteHashAndNullifier,\n        MAX_LOG_CONTENT_LEN,\n        nonce_discovery::{attempt_note_nonce_discovery, DiscoveredNoteInfo},\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_LOG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private log (e.g.\n/// the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_LOG_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_LOG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    log_metadata: u64,\n    log_content: BoundedVec<Field, MAX_LOG_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_log(log_metadata, log_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    let mut i = 0;\n    while i < pending_partial_notes.len() {\n        let pending_partial_note: DeliveredPendingPartialNote = pending_partial_notes.get(i);\n\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            i += 1 as u32;\n            // Note that we're not removing the pending partial note from the PXE DB, so we will continue searching\n            // for this tagged log when performing message discovery in the future until we either find it or the\n            // entry is somehow removed from the PXE DB.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the log sans the extra fields) to get the\n            // complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            array::for_each_in_bounded_vec(\n                discovered_notes,\n                |discovered_note: DiscoveredNoteInfo, _| {\n                    // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                    // temporary node connectivity issue - is simply throwing good enough here?\n                    assert(\n                        deliver_note(\n                            contract_address,\n                            pending_partial_note.storage_slot,\n                            discovered_note.nonce,\n                            complete_packed_note,\n                            discovered_note.note_hash,\n                            discovered_note.inner_nullifier,\n                            log.tx_hash,\n                            pending_partial_note.recipient,\n                        ),\n                        \"Failed to deliver note\",\n                    );\n                },\n            );\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n\n            // We don't increment `i` here, because CapsuleArray is contiguous and its `remove(...)` function\n            // shifts the elements to the left if the removed element is not the last element.\n        }\n    }\n}\n\nfn decode_partial_note_private_log(\n    log_metadata: u64,\n    log_content: BoundedVec<Field, MAX_LOG_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = log_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        log_content.len() > PARTIAL_NOTE_PRIVATE_LOG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note log: all partial note private logs must have at least {PARTIAL_NOTE_PRIVATE_LOG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_LOG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private log encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_LOG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_LOG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = log_content.get(0);\n    let note_completion_log_tag = log_content.get(1);\n\n    let packed_private_note_content = array::subbvec(log_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "73": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/discovery/private_logs.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    discovery::{\n        ComputeNoteHashAndNullifier,\n        MAX_LOG_CONTENT_LEN,\n        partial_notes::process_partial_note_private_log,\n        pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n        PRIVATE_LOG_EXPANDED_METADATA_LEN,\n        private_notes::process_private_note_log,\n    },\n    encrypted_logs::{\n        log_assembly_strategies::default_aes128::aes128::AES128,\n        log_encryption::LogEncryption,\n        log_type::{\n            PARTIAL_NOTE_PRIVATE_LOG_TYPE_ID, PRIVATE_EVENT_LOG_TYPE_ID, PRIVATE_NOTE_LOG_TYPE_ID,\n        },\n        metadata_packing::from_expanded_metadata,\n    },\n    oracle::{logs::store_private_event_log, message_discovery::sync_notes},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n// TODO(#12750): don't make these values assume we're using AES.\nuse crate::encrypted_logs::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `syncNotes` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    sync_notes(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get logs from capsules\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    let len = logs.len();\n\n    // We iterate over the logs in reverse order to avoid shifting elements.\n    let mut i = len;\n    while i > 0 {\n        i -= 1;\n\n        // Get and process each log\n        let log = logs.get(i);\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n\n        // Remove the log from the capsule array\n        logs.remove(i);\n    }\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (log_type_id, log_metadata, log_content) = decode_log_plaintext(log_plaintext);\n\n    if log_type_id == PRIVATE_NOTE_LOG_TYPE_ID {\n        debug_log(\"Processing private note log\");\n\n        process_private_note_log(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            log_metadata,\n            log_content,\n        );\n    } else if log_type_id == PARTIAL_NOTE_PRIVATE_LOG_TYPE_ID {\n        debug_log(\"Processing partial note private log\");\n\n        process_partial_note_private_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            log_metadata,\n            log_content,\n        );\n    } else if log_type_id == PRIVATE_EVENT_LOG_TYPE_ID {\n        debug_log(\"Processing private event log\");\n\n        // In the case of event logs, the log metadata is the event selector.\n        let event_selector = EventSelector::from_field(log_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            log_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n        );\n    } else {\n        debug_log_format(\n            \"Unknown log type id {0} (probably belonging to an event log)\",\n            [log_type_id as Field],\n        );\n    }\n}\n\n/// Decodes a log's plaintext following aztec-nr's standard log encoding.\n///\n/// The standard private log layout is composed of:\n///  - an initial field called the 'expanded metadata'\n///  - an arbitrary number of fields following that called the 'log content'\n///\n/// ```\n/// log_plaintext: [ log_expanded_metadata, ...log_content ]\n/// ```\n///\n/// The expanded metadata itself is (currently) interpreted as a u128, of which:\n///  - the upper 64 bits are the log type id\n///  - the lower 64 bits are called the 'log metadata'\n///\n/// ```\n/// log_expanded_metadata: [  log_type_id    |  log_metadata  ]\n///                        <---  64 bits --->|<--- 64 bits --->\n/// ```\n///\n/// The meaning of the log metadata and log content depend on the value of the log type id. Note that there is\n/// nothing special about the log metadata, it _can_ be considered part of the content. It just has a different name\n/// to make it distinct from the log content given that it is not a full field.\nunconstrained fn decode_log_plaintext(\n    log_plaintext: BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>,\n) -> (u64, u64, BoundedVec<Field, MAX_LOG_CONTENT_LEN>) {\n    assert(\n        log_plaintext.len() >= PRIVATE_LOG_EXPANDED_METADATA_LEN,\n        f\"Invalid log plaintext: all logs must be decrypted into at least {PRIVATE_LOG_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If PRIVATE_LOG_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the log encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_LOG_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for PRIVATE_LOG_EXPANDED_METADATA_LEN\",\n    );\n\n    // See the documentation of this function for a description of the log layout\n    let expanded_log_metadata = log_plaintext.get(0);\n    let (log_metadata, log_type_id) = from_expanded_metadata(expanded_log_metadata);\n    let log_content = array::subbvec(log_plaintext, PRIVATE_LOG_EXPANDED_METADATA_LEN);\n\n    (log_type_id, log_metadata, log_content)\n}\n"
    },
    "74": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/discovery/private_notes.nr",
      "source": "use crate::{\n    discovery::{\n        ComputeNoteHashAndNullifier,\n        MAX_LOG_CONTENT_LEN,\n        nonce_discovery::{attempt_note_nonce_discovery, DiscoveredNoteInfo},\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note log content that are not the note's packed representation.\nglobal PRIVATE_NOTE_LOG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the log (e.g. log type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_LOG_CONTENT_LEN - PRIVATE_NOTE_LOG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_log<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    log_metadata: u64,\n    log_content: BoundedVec<Field, MAX_LOG_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_log(log_metadata, log_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private log\",\n        [discovered_notes.len() as Field],\n    );\n\n    array::for_each_in_bounded_vec(\n        discovered_notes,\n        |discovered_note: DiscoveredNoteInfo, _| {\n            // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n            // issue, and we should perhaps not have marked the tag index as taken.\n            assert(\n                oracle::message_discovery::deliver_note(\n                    contract_address,\n                    storage_slot,\n                    discovered_note.nonce,\n                    packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    tx_hash,\n                    recipient,\n                ),\n                \"Failed to deliver note\",\n            );\n        },\n    );\n}\n\nfn decode_private_note_log(\n    log_metadata: u64,\n    log_content: BoundedVec<Field, MAX_LOG_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = log_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        log_content.len() > PRIVATE_NOTE_LOG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note log: all private note logs must have at least {PRIVATE_NOTE_LOG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_LOG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the private note log encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_LOG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_LOG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = log_content.get(0);\n    let packed_note = array::subbvec(log_content, PRIVATE_NOTE_LOG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "75": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypt/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::utils::point::point_to_bytes;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n"
    },
    "78": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/log_assembly_strategies/default_aes128/aes128.nr",
      "source": "use crate::{\n    encrypted_logs::{\n        encrypt::aes128::derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256,\n        log_assembly_strategies::default_aes128::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n        log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n    },\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\nuse std::aes128::aes128_encrypt;\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        encrypted_logs::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "87": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/metadata_packing.nr",
      "source": "global U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\npub fn to_expanded_metadata(log_metadata: u64, log_type: u64) -> Field {\n    let metadata_field = log_metadata as Field;\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (log_type as Field) * U64_SHIFT_MULTIPLIER;\n    type_field + metadata_field\n}\n\npub fn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let metadata = (input as u64);\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    let log_type = ((input - (metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    (metadata, log_type)\n}\n\nmod tests {\n    use super::{from_expanded_metadata, to_expanded_metadata};\n\n    global U64_MAX: Field = 2.pow_32(64) - 1;\n    global U128_MAX: Field = 2.pow_32(128) - 1;\n\n    #[test]\n    fn packing_metadata() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX as u64, U64_MAX as u64);\n        let (metadata, log_type) = from_expanded_metadata(packed);\n        assert(metadata == U64_MAX as u64, \"Metadata bits should be all 1s\");\n        assert(log_type == U64_MAX as u64, \"Log type bits should be all 1s\");\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(0, U64_MAX as u64);\n        let (metadata, log_type) = from_expanded_metadata(packed);\n        assert(metadata == 0, \"Metadata bits should be 0\");\n        assert(log_type == U64_MAX as u64, \"Log type bits should be all 1s\");\n\n        // Test case 3: Only metadata bits set\n        let packed = to_expanded_metadata(U64_MAX as u64, 0);\n        let (metadata, log_type) = from_expanded_metadata(packed);\n        assert(metadata == U64_MAX as u64, \"Metadata bits should be all 1s\");\n        assert(log_type == 0, \"Log type bits should be 0\");\n\n        // Test case 4: Zero\n        let packed = to_expanded_metadata(0, 0);\n        let (metadata, log_type) = from_expanded_metadata(packed);\n        assert(metadata == 0, \"Metadata bits should be 0\");\n        assert(log_type == 0, \"Log type bits should be 0\");\n    }\n\n    #[test]\n    fn unpacking_metadata() {\n        // Test case 1: All bits set\n        let input = U128_MAX;\n        let (metadata, log_type) = from_expanded_metadata(input);\n        assert(metadata == U64_MAX as u64, \"Metadata bits should be all 1s\");\n        assert(log_type == U64_MAX as u64, \"Log type bits should be all 1s\");\n\n        // Test case 2: Only log type bits set\n        let input = U128_MAX - U64_MAX;\n        let (metadata, log_type) = from_expanded_metadata(input);\n        assert(metadata == 0, \"Metadata bits should be 0\");\n        assert(log_type == U64_MAX as u64, \"Log type bits should be all 1s\");\n\n        // Test case 3: Only metadata bits set\n        let input = U64_MAX;\n        let (metadata, log_type) = from_expanded_metadata(input);\n        assert(metadata == U64_MAX as u64, \"Metadata bits should be all 1s\");\n        assert(log_type == 0, \"Log type bits should be 0\");\n\n        // Test case 4: Zero\n        let input = 0;\n        let (metadata, log_type) = from_expanded_metadata(input);\n        assert(metadata == 0, \"Metadata bits should be 0\");\n        assert(log_type == 0, \"Log type bits should be 0\");\n    }\n\n    #[test]\n    fn roundtrip_metadata(original_metadata: u64, original_type: u64) {\n        let packed = to_expanded_metadata(original_metadata, original_type);\n        let (unpacked_metadata, unpacked_type) = from_expanded_metadata(packed);\n        assert(original_type == unpacked_type, \"Log type bits should match after roundtrip\");\n        assert(\n            original_metadata == unpacked_metadata,\n            \"Metadata bits should match after roundtrip\",\n        );\n    }\n}\n"
    },
    "91": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.84.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    }
  }
}
