{
  "transpiled": true,
  "noir_version": "1.0.0-beta.4+0000000000000000000000000000000000000000",
  "name": "Train",
  "functions": [
    {
      "name": "commit_public_user",
      "is_unconstrained": true,
      "custom_attributes": [
        "internal",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 48
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "src_receiver",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3559210201980528457": {
            "error_kind": "string",
            "string": "Function commit_public_user can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "commit_public_user"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "772057049813214347": {
            "error_kind": "string",
            "string": "HTLCNotExists"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2570651705007895968": {
            "error_kind": "string",
            "string": "HashlockNotMatch"
          },
          "2722406262643068352": {
            "error_kind": "string",
            "string": "HashlockAlreadySet"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3559210201980528457": {
            "error_kind": "string",
            "string": "Function commit_public_user can only be called internally"
          },
          "3564161243949231814": {
            "error_kind": "string",
            "string": "Function refund_public can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "9174444391250494040": {
            "error_kind": "string",
            "string": "Function get_htlc_public can only be called statically"
          },
          "9323748002447105156": {
            "error_kind": "string",
            "string": "NotPassedTimelock"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "15001264570739363109": {
            "error_kind": "string",
            "string": "Function lock_public_solver can only be called internally"
          },
          "16870384257694633552": {
            "error_kind": "string",
            "string": "Function add_lock_public_user can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17814817983036354427": {
            "error_kind": "string",
            "string": "Function redeem_public can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "add_lock_public_user",
      "is_unconstrained": true,
      "custom_attributes": [
        "internal",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "2722406262643068352": {
            "error_kind": "string",
            "string": "HashlockAlreadySet"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16870384257694633552": {
            "error_kind": "string",
            "string": "Function add_lock_public_user can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "add_lock_public_user"
      ]
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "constructor"
      ]
    },
    {
      "name": "commit_private_user",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "src_receiver",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 48
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6652550611004701521": {
            "error_kind": "string",
            "string": "Funds Not Sent"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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VPQlPv3ccUs3jD21ZBUx9tTtVcOYpp4ayYoYe+pRK2Lsqf2tiLGnzroiRgGjBsae/EBFjD1ZjYoYcTEqGHExKhhxMRoYAy5GBWNPLuajC153jPlsICGscf/jIU9Pf/0fCd6LvSfX0xD2nlxSQ9gF7DWw9+TCGsLek2trCHtPLq8h7D25woaw9+Qi28Eee3KdDWHHpVbBjkutgh2XWgW7gL0G9oFdapzm+0hC/JjxCfb4IdPn5TFsT1C25ejqddqvXuPju33LDfvALrUm9oFdak3sA7vUmtgHdqkVsaeBXWpN7AO71JrYB3apNbEP7FJrYhew18COS62CHZdaBTsutQp2XGoV7CO71LRtO3aRs+A3LvtY4rLMj6tzOBpLiPc/nsL8dPU/gn2/Oq37yFNOX67+R6auHozYsUwju+CGZBrZNTck08guuyGZBJlakGlkF9+QTCO7/oZkGjklaEimkVOFhmQihWhBpq4eM9yxTKQQTchECtGETKQQTcgkyNSCTKQQTchECtGETKQQTchECtGETKQQLci0kEI0IRMpRBMykUI0IRMpRBMyCTK1IBMpRBMykUI0IRMpRBMykUI0IRMpRAsyraQQTchECtGETKQQTchECtGETIJMLchECtGETKQQTchECtGETKQQTchECtGCTBspRBMykUI0IRMpRBMykUI0IZMgUwsykUI0IRMpRBMykUI0IRMpRBMykUK0IFMmhWhCJlKIJmQihWhCJlKIJmQSZGpBJlKIJmQihWhCJlKIJmQihWhCJlKIBmSSiRSiCZlIIZqQiRSiCZlIIZqQSZCpBZlIIZqQiRSiCZlIIZqQiRSiCZlIIVqQKZBCNCETKUQTMpFCNCETKUQTMgkytSATKUQTMpFCNCETKUQTMpFCNCETKUQLMkVSiCZkIoVoQiZSiCZkIoVoQiZBphZkIoVoQiZSiCZkIoVoQiZSiCZkIoVoQaZECtGETKQQTchECtGETKQQTcgkyNSCTKQQTchECtGETKQQTchECtGETKQQLcgkpBBNyEQK0YRMpBBvkinKvCPczmSSvMs0T1P+LhMpRBMyCTK1IBMpRBMykUI0IRMpRBMykUI0IRMpRAsyzaQQTchECtGETKQQTchECtGETIJMLchECtGETKQQTchECtGETKQQTchECtGCTAspRBMykUI0IRMpRBMykUI0IZMg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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "notify_created_nullifier_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "random",
        "decompose_hint",
        "lte_hint",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "is_contract_initialized",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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bG315Os23fLj4G//9B99cKFsM6z1123vGAMYe2CcqwsUwzhXd/k5jO+/ohInW7xejuNc/bAcx7kabTGOk63jL8dxLmsgx3Euz1H2Px1KaHHMyX9tnHPatw3rF5m57ElPMgEyL8jMZSLekLlPd65mvznduXry5nTnap2b052rw21Nd7JPHzSnO1W/GF2I28YuHWSrc336oD3dqXq19nSDrelO1VW1pztVV9We7lRdVXu6U3VV7elO1VU1pzvXpw+ep7u69WC603ZVx9Odtqs6nu5cXVV2ed+41IPpBlvTnaurak53rq6qOd25uqrmdOfqqprTnaurakw3zfXpg/Z05+qqmtOdq6tqTtdUV5WWYGu6prqqNNenD2458rJtXFNp/OlQdzbPrzeX5QvNXB1YVzRzdWtd0czV2fVEM9enGvqimatj7Ipmru6yK5q5OtGuaAJoXqGZq8P9IzS3nHzbOJQDNIa74RYaw91wC43hbriFxnA33EAz1yc2+qIx3A230BjuhltoDHfDLTTBMJq4d8PloBue6/MhfdFY7oYbaCx3ww00lrvhBhrL3fB7NHN9GqUvGsvdcAON5W64gcZyN9xAE0DzCo2Zbvg+XTMd7n26ZrrW+3Sn6kTTsmwDudWtO5juVN1lc7pzffalPd2pusD2dKfq7NrTnapba0832JruVF1Ve7pTdVXt6U7VVbWna6urmuuzL83pzvXZl/Z0bXVVc332pT1dW13VXJ99aU/XVlc112df2tO11VXN9dmX9nRtdVVzffalPV1bXdVcn31pT9dWVzXX51na07XVVc31uZP2dG11VXN9PKQ9XVtd1Vyf4mhP11ZXNdeHLdrTtdVVzfUJivZ0bXVVc31Xoj1dW13VXN+VaE/XVlc113cl2tO11VXN9V2J9nRtdVVzfVeiPV1bXdVc35VoT9dWVzXXdyXa07XVVc31XYn2dG11VXN9V6I9XVtd1VzflWhP11ZXNdd3JdrTtdVVzfVdifZ0TXVVea7vSrSna6qrynN9V6I9XVNdVV6Crema6qryXN+VaE/XVFeV5/r+Q3u6trqqub7T0J6ura5qru8ptKdrq6ua67sH7ena6qrm+j5Be7q2uqq5viPQnq6trmqu9f7b07XVVc21Ln97ura6qrnWz29P11ZXNdc69+3p2uqq5lqPvj1dW13VXOvGt6drq6uaa333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47nsNZ7LXuO57DWey17juew1nste47nsNZ7LXuO57DWey17juew1nste47nsNZ7LXuO57DWey17juew1nste47nsNZ7LXuO57DWey17juew1nste47nsNZ7LXuO57DWey17juew1nste44vste4v77ka3MFuL6ok70tN1rr+stvR97t6fR04vsp0pYYTdQ0n6RpO1jWcoms4VdVwXmX8UsNxuoaz6hqOrqty0HVVDrquykHXVTnouioHXVfloOuqHHVdlePVV+X3H7aPcVU2Hq9sPEHZeKKy8SRl4/nja/N9t3Jut3pqt+MnuKvbP0O5ri42oLmU/f5hupTTY2Gdo5UO1uK3RWT88rwIz3K8FOiyL4C1+MePyevyNX6nfPy3KHQbf3z6WuI+/nXw8fvBxx8GH38cfPxp8PHnwcdfBh9/HXv8Wfv9tzX+we+/efD7bx78/psHv//mwe+/efD7bx78/psHv//mwe+/ZfD7bxn8/lsGv/+Wwe+/ZfD7bxn8/lsGv/+Wwe+/ZfD7bxn8/lsHv//Wwe+/dfD7bx38/lsHv//Wwe+/dfD7bx38/lsHv//Wse+/aRn7/puWse+/aRn7/puWse+/aRn7/puWse+/aRn7/puWse+/aRn7/puWwe+/bvD7rxv8/usGv/+6we+/bvD7rxv8/usGv/+6we+/bvD7rxv8/rsOfv9dB7//roPff9fB77/r4PffdfD77zr4/Xcd/P67Dn7/XQe///rB779+8PuvH/z+6we///rB779+8PuvH/z+6we///rB779+8PtvGPz+Gwa//4bB779h8PtvGPz+Gwa//4bB779h8PtvGPz+Gwa//8bB779x8PtvHPz+Gwe//8bB779x8PtvHPz+Gwe//8bB779x8Puv+vWvWuMf/P47+PpXafD1r9Lg61+lwde/SoOvf5UGX/8qDb7+VRp8/as0+PpXafD1r9Lg61+lwde/SoOvf5UGX/8qDb7+VRp8/as0+PpXafD1r9Lg61+lwde/SoOvf5UGX/8qDb7+VRp8/as0+PpXafD1r9Lg61+lwde/SoOvf5UGX/8qDb7+VRp8/as0+PpXafD1r9Lg61+lwde/SoOvf5UGX/8qD77+VR58/as8+PpXefD1r/Iy9v03D77+VR58/as8+PpXefD1r/Lg61/lwde/yoOvf5UHX/8qD77+VR58/as8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uqXGVIOdqQr8HOf9b1+Ku/7HlDfFt79dXD0Y0vU/pmws31PWRd+QnL4hrfqG5PUNKegb0vU/pmz8AK6sSd+Qsr4hFX1DquqG5Bd9Q3L6hrTqG9Lx519S3D6pF/PzpwZ+LAL9vSerdV/AZXn+esJt658HOV4CoPdB/BUHCVccJF5xkEuEz1ccpFxxkHrBQV58IbHzQdwVB7nijI9XnPHxijM+XnHGxyvO+HjFGR+vOOPjFWd8uuKMT1ec8emKMz5dccanK874dMUZn64449MVZ3y64oxPV5zx+YozPl9xxucrzvh8xRmfrzjj8xVnfL7ijM9XnPH5ijM+X3HGlyvO+HLFGV+uOOPLFWd8ueKML1ec8eWKM75cccaXK874csUZX6844+sVZ3y94oyvV5zx9Yozvl5xxtcrzvh6xRlfrzjj6wVnfF2WKw7irjjIesVB/BUHCVccJF5xkHTFQfIVBylXHOSKM95dcca7K854d8UZ7644490VZ7y74ox3V5zx7ooz3l1xxrsrzvj1ijN+veKMX68449crzvj1ijN+veKMX68449crzvj1ijN+veKM91ec8f6KM95fccb7K854f8UZ768446949ar6K854f8UZ768448MVZ3y44oy/4p27esU7d/WKd+7qFe/c1SveuatXvHNXr3jnrl7xzl294p27esU7d/WKd+7qFe/c1SveuatXvHNXr3jnrl7xzl294p27esU7d/WKd+7qFe/c1SveuatXvHNXr3jnrl7xzl294p27esU7d/WKd+7qFe/c1SveuatXvHNXr3jnrl7xzl294p27esU7d/WKd+7qFe/c1SveuatXvHNXr3jnrl7xzl294p27esU7d/WKd+7qFe/c1SveuatXvHNXr3jnrl7xzl294p27esU7d/WKd+7qFe/c1SveuatXvHNXr3jnrl7xzl294p272uOdO7/U7WfxfnWtrfM2oPz4AX3wP0ZTlh4v53UcjVM1mlXVaLyq0QRVo4mqRpNUjSarGk1RNRpV12Kn6lrsVF2LnaprsVN1LXaqrsVO1bXYqboWO1XXYqfqWnz8kp/zflukyfni9r1KOvjzwT+WdnwaSihfR8gfP0L5+BHqp49w/GJf1yO4jx9h/ctHiI+zIB0dwX/8COGvH2FfOzbmenCE+PEj/PVzOtZN6bT4gyPkjx+h9DyCcwdHqJ8+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",
      "brillig_names": [
        "is_contract_initialized"
      ]
    },
    {
      "name": "refund_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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4biFOTakMF9Icb6Q0nwh5flCKtOFdNzqHhuSnS8kN19I89297Xx3bzvf3dvOd/e289297Xx3bzfgvlTCHtLdu4C3kPr/4ioPCoM7+Rd3vUjscZHU4yIcOp/kI+BbGM49PsYIrqgZqjd6hmr1DNXpGarXM1TSM9SgZ6hRz1CTnqHqqZa8nmqJ9FRLpKdaIj3VEumplkhPtUR6qiXSUy2RnmqJ9FRLpKdaCnqqpaCnWgp6qqWgp1oKeqqloKdaCivNq+E21PjwgnaIC92BX38vE+JCd+DaUBe6A9eGutAduDbUhe7AtaEu5FdrQ13Ir9aGutC8WhvqQn61MtS0kF+tDXWhEuL1xn4hLVRC1IZKeoa6UAnxekuKkBYqIWpDXaiEqA11oRKiNtSFSojKUPNCJURtqAs1XGpDXalaqgx1pWqpMlTSM1Q91VIe8DlO5duX3P9jymy3lYku/yyPIZX+H1NWFoUMxc4XkpsvJD9fSDRfSGG+kPp/TFn7AK6k+ULK84VUZgspGjNfSHa+kNx8Ifn5Qjq8CbhS9iVZzP0eEd5eTzv+XL1+Wmw7rTHI3HZaaTrteEHg+mm27TTXdppvO43aTmtTiWtTiWtTiWtTiWtTiW9TiW9TiW9TiW9TiW9TiW9TiW9TiW9TiW9TiW9TCbWphNpUQm0qoTaVUJtKqE0l1KYSalMJtamE2lQS2lQS2lQS2lQS2lQS2lQS2lQS2lQS2lQS2lQS2lQS21QS21QS21QS21QS21QS21QS21QS21QS21QS21SS2lSS2lSS2lSS2lSS2lSS2lSS2lSS2lSS2lSS2lSS21SS21SS21SS21SS21SS21SS21SS21SS21SS21RS2lRS2lRS2lRS2lRS2lRS2lRS2lRS2lRS2lRSmlSSjGk7zbad5tpO822nUdtpoe202HZaajstt53WphLbphLbphLbphLbphLbppK23mtq672mtt5rauu9prbea2rrvaa23mtq672mtt5rauu9prbea2rrvaa23mtq672mtt5rauu9prbea2rrvaa23mtq672mtt5rauu9prbea2rrvaa23mtq672mtt5rauu9prbea2rrvaa23mtq672mtt5rauu9prbea2rrvaa23mtq672mtt5rauu9prbea2rrvaa23mtq672mtt5rauu9prbea2rrvaa23mtq672mtt5rauu9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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "get_note_internal",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "lock_private_solver",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 48
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6418028854678020178": {
            "error_kind": "string",
            "string": "FundsNotSent"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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JlKIJmQihWhCJlKIFmTKpBBNyEQK0YRMpBBNyEQK0YRMgkwtyEQK0YRMpBBNyEQK0YRMpBBNyEQK0YBMMpFCNCETKUQTMpFCNCETKUQTMgkytSATKUQTMpFCNCETKUQTMpFCNCETKUQLMgVSiCZkIoVoQiZSiCZkIoVoQiZBphZkIoVoQiZSiCZkIoVoQiZSiCZkIoVoQaZICtGETKQQTchECtGETKQQTcgkyNSCTKQQTchECtGETKQQTchECtGETKQQLciUSCGakIkUogmZSCGakIkUogmZBJlakIkUogmZSCGakIkUogmZSCGakIkUogWZhBSiCZlIIZqQiRTiTTJFmXeE25lMkneZ5mnK32UihWhCJkGmFmQihWhCJlKIJmQihWhCJlKIJmQihWhBppkUogmZSCGakIkUogmZSCGakEmQqQWZSCGakIkUogmZSCGakIkUogmZSCFakGkhhWhCJlKIJmQihWhCJlKIJmQSZGpBJlKIJmQihWhCJlKIJmQihWhCJlKIFmRaSSGakIkUogmZSCGakIkUogmZBJlakIkUogmZSCGakIkUogmZSCGakIkUogWZNlKIJmQihWhCJlKIJmQihWhCJkGmFmQihWhCJlKIJmQihWhCJlKIJmQihWhBpkwK0YRMpBBNyEQK0YRMpBBNyCTI1IJMpBBNyEQK0YRMpBBNyEQK0YRMpBANyPTxvyFTCzKRQjQhEylEEzKRQjQhkyBTCzKRQjQhEylEEzKRQjQhEylEEzKRQrQgUyCFaEImUogmZCKFaEImUogmZBJkakEmUogmZCKFaEImUogmZCKFaEImUogWZIqkEE3IRArRhEykEE3IRArRhEyCTC3IRArRhEykEE3IRArRhEykEE3IRArRgkyJFKIJmUghmpCJFKIJmUghmpBJkKkFmUghmpCJFKIJmUghmpCJFKIJmUghWpBJSCGakIkUogmZSCGakIkUogmZBJlakIkUogmZSCGakIkUogmZSCGakIkUogWZZlKIJmQihWhCJlKIJmQihWhCJkGmFmQihWhCJlKIJmQihWhCJlKIJmQihWhBpoUUogmZSCGakIkUogmZSCGakEmQqQWZSCGakIkUogmZSCGakIkUogmZRk4hlinsMq3PAz+U6eMlww7lWaaCqNt0F3UN+ezqOOX71TGuX67+R6Z15BSiIZlGTiEa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XKuS5VqVLNeqZLlWJcu1KlmuVclyrUrWa1WyXquS9VqVrNeqZL1WJeu1KlmvVcl6rUrWa1WyXquS7VqVbNeqZLtWJdu1KtmuVcl2rUq2a1WyXauS7VqVbNeqJF+rknytSvK1KsnXqiRfq5J8rUrytSrJ16okX6uSfKlK8jRd+7Nw7c/itT9L1/5Mrv3ZfO3Plmt/tl77s+3an12rknCtSsK1KgnXqiRcq5JwrUrCtSoJ16okXKuScK1KwrUqideqJF6rknitSuK1KonXqiReq5J4rUritSqJ16okXquSdK1K0rUqSdeqJF2rknStStK1KknXqiRdq5Jr2Wu+lr3ma9lrvpa95mvZa76WveZr2Wu+lr3ma9lrvpa95mvZa76WveZr2Wu+lr3ma9lrvpa95mvZa76WveZr2Wu+lr3ma9lrvpa95mvZa76WveZr2Wu+lr3ma9lrvpa95mvZa76WveZr2Wu+lr3ma9lrvpa95mvZa76WveZr2Wu+lr3ma9lrvpa95mvZa76WveZr2Wu+lr3ma9lrvpa95mvZa76WveZr2Wu+lr3ma9lrvpa95mvZa76WveZr2Wu+lr3ma9lrvpa95mvZa76WveZr2Wu+lL3O06Xs9ePPwrU/i9f+LF37M7n2Z/O1P1uu/dl67c+2a392rUrCtSoJ16okXKuScK1KwrUqCdeqJFyrknCtSsK1KgnXqiReq5J4rUoK2Wvev7wXPpKYgz8rVMm67n+W45c/OzpxVul5Fh/DEV/DmX0NZ/E1nNXXcDZfw8muhlPK+GsNJ/gaTvQ1HF+fysnXp3Ly9amcfH0qJ1+fysnXp3Ly9aksvj6VxfpT+eWjmD7GE52NJzkbjzgbz+xsPIuz8fz6s/n2Z9u1P8uX/uz4Dm4M2/0IjxjDfAItLGvan+67rMvjYJ2jkw7ilu6HyKTp+RCe6fgo0Gk/AOtj892vztPn+IPz8c/TXYBlTun7+GPj40+Nj18aH//c+PiXxse/Nj7+rfHx57bHv3jff8/G3/j+uzS+/y6N779L4/vv0vj+uzS+/y6N779L4/vv0vj+uza+/66N779r4/vv2vj+uza+/66N779r4/vv2vj+uza+/66N779b4/vv1vj+uzW+/26N779b4/vv1vj+uzW+/26N779b4/vv1vj+mxvff3Pj+29ufP/Nje+/ufH9Nze+/+bG99/c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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "notify_created_nullifier_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "random",
        "decompose_hint",
        "lte_hint",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "add_lock_private_user",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17476367995570638746": {
            "error_kind": "string",
            "string": "NoAllowance"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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jPQvw0LbsNg2LLUNK4f7dmh+DLPPAfjr5+EqPwvjPonpcRL785O8fa53O4W7/hR0/Sn8p6e4Dwttw2LbsNR09wltt8jYdouMbbfIk+eF1WGubRi1DfNtw0LbsNg07OTxT/THjTXG508+S6WZjdvxtk609uUU9vpTuOtPQdefwl9/inD9KeL1p0jXnyJffoqTxz+sp7j+6s7XX935+qs7X3915+uv7nz91Z2vv7rz9Vd3vvzqNtt2/Sk+vrrvw2zbMNc2jNqG+bZhoW1YbBuW2oblpmFmaxvWliWmLUtMW5aYtiwxbVli2rLEtGWJacsS05Ylti1LbFuW2LYssW1ZYtuyxLZliW3LEtuWJbYtS2xblri2LHFtWeLassS1ZYlryxLXliWuLUtcW5a4tixxbVlCbVlCbVlCbVlCbVlCbVlCbVlCbVlCbVlCbVlCbVni27LEt2WJb8sS35Ylvi1LfFuW+LYs8W1Z4tuyxLdlSWjLktCWJaEtS0JbloS2LAltWRLasiS0ZUloy5LQliWxLUtiW5bEtiyJbVkS27IktmVJbMuS2JYlsS1LYluWpLYsSW1ZktqyJLVlSWrLktSWJaktS1JblqS2LEltWZLbsiS3ZUluy5LcliW5LUtyW5bktizJbVmS27IkN2WJ3ba2YaZtmG0b5tqGUdsw3zYstA2LbcNS27C2LGnrvdq23qtt673att6rbeu92rbeq23rvdq23qtt673att6rbeu92rbeq23rvdq23qtt673att6rbeu92rbeq23rvdq23qtt673att6rbeu92rbeq23rvdq23qtt673att6rbeu92rbeq23rvdq23qtt673att6rbeu92rbeq23rvdq23qtt673att6rbeu92rbeq23rvdq23qtt673att6rbeu92rbeq23rvdq23qtt673att6rbeu92rbeq23rvdq23qtt673att6rbeu92rbeq23rvdq23qtt673att6rbeu92rbeq23rvdq23qtt673att6rbeu92rbeq23rvdq23qtt673ak95rPl7eu7XrTGHYSZbEeAzL9tuw0oqzTPtZ3MyJc5mT5jInT2XOWW97lDlmLnPsXOa4ucyhuczxc5kz1105z3VXznPdlfNUd2W3TXVXdttUd2W3TXVXdttUd2W39b4rv92K6WaPn8yeMJk9cTJ70mT25LnsMR/fm+/DTNsw2zaseE+6PcXcl/C4PSv0FWgmRHfs7htieCysU1rp4CaV90VkbvOFq/x22LZjAazNPT4mz9uX/TS5/X7bAxC8c6/2e+H2B+H2R+H2J+H2Z9n2l1/AEGS/EW6/FW7/7PNvzX7h868VPv9a4fOvFT7/WuHzrxU+/zrh868TPv864fOvEz7/OuHzrxM+/zrh868TPv864fOvEz7/kvD5l4TPvyR8/iXh8y8Jn39J+PxLwudfEj7/kvD5l4TPv174/OuFz79e+Pzrhc+/Xvj864XPv174/OuFz79e+Pzrhc+/Qfj8G4TPv0H4/BuEz79B+PwbhM+/Qfj8G4TPv0H4/BuEz79R+Pwbhc+/Ufj8G4XPv1H4/BuFz79R+Pwbhc+/Ufj8G4XPv0n4/JuEz79J+PybhM+/Sfj8m4TPv0n4/JuEz79J+PybhM+/Wfj8m4XPv1n4/JuFz79Z+Pybhc+/Wfj8m4XPv1n4/Jtlz7+0yZ5/aZM9/9Ime/6lTfb8S5vs+Zc22fMvbbLnX9pkz7+0yZ5/aRM+/xrh868RPv8a4fPv9Otf1ewXPv8KX/+KhK9/RcLXvyLh61+R8PWvSPj6VyR8/SsSvv4VCV//ioSvf0XC178i4etfkfD1r0j4+lckfP0rEr7+FQlf/4qEr39Fwte/IuHrX5Hw9a9I+PpXJHz9KxK+/hUJX/+KhK9/RcLXvyLh61+R8PWvSPj6VyR8/SsSvv4VCV//ioSvf0XC178i4etfkfD1r0j4+lckfP0rEr7+FQlf/4qEr39Fwte/IuHrX5Hw9a9I+PpXJHz9KxK+/hUJX/+KhK9/RcLXvyLh61+R8PWvSPj6VyR8/SsSvv4VCV//ioSvf0XC178i4etfkfD1r0j4+lckfP0rEr7+FQlf/4qEr39Fwte/IuHrX5Hw9a9I+PpXJHz9KxK+/hUJX/+KhK9/RcLXvyLh61+R8PWvSPj6VyR8/SsSvv4VCV//ioSvf0XC178i4etfkfD1r7zw9a+88PWvvPD1r7zw9a/8Jnv+9cLXv/LC17/ywte/8sLXv/LC17/ywte/8sLXv/LC17/ywte/8sLXv/LTr3/1+OkQs3m2v3TwbnVI4fHDyX35Ovtczenr7PM6p6+z1wCcvs5eLzD6Ov3aXpy+Tl6H+OzTw1f73leKebfj9oA5HQfbHIpmm3hY7eg42rn4xWbyGmcom8nrp6FsaPL7x7Yd94TNhZfabK610e4mTVVC3U2aqtK5mzRVQXI3aaq64bdJcy0ddjdpqln4btJUk9/dpKnmnLtJU93q7ybNd/eea7Gsu0nz3b3nWtLqbtJ8d++5Fp66mzTf3Xuu5aHuJs13955rEae7SfPdvedaaulu0nx377kWRLqbNN/de65li+4mzXf3nmtxobtJ892951oC6G7SfHfvuRbquZs03917ruV07ibNd/eea9Gbu0nz3b3nWprmbtJ8d++5FpC5mzTf3XuuZV7uJs13955rMZa7SfPdvedaMuVu0nx377kWNrmbNN/de67lR+4mzXf3nmuRkLtJ892951rK427SfHfvuRbcuJs03917rmUx7ibNd/eea/GKu0nz3b3nWmLibtJ8d++5FoK4mzTf3Xuu5RruJs13955rUYW7SfPdveda+uBu0nx377kWKLibNN/de65lBO4mTXf3DnN97H83abq7d5jrk/y7SdPdvcM23d07zPUt/N2k6e7eYa4v1u8mTXf3DnN9V/7bpLk+Fb+bNN/de64Puu8mzXf3nuuz67tJ89295/rg+W7SfHfvuT4fvps03917ro9x7ybNd/ee61PVu0nz3b3n+jDzbtJ8d+/5vrUM831rGeb71jLM961lmO9byzDft5Zhvm8tw3zfWob5vrUM831rGeb71jLM961lmO9byzDft5Zhvm8tw3zfWob5vrUM831rGeb71jLM961lmOtby9ejn5bVicnk4+jisjo3d/aFcnyKzz9dOjqZmL+Ovv1yPI62yX6xmXxpuaFsJl+KbiibyZeuG8lmru9xJ2MjZ2m8/mzkLI3Xn42cpfH6s+G5F2+PBfiiiU9sfp/k8w8w78Nc2zBqG+bbhoW2YbFtWGoblpuGff6B2n2YaRvWliWxLUtiW5bEtiyJbVkS27IktmVJbMuS1JYlqS1LUluWpLYsSW1ZktqyJLVlSWrLktSWJaktS3JbluS2LMltWZLbsiS3ZUluy5LcliW5LUtyW5bkpiyJ29Y2zLQNs23DXNswahvm24aFtmGxbVhqG9aWJaYtS0xblpi2LDFtWWLassS0ZYlpyxLTliWmLUtMW5bYtiyxbVli27LEtmWJbcsS25Ylti1LbFuW2LYssW1Z4tqypPzSAoVjGN3uG4VhtjzMPIbZ7T/fy+200S7p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",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert"
      ],
      "verification_key": "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"
    },
    {
      "name": "refund_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3564161243949231814": {
            "error_kind": "string",
            "string": "Function refund_public can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "9323748002447105156": {
            "error_kind": "string",
            "string": "NotPassedTimelock"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7V3bjhw3zn4XX/tCB5IS8yqLH0EO3sCAYQdO8gOLIO++NYdS17iklpvbUrNKugk8mfqG5CfqQEqi/n7364ef//rtx4+f//3lj3c//Ovvd5++/PLTnx+/fF5++vuf9+9+/vrx06ePv/24/d/vzNN/LOEz4I/ff/r89PMff/709c93P4QQw/t3Hz7/+u6HaG1Y/sS/P3768O4Hjv/83/sFxAJQAAEoGglIJEliE0vYY4EkZ0ACkkiyPgey3qF5RVnvI25h7/efG+fWrw24y8eY+RiI7OvHQMGkj8lnPo5ocNUend1+/Kx9vIv2zOvX1nI/7d19uMeYuI8V7i2G1RkseX9de0ZeTWXy8K323t5Ze+veaP8sg9vLgGxfWxyBE8oZS9dlQPSwukXc9ICCWwSX3CKGb4mFvNFu08ncm14WG/spfg9DAN8OLcgiGAURLLgcjCys7UI2XCxD+wIKAlC0EhBKQCwAsZeABER44yUgiSTrJCCJJGclIJSABI3rvYRyXyeC/Ra0HyE8Wf/6sScf08eWcoMPmbiOJ7RMrpXBJ/q1Y8eI/M3g48HdV3kIb5R/FhGai8D2VuA9rMCQRATeiSDXXgQ1FxFMexHQXkRsLiK2b+7Y3mm5vRXc3GnBmPYioL2I5k4L1rUX0b65Xfvmdu2b27Vvbt++uX375ob2zQ3tmxvaNze2b25s39zUvrmpfXNT++YOd25upkrkYtnQmmVguERS3sKLQkGZQt+RjPhfGyG27xDc3or2azQ0tr2I9lbY9la0X0Cha2+Fa2+Fb29F+9UNQnsroL0V2N6K9ksPpPZWtE/hYGhvRWhvRfu5G9vP3dh+7sb2cze1n7up/dxN7eduaj93U/u5m9rP3dR+7qb2cze1n7up/dxN7eduKszdzq6b9uQ8bUU8gQqzcQUkkVTYkaiA8luUjtPu3rIze502cuiTBHpziCSzFchmbZDI7s0piid1YsGGdJqCnqLib2wo7KFfBxW2w6+CgsknK6JNbG1PhqygIAAVhvkKCCUgFoDy55pqIAkRXiLJSySBpHFBIgkljYuSxkVJ45KEcqoTQfH6QOK8W8eGZaSy/1xPmzkM66ECR8Z8O1qH4LQpRMoUyp/FfaRCoE2hqEwh1ubUrKzbR6OMoWiUdftolXX7aJV1+2iVdfvotDm10+bUXptTe21O7bU5NWhzatDm1KjNqVGbU6M2pyZtTk3anDpoc+qgzamDNqeO2pw6anNqttoUQm0KsS6Fljy0NoWUdXu2yro9W2XJBnbKuj07Zd2etcVlrC0uY21xGYPXppC2bo/auj0qWw8xaev2pK3bk7b1UNDW7YO2bq8tDGJtYRCztm6vLQxibWGQNUZZv180UrYiskZbJLRopKzrW6MtFlo0Utb5F43U9X5t4dCikbrer22jatFI2dLIGm0h0aKRut6vLShaNFLX+0ld79cWFy0aqev9UV3v1xYaWaMtNlo0Utf71UVHVl10ZI223m/VRUdWXXRknbbeb9VFR7Z/dETeJo3QV75GdGudDkSs/e2AcdUkkLnUr83eigo+rleoArhKbVlrfUgFQyyYb+spLr9H5UTGtbYvkoPa37aJG2c3xVS8pRdrwQxl7anadjF3/dsOcW8tnqptnQ3JWuKMtfFM1nqT/ra3dm8t+aGsHaptw7na1mHSBDP9NpyrbTeaBL+3tn9o3dJaMOuFbwc2Y23/k50PtXaktnXmXG3r0uoCMGasPVfbpmDMQdjPQK7/pcKm1qaXMRyaTNta7aHzXa11Q7Wt+rTITdZieuLGbZMoyVp/qrZFl/420j6+df23lptay/6S4IOMtWEka3GotsVTtS1d8lIEmTGZTtW2dMlLEWXG5HCqLBzFi7UcMtaeKsNaszYO1bbxVG1bG5PjqVaOtbbtf5zhodaO1LbenCviu56X8uZU+eRKfOvtqfYKqtYO1bauf9umdyldsKby9R1fsVxsjQ+1dVev2Hrv1WmkjqP+t50DcNIo1PrjsiOz9kdnzHaucM/6Q/9jXHwZTxj3jEL/K/9VjdRx1N/rqhp175lMqR8wh8rXEWDtBxHe7MFDttdcfVLLAvqhrNV2ZBi0lUlbNFLHkbYC1hbUXTwBbVfyF43UcaStZvSikTaOUFvV6EUjdRypu+aB2uqBWdRWqHnRSB1HXh1HXh1H6q6co7or54jqOFK3zkZ162xUt85GdetsVLfORnXrbFS3zkZ162xUt84mdetsUrfOJnXrbFK3ziZ162xSt86m/uvsu+U4X/SnY+vf/17ynfWHg+t/3B2NZ/3x4P0XD95/6eD9lw7ef+ng/TccvP+Gg/ffePD+Gw/ef+PB+y8fvP/ysftvMMfuv8HgwfXnY+vf/VyxN7T+aW8CVr4mhPX2BlH1pCqnamLMm1O5jDk9MJ31Wv7pNszQKzNhMpNnpnteSQ0z0a9nyHzM1KYKblifYbf+Zc/e7pnxw/pMlZnpMwVmwE5mCszgZKbADE9m8sx0f5b6OMxMnykwQ8NGB1Vmhp21Y7ortjCzr9YTwowOnpihDDPjrvTw0ptixmfiuNFB5MRM5k5/iOP6TIUZnj5TYoYmM1lmYvds+XGYgclMgZlxo4MKM3b6TImZOJnJMzPu3gHjWs8IjLEZZsaNKFPctDCz32+Kw+4dgLGcmCGTYWZUn1nogMRMyPgMjOszNWamzxSYwVH3m+rMjLrfVGdm1Oigykz3k9XHYWb6TIGZMOp+U52ZcWftVGV+YWa/qxLH3TvYxk0hE2sPu3cAhlNvsm6/3xSH3TtY6EgRpfUZn+FhfabCDJvpMyVmRt1vqjJjR91vqjMDk5kCM8NGBzVm3PSZEjOj7jdVmRl47yC9ewMWXIaZud/0xMz+ZREed+/Apjr64IzJMDNsdOBMiiidzfQmHNZnqsxMnykwQ8PuN1WZGXa/qcrMsNFBjZkAk5kCM9NnCszEYfebqsyMmwdGvjCTiSjHvXewiZucjRlmxo0ok9YLSbuIcgmlhr3JXmVm2LsqNWbs9JkSM9NnCsy46TMlZoatmFFlZtj7TTVmPExm8szAsPcoq8zMcabAzLCn6+vMzPVMgRkaN9auMTNj7QIzw54hrzMz7K3kGjPdq4gfh5kZHRSY4bnSyzNjx62yUmVmrvQKzMxsZ5GZudIrMDNwHfIaM3OlV2DGz+igxMxc6RWY6f7G32GYwbnSKzEzo4MCM8Oeeq0zM6ODAjMD15SuMTOjgwIzw57trDMzo4MCMwyTmQIzMzrIM+PMXOkVmBm2+kGdmbnSKzAzTzAWmZkrvQIzfth7lAsFrx+DzzIzbGWeGjPDnmCsMwOTmQIzw1ZZqTEzbvWDKjNzBC4wQ3MELjEzR+ASM3MELjAzbIa8zswcgQvMxBk3lZiZPlNghuesXWJm3FmbQmJm/7rrwsyw9WcqzHgzbP2ZKjPD1p+pMTPsSek6M8NWjasyM0fgAjNujsAlZuYIXGBm4P2mGjNzBC4xM0fgAjMD7zfVmJk+U2AG56xdYGbcDDmYVLcTrNkzM+xNdoCQXh6HyHtmeIze9GLrGKvaJ1thkBfLXmw9U8beGr9qYg1SpX8HhlWTwHzJTLvocnqH9MSHv/DoTI4Ql9hzbpPyXj5+5vxUEeJBOD/Ve0ZH4XyOLd05P9X5zKNwfqbszUE4P9UN+qNwDpPz7pyfKS9xEM5PVT31KJzPtWJ3zsOcQ/tzPufQ/pyfKYN9EM5PVUXkKJzPvGJ3zk/1qt1ROJ9rxd6c46lqUx+F85lX7M/5XCt259zOtWJ/zmdesTvnp6q7fhTO51qxO+enOud/FM7nWrE/53Ot2J3zU916OAjnOP28Aed44Zxox3mc+Zb7cx5g/dYFhD3ncw7tz/kcW7pzfqp7K0fhfO7N9eaczIxD+3M+59DunJ/qvYCjcD79vD/nc63YnfMD1/l50f+4665n/Q98b/FFf+X7L+Rs0h9C5etowmptNPHSC8nnFHEQV0W2GZ716jVpv6r3SGqUz64PpEb7xbdHUjO9pkSN9kcDHknN9JoSNdovCD2SGpjUlKhRHqY9kBrtt2IeSA0rT9Y+khrlMezjqAnaS3U9kprpNSVqtJeCfyQ1M19Tokb7sdaW1MQLNZtKmIka7e8YNqTGm1Vt763PUDNuh/JoEjWY8RrtdVYeSc24MVSNmoEj7xo12g+NPpKacbN8NWq0Hwd8JDXjxlAVaqI9FzWeEjUYr1OzzEDpLEYA2n78zEzhKhbDaiwxhevMxLiqw87sBBQ2ju8ooLUF2NqCQqnKOwrgxgKotQXU2oLgWwuIjQVE11pAaCyAW1tQqMVzNwFs7jBUpONw7CrTHi8LxfXbaGmvDarShjVpY0GVNqq40V6GoOFqaTFsXS0tI/aOmZNlVW9iBv1VZgb2mWgSM5t888oMDOwzFWamzxSYOdm5yZuY8ZyYYXP9Y2shzWTWottPZSfb0LgPkc/MhIFP91zfIOQwcCLNUkqkebOnJg68C1ajZnpNiZqBj8tVdtx55KT9VWq8MTCpKVEz8I57hRrtd50fSI0beMe9Rs30miI1c6wpUeMHPoxQoWY+efgced+3/IF3IRHicfvxC+ezzEd3zrXfVT0l5zA5vz/n1idCHO05n+VsunOuPUV7Ss5n6cPunMdZ+rA/53Ot2J/zOYd253yWD34A5/O5pt6cL1pOzrtzPteK3Tl3cCLOOa6KMEOFcQCznucB2PzlZe/9lZkzjbq3MeNdYsaHPTPaz6Y2ZAZsYmZzYCwxo/1s6gOZmT5TYOZUOzv3ZWbcEbjCDM3eVGAmjDsCO7zM2jlmzrS6viszESYzBWbOlGG7KzN8pnzvPZlxZtz1TI2Z6TMlZsYdZ8IlCxEzzGivtPI4ZtxxH0dpzIwfdwSuMTPuCMwpp4eZbKfT/h7NA5mZPlNiZtxZu8IMjjtrV5jR/uDK45jR/t5Ky1n7st+0uT9+YWbcbGeFGe1PijyQmXH3DirMMExmCswMnIW4yow302dKzMxxJs8M5E/QWUOrQtZuLzpiyAixuBbCcMZtRHDm23ZHqFxqTOe83378bGj+CNUZDeVBDPWjuK4PgxgKbhRDR2lRtKMYiqMYOsr0QqNMLzTKYBRGGYzyqbgTGpp/TemMhsIoho4yvfAo0wsPMr2gGSR6QTPI9LJsAI5i6CDRC9pBphd0g0wvmL8AekJD/SjTix9leoFB4lGE00wv1+/pI55mwVAzFEYx9DTTS8VQOs30UjP0NNNLxdAwymAURhmMwmmil4qh50l31gwdZXo5T7qzZuhp0p3XDSVzmuilZugg0QuZQaYXsoMMRmRHGYzcINELuVFa1J9megmwfusCwt7Q08SjFUPhNPFozVAYxdDTRC8VQ/E000vN0FEGIxplejlPurNi6HnSnTVD89OLTe97Wwf4xtAXGItg8WZpe4sQebWIotvcWTO5m3aWcSXWcrg0w9NtuCeVQiEgr1gSClFfDeasDEYiWL4q0EPp9lGdSkDqVAqut0oc1iKrvKmiZJFfFIpGm0JRl0IxH3kB2VSealnKv2npzCyA6TZuWDKF6evs+6HB4ToZLf+E7cfPCuUjpEcqhMoUQm0MoTaGSBtDpI2hoI2h/ILukQqxMoXyFXQeqBBbbQoFXQpx/jbEIxXSxpBV5kNsla2H2PdnKJqkULQ7hbC7U/tURyYsEexeobs0Wbgo5Mx1hbyNa4rEO7d5dsi/BLB8n/XHXTVCdRqxNo2CV6dR1KZRdOo0Utf777MuuqtGobdGjlzSKJpvNQJjrDqNSJtGVh1HVh1HTh1HTh1HXh1HHrVpBEadRqBNI3TqNIraNCKvTqP+HKXtCe8tvNHotq+f9Q/u4PqHY+sf7cH1x2Prz+bQ+lujm39r0gmW5Z+XI7geX/V/wHruNv3JJv2D2evvdftPXX84uP58bP3h5hXNCyyIYLevMV9ghU4a1tQ6BBMrJFtKj8lbwl2ZcLBkewjBHkK4g5DQw5JoegjpYkmPNmHfQ0hoL8SVtlbvK+Quw0oMq5Bg416ItT2E9LDEmR5CoIeQ2EGI9z2E9LAEXA8hPVwYe7gwYg8h95hPAnISEmEvhKCHkNhBSHA9hIQOQmIPSyJ1EMKmh5AeLswdXNgb10NIh4b31vQQAj2E9Gh4d5eG5zXFYKMzGSGhgxBvewjBDkLA9BDSxRLuIAR9DyE9XJh6uDD1aHjq0fChR8OHHg0fezT8XVJR0ZskxO/THv4uWaKqkHBnIdvNm1chcJclUVVID0u4/8GCe26jAeveBl/2PtIVebN9IzR7AzMmrePmInv+W4xrjhGj3/GCRvf2+uN40b5t3IqXRdHXb8njnherfRx4EC9u1H5U40X78YVmvNgLL/v5CP2w/lLhZfpLlhfQfoymGS+pHBBtSn5ceNF9vPRhvOCw8/R1XmjYcbfCy7Dj7nVewhx387zAoY8VYjz2sVSM2vMZFf1Z97WKuv7a1x3X9SejfX1Q0//g/Ntj+z/ZY19LIN+/mtG1siaLQt1L44BdKQrg9gpB/zorTFcV6s6Qj/6ikLv+sbU+rOpbC4Z3+mN3l7tauGZRiJUpRKRMoWC1KRSUKRR1VWNaFNLGEGvzIUZdCoV8L4uR1xPGyz83G9jxFYUSVD7uq6JksrLja2S3zhORt8V2czy7mKhzcbNqWEXkT4/eV0RzK2I+GLmviNhchG1vhW1vhWtvhWtvRf5Z7/uKoOYi8rdR7yuifVvEwhiVXmOIb4q5v6AKtUvZpKCFTcA9Kkhk2YK3pCsucfu4REJRQUNIGm6C2hWVPyhQRYlk5e+uV1EsQYFIFjoRKhRQ7oLa+SGTE6FEsoKtovzerlBoZY8JBXs/jLbaU7bruRVVkAXx0r/2GnJBFoRrvZLp9r6MhRp9VRRKUIUn/cCZlEaCbXVcx/QC9E4KJCGw8ITbdwBRCESpRAQpMAqB+fpX3wOUOkC+p38PUOoAUSoxSh0gH8h8B5ClDsBCB7DGSYFCB7BWKtEKHcA6IwWiFCh0AOu9FCh1AJBKBKkDoJUCpQ5AUgcgkAKlDhCkEoPUAaKgP2bS+d6m++3e7+oaLmLCPcQQrwvCsMmiJSH5XfKlc1C6kQme4o4EZ4wUCEKglapaGAbrQCdVNZ9/+A6gl6oK0uYAqaoobQ6U2lh4zfM7gFKJQSoxSCVGaTtGqa8Wll51YP7C1vcAhS5XuP//PcAgBForBQodwDsjBaIUKHQA70EKlDoAeClQ6gDSUc7nxxxMaQyEDci8YPJHQSsYvB0TBXKiQA4L5OQDuqsYMEaAud0eyI8GFcztfgD5chcY13UfRrfH0O2Y/BWhCibLG9k1gUje7zF8Oyaf7a1gBHJQIAcFcvJ5owpGICcI7MmPBxWMwA/yud0Khm7GFK4EXn9xG7HwKDOlcwg2GLdHRQmq8LRxBVXIA9RQ+YVBSEcLbLS0QxUyADUUiFBRgiq8xVxDkQQVRWxEEfMsksUi5lnCPBknQkmYJ2tEKBChRGwUsgTs070Zhj2qsK1zHRUKUZ5JI9ubOzoJFSWoQmrIYhptbNiNNrGQF6qhogSVPw9TReVjgcsTY0v6e8dGLKaLN8m4vSxwIhRJUMVNtOsokKBIZFcQaZiPcJZGTq2MmyN/K6qwh1VDRQmqkAmpoViAWjbCRSiRrEL/Qk5jFNnd6qtw/qSKIgmqkIKooViCAhEbhcxDBYUiDgtrNn+ZU5Z8xh6FIhRLUMGLUEGCKowANZSIDRYxzzJZAubJGC9CBQmqlDWlmFDR7lFBgirt0VRQLEF5lKBKWzMVVJSgUDAvLyiSoMiIUBJZtuAb7O1ltbx5FnaJ7p9hhZx4DVbIBFRhUQQrzCtbGMY9rDBFVGEsglEQwfIx+rKDvXqxM29q0awwEsHyI34dJpPGMmksklbYb6/DZNKslcGCCOacDBZFsPyJoTqMRbB8HrsKQ1lz53N9VRjJmptkziUbFApvC1RhUdbcUeZcLGtuFknzRmRboWa7Mylvsgwbdg8r9YDgEizs5wBf6gEVaVBQMqarIIZxD0Mvg8mklXpABRasDMYiWAwiGBe6adoeXGAZ5+IggRUKGddhJPFJsE4GE/UAcCCCeSODoQgGMmkgsw1lDRAKSjJfcMy74xgLMAqB0UmBQQhkqcTSyrIGRGOkQBQCrVSilUp0UomlzlsH5gsIhVSDBJZNhT2sUDemCgsiWP4aax1GIhjKpBWeE6vCWNhyJOy6WJrX60CpqqXVbR0otVE6PCELJZJxUqBUorVSoMhTqfCuZBUGMphoYCLZwEReJq1QHKoKE86BhNImR6lEMlIgSIHCUYaCVKJ0XKMolRiFCz1imcOxaN4NxspgovElWCODCaWxCOaEU1lwwiYPXirRCyeWAFYKFI4yQTquBem4FkgqkVAKlDlcABlMNKGF6GQw2fgiG80Ci9b1URpARmkAGaUBZLQgBQpHmSgd16J0XIvSca1wyO07gOCkQJnDyQLJKAskI4rGl0ggg8mkBS+DCaeyKE2MRWnkGfnmRs/cugaTjryB2926XoRQeyFsbA8hwgmcpUMk2/i/m7VMr68fh01FrGSU8+1FtLYilI6zoEuXChHcHpbfJ6/DSATzVgaTSQOZNJBJK5yVrsHy+b1Aqe42fXutKBQqLDCtJ+g40B5DN2MKB0QqGBBgBJcJQql4Qw0VJCgnkuVEsrxIlhfJApEsELUXimShyK5CXYcaCkUolqAKx5ZrqHjzaOHyqyp2qT4fZDDh5l7s8734qhxvnQBDt2Py2fAK5vaRrFD44DrGC+TkoypOrzVsS3+umPyh0ApGIAdrs1MOI/C3/PXn65hgBBi8HVMob3kdc/sM7VkghwX28O1+DcYLMLf7ARRmI7rUwiJHu4UXFE6o12CFI+pbmIcMDEWwcLu0f5Yf//+nrx9/+vnThz8W0NNv//r8y58fv3x+/fHP//y+/ubnrx8/ffr424+/f/3yy4df//r64cdPX355+t078/qffz3ffVzCC1wUevK2ZVnt31vw9unnpw+WhOL7Jc/z9OPz79HY98t//KLJos1/AQ==",
      "brillig_names": [
        "refund_public"
      ]
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [
        "aztec::macros::functions::utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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39bJ3n87RPz8IdbPHyJ9/hD584conz9E/fghXjz+6XoI9/lD+M8f4vNnd/382V0/f3bXz5/d9fNnd/382V0/fna7Zfn8IdznD+E/f4jfPrvvu8Vzu63ndkvndsvndivndqundnPLud3cud38ud3OVYk7VyXuXJW4c1XizlWJO1cl7lyV+HNV4s9ViT9XJf5clfhzVeLPVYk/VyX+XJX4c1Xiz1VJOFcl4VyVhHNVEs5VSThXJeFclYRzVRLOVUk4VyXhXJXEc1USz1VJPFcl8VyVxHNVEs9VSTxXJfFclcRzVRLPVcl6rkrWc1WynquS9VyVrOeqZD1XJeu5KlnPVcl6rkrWc1WSzlVJOlcl6VyVpHNVks5VSTpXJelclaRzVZLOVUk6VyX5XJXkc1WSz1VJPlcl+VyV5HNVks9VST5XJflcleRzVVLOVUk5VyXlXJWUc1VSzlVJOVcl5VyVlHNVUs5VSTlXJfVcldRzVVLPVUk9VyX1XJXUc1VSz1VJPVcl9VyV1FNV4pfl3G7u3G7+3G7h3G7x3G7rud3Sud3yud3Kud3OVcm57NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1b/IXuv+8t4tHHQHu72okpz33ar/abejFWc7fc/iNpyqajivsmKp4Thdw/G6hhN0DSfqGs6qazhJ13CyruHouipXVVflsKi6KodF1VU5LKquymFRdVUOi6qrclhUXZXDcvVV+e2nmG7jycrGU5SNp+oaj1uUjccpG89vX5vvu4Vzu8Vzux1ek27PTLclPG5PJtcGNJdy2L/um3J6LKxztNLBzZhvi8jc7qah8bfTsuwLYC3h8WPyunyNPykf/7psAqQ1hO/jz4OPvww+/jr2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",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "redeem_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "get_htlc_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "view",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "key",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "Train::HTLC_Public",
            "fields": [
              {
                "name": "src_receiver",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "amount",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "token",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "hashlock_high",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "hashlock_low",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "secret_high",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "secret_low",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "timelock",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "claimed",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 8
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "9174444391250494040": {
            "error_kind": "string",
            "string": "Function get_htlc_public can only be called statically"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_htlc_public"
      ]
    },
    {
      "name": "lock_public_solver",
      "is_unconstrained": true,
      "custom_attributes": [
        "internal",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 48
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "15001264570739363109": {
            "error_kind": "string",
            "string": "Function lock_public_solver can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "lock_public_solver"
      ]
    },
    {
      "name": "redeem_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "772057049813214347": {
            "error_kind": "string",
            "string": "HTLCNotExists"
          },
          "2570651705007895968": {
            "error_kind": "string",
            "string": "HashlockNotMatch"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17814817983036354427": {
            "error_kind": "string",
            "string": "Function redeem_public can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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GYBeABokAgAaAAAftiUAAChEACgSAhsAOBsZHC0NHBoBKAATgFsAGQ44ExkbJAIAGwAAH94lAAAoMg0oABmAXgAbJAIAGwAAH/MlAAAoRAAoEgIcADgcGR0tDR0bASgAE4BTABkOOBMZHCQCABwAACAbJQAAKDINKAAZgF4AEyQCABMAACAwJQAAKEQAKBICHAA4HBkdLQ0dExwMGBkEGSgAGYBdABgcDBoZBAA4GBkaDjgYGhwkAgAcAAAgZyUAACgyGSgAGoBdABgcDBsZBAA4GBkaDjgYGhskAgAbAAAgiyUAACgyGSgAGoBdABgcDBMZBAA4GBkTDjgYExokAgAaAAAgryUAACgyDSgAF4BOABgkAgAYAAAgxCUAAChELgQAFIADKACABAQAESUAACiMLgiABQAYACgYAhkAOBkXGi0OExotDhgIASgACYBZABMtDBMJIwAACkAtDQgRDSgACYBOABIkAgASAAAhGCUAAChELgQAEYADKACABAQAESUAACiMLgiABQASACgSAhMAOBMJFC4KgFUAFC0OEggBKAAJgFkAES0MEQkjAAAJvC0IARMAAAECAS4KgFUAEwUoABCATAAUJwIYBAALKAAYgEwAFyQCABcAACGbBygAFIBMABoKOBoQGSQCABkAACGbJQAAKGguCIBVABIjAAAhpg0oABKATAAXJAIAFwAAIhMjAAAhuy0NCRItDRMUDSgAEIBOABMkAgATAAAh2CUAAChELgQAEoADKACABAQAESUAACiMLgiABQATACgTAhcAOBcQGC0OFBgBKAAQgFkAEi0OEwktDBIQIwAABfoAOBQSGA44FBgZJAIAGQAAIiolAAAoMg0oABiAYgAZJAIAGQAAIkgjAAAiPy0MDRcjAAAidA0oABiAYgAZJAIAGQAAIl0lAAAoRAAoAgIaADgaGBstDRsZLQwZFyMAACJ0LQ0TGBkoABiAXQAZHAwXGAQAOBkYFw44GRcaJAIAGgAAIpwlAAAoMi0OFxMBKAASgFkAFy0MFxIjAAAhpigAgAQEeAANAAAAgASAAyQAgAMAACLZKgEAAQX3ofOvpa3UyjwBAQImKgEAAQW+Hj//PqT2+jwBAQImKgEAAQX3OvKRkR9vezwBAQImJQAAIrErAgALAAAAAAAAAAACAAAAAAAAAAAnAhAEES0IABEtDAsSABAA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",
      "debug_symbols": "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",
      "brillig_names": [
        "redeem_public"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000001"
            },
            {
              "kind": "string",
              "value": "HTLC_Private"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Train"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "contracts_private",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "contracts_public",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 48
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::lock_public_solver_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::lock_public_solver_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 48
                    }
                  },
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "src_receiver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::commit_public_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::commit_public_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::refund_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::refund_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "secret",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::redeem_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::redeem_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 48
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::lock_private_solver_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::lock_private_solver_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::add_lock_private_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::add_lock_private_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "key",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::get_htlc_public_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "src_receiver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "hashlock_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "hashlock_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "secret_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "secret_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "claimed",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::HTLC_Public"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::get_htlc_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::refund_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::refund_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "Train::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::add_lock_public_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::add_lock_public_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "src_receiver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 48
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::commit_private_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::commit_private_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "secret",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::redeem_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::redeem_private_abi"
        }
      ]
    }
  },
  "file_map": {
    "100": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, &[], true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "101": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\nuse super::utils::is_note;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract. Only a single struct in the entire contract\n/// should have this macro (or `storage_no_init`) applied to it.\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot }, false);\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n/// Only a single struct in the entire contract should have this macro (or `storage`) applied to it.\npub comptime fn storage_no_init(_s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(\n    typ: Type,\n    slot: Quoted,\n    parent_is_map: bool,\n) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot }, true);\n        (quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }, 1)\n    } else {\n        let storage_size = if parent_is_map {\n            // Variables inside a map do not require contiguous slots since the map slot derivation is assumed to result\n            // in slots very far away from one another.\n            1\n        } else {\n            let (_, container_struct_generics) = typ.as_data_type().unwrap();\n            let stored_struct = container_struct_generics[0];\n\n            if is_note(stored_struct) {\n                // Private notes always occupy a single slot, since the slot is only used as a state variable\n                // identifier.\n                1\n            } else {\n                get_storage_size(typ)\n            }\n        };\n\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        (quote { $struct_name::new(context, $slot)}, storage_size)\n    }\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "103": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "104": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash =\n            compute_unique_note_hash(nonce, compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash));\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.nonce, note_and_data.nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == first_note_and_data.nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == second_note_and_data.nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "105": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    pending_partial_notes.for_each(|i, pending_partial_note: DeliveredPendingPartialNote| {\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log sans the extra\n            // fields) to get the complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                // temporary node connectivity issue - is simply throwing good enough here?\n                assert(\n                    deliver_note(\n                        contract_address,\n                        pending_partial_note.storage_slot,\n                        discovered_note.nonce,\n                        complete_packed_note,\n                        discovered_note.note_hash,\n                        discovered_note.inner_nullifier,\n                        log.tx_hash,\n                        pending_partial_note.recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "107": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/private_logs.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{\n            ComputeNoteHashAndNullifier,\n            partial_notes::process_partial_note_private_msg,\n            pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n            private_notes::process_private_note_msg,\n        },\n        encoding::decode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        msg_type::{\n            PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n        },\n    },\n    oracle::{logs::store_private_event_log, message_discovery::sync_notes},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `syncNotes` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    sync_notes(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get the logs from the capsule array and process them one by one\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    logs.for_each(|i, log: PendingTaggedLog| {\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n        logs.remove(i);\n    });\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(log_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            pending_tagged_log.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        // In the case of events, the msg metadata is the event selector.\n        let event_selector = EventSelector::from_field(msg_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            msg_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n            pending_tagged_log.tx_index_in_block,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "108": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n        // issue, and we should perhaps not have marked the tag index as taken.\n        assert(\n            oracle::message_discovery::deliver_note(\n                contract_address,\n                storage_slot,\n                discovered_note.nonce,\n                packed_note,\n                discovered_note.note_hash,\n                discovered_note.inner_nullifier,\n                tx_hash,\n                recipient,\n            ),\n            \"Failed to deliver note\",\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "109": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\nglobal MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "110": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "117": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/logs/note.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    messages::{\n        encoding::encode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        logs::utils::prefix_with_tag,\n        msg_type::{PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID},\n    },\n    note::{note_emission::NoteEmission, note_interface::NoteType},\n};\nuse protocol_types::{\n    abis::note_hash::NoteHash, address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS,\n    traits::Packable,\n};\n\n// TODO: it feels like this existence check is in the wrong place. In fact, why is it needed at all? Under what circumstances have we found a non-existent note being emitted accidentally?\nfn assert_note_exists<let N: u32>(context: PrivateContext, note_hash_counter: u32) {\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists =\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n}\n\npub fn compute_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PRIVATE_NOTE_MSG_TYPE_ID,\n    )\n}\n\npub fn compute_partial_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID,\n    )\n}\n\nfn compute_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    msg_type: u64,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let packed_note = note.pack();\n\n    // A note message's content is the storage slot followed by the packed note representation\n    let mut msg_content: [Field; N + 1] = std::mem::zeroed();\n    msg_content[0] = storage_slot;\n    for i in 0..packed_note.len() {\n        msg_content[1 + i] = packed_note[i];\n    }\n\n    // Notes use the note type id for metadata\n    let plaintext = encode_message(msg_type, Note::get_id() as u64, msg_content);\n\n    let ciphertext = AES128::encrypt_log(plaintext, recipient);\n\n    let log = prefix_with_tag(ciphertext, sender, recipient);\n\n    log\n}\n\npub unconstrained fn compute_note_log_unconstrained<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_note_log(note, storage_slot, recipient, sender)\n}\n\n/// Sends an encrypted message to `recipient` with the content of the note, which they will discover when processing\n/// private logs.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n        assert_note_exists(*context, note_hash_counter);\n\n        let encrypted_log = compute_note_log(note, storage_slot, recipient, sender);\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n\n/// Same as `encode_and_encrypt_note`, except encryption is unconstrained. This means that the sender is free to make\n/// the log contents be whatever they wish, potentially resulting in scenarios in which the recipient is unable to\n/// decrypt and process the payload, **leading to the note being lost**.\n///\n/// Only use this function in scenarios where the recipient not receiving the note is an acceptable outcome.\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n\n        assert_note_exists(*context, note_hash_counter);\n\n        // Safety: this function does not constrain the encryption of the log, as explained on its description.\n        let encrypted_log =\n            unsafe { compute_note_log_unconstrained(note, storage_slot, recipient, sender) };\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n"
    },
    "118": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/logs/utils.nr",
      "source": "use crate::{\n    oracle::notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n    prelude::AztecAddress,\n};\n\npub(crate) fn prefix_with_tag<let L: u32>(\n    log_without_tag: [Field; L],\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> [Field; L + 1] {\n    // Safety: we assume that the sender wants for the recipient to find the tagged note, and therefore that they will\n    // cooperate and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the\n    // note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    let mut log_with_tag = [0; L + 1];\n\n    log_with_tag[0] = tag;\n    for i in 0..log_without_tag.len() {\n        log_with_tag[i + 1] = log_without_tag[i];\n    }\n\n    log_with_tag\n}\n\nmod test {\n    use super::prefix_with_tag;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn prefixing_with_tag() {\n        let sender = AztecAddress::from_field(1);\n        let recipient = AztecAddress::from_field(2);\n\n        let app_tagging_secret = 42;\n        let index = 5;\n\n        // I am using the deserialize trait instead of directly instantiating the IndexedTaggingSecret struct because\n        // direct instantiation functionality is not exposed.\n        let indexed_tagging_secret = IndexedTaggingSecret::deserialize([app_tagging_secret, index]);\n\n        // Mock the tagging oracles\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(indexed_tagging_secret);\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        let log_without_tag = [1, 2, 3];\n        let log_with_tag = prefix_with_tag(log_without_tag, sender, recipient);\n\n        let expected_result = [indexed_tagging_secret.compute_tag(recipient), 1, 2, 3];\n\n        // Check tag was prefixed correctly\n        assert_eq(log_with_tag, expected_result, \"Tag was not prefixed correctly\");\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "123": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_interface::{NoteHash, NoteType},\n    retrieved_note::RetrievedNote,\n    utils::{compute_note_hash_for_nullify_from_read_request, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::notify_created_note;\nuse protocol_types::traits::Packable;\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    let note_hash_counter = context.side_effect_counter;\n\n    let note_hash = note.compute_note_hash(storage_slot);\n\n    let packed_note = Note::pack(note);\n    notify_created_note(\n        storage_slot,\n        Note::get_id(),\n        packed_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(note, storage_slot, note_hash_counter)\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n\n    destroy_note_unsafe(context, retrieved_note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_from_read_request(retrieved_note, note_hash_for_read_request);\n    let nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash = if retrieved_note.metadata.is_settled() {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifying so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, note_hash)\n}\n"
    },
    "125": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub note: Note,\n    pub storage_slot: Field,\n    pub note_hash_counter: u32, // a note_hash_counter of 0 means settled\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note, storage_slot: Field, note_hash_counter: u32) -> Self {\n        Self { note, storage_slot, note_hash_counter }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "128": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/note/note_getter.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n    retrieved_note::RetrievedNote,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::oracle;\nuse crate::utils::{array, comparison::compare};\nuse dep::protocol_types::{\n    constants::{GET_NOTES_ORACLE_RETURN_LENGTH, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL},\n    traits::{Packable, ToField},\n};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    packed_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the packed note.\n    // This allows easier packing and custom (un)packing schemas. A note property is located\n    // inside the packed note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = packed_note[selector.index as u32].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[(31 + offset - i) as u32] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_packed_note<let N: u32>(packed_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(packed_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (RetrievedNote<Note>, Field)\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    // Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do\n    // is check that the metadata is correct, and that the note exists.\n    let retrieved_note = unsafe { get_note_internal::<Note, N>(storage_slot) };\n\n    // For settled notes, the contract address is implicitly checked since the hash returned from\n    // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n    // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the contract\n    // address returned from the oracle matches. Since branching in circuits is expensive, we perform this check on all\n    // note types.\n    assert(\n        retrieved_note.contract_address.eq(context.this_address()),\n        \"Note contract address mismatch.\",\n    );\n\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (retrieved_note, note_hash_for_read_request)\n}\n\n/// Returns a BoundedVec of notes that have been proven to have been created by this contract, either in the current or\n/// past transactions (i.e. pending or settled notes). A second BoundedVec contains the note hashes used for the read\n/// requests, which can save constraints when computing the note's nullifiers.\n///\n/// WARNING: recall that notes are never destroyed! Note existence therefore does not imply that the note is _current_\n/// or _valid_ - this typically requires also emitting the note's nullifier to prove that it had not been emitted\n/// before. Because of this, calling this function directly from end-user applications should be discouraged, and safe\n/// abstractions such as aztec-nr's state variables should be used instead.\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // Safety: The notes are constrained below.\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the notes (as opposed to simply removing some), the private\n    // kernel will later validate that these note actually exist, so transformations would cause for that check\n    // to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = array::collapse(filtered_notes);\n    let mut note_hashes = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_packed_note = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let retrieved_note = notes.get_unchecked(i);\n\n            // For settled notes, the contract address is implicitly checked since the hash returned from\n            // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n            // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the\n            // contract address returned from the oracle matches. Since branching in circuits is expensive, we perform\n            // this check on all note types.\n            assert(\n                retrieved_note.contract_address.eq(context.this_address()),\n                \"Note contract address mismatch.\",\n            );\n\n            let packed_note = retrieved_note.note.pack();\n            check_packed_note(packed_note, options.selects);\n            if i != 0 {\n                check_notes_order(prev_packed_note, packed_note, options.sorts);\n            }\n            prev_packed_note = packed_note;\n\n            let note_hash_for_read_request =\n                compute_note_hash_for_read_request(retrieved_note, storage_slot);\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> RetrievedNote<Note>\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let opt_notes: [_; 1] = oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_fields,\n    );\n\n    opt_notes[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_fields,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\n/// Unconstrained variant of `get_notes`, meant to be used in unconstrained execution contexts. Notably only the note\n/// content is returned, and not any of the information used when proving its existence (e.g. nonce, note hash, etc.).\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteType + Packable<N> + Eq,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n\n    // We fetch the notes from the same oracle we use in the constrained case, except we don't bother inspecting the\n    // metadata in order to prove existence.\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_fields,\n    );\n\n    // Even though we don't expect for the opt_notes array to be sparse, collapse is still useful in this case to\n    // convert it into a BoundedVec.\n    array::collapse(opt_notes).map(\n        // view_notes just returns the actual note, so we drop the metadata\n        |retrieved_note| retrieved_note.note,\n    )\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects as u32] = select.unwrap_unchecked().value;\n            select_comparators[num_selects as u32] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
    },
    "131": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "134": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "137": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "138": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "139": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "140": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "141": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "142": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "146": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "147": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "148": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "149": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use crate::messages::encoding::MAX_MESSAGE_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        msg_content,\n        tx_hash,\n        log_index_in_tx,\n        tx_index_in_block,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {}\n"
    },
    "150": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr",
      "source": "use crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn sync_notes(pending_tagged_log_array_base_slot: Field) {\n    sync_notes_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "152": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::{\n    note::{note_interface::NoteType, note_metadata::NoteMetadata, retrieved_note::RetrievedNote},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::IndexedTaggingSecret,\n    traits::{FromField, Packable},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {\n    // This wrapper exists to extract the ORACLE_RETURN_FIELD_LENGTH generic numeric param into a value and pass it to\n    // the oracle, so that it knows how big the return array must be.\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        ORACLE_RETURN_FIELD_LENGTH,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let MAX_NOTES: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    _placeholder_fields: [Field; ORACLE_RETURN_FIELD_LENGTH], // TODO: Compute this value automatically from MAX_NOTES\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let fields: [_; ORACLE_RETURN_FIELD_LENGTH] = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n\n    let mut opt_notes = [Option::none(); MAX_NOTES];\n    for i in 0..opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let maybe_nonce = fields[read_offset];\n            let maybe_note_hash_counter = fields[read_offset + 1] as u32;\n            let packed_note = array::subarray(fields, read_offset + 2);\n\n            let note = Note::unpack(packed_note);\n            let retrieved_note = RetrievedNote {\n                note,\n                contract_address,\n                metadata: NoteMetadata::from_raw_data(maybe_note_hash_counter != 0, maybe_nonce),\n            };\n\n            opt_notes[i] = Option::some(retrieved_note);\n        };\n    }\n    opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "153": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "154": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "155": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "157": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "159": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/state_vars/private_immutable.nr",
      "source": "use dep::protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\nuse crate::context::{PrivateContext, UtilityContext};\nuse crate::note::{\n    lifecycle::create_note,\n    note_emission::NoteEmission,\n    note_getter::{get_note, view_notes},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateImmutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context, let N: u32> Storage<N> for PrivateImmutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateImmutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateImmutable>` type (for example), because the storage slot often also identifies an actor.\n    // e.g. the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<Note> PrivateImmutable<Note, &mut PrivateContext> {\n    // docs:start:initialize\n    pub fn initialize<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: NoteType + NoteHash + Packable<N>,\n    {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:get_note\n    pub fn get_note<let N: u32>(self) -> Note\n    where\n        Note: NoteType + NoteHash + Packable<N>,\n    {\n        let storage_slot = self.storage_slot;\n        let retrieved_note = get_note(self.context, storage_slot).0;\n\n        // Because the notes obtained from PrivateImmutable are not meant to be nullified and get_note(...) function\n        // has already constrained the note (by pushing a read request to the context), we can return just the note\n        // and skip the additional data in RetrievedNote.\n        retrieved_note.note\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateImmutable<Note, UtilityContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    // docs:start:is_initialized\n    pub unconstrained fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // view_note does not actually use the context, but it calls oracles that are only available in private\n    // docs:start:view_note\n    pub unconstrained fn view_note<let N: u32>(self) -> Note\n    where\n        Note: Packable<N>,\n    {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: x_coordinates_match,\n        };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "168": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable.nr",
      "source": "use dep::protocol_types::{\n    shared_mutable::{\n        ScheduledDelayChange,\n        ScheduledValueChange,\n        shared_mutable_values::{unpack_delay_change, unpack_value_change},\n        SharedMutableValues,\n    },\n    traits::Packable,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\n\nmod test;\n\npub struct SharedMutable<T, let INITIAL_DELAY: u32, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// This will make the Aztec macros require that T implements the Packable and Eq traits, and allocate `M` storage\n// slots to this state variable.\nimpl<T, let INITIAL_DELAY: u32, Context, let M: u32> Storage<M> for SharedMutable<T, INITIAL_DELAY, Context>\nwhere\n    WithHash<SharedMutableValues<T, INITIAL_DELAY>, _>: Packable<M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in blocks. Reads in private are only valid as long as they are included in a block not too far into the\n// future, so that they can guarantee the value will not have possibly changed by then (because of the delay).\n// The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, let INITIAL_DELAY: u32, Context> SharedMutable<T, INITIAL_DELAY, Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PublicContext>\nwhere\n    T: Eq,\n{\n\n    pub fn schedule_value_change<let N: u32>(self, new_value: T)\n    where\n        T: Packable<N>,\n    {\n        let _value_change = self.schedule_and_return_value_change(new_value);\n    }\n\n    pub fn schedule_and_return_value_change<let N: u32>(\n        self,\n        new_value: T,\n    ) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n        let current_delay = delay_change.get_current(block_number);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let block_of_change = block_number + current_delay;\n        value_change.schedule_change(new_value, block_number, current_delay, block_of_change);\n\n        self.write(value_change, delay_change);\n\n        value_change\n    }\n\n    pub fn schedule_delay_change<let N: u32>(self, new_delay: u32)\n    where\n        T: Packable<N>,\n    {\n        let mut delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n\n        delay_change.schedule_change(new_delay, block_number);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    pub fn get_current_delay<let N: u32>(self) -> u32\n    where\n        T: Packable<N>,\n    {\n        let block_number = self.context.block_number() as u32;\n        self.read_delay_change().get_current(block_number)\n    }\n\n    pub fn get_scheduled_value<let N: u32>(self) -> (T, u32)\n    where\n        T: Packable<N>,\n    {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay<let N: u32>(self) -> (u32, u32)\n    where\n        T: Packable<N>,\n    {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change<let N: u32>(self) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        // We don't read ScheduledValueChange directly by having it implement Packable because ScheduledValueChange\n        // and ScheduledDelayChange are packed together (sdc and svc.block_of_change are stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_value_change::<T, N>(packed)\n    }\n\n    fn read_delay_change<let N: u32>(self) -> ScheduledDelayChange<INITIAL_DELAY>\n    where\n        T: Packable<N>,\n    {\n        // Since all ScheduledDelayChange member are packed into a single field, we can read a single storage slot\n        // here and skip the ones that correspond to ScheduledValueChange members. We are abusing the fact that\n        // the field containing the ScheduledDelayChange data is the first one in the storage layout - otherwise we'd\n        // need to offset the storage slot to get the position where it'd land.\n        // We don't read ScheduledDelayChange directly by having it implement Packable because\n        // ScheduledValueChange and ScheduledDelayChange are packed together (sdc and svc.block_of_change are\n        // stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_delay_change::<INITIAL_DELAY>(packed)\n    }\n\n    fn write<let N: u32>(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>,\n    )\n    where\n        T: Packable<N>,\n    {\n        // Whenever we write to public storage, we write both the value change and delay change to storage at once.\n        // We do so by wrapping them in a single struct (`SharedMutableValues`). Then we wrap the resulting struct in\n        // `WithHash`.\n        // Wrapping in `WithHash` makes for more costly writes but it also makes private proofs much simpler because\n        // they only need to produce a historical proof for the hash, which results in a single inclusion proof (as\n        // opposed to 4 in the best case scenario in which T is a single field). Private shared mutable reads are\n        // assumed to be much more frequent than public writes, so this tradeoff makes sense.\n        let values = WithHash::new(SharedMutableValues::new(value_change, delay_change));\n\n        self.context.storage_write(self.storage_slot, values);\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext>\nwhere\n    T: Eq,\n{\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction block number as this proof\n        // will only be valid for however many blocks we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n        let (value_change, delay_change, historical_block_number) =\n            self.historical_read_from_public_storage();\n\n        // We use the effective minimum delay as opposed to the current delay at the historical block as this one also\n        // takes into consideration any scheduled delay changes.\n        // For example, consider a scenario in which at block 200 the current delay was 50. We may naively think that\n        // the earliest we could change the value would be at block 251 by scheduling immediately after the historical\n        // block, i.e. at block 201. But if there was a delay change scheduled for block 210 to reduce the delay to 20\n        // blocks, then if a value change was scheduled at block 210 it would go into effect at block 230, which is\n        // earlier than what we'd expect if we only considered the current delay.\n        let effective_minimum_delay =\n            delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon =\n            value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any block after the block horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_tx_max_block_number(block_horizon);\n        value_change.get_current_at(historical_block_number)\n    }\n\n    fn historical_read_from_public_storage<let N: u32>(\n        self,\n    ) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u32)\n    where\n        T: Packable<N>,\n    {\n        let header = self.context.get_block_header();\n        let address = self.context.this_address();\n\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        let values: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::historical_public_storage_read(header, address, self.storage_slot);\n\n        (values.svc, values.sdc, historical_block_number)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, UtilityContext>\nwhere\n    T: Eq,\n{\n    pub unconstrained fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let smv: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::utility_public_storage_read(self.context, self.storage_slot);\n\n        let block_number = self.context.block_number() as u32;\n        smv.svc.get_current_at(block_number)\n    }\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "180": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "183": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "184": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "186": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "187": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "189": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "191": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "192": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/random.nr",
      "source": "use crate::oracle::random::random;\n\n/// Returns as many random bytes as specified through N.\npub unconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n"
    },
    "195": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "20": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "219": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "221": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "264": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "279": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "281": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "282": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "283": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr",
      "source": "use crate::traits::{Deserialize, Serialize, ToField};\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\nuse std::meta::derive;\n\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\n\n#[derive(Serialize, Deserialize)]\npub struct IndexedTaggingSecret {\n    app_tagging_secret: Field,\n    index: u32,\n}\n\nimpl IndexedTaggingSecret {\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\n        poseidon2_hash(\n            [self.app_tagging_secret, recipient.to_field(), self.index as Field],\n        )\n    }\n}\n"
    },
    "292": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "296": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `omit`: A list of field names (as `Quoted`) to be excluded from the serialized output.\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, &[], false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, &[], false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], &[], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, &[], false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with Omitted Field and packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// Serializing while omitting `value2`:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, MyStruct, &[quote { self.value2 }], true)\n/// // Returns:\n/// // ([`value_packed[0]`], [`let value_packed = self.value.pack()`])\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    omit: [Quoted],\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // Proceed if none of the omit rules omits this name\n    if !omit.any(|to_omit| to_omit == name) {\n        // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n        let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n        let packable_constraint =\n            quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n        if (should_pack & typ.implements(packable_constraint)) {\n            // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n            // method, add the resulting field array to `aux_vars` and each field to `fields`.\n            let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n            // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n            let name_at_one_token = collapse_to_one_token(name);\n            let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n            // We add the individual fields to the fields array\n            let pack_method = get_trait_impl_method(\n                typ,\n                quote { crate::traits::Packable<$packed_len> },\n                quote { pack },\n            );\n            let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n            for i in 0..packed_len {\n                fields = fields.push_back(quote { $packed_struct_name[$i] });\n            }\n\n            // We add the new auxiliary variable to the aux_vars array\n            aux_vars = aux_vars.push_back(packed_struct);\n        } else if typ.is_field() {\n            // For field we just add the value to fields\n            fields = fields.push_back(name);\n        } else if typ.as_integer().is_some() | typ.is_bool() {\n            // For integer and bool we just cast to Field and add the value to fields\n            fields = fields.push_back(quote { $name as Field });\n        } else if typ.as_data_type().is_some() {\n            // For struct we pref\n            let nested_struct = typ.as_data_type().unwrap();\n            let params = nested_struct.0.fields(nested_struct.1);\n            let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n                let maybe_prefixed_name = if name == quote {} {\n                    // Triggered when the param name is of a value available in the current scope (e.g. a function\n                    // argument) --> then we don't prefix the name with anything.\n                    param_name\n                } else {\n                    // Triggered when we want to prefix the param name with the `name` from function input. This\n                    // can typically be `self` when implementing a method on a struct.\n                    quote { $name.$param_name }\n                };\n                generate_serialize_to_fields(\n                    quote {$maybe_prefixed_name},\n                    param_type,\n                    omit,\n                    should_pack,\n                )\n            });\n            let struct_flattened_fields = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n            );\n            let struct_flattened_aux_vars = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n            );\n            fields = fields.append(struct_flattened_fields);\n            aux_vars = aux_vars.append(struct_flattened_aux_vars);\n        } else if typ.as_array().is_some() {\n            // For array we recursively call `generate_serialize_to_fields(...)` for each element\n            let (element_type, array_len) = typ.as_array().unwrap();\n            let array_len = array_len.as_constant().unwrap();\n            for i in 0..array_len {\n                let (element_fields, element_aux_vars) = generate_serialize_to_fields(\n                    quote { $name[$i] },\n                    element_type,\n                    omit,\n                    should_pack,\n                );\n                fields = fields.append(element_fields);\n                aux_vars = aux_vars.append(element_aux_vars);\n            }\n        } else if typ.as_str().is_some() {\n            // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n            // then we add each byte to fields as a Field\n            let length_type = typ.as_str().unwrap();\n            let str_len = length_type.as_constant().unwrap();\n            let as_member = name.as_expr().unwrap().as_member_access();\n            let var_name = if as_member.is_some() {\n                as_member.unwrap().1\n            } else {\n                name\n            };\n            let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n            let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n            for i in 0..str_len {\n                fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n            }\n            aux_vars = aux_vars.push_back(as_bytes);\n        } else {\n            panic(\n                f\"Unsupported type for serialization of argument {name} and type {typ}\",\n            )\n        }\n    }\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) =\n        generate_serialize_to_fields(quote { self }, typ, &[], packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "298": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "299": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "308": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize, ToField},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "312": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_delay_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initially equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation\n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the\n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a\n// reduced delay, invalidating prior private reads.\npub struct ScheduledDelayChange<let INITIAL_DELAY: u32> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option,\n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pub(crate) pre: Option<u32>,\n    pub(crate) post: Option<u32>,\n    // Block at which `post` value is used instead of `pre`\n    pub(crate) block_of_change: u32,\n}\n\nimpl<let INITIAL_DELAY: u32> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u32>, post: Option<u32>, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current block number - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_block_number: u32) -> u32 {\n        // The post value becomes the current one at the block of change, so any transaction that is included in the\n        // block of change will use the post value.\n        if current_block_number < self.block_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the block at which it will become the current\n    /// delay. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u32, u32) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.block_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current block number. This function is only meaningful\n    /// when called in public with the current block number.\n    /// The block at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u32, current_block_number: u32) {\n        let current = self.get_current(current_block_number);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let blocks_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior constraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value block of change\n            //       block                 block of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   blocks until change               new delay            |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.block_of_change = current_block_number + blocks_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical block number. It only returns a meaningful value when called in private with historical blocks. This\n    /// function can be used alongside `ScheduledValueChange.get_block_horizon` to properly constrain the\n    /// `max_block_number` transaction property when reading mutable shared state.\n    /// This value typically equals the current delay at the block following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is\n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_block_number: u32) -> u32 {\n        if self.block_of_change <= historical_block_number {\n            // If no delay changes were scheduled, then the delay value at the historical block (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // block of change the current delay will be the scheduled one, with an overall delay from the historical\n            // block number equal to the number of blocks until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //         block                  delay                  actual earliest value\n            //           v                block of change              block of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest block in            |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |         blocks                  new delay                      |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest block in\n            //                             which to scheduled value change\n            let blocks_until_change = self.block_of_change - (historical_block_number + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                blocks_until_change + self.post.unwrap_or(INITIAL_DELAY),\n            )\n        }\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Empty for ScheduledDelayChange<INITIAL_DELAY> {\n    fn empty() -> Self {\n        Self { pre: Option::none(), post: Option::none(), block_of_change: 0 }\n    }\n}\n"
    },
    "314": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_value_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some block\n// called the `block_of_change`. The value can only be made to change by scheduling a change event at some future block\n// of change after some minimum delay measured in blocks has elapsed. This means that at any given block number we know\n// both the current value and the smallest block number at which the value might change - this is called the\n// 'block horizon'.\npub struct ScheduledValueChange<T> {\n    pub(crate) pre: T,\n    pub(crate) post: T,\n    // Block at which `post` value is used instead of `pre`\n    pub(crate) block_of_change: u32,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given block. This function can be called both in public\n    /// (where `block_number` is simply the current block number, i.e. the number of the block in which the current\n    /// transaction will be included) and in private (where `block_number` is the historical block number that is used\n    /// to construct the proof).\n    /// Reading in private is only safe if the transaction's `max_block_number` property is set to a value lower or\n    /// equal to the block horizon (see `get_block_horizon()`).\n    pub fn get_current_at(self, block_number: u32) -> T {\n        // The post value becomes the current one at the block of change. This means different things in each realm:\n        // - in public, any transaction that is included in the block of change will use the post value\n        // - in private, any transaction that includes the block of change as part of the historical state will use the\n        //   post value (barring any follow-up changes)\n        if block_number < self.block_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the block at which it will become the current\n    /// value. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u32) {\n        (self.post, self.block_of_change)\n    }\n\n    // Returns the previous value. This is the value that is current up until the block of change. Note that this value\n    // might not be the current anymore since block of change might have already passed.\n    pub fn get_previous(self) -> (T, u32) {\n        (self.pre, self.block_of_change)\n    }\n\n    /// Returns the largest block number at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_block_number`,\n    /// since due to its asynchronous nature private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum number of blocks that need to\n    /// elapse from the next block until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical block number is only safe to use\n    /// if the transaction's `max_block_number` property is set to a value lower or equal to the block horizon computed\n    /// using the same historical block number.\n    pub fn get_block_horizon(self, historical_block_number: u32, minimum_delay: u32) -> u32 {\n        // The block horizon is the very last block in which the current value is known. Any block past the horizon\n        // (i.e. with a block number larger than the block horizon) may have a different current value. Reading the\n        // current value in private typically requires constraining the maximum valid block number to be equal to the\n        // block horizon.\n        if historical_block_number >= self.block_of_change {\n            // Once the block of change has been mined, the current value (post) will not change unless a new value\n            // change is scheduled. This did not happen at the historical block number (or else it would not be\n            // greater or equal to the block of change), and therefore could only happen after the historical block\n            // number. The earliest would be the immediate next block, and so the smallest possible next block of change\n            // equals `historical_block_number + 1 + minimum_delay`. Our block horizon is simply the previous block to\n            // that one.\n            //\n            //      block of      historical\n            //       change         block            block horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n            historical_block_number + minimum_delay\n        } else {\n            // If the block of change has not yet been mined however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the block horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the block of change is in the past: the time horizon is the\n            //      block prior to the earliest one in which a new block of change might land.\n            //\n            //         historical\n            //           block                        block horizon      block of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` blocks away from the historical block number, in which case\n            //      the block of change would become the limiting factor for the time horizon, which would equal the\n            //      block right before the block of change (since by definition the value changes at the block of\n            //      change).\n            //\n            //           historical                         block horizon\n            //             block     block of change       if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the block of change to an arbitrary\n            // value, and therefore scenario a) is not currently possible. However implementing #5501 would allow for\n            // this to happen.\n            // Because historical_block_number < self.block_of_change, then block_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.block_of_change - 1,\n                historical_block_number + minimum_delay,\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current block number. This function is only meaningful when\n    /// called in public with the current block number.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_block_number: u32,\n        minimum_delay: u32,\n        block_of_change: u32,\n    ) {\n        assert(block_of_change >= current_block_number + minimum_delay);\n\n        self.pre = self.get_current_at(current_block_number);\n        self.post = new_value;\n        self.block_of_change = block_of_change;\n    }\n}\n\nimpl<T> Eq for ScheduledValueChange<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n\nimpl<T> Empty for ScheduledValueChange<T>\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        Self { pre: T::empty(), post: T::empty(), block_of_change: 0 }\n    }\n}\n"
    },
    "316": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/shared_mutable_values.nr",
      "source": "use crate::{\n    hash::poseidon2_hash,\n    shared_mutable::{\n        scheduled_delay_change::ScheduledDelayChange, scheduled_value_change::ScheduledValueChange,\n    },\n    traits::{Hash, Packable},\n    utils::arrays,\n};\nuse std::meta::derive;\n\nmod test;\n\n/// SharedMutableValues is just a wrapper around ScheduledValueChange and ScheduledDelayChange that then allows us\n/// to wrap both of these values in WithHash. WithHash allows for efficient read of values in private.\n///\n/// Note that the WithHash optimization does not work in public (due to there being no unconstrained). But we also want\n/// to be able to read the values efficiently in public and we want to be able to read each value separately. Reading\n/// the values separately is tricky because ScheduledValueChange and ScheduledDelayChange are packed together (sdc and\n/// svc.block_of_change are stored in the same slot). For that reason we expose `unpack_value_change` and\n/// `unpack_delay_change` functions that can be used to extract the values from the packed representation. This\n/// is \"hacky\" but there is no way around it.\n#[derive(Eq)]\npub struct SharedMutableValues<T, let INITIAL_DELAY: u32> {\n    pub svc: ScheduledValueChange<T>,\n    pub sdc: ScheduledDelayChange<INITIAL_DELAY>,\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutableValues<T, INITIAL_DELAY> {\n    pub fn new(svc: ScheduledValueChange<T>, sdc: ScheduledDelayChange<INITIAL_DELAY>) -> Self {\n        SharedMutableValues { svc, sdc }\n    }\n}\n\npub fn unpack_value_change<T, let N: u32>(packed: [Field; 2 * N + 1]) -> ScheduledValueChange<T>\nwhere\n    T: Packable<N>,\n{\n    let svc_pre_packed = arrays::subarray(packed, 1);\n    let svc_post_packed = arrays::subarray(packed, N + 1);\n    ScheduledValueChange::new(\n        T::unpack(svc_pre_packed),\n        T::unpack(svc_post_packed),\n        packed[0] as u32,\n    )\n}\n\npub fn unpack_delay_change<let INITIAL_DELAY: u32>(\n    packed: Field,\n) -> ScheduledDelayChange<INITIAL_DELAY> {\n    // This function expects to be called with just the first field of the packed representation, which contains sdc\n    // and svc block_of_change. We'll discard the svc component.\n    let svc_block_of_change = packed as u32;\n\n    let mut tmp = (packed - svc_block_of_change as Field) / TWO_POW_32;\n    let sdc_block_of_change = tmp as u32;\n\n    tmp = (tmp - sdc_block_of_change as Field) / TWO_POW_32;\n    let sdc_post_is_some = tmp as bool;\n\n    tmp = (tmp - sdc_post_is_some as Field) / TWO_POW_8;\n    let sdc_post_inner = tmp as u32;\n\n    tmp = (tmp - sdc_post_inner as Field) / TWO_POW_32;\n    let sdc_pre_is_some = tmp as bool;\n\n    tmp = (tmp - sdc_pre_is_some as Field) / TWO_POW_8;\n    let sdc_pre_inner = tmp as u32;\n\n    ScheduledDelayChange {\n        pre: if sdc_pre_is_some {\n            Option::some(sdc_pre_inner)\n        } else {\n            Option::none()\n        },\n        post: if sdc_post_is_some {\n            Option::some(sdc_post_inner)\n        } else {\n            Option::none()\n        },\n        block_of_change: sdc_block_of_change,\n    }\n}\n\nglobal TWO_POW_32: Field = 2.pow_32(32);\nglobal TWO_POW_8: Field = 2.pow_32(8);\n\n// We pack to `2 * N + 1` fields because ScheduledValueChange contains T twice (hence `2 * N`) and we need one extra\n// field to store ScheduledDelayChange and the block_of_change of ScheduledValueChange.\nimpl<T, let INITIAL_DELAY: u32, let N: u32> Packable<2 * N + 1> for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; 2 * N + 1] {\n        let mut result = [0; 2 * N + 1];\n\n        // We pack sdc.pre, sdc.post, sdc.block_of_change and svc.block_of_change into a single field as follows:\n        // [ sdc.pre_inner: u32 | sdc.pre_is_some: u8 | sdc.post_inner: u32 | sdc.post_is_some: u8 | sdc.block_of_change: u32 | svc.block_of_change: u32 ]\n        result[0] = self.svc.block_of_change as Field\n            + ((self.sdc.block_of_change as Field) * 2.pow_32(32))\n            + ((self.sdc.post.is_some() as Field) * 2.pow_32(64))\n            + ((self.sdc.post.unwrap_unchecked() as Field) * 2.pow_32(72))\n            + ((self.sdc.pre.is_some() as Field) * 2.pow_32(104))\n            + ((self.sdc.pre.unwrap_unchecked() as Field) * 2.pow_32(112));\n\n        // Pack the pre and post values from ScheduledValueChange\n        let svc_pre_packed = self.svc.pre.pack();\n        let svc_post_packed = self.svc.post.pack();\n        for i in 0..N {\n            result[i + 1] = svc_pre_packed[i];\n            result[i + 1 + N] = svc_post_packed[i];\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; 2 * N + 1]) -> Self {\n        let svc = unpack_value_change::<T, N>(fields);\n        let sdc = unpack_delay_change::<INITIAL_DELAY>(fields[0]);\n        Self::new(svc, sdc)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32, let N: u32> Hash for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn hash(self) -> Field {\n        poseidon2_hash(self.pack())\n    }\n}\n"
    },
    "319": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "333": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n"
    },
    "337": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "338": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "354": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "355": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "357": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "363": {
      "path": "/home/nerses/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "392": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER},\n        hash::poseidon2_hash_with_separator,\n        traits::{Deserialize, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// The returned `PartialUintNote` value must be sent to public execution via a secure channel, since it is not\n    /// possible to verify the integrity of its contents due to it hiding information. The recommended ways to do this\n    /// are to retrieve it from public storage, or to receive it in an internal public function call.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient, sender);\n        context.emit_private_log(encrypted_log);\n\n        PartialUintNote { commitment }\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nimpl PartialUintNote {\n    pub fn commitment(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, value: u128, context: &mut PublicContext) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; 2] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "50": {
      "path": "/home/nerses/contracts/chains/aztec/contracts/train/src/lib.nr",
      "source": "pub fn bytes_to_u128_limbs(bytes: [u8; 32]) -> (u128, u128) {\n    let mut high: u128 = 0;\n    let mut low: u128 = 0;\n    for i in 0..16 {\n        high = (high << 8) + (bytes[i] as u128);\n    }\n    for i in 16..32 {\n        low = (low << 8) + (bytes[i] as u128);\n    }\n    (high, low)\n}\n\npub fn u128_limbs_to_bytes(high: u128, low: u128) -> [u8; 32] {\n    let mut bytes: [u8; 32] = [0; 32];\n\n    let mut temp = high;\n    for i in 0..16 {\n        bytes[15 - i] = (temp & 0xff) as u8;\n        temp >>= 8;\n    }\n\n    temp = low;\n    for i in 0..16 {\n        bytes[31 - i] = (temp & 0xff) as u8;\n        temp >>= 8;\n    }\n\n    bytes\n}\n"
    },
    "51": {
      "path": "/home/nerses/contracts/chains/aztec/contracts/train/src/main.nr",
      "source": "mod lib;\nmod types;\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract Train {\n    use crate::lib::{bytes_to_u128_limbs, u128_limbs_to_bytes};\n    use crate::types::events::{\n        TokenCommitted, TokenLockAdded, TokenLocked, TokenRedeemed, TokenRefunded,\n    };\n    use dep::aztec::messages::logs::note::encode_and_encrypt_note;\n    use dep::aztec::protocol_types::traits::{Packable, Serialize};\n    use dep::aztec::state_vars::{private_immutable::PrivateImmutable, SharedMutable};\n    use dep::sha256;\n    use dep::token::Token;\n    use aztec::macros::{\n        functions::{initializer, internal, private, public, utility, view},\n        notes::note,\n        storage::storage,\n    };\n    use aztec::prelude::{AztecAddress, Map};\n    use std::meta::derive;\n\n    #[note]\n    #[derive(Eq)]\n    struct HTLC_Private {\n        owner: AztecAddress,\n        randomness: Field,\n    }\n    #[derive(Eq, Packable, Serialize)]\n    pub struct HTLC_Public {\n        src_receiver: AztecAddress,\n        amount: u128,\n        token: AztecAddress,\n        hashlock_high: u128,\n        hashlock_low: u128,\n        secret_high: u128,\n        secret_low: u128,\n        timelock: u64,\n        claimed: u8,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor() {}\n\n    #[storage]\n    struct Storage<Context> {\n        contracts_private: Map<Field, PrivateImmutable<HTLC_Private, Context>, Context>,\n        contracts_public: Map<Field, SharedMutable<HTLC_Public, 3, Context>, Context>,\n    }\n\n    #[private]\n    fn commit_private_user(\n        Id: Field,\n        src_receiver: AztecAddress,\n        timelock: u64,\n        token: AztecAddress,\n        amount: u128,\n        dst_chain: str<8>,\n        dst_asset: str<8>,\n        dst_address: str<48>,\n        randomness: Field,\n    ) {\n        assert(amount > 0, \"Funds Not Sent\");\n\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address())\n            .commit_public_user(\n                dst_chain,\n                dst_asset,\n                dst_address,\n                Id,\n                src_receiver,\n                timelock,\n                token,\n                amount,\n            )\n            .enqueue(&mut context);\n\n        let htlc_note = HTLC_Private { owner: context.msg_sender(), randomness: randomness };\n        storage.contracts_private.at(Id).initialize(htlc_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n\n        Token::at(token)\n            .transfer_in_private(context.msg_sender(), context.this_address(), amount, randomness)\n            .call(&mut context);\n    }\n\n    #[internal]\n    #[public]\n    fn commit_public_user(\n        dst_chain: str<8>,\n        dst_asset: str<8>,\n        dst_address: str<48>,\n        Id: Field,\n        src_receiver: AztecAddress,\n        timelock: u64,\n        token: AztecAddress,\n        amount: u128,\n    ) {\n        assert(context.timestamp() + 900 < timelock, \"InvalidTimelock\");\n        let htlc_public = HTLC_Public {\n            src_receiver: src_receiver,\n            amount: amount,\n            token: token,\n            hashlock_high: 0 as u128,\n            hashlock_low: 0 as u128,\n            secret_high: 0 as u128,\n            secret_low: 0 as u128,\n            timelock: timelock,\n            claimed: 1 as u8,\n        };\n        storage.contracts_public.at(Id).schedule_value_change(htlc_public);\n        let log_msg = TokenCommitted {\n            Id: Id,\n            amount: amount,\n            token: token,\n            timelock: timelock,\n            dst_chain: dst_chain,\n            dst_asset: dst_asset,\n            dst_address: dst_address,\n            src_receiver: src_receiver,\n        };\n        context.emit_public_log(log_msg.pack());\n    }\n\n    #[private]\n    fn add_lock_private_user(Id: Field, hashlock: [u8; 32], timelock: u64) {\n        let htlc_private = storage.contracts_private.at(Id).get_note();\n        assert(htlc_private.owner == context.msg_sender(), \"NoAllowance\");\n\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address()).add_lock_public_user(Id, hashlock, timelock).enqueue(\n            &mut context,\n        );\n    }\n\n    #[internal]\n    #[public]\n    fn add_lock_public_user(Id: Field, hashlock: [u8; 32], timelock: u64) {\n        assert(context.timestamp() + 900 < timelock, \"InvalidTimelock\");\n\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n        assert(htlc_public.hashlock_high == (0 as u128), \"HashlockAlreadySet\");\n        assert(htlc_public.hashlock_low == (0 as u128), \"HashlockAlreadySet\");\n\n        let hashlock_tuple = bytes_to_u128_limbs(hashlock);\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: hashlock_tuple.0,\n            hashlock_low: hashlock_tuple.1,\n            secret_high: htlc_public.secret_high,\n            secret_low: htlc_public.secret_low,\n            timelock: timelock,\n            claimed: htlc_public.claimed,\n        };\n        storage.contracts_public.at(Id).schedule_value_change(modified_htlc_public);\n        let log_msg = TokenLockAdded { Id, hashlock, timelock };\n        context.emit_public_log(log_msg.pack());\n    }\n\n    #[private]\n    fn refund_private(Id: Field, randomness: Field) {\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address()).refund_public(Id).enqueue(&mut context);\n\n        let htlc_private = storage.contracts_private.at(Id).get_note();\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n\n        Token::at(htlc_public.token)\n            .transfer_in_private(context.this_address(), htlc_private.owner, htlc_public.amount, 0)\n            .call(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn refund_public(Id: Field) {\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n        assert(htlc_public.timelock < context.timestamp(), \"NotPassedTimelock\");\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: htlc_public.hashlock_high,\n            hashlock_low: htlc_public.hashlock_low,\n            secret_high: htlc_public.secret_high,\n            secret_low: htlc_public.secret_low,\n            timelock: htlc_public.timelock,\n            claimed: 2 as u8,\n        };\n\n        storage.contracts_public.at(Id).schedule_value_change(modified_htlc_public);\n        let log_msg = TokenRefunded { Id };\n        context.emit_public_log(log_msg);\n    }\n\n    #[private]\n    fn lock_private_solver(\n        Id: Field,\n        hashlock: [u8; 32],\n        amount: u128,\n        timelock: u64,\n        token: AztecAddress,\n        randomness: Field,\n        dst_chain: str<8>,\n        dst_asset: str<8>,\n        dst_address: str<48>,\n    ) {\n        assert(amount > 0, \"FundsNotSent\");\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address())\n            .lock_public_solver(\n                Id,\n                hashlock,\n                amount,\n                token,\n                timelock,\n                dst_chain,\n                dst_asset,\n                dst_address,\n            )\n            .enqueue(&mut context);\n\n        let htlc_note = HTLC_Private { owner: context.msg_sender(), randomness: randomness };\n        storage.contracts_private.at(Id).initialize(htlc_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n\n        Token::at(token)\n            .transfer_in_private(context.msg_sender(), context.this_address(), amount, randomness)\n            .call(&mut context);\n    }\n\n    #[internal]\n    #[public]\n    fn lock_public_solver(\n        Id: Field,\n        hashlock: [u8; 32],\n        amount: u128,\n        token: AztecAddress,\n        timelock: u64,\n        dst_chain: str<8>,\n        dst_asset: str<8>,\n        dst_address: str<48>,\n    ) {\n        assert(context.timestamp() + 2700 < timelock, \"InvalidTimelock\");\n        let hashlock_tuple = bytes_to_u128_limbs(hashlock);\n        let htlc_public = HTLC_Public {\n            src_receiver: AztecAddress::zero(),\n            amount: amount,\n            token: token,\n            hashlock_high: hashlock_tuple.0,\n            hashlock_low: hashlock_tuple.1,\n            secret_high: 0 as u128,\n            secret_low: 0 as u128,\n            timelock: timelock,\n            claimed: 1 as u8,\n        };\n        storage.contracts_public.at(Id).schedule_value_change(htlc_public);\n\n        let log_msg = TokenLocked {\n            Id: Id,\n            hashlock: hashlock,\n            amount: amount,\n            token: token,\n            timelock: timelock,\n            dst_chain: dst_chain,\n            dst_asset: dst_asset,\n            dst_address: dst_address,\n        };\n\n        context.emit_public_log(log_msg.pack());\n    }\n\n    #[private]\n    fn redeem_private(Id: Field, secret: [u8; 32], randomness: Field) {\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address()).redeem_public(Id, secret).enqueue(&mut context);\n\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n\n        if htlc_public.src_receiver == AztecAddress::zero() {\n            Token::at(htlc_public.token)\n                .transfer_in_private(\n                    context.this_address(),\n                    context.msg_sender(),\n                    htlc_public.amount,\n                    0 as Field,\n                )\n                .call(&mut context);\n        } else {\n            Token::at(htlc_public.token)\n                .transfer_in_private(\n                    context.this_address(),\n                    htlc_public.src_receiver,\n                    htlc_public.amount,\n                    0 as Field,\n                )\n                .call(&mut context);\n        }\n    }\n\n    #[public]\n    #[internal]\n    fn redeem_public(Id: Field, secret: [u8; 32]) {\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public.amount > 0, \"HTLCNotExists\"); // If it doesn't exist, all parameters will default to zero values.\n        let hashed_secret = sha256::sha256_var(secret, secret.len() as u64);\n        let hashed_secret_tuple = bytes_to_u128_limbs(hashed_secret);\n        assert(htlc_public.hashlock_high == hashed_secret_tuple.0, \"HashlockNotMatch\");\n        assert(htlc_public.hashlock_low == hashed_secret_tuple.1, \"HashlockNotMatch\");\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n        let secret_limbs = bytes_to_u128_limbs(secret);\n\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: htlc_public.hashlock_high,\n            hashlock_low: htlc_public.hashlock_low,\n            secret_high: secret_limbs.0,\n            secret_low: secret_limbs.1,\n            timelock: htlc_public.timelock,\n            claimed: 3 as u8,\n        };\n\n        storage.contracts_public.at(Id).schedule_value_change(modified_htlc_public);\n\n        let log_msg = TokenRedeemed {\n            Id: Id,\n            hashlock: u128_limbs_to_bytes(htlc_public.hashlock_high, htlc_public.hashlock_low),\n            secret: secret,\n        };\n\n        context.emit_public_log(log_msg.pack());\n    }\n\n    // This utility function should be invoked by the frontend before each function call\n    // where the existence or non-existence of an HTLC is a critical security check.\n    #[utility]\n    unconstrained fn is_contract_initialized(Id: Field) -> bool {\n        storage.contracts_private.at(Id).is_initialized()\n    }\n\n    #[view]\n    #[public]\n    fn get_htlc_public(key: Field) -> pub HTLC_Public {\n        storage.contracts_public.at(key).get_current_value()\n    }\n\n}\n"
    },
    "52": {
      "path": "/home/nerses/contracts/chains/aztec/contracts/train/src/types/events.nr",
      "source": "use dep::aztec::prelude::AztecAddress;\nuse dep::aztec::protocol_types::traits::{Packable, Serialize};\n\n#[derive(Serialize)]\npub struct TokenCommitted {\n    pub Id: Field,\n    pub amount: u128,\n    pub token: AztecAddress,\n    pub timelock: u64,\n    pub dst_chain: str<8>,\n    pub dst_asset: str<8>,\n    pub dst_address: str<48>,\n    pub src_receiver: AztecAddress,\n}\n\nimpl Packable<9> for TokenCommitted {\n    fn pack(self) -> [Field; 9] {\n        let zero: Field = 0;\n        let mut out = [zero; 9];\n        out[0] = self.Id;\n        out[1] = self.amount as Field;\n        out[2] = self.token.inner;\n        out[3] = self.timelock as Field;\n\n        let dst_chain_byte_array = self.dst_chain.as_bytes();\n        let mut dst_chain_byte_array_filled = [0 as u8; 31];\n        for i in 0..dst_chain_byte_array.len() {\n            dst_chain_byte_array_filled[i] = dst_chain_byte_array[i];\n        }\n\n        out[4] = Field::from_be_bytes::<31>(dst_chain_byte_array_filled);\n\n        let dst_asset_byte_array = self.dst_asset.as_bytes();\n        let mut dst_asset_byte_array_filled = [0 as u8; 31];\n        for i in 0..dst_asset_byte_array.len() {\n            dst_asset_byte_array_filled[i] = dst_asset_byte_array[i];\n        }\n\n        out[5] = Field::from_be_bytes::<31>(dst_asset_byte_array_filled);\n\n        let dst_address_byte_array = self.dst_address.as_bytes();\n        let mut dst_address_byte_array_filled_1 = [0 as u8; 31];\n        let mut dst_address_byte_array_filled_2 = [0 as u8; 31];\n\n        for i in 0..31 {\n            dst_address_byte_array_filled_1[i] = dst_address_byte_array[i];\n        }\n\n        for i in 31..48 {\n            dst_address_byte_array_filled_2[i - 31] = dst_address_byte_array[i];\n        }\n\n        out[6] = Field::from_be_bytes::<31>(dst_address_byte_array_filled_1);\n        out[7] = Field::from_be_bytes::<31>(dst_address_byte_array_filled_2);\n\n        out[8] = self.src_receiver.inner;\n        out\n    }\n\n    fn unpack(fields: [Field; 9]) -> Self {\n        assert(false, \"unpack not implemented\");\n        TokenCommitted {\n            Id: fields[0] as Field,\n            amount: 0 as u128,\n            token: AztecAddress::zero(),\n            timelock: 0 as u64,\n            dst_chain: \"00000000\",\n            dst_asset: \"00000000\",\n            dst_address: \"000000000000000000000000000000000000000000000000\",\n            src_receiver: AztecAddress::zero(),\n        }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenLockAdded {\n    pub Id: Field,\n    pub hashlock: [u8; 32],\n    pub timelock: u64,\n}\n\nimpl Packable<4> for TokenLockAdded {\n    fn pack(self) -> [Field; 4] {\n        let mut out = [0 as Field; 4];\n        out[0] = self.Id;\n\n        let hb = self.hashlock;\n        let mut h1 = [0 as u8; 31];\n        for i in 0..31 {\n            h1[i] = hb[i];\n        }\n        out[1] = Field::from_be_bytes::<31>(h1);\n\n        let mut h2 = [0 as u8; 31];\n        h2[0] = hb[31];\n        out[2] = Field::from_be_bytes::<31>(h2);\n\n        out[3] = self.timelock as Field;\n        out\n    }\n\n    fn unpack(fields: [Field; 4]) -> Self {\n        let Id = fields[0];\n\n        let b1 = fields[1].to_be_bytes();\n        let b2 = fields[2].to_be_bytes();\n        let mut hash = [0 as u8; 32];\n        for i in 0..31 {\n            hash[i] = b1[i];\n        }\n        hash[31] = b2[0];\n\n        let timelock = fields[3] as u64;\n\n        TokenLockAdded { Id, hashlock: hash, timelock }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenRefunded {\n    pub Id: Field,\n}\n\n#[derive(Serialize)]\npub struct TokenRedeemed {\n    pub Id: Field,\n    pub hashlock: [u8; 32],\n    pub secret: [u8; 32],\n}\n\nimpl Packable<5> for TokenRedeemed {\n    fn pack(self) -> [Field; 5] {\n        let mut out = [0 as Field; 5];\n        out[0] = self.Id;\n\n        let hb = self.hashlock;\n        let mut h1 = [0 as u8; 31];\n        for i in 0..31 {\n            h1[i] = hb[i];\n        }\n        out[1] = Field::from_be_bytes::<31>(h1);\n        let mut h2 = [0 as u8; 31];\n        h2[0] = hb[31];\n        out[2] = Field::from_be_bytes::<31>(h2);\n\n        let sb = self.secret;\n        let mut s1 = [0 as u8; 31];\n        for i in 0..31 {\n            s1[i] = sb[i];\n        }\n        out[3] = Field::from_be_bytes::<31>(s1);\n        let mut s2 = [0 as u8; 31];\n        s2[0] = sb[31];\n        out[4] = Field::from_be_bytes::<31>(s2);\n\n        out\n    }\n\n    fn unpack(fields: [Field; 5]) -> Self {\n        let Id = fields[0];\n\n        let b1 = fields[1].to_be_bytes();\n        let b2 = fields[2].to_be_bytes();\n        let mut hashlock = [0 as u8; 32];\n        for i in 0..31 {\n            hashlock[i] = b1[i];\n        }\n        hashlock[31] = b2[0];\n\n        let b3 = fields[3].to_be_bytes();\n        let b4 = fields[4].to_be_bytes();\n        let mut secret = [0 as u8; 32];\n        for i in 0..31 {\n            secret[i] = b3[i];\n        }\n        secret[31] = b4[0];\n\n        TokenRedeemed { Id, hashlock, secret }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenLocked {\n    pub Id: Field,\n    pub hashlock: [u8; 32],\n    pub amount: u128,\n    pub token: AztecAddress,\n    pub timelock: u64,\n    pub dst_chain: str<8>,\n    pub dst_asset: str<8>,\n    pub dst_address: str<48>,\n}\n\nimpl Packable<10> for TokenLocked {\n    fn pack(self) -> [Field; 10] {\n        let mut out = [0 as Field; 10];\n        out[0] = self.Id;\n\n        let hb = self.hashlock;\n        let mut h1 = [0 as u8; 31];\n        for i in 0..31 {\n            h1[i] = hb[i];\n        }\n        out[1] = Field::from_be_bytes::<31>(h1);\n\n        let mut h2 = [0 as u8; 31];\n        h2[0] = hb[31];\n        out[2] = Field::from_be_bytes::<31>(h2);\n\n        out[3] = self.amount as Field;\n        out[4] = self.token.inner;\n        out[5] = self.timelock as Field;\n\n        let dst_chain_byte_array = self.dst_chain.as_bytes();\n        let mut dst_chain_byte_array_filled = [0 as u8; 31];\n        for i in 0..dst_chain_byte_array.len() {\n            dst_chain_byte_array_filled[i] = dst_chain_byte_array[i];\n        }\n        out[6] = Field::from_be_bytes::<31>(dst_chain_byte_array_filled);\n\n        let dst_asset_byte_array = self.dst_asset.as_bytes();\n        let mut dst_asset_byte_array_filled = [0 as u8; 31];\n        for i in 0..dst_asset_byte_array.len() {\n            dst_asset_byte_array_filled[i] = dst_asset_byte_array[i];\n        }\n        out[7] = Field::from_be_bytes::<31>(dst_asset_byte_array_filled);\n\n        let addr = self.dst_address.as_bytes();\n        let mut dst_address_byte_array_filled_1 = [0 as u8; 31];\n        let mut dst_address_byte_array_filled_2 = [0 as u8; 31];\n        for i in 0..31 {\n            dst_address_byte_array_filled_1[i] = addr[i];\n        }\n        for i in 31..48 {\n            dst_address_byte_array_filled_2[i - 31] = addr[i];\n        }\n        out[8] = Field::from_be_bytes::<31>(dst_address_byte_array_filled_1);\n        out[9] = Field::from_be_bytes::<31>(dst_address_byte_array_filled_2);\n\n        out\n    }\n\n    fn unpack(fields: [Field; 10]) -> Self {\n        assert(false, \"unpack not implemented\");\n        TokenLocked {\n            Id: fields[0] as Field,\n            hashlock: [0 as u8; 32],\n            amount: 0 as u128,\n            token: AztecAddress::zero(),\n            timelock: 0 as u64,\n            dst_chain: \"00000000\",\n            dst_asset: \"00000000\",\n            dst_address: \"000000000000000000000000000000000000000000000000\",\n        }\n    }\n}\n"
    },
    "54": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
    },
    "55": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "62": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "63": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(gas_for_call(gas_opts), contract_address, calldata);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(gas_for_call(gas_opts), contract_address, calldata);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_opcode(gas, address, args)\n}\n\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "64": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "65": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "69": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "81": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "84": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/keys/ecdh_shared_secret.nr",
      "source": "use dep::protocol_types::{\n    address::aztec_address::AztecAddress, point::Point, scalar::Scalar, traits::FromField,\n};\nuse std::{embedded_curve_ops::multi_scalar_mul, ops::Neg};\n\n/// Computes a standard ecdh shared secret: [secret] * public_key = shared_secret.\n/// The input secret is known only to one party. The output shared secret is derivable\n/// by both parties, through this function.\n/// E.g.:\n/// Epk = esk * G // ephemeral keypair\n/// Pk = sk * G // recipient keypair\n/// Shared secret S = esk * Pk = sk * Epk // see how this function can be called with two different sets of inputs, depending on which secret the caller knows (either esk or sk)?\n// See also: https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman\npub fn derive_ecdh_shared_secret(secret: Scalar, public_key: Point) -> Point {\n    let shared_secret = multi_scalar_mul([public_key], [secret]);\n    shared_secret\n}\n\n/// Computes a standard ecdh shared secret using the address public key of the given address:\n/// [ephemeral_secret] * recipient_address_public_key = shared_secret.\n/// The intention is that the _creator_ of a shared secret would call this function,\n/// given the address of their intended recipient.\npub fn derive_ecdh_shared_secret_using_aztec_address(\n    ephemeral_secret: Scalar,\n    recipient_address: AztecAddress,\n) -> Point {\n    derive_ecdh_shared_secret(ephemeral_secret, recipient_address.to_address_point().inner)\n}\n\n#[test]\nunconstrained fn test_consistency_with_typescript() {\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let shared_secret = derive_ecdh_shared_secret(secret, point);\n\n    // This is just pasted from a test run.\n    // The original typescript code from which this could be generated seems to have been deleted by someone, and soon the typescript code for encryption and decryption won't be needed, so this will have to do.\n    let hard_coded_shared_secret = Point {\n        x: 0x15d55a5b3b2caa6a6207f313f05c5113deba5da9927d6421bcaa164822b911bc,\n        y: 0x0974c3d0825031ae933243d653ebb1a0b08b90ee7f228f94c5c74739ea3c871e,\n        is_infinite: false,\n    };\n    assert_eq(shared_secret, hard_coded_shared_secret);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let shared_secret = derive_ecdh_shared_secret(secret_a, pk_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_from_address_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let mut pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let mut pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let address_b = AztecAddress::from_field(pk_b.x);\n\n    // We were lazy in deriving the secret keys, and didn't check the resulting y-coordinates\n    // of the pk_a or pk_b to be less than half the field modulus.\n    // If needed, we negate the pk's so that they yield valid address points.\n    // (We could also have negated the secrets, but there's no negate method for\n    // EmbeddedCurvesScalar).\n    pk_a = if (AztecAddress::from_field(pk_a.x).to_address_point().inner == pk_a) {\n        pk_a\n    } else {\n        pk_a.neg()\n    };\n    pk_b = if (address_b.to_address_point().inner == pk_b) {\n        pk_b\n    } else {\n        pk_b.neg()\n    };\n\n    let shared_secret = derive_ecdh_shared_secret_using_aztec_address(secret_a, address_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n"
    },
    "85": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/keys/ephemeral.nr",
      "source": "use std::embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul};\n\nuse dep::protocol_types::{point::Point, scalar::Scalar};\n\nuse crate::oracle::random::random;\n\npub fn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n\n    // Safety: we use the randomness to preserve the privacy of both the sender and recipient via encryption, so a\n    // malicious sender could use non-random values to reveal the plaintext. But they already know it themselves anyway,\n    // and so the recipient already trusts them to not disclose this information. We can therefore assume that the\n    // sender will cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // TODO(#12757): compute the key pair without constraining eph_sk twice (once in from_field, once in the black box\n    // called by fixed_base_scalar_mul).\n    let eph_sk = EmbeddedCurveScalar::from_field(randomness);\n    let eph_pk = fixed_base_scalar_mul(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n"
    },
    "86": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "90": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_notes` utility function PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_notes = generate_sync_notes();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_notes\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_notes() -> Quoted {\n    // TODO(https://github.com/noir-lang/noir/issues/7912): Doing the following unfortunately doesn't work. Once\n    // the issue is fixed uncomment the following and remove the workaround from TS (look for the issue link in the\n    // codebase).\n    // let utility: fn(FunctionDefinition) -> () = crate::macros::functions::utility;\n    // quote {\n    //     #[$utility]\n    //     unconstrained fn sync_notes() {\n    //     }\n    // }\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[aztec::macros::functions::utility]\n        unconstrained fn sync_notes() { }\n    }\n}\n"
    },
    "91": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "94": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_slice, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_view,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_SLICE_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args =  &[];\n    // serialized_args = serialized_args.append(aztec::protocol_types::traits::Serialize::serialize(target_address));\n    // serialized_args = serialized_args.push_back(fee_juice_limit_per_tx as Field);\n    // ```\n    let serialized_args_slice_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_SLICE_NAME = &[];\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append = add_to_field_slice(SERIALIZED_ARGS_SLICE_NAME, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n"
    },
    "95": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "98": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, &[], false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    }
  }
}
